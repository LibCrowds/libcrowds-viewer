!function(g){function I(e){if(n[e])return n[e].exports;var t=n[e]={i:e,l:!1,exports:{}};return g[e].call(t.exports,t,t.exports,I),t.l=!0,t.exports}var n={};I.m=g,I.c=n,I.i=function(g){return g},I.d=function(g,n,e){I.o(g,n)||Object.defineProperty(g,n,{configurable:!1,enumerable:!0,get:e})},I.n=function(g){var n=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(n,"a",n),n},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="/dist/",I(I.s=34)}([function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(122)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(84),\n  /* template */\n  __webpack_require__(53),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlPzIxNGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0EsdUJBQXNMOztBQUV0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP21pbmltaXplIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMDY2NTk3MGJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vSWNvbi52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0ljb24udnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTA2NjU5NzBiXFxcIn0hLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vSWNvbi52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar bind = __webpack_require__(20);\nvar isBuffer = __webpack_require__(104);\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object' && !isArray(obj)) {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvdXRpbHMuanM/NmJmMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmICFpc0FycmF5KG9iaikpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return store; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuex__ = __webpack_require__(124);\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */].use(__WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */]);\n\nvar store = new __WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */].Store({\n  state: {\n    selector: {},\n    viewer: {},\n    imgSource: \'\',\n    note: \'\'\n  },\n\n  mutations: {\n    SET_ITEM: function SET_ITEM(state, obj) {\n      state[obj.key] = obj.value;\n    },\n    DEL_ITEM: function DEL_ITEM(state, obj) {\n      state[obj.key].splice(obj.index, 1);\n    },\n    ADD_ITEM: function ADD_ITEM(state, obj) {\n      state[obj.key].unshift(obj.value);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3N0b3JlLmpzP2EyNTYiXSwibmFtZXMiOlsiVnVlIiwidXNlIiwic3RvcmUiLCJWdWV4IiwiU3RvcmUiLCJzdGF0ZSIsInNlbGVjdG9yIiwidmlld2VyIiwiaW1nU291cmNlIiwibm90ZSIsIm11dGF0aW9ucyIsIlNFVF9JVEVNIiwib2JqIiwia2V5IiwidmFsdWUiLCJERUxfSVRFTSIsInNwbGljZSIsImluZGV4IiwiQUREX0lURU0iLCJ1bnNoaWZ0Il0sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBOztBQUVBLG9EQUFBQSxDQUFJQyxHQUFKLENBQVEscURBQVI7O0FBRU8sSUFBTUMsUUFBUSxJQUFJLHFEQUFBQyxDQUFLQyxLQUFULENBQWU7QUFDbENDLFNBQU87QUFDTEMsY0FBVSxFQURMO0FBRUxDLFlBQVEsRUFGSDtBQUdMQyxlQUFXLEVBSE47QUFJTEMsVUFBTTtBQUpELEdBRDJCOztBQVFsQ0MsYUFBVztBQUNUQyxjQUFVLGtCQUFDTixLQUFELEVBQVFPLEdBQVIsRUFBZ0I7QUFDeEJQLFlBQU1PLElBQUlDLEdBQVYsSUFBaUJELElBQUlFLEtBQXJCO0FBQ0QsS0FIUTtBQUlUQyxjQUFVLGtCQUFDVixLQUFELEVBQVFPLEdBQVIsRUFBZ0I7QUFDeEJQLFlBQU1PLElBQUlDLEdBQVYsRUFBZUcsTUFBZixDQUFzQkosSUFBSUssS0FBMUIsRUFBaUMsQ0FBakM7QUFDRCxLQU5RO0FBT1RDLGNBQVUsa0JBQUNiLEtBQUQsRUFBUU8sR0FBUixFQUFnQjtBQUN4QlAsWUFBTU8sSUFBSUMsR0FBVixFQUFlTSxPQUFmLENBQXVCUCxJQUFJRSxLQUEzQjtBQUNEO0FBVFE7QUFSdUIsQ0FBZixDQUFkIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnXG5cblZ1ZS51c2UoVnVleClcblxuZXhwb3J0IGNvbnN0IHN0b3JlID0gbmV3IFZ1ZXguU3RvcmUoe1xuICBzdGF0ZToge1xuICAgIHNlbGVjdG9yOiB7fSxcbiAgICB2aWV3ZXI6IHt9LFxuICAgIGltZ1NvdXJjZTogJycsXG4gICAgbm90ZTogJydcbiAgfSxcblxuICBtdXRhdGlvbnM6IHtcbiAgICBTRVRfSVRFTTogKHN0YXRlLCBvYmopID0+IHtcbiAgICAgIHN0YXRlW29iai5rZXldID0gb2JqLnZhbHVlXG4gICAgfSxcbiAgICBERUxfSVRFTTogKHN0YXRlLCBvYmopID0+IHtcbiAgICAgIHN0YXRlW29iai5rZXldLnNwbGljZShvYmouaW5kZXgsIDEpXG4gICAgfSxcbiAgICBBRERfSVRFTTogKHN0YXRlLCBvYmopID0+IHtcbiAgICAgIHN0YXRlW29iai5rZXldLnVuc2hpZnQob2JqLnZhbHVlKVxuICAgIH1cbiAgfVxufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvc3RvcmUuanMiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join("");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === "string")\r\n\t\t\tmodules = [[null, modules, ""]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === "number")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz80MmNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(123)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanM/MTY1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(114)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(86),\n  /* template */\n  __webpack_require__(52),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlP2Y2ZWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0EsdUJBQTBLOztBQUUxSztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMDYwYzA1MjBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vTW9kYWwudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9Nb2RhbC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMDYwYzA1MjBcXFwifSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9Nb2RhbC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL01vZGFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(2);\nvar normalizeHeaderName = __webpack_require__(81);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(16);\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(16);\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvZGVmYXVsdHMuanM/ZDNiNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiK0NBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvZGVmYXVsdHMuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"times-circle":{"width":1536,"height":1792,"paths":[{"d":"M1149 1122q0-26-19-45l-181-181 181-181q19-19 19-45 0-27-19-46l-90-90q-19-19-46-19-26 0-45 19l-181 181-181-181q-19-19-45-19-27 0-46 19l-90 90q-19 19-19 46 0 26 19 45l181 181-181 181q-19 19-19 45 0 27 19 46l90 90q19 19 46 19 26 0 45-19l181-181 181 181q19 19 45 19 27 0 46-19l90-90q19-19 19-46zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy90aW1lcy1jaXJjbGUuanM/MGEyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMsMmJBQTJiLEdBQUciLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi52dWUnXG5cbkljb24ucmVnaXN0ZXIoe1widGltZXMtY2lyY2xlXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xMTQ5IDExMjJxMC0yNi0xOS00NWwtMTgxLTE4MSAxODEtMTgxcTE5LTE5IDE5LTQ1IDAtMjctMTktNDZsLTkwLTkwcS0xOS0xOS00Ni0xOS0yNiAwLTQ1IDE5bC0xODEgMTgxLTE4MS0xODFxLTE5LTE5LTQ1LTE5LTI3IDAtNDYgMTlsLTkwIDkwcS0xOSAxOS0xOSA0NiAwIDI2IDE5IDQ1bDE4MSAxODEtMTgxIDE4MXEtMTkgMTktMTkgNDUgMCAyNyAxOSA0Nmw5MCA5MHExOSAxOSA0NiAxOSAyNiAwIDQ1LTE5bDE4MS0xODEgMTgxIDE4MXExOSAxOSA0NSAxOSAyNyAwIDQ2LTE5bDkwLTkwcTE5LTE5IDE5LTQ2ek0xNTM2IDg5NnEwIDIwOS0xMDMgMzg1LjV0LTI3OS41IDI3OS41LTM4NS41IDEwMy0zODUuNS0xMDMtMjc5LjUtMjc5LjUtMTAzLTM4NS41IDEwMy0zODUuNSAyNzkuNS0yNzkuNSAzODUuNS0xMDMgMzg1LjUgMTAzIDI3OS41IDI3OS41IDEwMyAzODUuNXpcIn1dfX0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1hd2Vzb21lL2ljb25zL3RpbWVzLWNpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__store_js__ = __webpack_require__(3);\n\n\n/* harmony default export */ __webpack_exports__["a"] = (function (selection) {\n  var viewer = __WEBPACK_IMPORTED_MODULE_0__store_js__["a" /* store */].state.viewer;\n  viewer.removeOverlay(selection.id);\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2RlbGV0ZVNlbGVjdGlvbi5qcz80OWEwIl0sIm5hbWVzIjpbInNlbGVjdGlvbiIsInZpZXdlciIsInN0b3JlIiwic3RhdGUiLCJyZW1vdmVPdmVybGF5IiwiaWQiXSwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQSx5REFBZSxVQUFVQSxTQUFWLEVBQXFCO0FBQ2xDLE1BQU1DLFNBQVMsd0RBQUFDLENBQU1DLEtBQU4sQ0FBWUYsTUFBM0I7QUFDQUEsU0FBT0csYUFBUCxDQUFxQkosVUFBVUssRUFBL0I7QUFDRCxDIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RvcmUgfSBmcm9tICdAL3N0b3JlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IHZpZXdlciA9IHN0b3JlLnN0YXRlLnZpZXdlclxuICB2aWV3ZXIucmVtb3ZlT3ZlcmxheShzZWxlY3Rpb24uaWQpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vc3JjL3V0aWxzL2RlbGV0ZVNlbGVjdGlvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__store_js__ = __webpack_require__(3);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  var viewer = __WEBPACK_IMPORTED_MODULE_0__store_js__[\"a\" /* store */].state.viewer;\n  var overlays = typeof viewer.currentOverlays !== 'undefined' ? viewer.currentOverlays : [];\n  var selections = overlays.filter(function (overlay) {\n    return overlay.element.classList.contains('selection');\n  }).map(function (s) {\n    var bounds = s.getBounds(viewer.viewport);\n    var vpRect = new OpenSeadragon.SelectionRect(bounds.x, bounds.y, bounds.width, bounds.height);\n    return {\n      id: s.element.id,\n      rect: viewer.viewport.viewportToImageRectangle(vpRect)\n    };\n  });\n  return selections.reverse();\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2dldFNlbGVjdGlvbnMuanM/OWUwMCJdLCJuYW1lcyI6WyJ2aWV3ZXIiLCJzdG9yZSIsInN0YXRlIiwib3ZlcmxheXMiLCJjdXJyZW50T3ZlcmxheXMiLCJzZWxlY3Rpb25zIiwiZmlsdGVyIiwib3ZlcmxheSIsImVsZW1lbnQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsIm1hcCIsInMiLCJib3VuZHMiLCJnZXRCb3VuZHMiLCJ2aWV3cG9ydCIsInZwUmVjdCIsIk9wZW5TZWFkcmFnb24iLCJTZWxlY3Rpb25SZWN0IiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsImlkIiwicmVjdCIsInZpZXdwb3J0VG9JbWFnZVJlY3RhbmdsZSIsInJldmVyc2UiXSwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQSx5REFBZSxZQUFZO0FBQ3pCLE1BQU1BLFNBQVMsd0RBQUFDLENBQU1DLEtBQU4sQ0FBWUYsTUFBM0I7QUFDQSxNQUFNRyxXQUFXLE9BQU9ILE9BQU9JLGVBQWQsS0FBa0MsV0FBbEMsR0FDSUosT0FBT0ksZUFEWCxHQUVJLEVBRnJCO0FBR0EsTUFBTUMsYUFBYUYsU0FBU0csTUFBVCxDQUFnQixVQUFVQyxPQUFWLEVBQW1CO0FBQ3BELFdBQU9BLFFBQVFDLE9BQVIsQ0FBZ0JDLFNBQWhCLENBQTBCQyxRQUExQixDQUFtQyxXQUFuQyxDQUFQO0FBQ0QsR0FGa0IsRUFFaEJDLEdBRmdCLENBRVosVUFBVUMsQ0FBVixFQUFhO0FBQ2xCLFFBQU1DLFNBQVNELEVBQUVFLFNBQUYsQ0FBWWQsT0FBT2UsUUFBbkIsQ0FBZjtBQUNBLFFBQU1DLFNBQVMsSUFBSUMsY0FBY0MsYUFBbEIsQ0FBZ0NMLE9BQU9NLENBQXZDLEVBQ2lDTixPQUFPTyxDQUR4QyxFQUVpQ1AsT0FBT1EsS0FGeEMsRUFHaUNSLE9BQU9TLE1BSHhDLENBQWY7QUFJQSxXQUFPO0FBQ0xDLFVBQUlYLEVBQUVKLE9BQUYsQ0FBVWUsRUFEVDtBQUVMQyxZQUFNeEIsT0FBT2UsUUFBUCxDQUFnQlUsd0JBQWhCLENBQXlDVCxNQUF6QztBQUZELEtBQVA7QUFJRCxHQVprQixDQUFuQjtBQWFBLFNBQU9YLFdBQVdxQixPQUFYLEVBQVA7QUFDRCxDIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RvcmUgfSBmcm9tICdAL3N0b3JlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHZpZXdlciA9IHN0b3JlLnN0YXRlLnZpZXdlclxuICBjb25zdCBvdmVybGF5cyA9IHR5cGVvZiB2aWV3ZXIuY3VycmVudE92ZXJsYXlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgPyB2aWV3ZXIuY3VycmVudE92ZXJsYXlzXG4gICAgICAgICAgICAgICAgICAgICA6IFtdXG4gIGNvbnN0IHNlbGVjdGlvbnMgPSBvdmVybGF5cy5maWx0ZXIoZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICByZXR1cm4gb3ZlcmxheS5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0aW9uJylcbiAgfSkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgY29uc3QgYm91bmRzID0gcy5nZXRCb3VuZHModmlld2VyLnZpZXdwb3J0KVxuICAgIGNvbnN0IHZwUmVjdCA9IG5ldyBPcGVuU2VhZHJhZ29uLlNlbGVjdGlvblJlY3QoYm91bmRzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5oZWlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzLmVsZW1lbnQuaWQsXG4gICAgICByZWN0OiB2aWV3ZXIudmlld3BvcnQudmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlKHZwUmVjdClcbiAgICB9XG4gIH0pXG4gIHJldHVybiBzZWxlY3Rpb25zLnJldmVyc2UoKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy91dGlscy9nZXRTZWxlY3Rpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval('/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join("");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === "string")\r\n\t\t\tmodules = [[null, modules, ""]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === "number")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(115)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(85),\n  /* template */\n  __webpack_require__(54),\n  /* scopeId */\n  "data-v-33163bc3",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlPzdjODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0EsdUJBQXlLOztBQUV6SztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTMzMTYzYmMzXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vQ29udHJvbHMudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9Db250cm9scy52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzMxNjNiYzNcXFwifSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9Db250cm9scy52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtMzMxNjNiYzNcIixcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL0NvbnRyb2xzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(117)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(87),\n  /* template */\n  __webpack_require__(57),\n  /* scopeId */\n  "data-v-4f491fdf",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/NDk1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSx1QkFBeUs7O0FBRXpLO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGY0OTFmZGZcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TaWRlYmFyLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vU2lkZWJhci52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGY0OTFmZGZcXFwifSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TaWRlYmFyLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi00ZjQ5MWZkZlwiLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWVcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(67);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9pbmRleC5qcz9iNmUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\nvar settle = __webpack_require__(73);\nvar buildURL = __webpack_require__(76);\nvar parseHeaders = __webpack_require__(82);\nvar isURLSameOrigin = __webpack_require__(80);\nvar createError = __webpack_require__(19);\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(75);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (\"production\" !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(78);\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzP2Y5ZGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9heGlvcy9pc3N1ZXMvMjAxKVxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcz8yYWVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzP2YxN2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar enhanceError = __webpack_require__(72);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcz8zYjVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzPzA3ZjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"check-circle":{"width":1536,"height":1792,"paths":[{"d":"M1284 734q0-28-18-46l-91-90q-19-19-45-19t-45 19l-408 407-226-226q-19-19-45-19t-45 19l-91 90q-18 18-18 46 0 27 18 45l362 362q19 19 45 19 27 0 46-19l543-543q18-18 18-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGVjay1jaXJjbGUuanM/ODM4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMsK1RBQStULEdBQUciLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcImNoZWNrLWNpcmNsZVwiOntcIndpZHRoXCI6MTUzNixcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMTI4NCA3MzRxMC0yOC0xOC00NmwtOTEtOTBxLTE5LTE5LTQ1LTE5dC00NSAxOWwtNDA4IDQwNy0yMjYtMjI2cS0xOS0xOS00NS0xOXQtNDUgMTlsLTkxIDkwcS0xOCAxOC0xOCA0NiAwIDI3IDE4IDQ1bDM2MiAzNjJxMTkgMTkgNDUgMTkgMjcgMCA0Ni0xOWw1NDMtNTQzcTE4LTE4IDE4LTQ1ek0xNTM2IDg5NnEwIDIwOS0xMDMgMzg1LjV0LTI3OS41IDI3OS41LTM4NS41IDEwMy0zODUuNS0xMDMtMjc5LjUtMjc5LjUtMTAzLTM4NS41IDEwMy0zODUuNSAyNzkuNS0yNzkuNSAzODUuNS0xMDMgMzg1LjUgMTAzIDI3OS41IDI3OS41IDEwMyAzODUuNXpcIn1dfX0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1hd2Vzb21lL2ljb25zL2NoZWNrLWNpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"expand":{"width":1536,"height":1792,"paths":[{"d":"M755 1056q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23zM1536 192v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9leHBhbmQuanM/YWM1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLFVBQVUscUNBQXFDLHFWQUFxVixHQUFHIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJleHBhbmRcIjp7XCJ3aWR0aFwiOjE1MzYsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTc1NSAxMDU2cTAgMTMtMTAgMjNsLTMzMiAzMzIgMTQ0IDE0NHExOSAxOSAxOSA0NXQtMTkgNDUtNDUgMTloLTQ0OHEtMjYgMC00NS0xOXQtMTktNDV2LTQ0OHEwLTI2IDE5LTQ1dDQ1LTE5IDQ1IDE5bDE0NCAxNDQgMzMyLTMzMnExMC0xMCAyMy0xMHQyMyAxMGwxMTQgMTE0cTEwIDEwIDEwIDIzek0xNTM2IDE5MnY0NDhxMCAyNi0xOSA0NXQtNDUgMTktNDUtMTlsLTE0NC0xNDQtMzMyIDMzMnEtMTAgMTAtMjMgMTB0LTIzLTEwbC0xMTQtMTE0cS0xMC0xMC0xMC0yM3QxMC0yM2wzMzItMzMyLTE0NC0xNDRxLTE5LTE5LTE5LTQ1dDE5LTQ1IDQ1LTE5aDQ0OHEyNiAwIDQ1IDE5dDE5IDQ1elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvZXhwYW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"info-circle":{"width":1536,"height":1792,"paths":[{"d":"M1024 1376v-160q0-14-9-23t-23-9h-96v-512q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v160q0 14 9 23t23 9h96v320h-96q-14 0-23 9t-9 23v160q0 14 9 23t23 9h448q14 0 23-9t9-23zM896 480v-160q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v160q0 14 9 23t23 9h192q14 0 23-9t9-23zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9pbmZvLWNpcmNsZS5qcz9lMjM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsdUVBQWUsZUFBZSxxQ0FBcUMsc1pBQXNaLEdBQUciLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcImluZm8tY2lyY2xlXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xMDI0IDEzNzZ2LTE2MHEwLTE0LTktMjN0LTIzLTloLTk2di01MTJxMC0xNC05LTIzdC0yMy05aC0zMjBxLTE0IDAtMjMgOXQtOSAyM3YxNjBxMCAxNCA5IDIzdDIzIDloOTZ2MzIwaC05NnEtMTQgMC0yMyA5dC05IDIzdjE2MHEwIDE0IDkgMjN0MjMgOWg0NDhxMTQgMCAyMy05dDktMjN6TTg5NiA0ODB2LTE2MHEwLTE0LTktMjN0LTIzLTloLTE5MnEtMTQgMC0yMyA5dC05IDIzdjE2MHEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMy05dDktMjN6TTE1MzYgODk2cTAgMjA5LTEwMyAzODUuNXQtMjc5LjUgMjc5LjUtMzg1LjUgMTAzLTM4NS41LTEwMy0yNzkuNS0yNzkuNS0xMDMtMzg1LjUgMTAzLTM4NS41IDI3OS41LTI3OS41IDM4NS41LTEwMyAzODUuNSAxMDMgMjc5LjUgMjc5LjUgMTAzIDM4NS41elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvaW5mby1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"minus-circle":{"width":1536,"height":1792,"paths":[{"d":"M1216 960v-128q0-26-19-45t-45-19h-768q-26 0-45 19t-19 45v128q0 26 19 45t45 19h768q26 0 45-19t19-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9taW51cy1jaXJjbGUuanM/MDJiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMsMlBBQTJQLEdBQUciLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcIm1pbnVzLWNpcmNsZVwiOntcIndpZHRoXCI6MTUzNixcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMTIxNiA5NjB2LTEyOHEwLTI2LTE5LTQ1dC00NS0xOWgtNzY4cS0yNiAwLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWg3NjhxMjYgMCA0NS0xOXQxOS00NXpNMTUzNiA4OTZxMCAyMDktMTAzIDM4NS41dC0yNzkuNSAyNzkuNS0zODUuNSAxMDMtMzg1LjUtMTAzLTI3OS41LTI3OS41LTEwMy0zODUuNSAxMDMtMzg1LjUgMjc5LjUtMjc5LjUgMzg1LjUtMTAzIDM4NS41IDEwMyAyNzkuNSAyNzkuNSAxMDMgMzg1LjV6XCJ9XX19KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtYXdlc29tZS9pY29ucy9taW51cy1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"pencil":{"width":1536,"height":1792,"paths":[{"d":"M363 1536l91-91-235-235-91 91v107h128v128h107zM886 608q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zM832 416l416 416-832 832h-416v-416zM1515 512q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9wZW5jaWwuanM/ZDkwNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLFVBQVUscUNBQXFDLHdRQUF3USxHQUFHIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJwZW5jaWxcIjp7XCJ3aWR0aFwiOjE1MzYsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTM2MyAxNTM2bDkxLTkxLTIzNS0yMzUtOTEgOTF2MTA3aDEyOHYxMjhoMTA3ek04ODYgNjA4cTAtMjItMjItMjItMTAgMC0xNyA3bC01NDIgNTQycS03IDctNyAxNyAwIDIyIDIyIDIyIDEwIDAgMTctN2w1NDItNTQycTctNyA3LTE3ek04MzIgNDE2bDQxNiA0MTYtODMyIDgzMmgtNDE2di00MTZ6TTE1MTUgNTEycTAgNTMtMzcgOTBsLTE2NiAxNjYtNDE2LTQxNiAxNjYtMTY1cTM2LTM4IDkwLTM4IDUzIDAgOTEgMzhsMjM1IDIzNHEzNyAzOSAzNyA5MXpcIn1dfX0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1hd2Vzb21lL2ljb25zL3BlbmNpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"plus-circle":{"width":1536,"height":1792,"paths":[{"d":"M1216 960v-128q0-26-19-45t-45-19h-256v-256q0-26-19-45t-45-19h-128q-26 0-45 19t-19 45v256h-256q-26 0-45 19t-19 45v128q0 26 19 45t45 19h256v256q0 26 19 45t45 19h128q26 0 45-19t19-45v-256h256q26 0 45-19t19-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9wbHVzLWNpcmNsZS5qcz8zODBmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsdUVBQWUsZUFBZSxxQ0FBcUMsc1dBQXNXLEdBQUciLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcInBsdXMtY2lyY2xlXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xMjE2IDk2MHYtMTI4cTAtMjYtMTktNDV0LTQ1LTE5aC0yNTZ2LTI1NnEwLTI2LTE5LTQ1dC00NS0xOWgtMTI4cS0yNiAwLTQ1IDE5dC0xOSA0NXYyNTZoLTI1NnEtMjYgMC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMjU2djI1NnEwIDI2IDE5IDQ1dDQ1IDE5aDEyOHEyNiAwIDQ1LTE5dDE5LTQ1di0yNTZoMjU2cTI2IDAgNDUtMTl0MTktNDV6TTE1MzYgODk2cTAgMjA5LTEwMyAzODUuNXQtMjc5LjUgMjc5LjUtMzg1LjUgMTAzLTM4NS41LTEwMy0yNzkuNS0yNzkuNS0xMDMtMzg1LjUgMTAzLTM4NS41IDI3OS41LTI3OS41IDM4NS41LTEwMyAzODUuNSAxMDMgMjc5LjUgMjc5LjUgMTAzIDM4NS41elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvcGx1cy1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"question-circle":{"width":1536,"height":1792,"paths":[{"d":"M896 1376v-192q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v192q0 14 9 23t23 9h192q14 0 23-9t9-23zM1152 704q0-88-55.5-163t-138.5-116-170-41q-243 0-371 213-15 24 8 42l132 100q7 6 19 6 16 0 25-12 53-68 86-92 34-24 86-24 48 0 85.5 26t37.5 59q0 38-20 61t-68 45q-63 28-115.5 86.5t-52.5 125.5v36q0 14 9 23t23 9h192q14 0 23-9t9-23q0-19 21.5-49.5t54.5-49.5q32-18 49-28.5t46-35 44.5-48 28-60.5 12.5-81zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9xdWVzdGlvbi1jaXJjbGUuanM/ZTBhOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLG1CQUFtQixxQ0FBcUMsMGhCQUEwaEIsR0FBRyIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi52dWUnXG5cbkljb24ucmVnaXN0ZXIoe1wicXVlc3Rpb24tY2lyY2xlXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk04OTYgMTM3NnYtMTkycTAtMTQtOS0yM3QtMjMtOWgtMTkycS0xNCAwLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzLTl0OS0yM3pNMTE1MiA3MDRxMC04OC01NS41LTE2M3QtMTM4LjUtMTE2LTE3MC00MXEtMjQzIDAtMzcxIDIxMy0xNSAyNCA4IDQybDEzMiAxMDBxNyA2IDE5IDYgMTYgMCAyNS0xMiA1My02OCA4Ni05MiAzNC0yNCA4Ni0yNCA0OCAwIDg1LjUgMjZ0MzcuNSA1OXEwIDM4LTIwIDYxdC02OCA0NXEtNjMgMjgtMTE1LjUgODYuNXQtNTIuNSAxMjUuNXYzNnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMy05dDktMjNxMC0xOSAyMS41LTQ5LjV0NTQuNS00OS41cTMyLTE4IDQ5LTI4LjV0NDYtMzUgNDQuNS00OCAyOC02MC41IDEyLjUtODF6TTE1MzYgODk2cTAgMjA5LTEwMyAzODUuNXQtMjc5LjUgMjc5LjUtMzg1LjUgMTAzLTM4NS41LTEwMy0yNzkuNS0yNzkuNS0xMDMtMzg1LjUgMTAzLTM4NS41IDI3OS41LTI3OS41IDM4NS41LTEwMyAzODUuNSAxMDMgMjc5LjUgMjc5LjUgMTAzIDM4NS41elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvcXVlc3Rpb24tY2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"refresh":{"width":1536,"height":1792,"paths":[{"d":"M1511 1056q0 5-1 7-64 268-268 434.5t-478 166.5q-146 0-282.5-55t-243.5-157l-129 129q-19 19-45 19t-45-19-19-45v-448q0-26 19-45t45-19h448q26 0 45 19t19 45-19 45l-137 137q71 66 161 102t187 36q134 0 250-65t186-179q11-17 53-117 8-23 30-23h192q13 0 22.5 9.5t9.5 22.5zM1536 256v448q0 26-19 45t-45 19h-448q-26 0-45-19t-19-45 19-45l138-138q-148-137-349-137-134 0-250 65t-186 179q-11 17-53 117-8 23-30 23h-199q-13 0-22.5-9.5t-9.5-22.5v-7q65-268 270-434.5t480-166.5q146 0 284 55.5t245 156.5l130-129q19-19 45-19t45 19 19 45z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9yZWZyZXNoLmpzP2E3OTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQSx1RUFBZSxXQUFXLHFDQUFxQyxzZ0JBQXNnQixHQUFHIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJyZWZyZXNoXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xNTExIDEwNTZxMCA1LTEgNy02NCAyNjgtMjY4IDQzNC41dC00NzggMTY2LjVxLTE0NiAwLTI4Mi41LTU1dC0yNDMuNS0xNTdsLTEyOSAxMjlxLTE5IDE5LTQ1IDE5dC00NS0xOS0xOS00NXYtNDQ4cTAtMjYgMTktNDV0NDUtMTloNDQ4cTI2IDAgNDUgMTl0MTkgNDUtMTkgNDVsLTEzNyAxMzdxNzEgNjYgMTYxIDEwMnQxODcgMzZxMTM0IDAgMjUwLTY1dDE4Ni0xNzlxMTEtMTcgNTMtMTE3IDgtMjMgMzAtMjNoMTkycTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6TTE1MzYgMjU2djQ0OHEwIDI2LTE5IDQ1dC00NSAxOWgtNDQ4cS0yNiAwLTQ1LTE5dC0xOS00NSAxOS00NWwxMzgtMTM4cS0xNDgtMTM3LTM0OS0xMzctMTM0IDAtMjUwIDY1dC0xODYgMTc5cS0xMSAxNy01MyAxMTctOCAyMy0zMCAyM2gtMTk5cS0xMyAwLTIyLjUtOS41dC05LjUtMjIuNXYtN3E2NS0yNjggMjcwLTQzNC41dDQ4MC0xNjYuNXExNDYgMCAyODQgNTUuNXQyNDUgMTU2LjVsMTMwLTEyOXExOS0xOSA0NS0xOXQ0NSAxOSAxOSA0NXpcIn1dfX0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1hd2Vzb21lL2ljb25zL3JlZnJlc2guanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.3.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    } )); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (false) {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (false) {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.3.4';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (isUndef(value)) {\n    return ''\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((isDef(modifiers) && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^\x3c!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('--\x3e');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/\x3c!--([\\s\\S]*?)--\x3e/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (false\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    false\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, warn$3)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, warn$3)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (false) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}}\"\n}\n\nfunction genForScopedSlot (key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el)) +\n    '})'\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (false) {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(7)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUvZGlzdC92dWUuZXNtLmpzP2FlNjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRCxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0YsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyREFBMkQsMkJBQTJCLEVBQUU7QUFDeEYsS0FBSztBQUNMO0FBQ0EsMkRBQTJELDRCQUE0QixFQUFFO0FBQ3pGO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHNCQUFzQjs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCLEVBQUU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCLEVBQUU7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQ0FBMkMsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLGNBQWMsRUFBRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSwwQkFBMEIsRUFBRTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLDZDQUE2QywyQkFBMkIsRUFBRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkM7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjMuNFxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBwb3NzaWJsZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgIHJldHVybiBhID09PSBiXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChudWxsKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gKSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWUsXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlclxuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSAnJztcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGNoaWxkLmRhdGEgJiYgY2hpbGQuZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gY2hpbGQuZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZUhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHtcbiAga2V5OiAxLFxuICByZWY6IDEsXG4gIHNsb3Q6IDFcbn07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldIHx8IGNvbmZpZy5pc1Jlc2VydmVkQXR0cihrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJObyBnZXR0ZXIgZnVuY3Rpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICAvLyBpc0FycmF5IGhlcmVcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGlzQXJyYXlcbiAgICAgID8gaW5qZWN0XG4gICAgICA6IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCB7fSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGxpc3RlbmVyczogZGF0YS5vbiB8fCB7fSxcbiAgICBpbmplY3Rpb25zOiByZXNvbHZlSW5qZWN0KEN0b3Iub3B0aW9ucy5pbmplY3QsIGNvbnRleHQpLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB2bm9kZS5mdW5jdGlvbmFsT3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDErKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHBdO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgY3VycmVudCwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIGlmIChjYWNoZWROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjMuNCc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmKHZhbHVlKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChpc0RlZih2YWx1ZVtpXSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQgKyAnICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkgeyByZXMgKz0ga2V5ICsgJyAnOyB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiZcbiAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICApXG59XG5cbi8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgZHluYW1pY2FsbHkgY2hhbmdpbmcgdHlwZSBmb3IgPGlucHV0PlxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgaW5QcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluUHJlICYmXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuICAgICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHRhZylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGluUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgIGlmIChyZWYucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSkgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV0gOiBudWxsO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBuZXdTdGFydFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICFiYWlsZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwidmFyICQkZXhwID0gXCIgKyAobW9kZWxScy5leHApICsgXCIsICQkaWR4ID0gXCIgKyAobW9kZWxScy5pZHgpICsgXCI7XCIgK1xuICAgICAgXCJpZiAoIUFycmF5LmlzQXJyYXkoJCRleHApKXtcIiArXG4gICAgICAgIHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIgK1xuICAgICAgXCJlbHNleyQkZXhwLnNwbGljZSgkJGlkeCwgMSwgXCIgKyBhc3NpZ25tZW50ICsgXCIpfVwiXG4gIH1cbn1cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcbiAgICBpZHg6IHZhbC5zdWJzdHJpbmcoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgZHluYW1pY1R5cGUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPGlucHV0IDp0eXBlPVxcXCJcIiArIGR5bmFtaWNUeXBlICsgXCJcXFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OlxcblwiICtcbiAgICAgICAgXCJ2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBpbnB1dCB0eXBlcy4gVXNlIHYtaWYgYnJhbmNoZXMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlciB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBpZiAob25jZSQkMSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgdGVzdEVsO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICB0ZXN0RWwgPSB0ZXN0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBlbC5vcHRpb25zKTsgfSlcbiAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgZWwub3B0aW9ucyk7XG4gICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uc1tpXSksIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW92ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0JDEpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QkMS5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChleHByZXNzaW9uID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFszXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzKG5vZGUuaWZDb25kaXRpb25zLCBpc0luRm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIChjb25kaXRpb25CbG9ja3MsIGlzSW5Gb3IpIHtcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvbmRpdGlvbkJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG1hcmtTdGF0aWNSb290cyhjb25kaXRpb25CbG9ja3NbaV0uYmxvY2ssIGlzSW5Gb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcbiAgICAvLyAjNTMzMDogd2FybiBjbGljay5yaWdodCwgc2luY2UgcmlnaHQgY2xpY2tzIGRvIG5vdCBhY3R1YWxseSBmaXJlIGNsaWNrIGV2ZW50cy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbmFtZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLm1vZGlmaWVycyAmJiBoYW5kbGVyLm1vZGlmaWVycy5yaWdodFxuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJVc2UgXFxcImNvbnRleHRtZW51XFxcIiBpbnN0ZWFkIG9mIFxcXCJjbGljay5yaWdodFxcXCIgc2luY2UgcmlnaHQgY2xpY2tzIFwiICtcbiAgICAgICAgXCJkbyBub3QgYWN0dWFsbHkgZmlyZSBcXFwiY2xpY2tcXFwiIGV2ZW50cy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQzO1xudmFyIHRyYW5zZm9ybXMkMTtcbnZhciBkYXRhR2VuRm5zO1xudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxO1xudmFyIHN0YXRpY1JlbmRlckZucztcbnZhciBvbmNlQ291bnQ7XG52YXIgY3VycmVudE9wdGlvbnM7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuICB2YXIgcHJldlN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG4gIG9uY2VDb3VudCA9IDA7XG4gIGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgd2FybiQzID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0cmFuc2Zvcm1zJDEgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcbiAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgb25jZUNvdW50ID0gcHJldk9uY2VDb3VudDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbClcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMkMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDMoXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIixcIiArIChvbmNlQ291bnQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoZWwpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChjb25kaXRpb25zKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGVsLm9uY2UgPyBnZW5PbmNlKGVsKSA6IGdlbkVsZW1lbnQoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBtYXliZUNvbXBvbmVudChlbCkgJiYgZWwudGFnICE9PSAnc2xvdCcgJiYgZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5rZXlcbiAgKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgd2FybiQzKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCB3YXJuJDMpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHBsYXRmb3JtRGlyZWN0aXZlcyQxW2Rpci5uYW1lXSB8fCBiYXNlRGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgd2FybiQzKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHdhcm4kMygnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgY3VycmVudE9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKHNsb3RzKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSk7IH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbClcbiAgfVxuICByZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCkpICsgXCJ9fVwiXG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChjaGlsZHJlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG4gIHJldHVybiAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEoZWwudGFnKVxufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YShlbCkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG4gICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgdmFyIGZ1bmN0aW9uQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBjb21waWxlIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHRpcHMgPSBbXTtcbiAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCQkMSkge1xuICAgICAgKHRpcCQkMSA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID0gKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgfVxuICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcbiAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgfVxuICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICByZXR1cm4gY29tcGlsZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHZhciBsID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLmxlbmd0aDtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXMuc3RhdGljUmVuZGVyRm5zW2ldID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnN0YXRpY1JlbmRlckZuc1tpXSwgZm5HZW5FcnJvcnMpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0gPSByZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjb21waWxlVG9GdW5jdGlvbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDJcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKCh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUvZGlzdC92dWUuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_normalize_css__ = __webpack_require__(42);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_normalize_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_normalize_css__);\n\n\n\n/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue___default.a);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL21haW4uanM/ZGQ2NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQSx5REFBZSw4REFBZiIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaWJjcm93ZHNWaWV3ZXIgZnJvbSAnLi9jb21wb25lbnRzL1ZpZXdlci52dWUnXG5pbXBvcnQgJ25vcm1hbGl6ZS5jc3MnXG5cbmV4cG9ydCBkZWZhdWx0IExpYmNyb3dkc1ZpZXdlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(64)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(33),\n  /* template */\n  __webpack_require__(55),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8zNWE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHNCQUFrSzs7QUFFbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDZlNzIwYjhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDZlNzIwYjhcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.3.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    } )); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (false) {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (false) {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.3.4';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (isUndef(value)) {\n    return ''\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((isDef(modifiers) && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^\x3c!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('--\x3e');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/\x3c!--([\\s\\S]*?)--\x3e/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (false\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    false\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, warn$3)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, warn$3)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (false) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}}\"\n}\n\nfunction genForScopedSlot (key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el)) +\n    '})'\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (false) {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(7)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanM/NjVkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUNBQWlDLEVBQUU7QUFDckYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjOztBQUVwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFVBQVU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFx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QUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RCxtQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBNkM7QUFDOUU7QUFDQTtBQUNBLDZDQUE2Qyw0Q0FBNEM7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDJEQUEyRCwyQkFBMkIsRUFBRTtBQUN4RixLQUFLO0FBQ0w7QUFDQSwyREFBMkQsNEJBQTRCLEVBQUU7QUFDekY7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FB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bUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkVBQTZFO0FBQzdFLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEyQjtBQUMzQixlQUFlLHVDQUF1QztBQUN0RCxZQUFZLGtFQUFrRTtBQUM5RSxNQUFNLEtBQUssMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxzQkFBc0IsK0NBQStDO0FBQ3JFLGlEQUFpRDs7QUFFakQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEIsRUFBRTtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0IsRUFBRTtBQUM5RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMscUNBQXFDOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJDQUEyQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsY0FBYyxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLDBCQUEwQixFQUFFO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixFQUFFO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QixFQUFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixHQUFHLElBQUk7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuMy40XG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSApKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gRE9NIG5vZGVzIChwcmV2ZW50cyBsZWFrKVxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgaWYgKHRoaXMudXNlcikge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIHBvcFRhcmdldCgpO1xuICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cbn1cblxudmFyIGlzUmVzZXJ2ZWRQcm9wID0ge1xuICBrZXk6IDEsXG4gIHJlZjogMSxcbiAgc2xvdDogMVxufTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0gfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk5vIGdldHRlciBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICAgIGdldHRlciA9IG5vb3A7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3Bcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMSsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBjdXJyZW50LCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgaWYgKGNhY2hlZE5vZGUgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMy40JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKGlzVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICB2YXIgcmVzID0gJyc7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGlzRGVmKHZhbHVlW2ldKSkge1xuICAgICAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZikpIHtcbiAgICAgICAgaWYgKHJlZi5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXG4gICAgKTtcbiAgfVxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ2YXIgJCRleHAgPSBcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgJCRpZHggPSBcIiArIChtb2RlbFJzLmlkeCkgKyBcIjtcIiArXG4gICAgICBcImlmICghQXJyYXkuaXNBcnJheSgkJGV4cCkpe1wiICtcbiAgICAgICAgdmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQgKyBcIn1cIiArXG4gICAgICBcImVsc2V7JCRleHAuc3BsaWNlKCQkaWR4LCAxLCBcIiArIGFzc2lnbm1lbnQgKyBcIil9XCJcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGMpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmICgoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB8fCBlbG0udHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtsZXkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gIGFkZENsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0JyB8fCBlbC50eXBlID09PSAncGFzc3dvcmQnKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZzsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xuZnVuY3Rpb24gc2hvdWxkRGVjb2RlIChjb250ZW50LCBlbmNvZGVkKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBhPVxcXCJcIiArIGNvbnRlbnQgKyBcIlxcXCI+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoZW5jb2RlZCkgPiAwXG59XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbn1cblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBzaW5nbGVBdHRySWRlbnRpZmllciA9IC8oW15cXHNcIic8Pi89XSspLztcbnZhciBzaW5nbGVBdHRyQXNzaWduID0gLyg/Oj0pLztcbnZhciBzaW5nbGVBdHRyVmFsdWVzID0gW1xuICAvLyBhdHRyIHZhbHVlIGRvdWJsZSBxdW90ZXNcbiAgL1wiKFteXCJdKilcIisvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgc2luZ2xlIHF1b3Rlc1xuICAvJyhbXiddKiknKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBubyBxdW90ZXNcbiAgLyhbXlxcc1wiJz08PmBdKykvLnNvdXJjZVxuXTtcbnZhciBhdHRyaWJ1dGUgPSBuZXcgUmVnRXhwKFxuICAnXlxcXFxzKicgKyBzaW5nbGVBdHRySWRlbnRpZmllci5zb3VyY2UgK1xuICAnKD86XFxcXHMqKCcgKyBzaW5nbGVBdHRyQXNzaWduLnNvdXJjZSArICcpJyArXG4gICdcXFxccyooPzonICsgc2luZ2xlQXR0clZhbHVlcy5qb2luKCd8JykgKyAnKSk/J1xuKTtcblxuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXG4vLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xudmFyIHFuYW1lQ2FwdHVyZSA9ICcoKD86JyArIG5jbmFtZSArICdcXFxcOik/JyArIG5jbmFtZSArICcpJztcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKCdePCcgKyBxbmFtZUNhcHR1cmUpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKCdePFxcXFwvJyArIHFuYW1lQ2FwdHVyZSArICdbXj5dKj4nKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG52YXIgY29tbWVudCA9IC9ePCEtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMCk7L2c7XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QkMSA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QkMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdCQxLmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8IHRhZ05hbWUgPT09ICdodG1sJyAmJiBsYXN0VGFnID09PSAnaGVhZCcgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4O1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14sXSopLChbXixdKikoPzosKFteLF0qKSk/XFwpLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9O1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhYXR0cnMubGVuZ3RoO1xuXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMl0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3Mobm9kZS5pZkNvbmRpdGlvbnMsIGlzSW5Gb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3MgKGNvbmRpdGlvbkJsb2NrcywgaXNJbkZvcikge1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gY29uZGl0aW9uQmxvY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbWFya1N0YXRpY1Jvb3RzKGNvbmRpdGlvbkJsb2Nrc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW25hbWVdO1xuICAgIC8vICM1MzMwOiB3YXJuIGNsaWNrLnJpZ2h0LCBzaW5jZSByaWdodCBjbGlja3MgZG8gbm90IGFjdHVhbGx5IGZpcmUgY2xpY2sgZXZlbnRzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBuYW1lID09PSAnY2xpY2snICYmXG4gICAgICBoYW5kbGVyICYmIGhhbmRsZXIubW9kaWZpZXJzICYmIGhhbmRsZXIubW9kaWZpZXJzLnJpZ2h0XG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlVzZSBcXFwiY29udGV4dG1lbnVcXFwiIGluc3RlYWQgb2YgXFxcImNsaWNrLnJpZ2h0XFxcIiBzaW5jZSByaWdodCBjbGlja3MgXCIgK1xuICAgICAgICBcImRvIG5vdCBhY3R1YWxseSBmaXJlIFxcXCJjbGlja1xcXCIgZXZlbnRzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcikpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIHJldHVybiBpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgID8gaGFuZGxlci52YWx1ZVxuICAgICAgOiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwiKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIgYWxpYXMgPSBrZXlDb2Rlc1trZXldO1xuICByZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyAoYWxpYXMgPyAnLCcgKyBKU09OLnN0cmluZ2lmeShhbGlhcykgOiAnJykgKyBcIilcIilcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDM7XG52YXIgdHJhbnNmb3JtcyQxO1xudmFyIGRhdGFHZW5GbnM7XG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzJDE7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDE7XG52YXIgc3RhdGljUmVuZGVyRm5zO1xudmFyIG9uY2VDb3VudDtcbnZhciBjdXJyZW50T3B0aW9ucztcblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICAvLyBzYXZlIHByZXZpb3VzIHN0YXRpY1JlbmRlckZucyBzbyBnZW5lcmF0ZSBjYWxscyBjYW4gYmUgbmVzdGVkXG4gIHZhciBwcmV2U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuICB2YXIgY3VycmVudFN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucyA9IFtdO1xuICB2YXIgcHJldk9uY2VDb3VudCA9IG9uY2VDb3VudDtcbiAgb25jZUNvdW50ID0gMDtcbiAgY3VycmVudE9wdGlvbnMgPSBvcHRpb25zO1xuICB3YXJuJDMgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRyYW5zZm9ybXMkMSA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICBkYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHBsYXRmb3JtRGlyZWN0aXZlcyQxID0gb3B0aW9ucy5kaXJlY3RpdmVzIHx8IHt9O1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCkgOiAnX2MoXCJkaXZcIiknO1xuICBzdGF0aWNSZW5kZXJGbnMgPSBwcmV2U3RhdGljUmVuZGVyRm5zO1xuICBvbmNlQ291bnQgPSBwcmV2T25jZUNvdW50O1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogY3VycmVudFN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbClcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEoZWwpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtcyQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gdHJhbnNmb3JtcyQxW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMyhcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbClcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwiLFwiICsgKG9uY2VDb3VudCsrKSArIChrZXkgPyAoXCIsXCIgKyBrZXkpIDogXCJcIikgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChlbCkge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpKVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKGNvbmRpdGlvbnMpIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gZWwub25jZSA/IGdlbk9uY2UoZWwpIDogZ2VuRWxlbWVudChlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKGVsKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIG1heWJlQ29tcG9uZW50KGVsKSAmJiBlbC50YWcgIT09ICdzbG90JyAmJiBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLmtleVxuICApIHtcbiAgICB3YXJuJDMoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBkYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCB3YXJuJDMpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHdhcm4kMykpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cykpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gcGxhdGZvcm1EaXJlY3RpdmVzJDFbZGlyLm5hbWVdIHx8IGJhc2VEaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCB3YXJuJDMpO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgd2FybiQzKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBjdXJyZW50T3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoc2xvdHMpIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldKTsgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsKVxuICB9XG4gIHJldHVybiBcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsKSkgKyBcIn19XCJcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoZWwsIGNoZWNrU2tpcCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCQxKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbikgOiAwO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKGNoaWxkcmVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBvbmVudCAoZWwpIHtcbiAgcmV0dXJuICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMShlbC50YWcpXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChjb21wb25lbnROYW1lLCBlbCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhKGVsKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICB2YXIgZnVuY3Rpb25Db21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdGlwcyA9IFtdO1xuICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwJCQxKSB7XG4gICAgICAodGlwJCQxID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICB9XG4gICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgIHJldHVybiBjb21waWxlZFxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldLCBmbkdlbkVycm9ycyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSA9IHJlcylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGlsZTogY29tcGlsZSxcbiAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNvbXBpbGVUb0Z1bmN0aW9uc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlL2Rpc3QvdnVlLmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    var _ref;\n\n    return _ref = {\n      mode: 'selection',\n      objective: 'Mark the play titles',\n      guidance: 'Draw a box around each play title, including any subtitles.'\n    }, _defineProperty(_ref, 'mode', 'selection'), _defineProperty(_ref, 'scheme', \"https\"), _defineProperty(_ref, 'server', \"api.bl.uk\"), _defineProperty(_ref, 'imageApiPrefix', \"image/iiif\"), _defineProperty(_ref, 'presentationApiPrefix', \"metadata/iiif\"), _defineProperty(_ref, 'imageId', \"ark:/81055/vdc_100022589157.0x000005\"), _defineProperty(_ref, 'manifestId', \"ark:/81055/vdc_100022589158.0x000002\"), _ref;\n  },\n\n\n  methods: {\n    handleResponse: function handleResponse(obj) {\n      var jsonStr = JSON.stringify(obj, null, 2);\n      var msg = 'Selections submitted:\\n\\n' + jsonStr;\n      console.log(obj);\n      alert(msg);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQXBwLnZ1ZT82NTA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7O0FBRUE7O0FBQ0E7WUFDQTtpQkFDQTtnQkFDQTtxQ0FDQSw4Q0FDQSwwQ0FDQSxzREFDQSw4REFDQSxtREFDQSw2RUFFQTtBQUVBOzs7O2lEQUVBOzhDQUNBOzhDQUNBO2tCQUNBO1lBQ0E7QUFFQTtBQVBBO0FBaEJBIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGlkPVwiYXBwXCI+XG4gICAgPGxpYmNyb3dkcy12aWV3ZXJcbiAgICAgIHNob3ctbm90ZVxuICAgICAgOm1vZGU9XCJtb2RlXCJcbiAgICAgIDpvYmplY3RpdmU9XCJvYmplY3RpdmVcIlxuICAgICAgOmd1aWRhbmNlPVwiZ3VpZGFuY2VcIlxuICAgICAgOnNjaGVtZT1cInNjaGVtZVwiXG4gICAgICA6c2VydmVyPVwic2VydmVyXCJcbiAgICAgIDppbWFnZS1hcGktcHJlZml4PVwiaW1hZ2VBcGlQcmVmaXhcIlxuICAgICAgOnByZXNlbnRhdGlvbi1hcGktcHJlZml4PVwicHJlc2VudGF0aW9uQXBpUHJlZml4XCJcbiAgICAgIDppbWFnZS1pZD1cImltYWdlSWRcIlxuICAgICAgOm1hbmlmZXN0LWlkPVwibWFuaWZlc3RJZFwiXG4gICAgICBAc3VibWl0PVwiaGFuZGxlUmVzcG9uc2VcIj5cbiAgICA8L2xpYmNyb3dkcy12aWV3ZXI+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6ICdzZWxlY3Rpb24nLFxuICAgICAgb2JqZWN0aXZlOiAnTWFyayB0aGUgcGxheSB0aXRsZXMnLFxuICAgICAgZ3VpZGFuY2U6ICdEcmF3IGEgYm94IGFyb3VuZCBlYWNoIHBsYXkgdGl0bGUsIGluY2x1ZGluZyBhbnkgc3VidGl0bGVzLicsXG4gICAgICBtb2RlOiAnc2VsZWN0aW9uJyxcbiAgICAgIHNjaGVtZTogXCJodHRwc1wiLFxuICAgICAgc2VydmVyOiBcImFwaS5ibC51a1wiLFxuICAgICAgaW1hZ2VBcGlQcmVmaXg6IFwiaW1hZ2UvaWlpZlwiLFxuICAgICAgcHJlc2VudGF0aW9uQXBpUHJlZml4OiBcIm1ldGFkYXRhL2lpaWZcIixcbiAgICAgIGltYWdlSWQ6IFwiYXJrOi84MTA1NS92ZGNfMTAwMDIyNTg5MTU3LjB4MDAwMDA1XCIsXG4gICAgICBtYW5pZmVzdElkOiBcImFyazovODEwNTUvdmRjXzEwMDAyMjU4OTE1OC4weDAwMDAwMlwiXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVSZXNwb25zZSAob2JqKSB7XG4gICAgICBjb25zdCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKVxuICAgICAgY29uc3QgbXNnID0gYFNlbGVjdGlvbnMgc3VibWl0dGVkOlxcblxcbiR7anNvblN0cn1gXG4gICAgICBjb25zb2xlLmxvZyhvYmopXG4gICAgICBhbGVydChtc2cpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4jYXBwIHtcbiAgbWFyZ2luOiAwO1xuICBoZWlnaHQ6IDEwMHZoO1xufVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBBcHAudnVlPzJlYTkyYjA4Il0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_libcrowds_viewer__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App_vue__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__App_vue__);\n\n\n/* eslint-enable */\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */].component(\'libcrowds-viewer\', __WEBPACK_IMPORTED_MODULE_1_libcrowds_viewer__["a" /* default */]);\n\n/* eslint-disable no-new */\nnew __WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */]({\n  el: \'#app\',\n  render: function render(h) {\n    return h(__WEBPACK_IMPORTED_MODULE_2__App_vue___default.a);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCIsImVsIiwicmVuZGVyIiwiaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBQUEsQ0FBSUMsU0FBSixDQUFjLGtCQUFkLEVBQWtDLGlFQUFsQzs7QUFFQTtBQUNBLElBQUksb0RBQUosQ0FBUTtBQUNOQyxNQUFJLE1BREU7QUFFTkMsVUFBUTtBQUFBLFdBQUtDLEVBQUUsZ0RBQUYsQ0FBTDtBQUFBO0FBRkYsQ0FBUiIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IExpYmNyb3dkc1ZpZXdlciBmcm9tICdsaWJjcm93ZHMtdmlld2VyJ1xuLyogZXNsaW50LWVuYWJsZSAqL1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcC52dWUnO1xuXG5WdWUuY29tcG9uZW50KCdsaWJjcm93ZHMtdmlld2VyJywgTGliY3Jvd2RzVmlld2VyKVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbm5ldyBWdWUoe1xuICBlbDogJyNhcHAnLFxuICByZW5kZXI6IGggPT4gaChBcHApXG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4uanMiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__store_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_deleteSelection_js__ = __webpack_require__(10);\n\n\n\n/* harmony default export */ __webpack_exports__["a"] = (function (selection) {\n  var viewer = __WEBPACK_IMPORTED_MODULE_0__store_js__["a" /* store */].state.viewer;\n  var selector = __WEBPACK_IMPORTED_MODULE_0__store_js__["a" /* store */].state.selector;\n  var overlay = viewer.getOverlayById(selection.id);\n  var bounds = overlay.getBounds(viewer.viewport);\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_deleteSelection_js__["a" /* default */])(selection);\n  selector.rect = new OpenSeadragon.SelectionRect(bounds.x, bounds.y, bounds.width, bounds.height);\n  selector.draw();\n  selector.enable();\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2VkaXRTZWxlY3Rpb24uanM/NjgyZCJdLCJuYW1lcyI6WyJzZWxlY3Rpb24iLCJ2aWV3ZXIiLCJzdG9yZSIsInN0YXRlIiwic2VsZWN0b3IiLCJvdmVybGF5IiwiZ2V0T3ZlcmxheUJ5SWQiLCJpZCIsImJvdW5kcyIsImdldEJvdW5kcyIsInZpZXdwb3J0IiwiZGVsZXRlU2VsZWN0aW9uIiwicmVjdCIsIk9wZW5TZWFkcmFnb24iLCJTZWxlY3Rpb25SZWN0IiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsImRyYXciLCJlbmFibGUiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7QUFFQSx5REFBZSxVQUFVQSxTQUFWLEVBQXFCO0FBQ2xDLE1BQU1DLFNBQVMsd0RBQUFDLENBQU1DLEtBQU4sQ0FBWUYsTUFBM0I7QUFDQSxNQUFNRyxXQUFXLHdEQUFBRixDQUFNQyxLQUFOLENBQVlDLFFBQTdCO0FBQ0EsTUFBTUMsVUFBVUosT0FBT0ssY0FBUCxDQUFzQk4sVUFBVU8sRUFBaEMsQ0FBaEI7QUFDQSxNQUFNQyxTQUFTSCxRQUFRSSxTQUFSLENBQWtCUixPQUFPUyxRQUF6QixDQUFmO0FBQ0FDLEVBQUEsaUdBQUFBLENBQWdCWCxTQUFoQjtBQUNBSSxXQUFTUSxJQUFULEdBQWdCLElBQUlDLGNBQWNDLGFBQWxCLENBQWdDTixPQUFPTyxDQUF2QyxFQUEwQ1AsT0FBT1EsQ0FBakQsRUFDZ0NSLE9BQU9TLEtBRHZDLEVBQzhDVCxPQUFPVSxNQURyRCxDQUFoQjtBQUVBZCxXQUFTZSxJQUFUO0FBQ0FmLFdBQVNnQixNQUFUO0FBQ0QsQyIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0b3JlIH0gZnJvbSAnQC9zdG9yZS5qcydcbmltcG9ydCBkZWxldGVTZWxlY3Rpb24gZnJvbSAnQC91dGlscy9kZWxldGVTZWxlY3Rpb24uanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgY29uc3Qgdmlld2VyID0gc3RvcmUuc3RhdGUudmlld2VyXG4gIGNvbnN0IHNlbGVjdG9yID0gc3RvcmUuc3RhdGUuc2VsZWN0b3JcbiAgY29uc3Qgb3ZlcmxheSA9IHZpZXdlci5nZXRPdmVybGF5QnlJZChzZWxlY3Rpb24uaWQpXG4gIGNvbnN0IGJvdW5kcyA9IG92ZXJsYXkuZ2V0Qm91bmRzKHZpZXdlci52aWV3cG9ydClcbiAgZGVsZXRlU2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgc2VsZWN0b3IucmVjdCA9IG5ldyBPcGVuU2VhZHJhZ29uLlNlbGVjdGlvblJlY3QoYm91bmRzLngsIGJvdW5kcy55LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KVxuICBzZWxlY3Rvci5kcmF3KClcbiAgc2VsZWN0b3IuZW5hYmxlKClcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvdXRpbHMvZWRpdFNlbGVjdGlvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__store_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_getSelections_js__ = __webpack_require__(11);\n\n\n\n/* harmony default export */ __webpack_exports__["a"] = (function () {\n  return {\n    selections: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_getSelections_js__["a" /* default */])(),\n    note: __WEBPACK_IMPORTED_MODULE_0__store_js__["a" /* store */].state.note\n  };\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2dldERhdGEuanM/MjQ1ZSJdLCJuYW1lcyI6WyJzZWxlY3Rpb25zIiwiZ2V0U2VsZWN0aW9ucyIsIm5vdGUiLCJzdG9yZSIsInN0YXRlIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUEseURBQWUsWUFBWTtBQUN6QixTQUFPO0FBQ0xBLGdCQUFZLCtGQUFBQyxFQURQO0FBRUxDLFVBQU0sd0RBQUFDLENBQU1DLEtBQU4sQ0FBWUY7QUFGYixHQUFQO0FBSUQsQyIsImZpbGUiOiIzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0b3JlIH0gZnJvbSAnQC9zdG9yZS5qcydcbmltcG9ydCBnZXRTZWxlY3Rpb25zIGZyb20gJ0AvdXRpbHMvZ2V0U2VsZWN0aW9ucy5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHNlbGVjdGlvbnM6IGdldFNlbGVjdGlvbnMoKSxcbiAgICBub3RlOiBzdG9yZS5zdGF0ZS5ub3RlXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvdXRpbHMvZ2V0RGF0YS5qcyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__store_js__ = __webpack_require__(3);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n                 var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'full';\n                 var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'full';\n                 var rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n                 var quality = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'default';\n                 var format = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'jpg';\n\n                 var regStr = (typeof region === 'undefined' ? 'undefined' : _typeof(region)) === 'object' ? region.x + ',' + region.y + ',' + region.width + ',' + region.height : region;\n                 return __WEBPACK_IMPORTED_MODULE_0__store_js__[\"a\" /* store */].state.imgSource + '/' + (regStr + '/') + (size + '/') + (rotation + '/') + (quality + '.') + ('' + format);\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2dldEltYWdlVXJpLmpzP2U0NWUiXSwibmFtZXMiOlsicmVnaW9uIiwic2l6ZSIsInJvdGF0aW9uIiwicXVhbGl0eSIsImZvcm1hdCIsInJlZ1N0ciIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJzdG9yZSIsInN0YXRlIiwiaW1nU291cmNlIl0sIm1hcHBpbmdzIjoiOzs7QUFBQTs7QUFFQSx5REFBZSxZQUMrQztBQUFBLHFCQURyQ0EsTUFDcUMsdUVBRDVCLE1BQzRCO0FBQUEscUJBRHBCQyxJQUNvQix1RUFEYixNQUNhO0FBQUEscUJBRExDLFFBQ0ssdUVBRE0sQ0FDTjtBQUFBLHFCQUFyQ0MsT0FBcUMsdUVBQTNCLFNBQTJCO0FBQUEscUJBQWhCQyxNQUFnQix1RUFBUCxLQUFPOztBQUM1RCxxQkFBTUMsU0FBUyxRQUFPTCxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLEdBQ09BLE9BQU9NLENBRGQsU0FDbUJOLE9BQU9PLENBRDFCLFNBQytCUCxPQUFPUSxLQUR0QyxTQUMrQ1IsT0FBT1MsTUFEdEQsR0FFSVQsTUFGbkI7QUFHQSx3QkFBVSx3REFBQVUsQ0FBTUMsS0FBTixDQUFZQyxTQUFmLFVBQ0dQLE1BREgsV0FFR0osSUFGSCxXQUdHQyxRQUhILFdBSUdDLE9BSkgsZ0JBS0dDLE1BTEgsQ0FBUDtBQU1ELEMiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdG9yZSB9IGZyb20gJ0Avc3RvcmUuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChyZWdpb24gPSAnZnVsbCcsIHNpemUgPSAnZnVsbCcsIHJvdGF0aW9uID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBxdWFsaXR5ID0gJ2RlZmF1bHQnLCBmb3JtYXQgPSAnanBnJykge1xuICBjb25zdCByZWdTdHIgPSB0eXBlb2YgcmVnaW9uID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgID8gYCR7cmVnaW9uLnh9LCR7cmVnaW9uLnl9LCR7cmVnaW9uLndpZHRofSwke3JlZ2lvbi5oZWlnaHR9YFxuICAgICAgICAgICAgICAgICAgIDogcmVnaW9uXG4gIHJldHVybiBgJHtzdG9yZS5zdGF0ZS5pbWdTb3VyY2V9L2AgK1xuICAgICAgICAgYCR7cmVnU3RyfS9gICtcbiAgICAgICAgIGAke3NpemV9L2AgK1xuICAgICAgICAgYCR7cm90YXRpb259L2AgK1xuICAgICAgICAgYCR7cXVhbGl0eX0uYCArXG4gICAgICAgICBgJHtmb3JtYXR9YFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy91dGlscy9nZXRJbWFnZVVyaS5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__store_js__ = __webpack_require__(3);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (selection, highlight) {\n  var el = document.querySelector('#' + selection.id);\n  if (highlight) {\n    el.classList.add('highlight');\n  } else {\n    el.classList.remove('highlight');\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2hpZ2hsaWdodFNlbGVjdGlvbi5qcz83MjVlIl0sIm5hbWVzIjpbInNlbGVjdGlvbiIsImhpZ2hsaWdodCIsImVsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaWQiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiXSwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQSx5REFBZSxVQUFVQSxTQUFWLEVBQXFCQyxTQUFyQixFQUFnQztBQUM3QyxNQUFNQyxLQUFLQyxTQUFTQyxhQUFULE9BQTJCSixVQUFVSyxFQUFyQyxDQUFYO0FBQ0EsTUFBSUosU0FBSixFQUFlO0FBQ2JDLE9BQUdJLFNBQUgsQ0FBYUMsR0FBYixDQUFpQixXQUFqQjtBQUNELEdBRkQsTUFFTztBQUNMTCxPQUFHSSxTQUFILENBQWFFLE1BQWIsQ0FBb0IsV0FBcEI7QUFDRDtBQUNGLEMiLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdG9yZSB9IGZyb20gJ0Avc3RvcmUuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzZWxlY3Rpb24sIGhpZ2hsaWdodCkge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3NlbGVjdGlvbi5pZH1gKVxuICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0JylcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWdobGlnaHQnKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vc3JjL3V0aWxzL2hpZ2hsaWdodFNlbGVjdGlvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(12)();\n// imports\n\n\n// module\nexports.push([module.i, "#app{margin:0;height:100vh}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9mYzI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsOEJBQStCLFNBQVMsYUFBYTs7QUFFckQiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjYXBwe21hcmdpbjowO2hlaWdodDoxMDB2aH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00NmU3MjBiOFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(12)();\n// imports\n\n\n// module\nexports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}[hidden],template{display:none}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3M/ODMxYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLDBHQUEyRyxpQkFBaUIsMEJBQTBCLDhCQUE4QixLQUFLLFNBQVMsd0NBQXdDLGNBQWMsR0FBRyxjQUFjLGVBQWUsdUJBQXVCLGNBQWMsT0FBTyxnQkFBZ0IsR0FBRyx1QkFBdUIsU0FBUyxpQkFBaUIsSUFBSSxnQ0FBZ0MsY0FBYyxFQUFFLDZCQUE2QixxQ0FBcUMsWUFBWSxtQkFBbUIsMEJBQTBCLGlDQUFpQyxTQUFTLG9CQUFvQixtQkFBbUIsY0FBYyxnQ0FBZ0MsY0FBYyxJQUFJLGtCQUFrQixLQUFLLHNCQUFzQixXQUFXLE1BQU0sY0FBYyxRQUFRLGNBQWMsY0FBYyxrQkFBa0Isd0JBQXdCLElBQUksY0FBYyxJQUFJLFVBQVUsWUFBWSxxQkFBcUIsc0JBQXNCLGFBQWEsU0FBUyxJQUFJLGtCQUFrQixlQUFlLGdCQUFnQixzQ0FBc0MsdUJBQXVCLGVBQWUsaUJBQWlCLFNBQVMsYUFBYSxpQkFBaUIsY0FBYyxvQkFBb0IscURBQXFELDBCQUEwQix3SEFBd0gsa0JBQWtCLFVBQVUsNEdBQTRHLDhCQUE4QixTQUFTLDJCQUEyQixPQUFPLHNCQUFzQixjQUFjLGNBQWMsZUFBZSxVQUFVLG1CQUFtQixTQUFTLHFCQUFxQix3QkFBd0IsU0FBUyxjQUFjLDZCQUE2QixzQkFBc0IsVUFBVSxrRkFBa0YsWUFBWSxjQUFjLDZCQUE2QixvQkFBb0IscUZBQXFGLHdCQUF3Qiw2QkFBNkIsMEJBQTBCLGFBQWEsYUFBYSxjQUFjLFFBQVEsa0JBQWtCLE9BQU8scUJBQXFCLGtCQUFrQixhQUFhOztBQUV4dUUiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBub3JtYWxpemUuY3NzIHY3LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9odG1se2xpbmUtaGVpZ2h0OjEuMTU7LW1zLXRleHQtc2l6ZS1hZGp1c3Q6MTAwJTstd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6MTAwJX1ib2R5e21hcmdpbjowfWFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9ZmlnY2FwdGlvbixmaWd1cmUsbWFpbntkaXNwbGF5OmJsb2NrfWZpZ3VyZXttYXJnaW46MWVtIDQwcHh9aHJ7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MDtvdmVyZmxvdzp2aXNpYmxlfXByZXtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXA6b2JqZWN0c31hYmJyW3RpdGxlXXtib3JkZXItYm90dG9tOm5vbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lIGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDppbmhlcml0O2ZvbnQtd2VpZ2h0OmJvbGRlcn1jb2RlLGtiZCxzYW1we2ZvbnQtZmFtaWx5Om1vbm9zcGFjZSxtb25vc3BhY2U7Zm9udC1zaXplOjFlbX1kZm57Zm9udC1zdHlsZTppdGFsaWN9bWFya3tiYWNrZ3JvdW5kLWNvbG9yOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1Yntib3R0b206LS4yNWVtfXN1cHt0b3A6LS41ZW19YXVkaW8sdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2t9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1pbWd7Ym9yZGVyLXN0eWxlOm5vbmV9c3ZnOm5vdCg6cm9vdCl7b3ZlcmZsb3c6aGlkZGVufWJ1dHRvbixpbnB1dCxvcHRncm91cCxzZWxlY3QsdGV4dGFyZWF7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXNpemU6MTAwJTtsaW5lLWhlaWdodDoxLjE1O21hcmdpbjowfWJ1dHRvbixpbnB1dHtvdmVyZmxvdzp2aXNpYmxlfWJ1dHRvbixzZWxlY3R7dGV4dC10cmFuc2Zvcm06bm9uZX1bdHlwZT1yZXNldF0sW3R5cGU9c3VibWl0XSxidXR0b24saHRtbCBbdHlwZT1idXR0b25dey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b259W3R5cGU9YnV0dG9uXTo6LW1vei1mb2N1cy1pbm5lcixbdHlwZT1yZXNldF06Oi1tb3otZm9jdXMtaW5uZXIsW3R5cGU9c3VibWl0XTo6LW1vei1mb2N1cy1pbm5lcixidXR0b246Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyLXN0eWxlOm5vbmU7cGFkZGluZzowfVt0eXBlPWJ1dHRvbl06LW1vei1mb2N1c3JpbmcsW3R5cGU9cmVzZXRdOi1tb3otZm9jdXNyaW5nLFt0eXBlPXN1Ym1pdF06LW1vei1mb2N1c3JpbmcsYnV0dG9uOi1tb3otZm9jdXNyaW5ne291dGxpbmU6MXB4IGRvdHRlZCBCdXR0b25UZXh0fWZpZWxkc2V0e3BhZGRpbmc6LjM1ZW0gLjc1ZW0gLjYyNWVtfWxlZ2VuZHtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6aW5oZXJpdDtkaXNwbGF5OnRhYmxlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6MDt3aGl0ZS1zcGFjZTpub3JtYWx9cHJvZ3Jlc3N7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9dGV4dGFyZWF7b3ZlcmZsb3c6YXV0b31bdHlwZT1jaGVja2JveF0sW3R5cGU9cmFkaW9de2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjB9W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfVt0eXBlPXNlYXJjaF17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDtvdXRsaW5lLW9mZnNldDotMnB4fVt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sW3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbnstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX06Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247Zm9udDppbmhlcml0fWRldGFpbHMsbWVudXtkaXNwbGF5OmJsb2NrfXN1bW1hcnl7ZGlzcGxheTpsaXN0LWl0ZW19Y2FudmFze2Rpc3BsYXk6aW5saW5lLWJsb2NrfVtoaWRkZW5dLHRlbXBsYXRle2Rpc3BsYXk6bm9uZX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuLi9+L25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(40);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(43)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../demo/node_modules/css-loader/index.js!./normalize.css\", function() {\n\t\t\tvar newContent = require(\"!!../../demo/node_modules/css-loader/index.js!./normalize.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3M/ZWQ3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ub3JtYWxpemUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ub3JtYWxpemUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbm9ybWFsaXplLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === "undefined") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(44);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\toptions.attrs.type = "text/css";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\toptions.attrs.type = "text/css";\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzP2I3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85YzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(120)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(88),\n  /* template */\n  __webpack_require__(61),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT8yODg1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHVCQUEwSzs7QUFFMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1hYWQ0MWI0MlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9WaWV3ZXIudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9WaWV3ZXIudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWFhZDQxYjQyXFxcIn0hLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vVmlld2VyLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("var Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(89),\n  /* template */\n  __webpack_require__(62),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvY29udHJvbHMvUGFuLnZ1ZT9lMmM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vUGFuLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1iZWJkNGRkZVxcXCJ9IS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1Bhbi52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL2NvbnRyb2xzL1Bhbi52dWVcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(90),\n  /* template */\n  __webpack_require__(58),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvY29udHJvbHMvVmlld2VyLnZ1ZT9hNzllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vVmlld2VyLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi02NTkwNTFjZVxcXCJ9IS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1ZpZXdlci52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL2NvbnRyb2xzL1ZpZXdlci52dWVcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(119)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(91),\n  /* template */\n  __webpack_require__(60),\n  /* scopeId */\n  "data-v-8890bee6",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL0hlbHAudnVlPzM4YzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0EsdUJBQTRLOztBQUU1SztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlciEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTg4OTBiZWU2XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vSGVscC52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0hlbHAudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTg4OTBiZWU2XFxcIn0hLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vSGVscC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtODg5MGJlZTZcIixcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL21vZGFscy9IZWxwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(121)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(92),\n  /* template */\n  __webpack_require__(63),\n  /* scopeId */\n  "data-v-ef9c290a",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL01ldGFkYXRhLnZ1ZT9lMmEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHVCQUE0Szs7QUFFNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1lZjljMjkwYVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc2Fzcy1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL01ldGFkYXRhLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWV0YWRhdGEudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWVmOWMyOTBhXFxcIn0hLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vTWV0YWRhdGEudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIFwiZGF0YS12LWVmOWMyOTBhXCIsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zcmMvY29tcG9uZW50cy9tb2RhbHMvTWV0YWRhdGEudnVlXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(118)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(93),\n  /* template */\n  __webpack_require__(59),\n  /* scopeId */\n  "data-v-76bf11a1",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT8yYThhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHVCQUE0Szs7QUFFNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03NmJmMTFhMVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc2Fzcy1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1NlbGVjdGlvbi52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1NlbGVjdGlvbi52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzZiZjExYTFcXFwifSEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TZWxlY3Rpb24udnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIFwiZGF0YS12LTc2YmYxMWExXCIsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zcmMvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(116)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(94),\n  /* template */\n  __webpack_require__(56),\n  /* scopeId */\n  "data-v-4ae81000",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvVGFzay52dWU/ODA3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSx1QkFBNEs7O0FBRTVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGFlODEwMDBcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9UYXNrLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vVGFzay52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGFlODEwMDBcXFwifSEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9UYXNrLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi00YWU4MTAwMFwiLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvVGFzay52dWVcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'transition\', {\n    attrs: {\n      "name": "modal"\n    }\n  }, [_c(\'div\', {\n    directives: [{\n      name: "show",\n      rawName: "v-show",\n      value: (_vm.show),\n      expression: "show"\n    }],\n    staticClass: "modal",\n    attrs: {\n      "id": _vm.id\n    }\n  }, [_c(\'div\', {\n    staticClass: "modal-mask"\n  }, [_c(\'div\', {\n    staticClass: "modal-wrapper"\n  }, [_c(\'div\', {\n    staticClass: "modal-container"\n  }, [_c(\'div\', {\n    staticClass: "modal-header"\n  }, [_vm._t("header", [_c(\'h3\', [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _c(\'span\', {\n    staticClass: "close",\n    on: {\n      "click": function($event) {\n        _vm.show = false\n      }\n    }\n  }, [_vm._v("×")])])], 2), _vm._v(" "), _c(\'div\', {\n    staticClass: "modal-body"\n  }, [_vm._t("default")], 2), _vm._v(" "), _c(\'div\', {\n    staticClass: "modal-footer"\n  }, [_vm._t("footer", [_c(\'button\', {\n    staticClass: "btn",\n    on: {\n      "click": function($event) {\n        _vm.show = false\n      }\n    }\n  }, [_vm._v("\\n                OK\\n              ")])])], 2)])])])])])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlPzJiYzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsImZpbGUiOiI1Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygndHJhbnNpdGlvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJuYW1lXCI6IFwibW9kYWxcIlxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnNob3cpLFxuICAgICAgZXhwcmVzc2lvbjogXCJzaG93XCJcbiAgICB9XSxcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IF92bS5pZFxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtbWFza1wiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLXdyYXBwZXJcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jb250YWluZXJcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1oZWFkZXJcIlxuICB9LCBbX3ZtLl90KFwiaGVhZGVyXCIsIFtfYygnaDMnLCBbX3ZtLl92KF92bS5fcyhfdm0udGl0bGUpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjbG9zZVwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2hvdyA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9LCBbX3ZtLl92KFwiw5dcIildKV0pXSwgMiksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtYm9keVwiXG4gIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMiksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtZm9vdGVyXCJcbiAgfSwgW192bS5fdChcImZvb3RlclwiLCBbX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidG5cIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLnNob3cgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihcIlxcbiAgICAgICAgICAgICAgICBPS1xcbiAgICAgICAgICAgICAgXCIpXSldKV0sIDIpXSldKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTA2MGMwNTIwXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'svg\', {\n    class: _vm.clazz,\n    style: (_vm.style),\n    attrs: {\n      "version": "1.1",\n      "role": _vm.label ? \'img\' : \'presentation\',\n      "aria-label": _vm.label,\n      "x": _vm.x,\n      "y": _vm.y,\n      "width": _vm.width,\n      "height": _vm.height,\n      "viewBox": _vm.box\n    }\n  }, [_vm._t("default", [(_vm.icon && _vm.icon.paths) ? _vm._l((_vm.icon.paths), function(path) {\n    return _c(\'path\', _vm._b({}, \'path\', path))\n  }) : _vm._e(), _vm._v(" "), (_vm.icon && _vm.icon.polygons) ? _vm._l((_vm.icon.polygons), function(polygon) {\n    return _c(\'polygon\', _vm._b({}, \'polygon\', polygon))\n  }) : _vm._e(), _vm._v("\\b\\n    "), (_vm.icon && _vm.icon.raw) ? [_c(\'g\', {\n    domProps: {\n      "innerHTML": _vm._s(_vm.icon.raw)\n    }\n  })] : _vm._e()])], 2)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlPzAwODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0I7QUFDL0IsR0FBRztBQUNILGtDQUFrQztBQUNsQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3N2ZycsIHtcbiAgICBjbGFzczogX3ZtLmNsYXp6LFxuICAgIHN0eWxlOiAoX3ZtLnN0eWxlKSxcbiAgICBhdHRyczoge1xuICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS4xXCIsXG4gICAgICBcInJvbGVcIjogX3ZtLmxhYmVsID8gJ2ltZycgOiAncHJlc2VudGF0aW9uJyxcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiBfdm0ubGFiZWwsXG4gICAgICBcInhcIjogX3ZtLngsXG4gICAgICBcInlcIjogX3ZtLnksXG4gICAgICBcIndpZHRoXCI6IF92bS53aWR0aCxcbiAgICAgIFwiaGVpZ2h0XCI6IF92bS5oZWlnaHQsXG4gICAgICBcInZpZXdCb3hcIjogX3ZtLmJveFxuICAgIH1cbiAgfSwgW192bS5fdChcImRlZmF1bHRcIiwgWyhfdm0uaWNvbiAmJiBfdm0uaWNvbi5wYXRocykgPyBfdm0uX2woKF92bS5pY29uLnBhdGhzKSwgZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBfYygncGF0aCcsIF92bS5fYih7fSwgJ3BhdGgnLCBwYXRoKSlcbiAgfSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKF92bS5pY29uICYmIF92bS5pY29uLnBvbHlnb25zKSA/IF92bS5fbCgoX3ZtLmljb24ucG9seWdvbnMpLCBmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgcmV0dXJuIF9jKCdwb2x5Z29uJywgX3ZtLl9iKHt9LCAncG9seWdvbicsIHBvbHlnb24pKVxuICB9KSA6IF92bS5fZSgpLCBfdm0uX3YoXCJcXGJcXG4gICAgXCIpLCAoX3ZtLmljb24gJiYgX3ZtLmljb24ucmF3KSA/IFtfYygnZycsIHtcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKF92bS5pY29uLnJhdylcbiAgICB9XG4gIH0pXSA6IF92bS5fZSgpXSldLCAyKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTA2NjU5NzBiXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    ref: "controls",\n    staticClass: "lv-controls"\n  }, _vm._l((_vm.buttons), function(b) {\n    return _c(\'button\', {\n      key: b.id,\n      staticClass: "hint--right hint--no-animate btn btn-control",\n      attrs: {\n        "id": b.id,\n        "aria-label": b.tooltip\n      },\n      on: {\n        "click": function($event) {\n          _vm.handleClick(b.click)\n        }\n      }\n    }, [_c(\'icon\', {\n      attrs: {\n        "name": b.icon,\n        "scale": _vm.scale\n      }\n    })], 1)\n  }))\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlP2M3NjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICByZWY6IFwiY29udHJvbHNcIixcbiAgICBzdGF0aWNDbGFzczogXCJsdi1jb250cm9sc1wiXG4gIH0sIF92bS5fbCgoX3ZtLmJ1dHRvbnMpLCBmdW5jdGlvbihiKSB7XG4gICAgcmV0dXJuIF9jKCdidXR0b24nLCB7XG4gICAgICBrZXk6IGIuaWQsXG4gICAgICBzdGF0aWNDbGFzczogXCJoaW50LS1yaWdodCBoaW50LS1uby1hbmltYXRlIGJ0biBidG4tY29udHJvbFwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJpZFwiOiBiLmlkLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogYi50b29sdGlwXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICBfdm0uaGFuZGxlQ2xpY2soYi5jbGljaylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygnaWNvbicsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwibmFtZVwiOiBiLmljb24sXG4gICAgICAgIFwic2NhbGVcIjogX3ZtLnNjYWxlXG4gICAgICB9XG4gICAgfSldLCAxKVxuICB9KSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zMzE2M2JjM1wifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL0NvbnRyb2xzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "app"\n    }\n  }, [_c(\'libcrowds-viewer\', {\n    attrs: {\n      "show-note": "",\n      "mode": _vm.mode,\n      "objective": _vm.objective,\n      "guidance": _vm.guidance,\n      "scheme": _vm.scheme,\n      "server": _vm.server,\n      "image-api-prefix": _vm.imageApiPrefix,\n      "presentation-api-prefix": _vm.presentationApiPrefix,\n      "image-id": _vm.imageId,\n      "manifest-id": _vm.manifestId\n    },\n    on: {\n      "submit": _vm.handleResponse\n    }\n  })], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9lNmJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsImZpbGUiOiI1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwiYXBwXCJcbiAgICB9XG4gIH0sIFtfYygnbGliY3Jvd2RzLXZpZXdlcicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJzaG93LW5vdGVcIjogXCJcIixcbiAgICAgIFwibW9kZVwiOiBfdm0ubW9kZSxcbiAgICAgIFwib2JqZWN0aXZlXCI6IF92bS5vYmplY3RpdmUsXG4gICAgICBcImd1aWRhbmNlXCI6IF92bS5ndWlkYW5jZSxcbiAgICAgIFwic2NoZW1lXCI6IF92bS5zY2hlbWUsXG4gICAgICBcInNlcnZlclwiOiBfdm0uc2VydmVyLFxuICAgICAgXCJpbWFnZS1hcGktcHJlZml4XCI6IF92bS5pbWFnZUFwaVByZWZpeCxcbiAgICAgIFwicHJlc2VudGF0aW9uLWFwaS1wcmVmaXhcIjogX3ZtLnByZXNlbnRhdGlvbkFwaVByZWZpeCxcbiAgICAgIFwiaW1hZ2UtaWRcIjogX3ZtLmltYWdlSWQsXG4gICAgICBcIm1hbmlmZXN0LWlkXCI6IF92bS5tYW5pZmVzdElkXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJzdWJtaXRcIjogX3ZtLmhhbmRsZVJlc3BvbnNlXG4gICAgfVxuICB9KV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNDZlNzIwYjhcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lv-task-sidebar"\n    }\n  }, [_c(\'sidebar\', {\n    attrs: {\n      "title": "Task"\n    }\n  }, [_c(\'h4\', [_vm._v(_vm._s(_vm.objective))]), _vm._v(" "), _c(\'p\', [_vm._v(_vm._s(_vm.guidance))]), _vm._v(" "), (_vm.showNote) ? _c(\'button\', {\n    staticClass: "btn",\n    on: {\n      "click": _vm.toggleCollapseNote\n    }\n  }, [_vm._v("\\n      Add a note\\n    ")]) : _vm._e(), _vm._v(" "), (!_vm.collapseNote) ? _c(\'div\', {\n    directives: [{\n      name: "show",\n      rawName: "v-show",\n      value: (_vm.showNote),\n      expression: "showNote"\n    }]\n  }, [_c(\'textarea\', {\n    attrs: {\n      "rows": "3",\n      "placeholder": "Leave a note..."\n    },\n    on: {\n      "input": _vm.updateNote\n    }\n  })]) : _vm._e(), _vm._v(" "), _c(\'button\', {\n    staticClass: "btn btn-green",\n    on: {\n      "click": _vm.submit\n    }\n  }, [_vm._v("\\n      Submit\\n    ")])])], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvVGFzay52dWU/YmZmNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImx2LXRhc2stc2lkZWJhclwiXG4gICAgfVxuICB9LCBbX2MoJ3NpZGViYXInLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidGl0bGVcIjogXCJUYXNrXCJcbiAgICB9XG4gIH0sIFtfYygnaDQnLCBbX3ZtLl92KF92bS5fcyhfdm0ub2JqZWN0aXZlKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCBbX3ZtLl92KF92bS5fcyhfdm0uZ3VpZGFuY2UpKV0pLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLnNob3dOb3RlKSA/IF9jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYnRuXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLnRvZ2dsZUNvbGxhcHNlTm90ZVxuICAgIH1cbiAgfSwgW192bS5fdihcIlxcbiAgICAgIEFkZCBhIG5vdGVcXG4gICAgXCIpXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKCFfdm0uY29sbGFwc2VOb3RlKSA/IF9jKCdkaXYnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnNob3dOb3RlKSxcbiAgICAgIGV4cHJlc3Npb246IFwic2hvd05vdGVcIlxuICAgIH1dXG4gIH0sIFtfYygndGV4dGFyZWEnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm93c1wiOiBcIjNcIixcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJMZWF2ZSBhIG5vdGUuLi5cIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogX3ZtLnVwZGF0ZU5vdGVcbiAgICB9XG4gIH0pXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidG4gYnRuLWdyZWVuXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLnN1Ym1pdFxuICAgIH1cbiAgfSwgW192bS5fdihcIlxcbiAgICAgIFN1Ym1pdFxcbiAgICBcIildKV0pXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00YWU4MTAwMFwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL3NpZGViYXJzL1Rhc2sudnVlXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "lv-sidebar"\n  }, [_c(\'div\', {\n    staticClass: "lv-sidebar-header"\n  }, [_c(\'h4\', [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _c(\'span\', {\n    class: _vm.toggleClassObj,\n    on: {\n      "click": _vm.toggleCollapse\n    }\n  }, [_vm._v("\\n      ▲\\n    ")])]), _vm._v(" "), _c(\'div\', {\n    directives: [{\n      name: "show",\n      rawName: "v-show",\n      value: (!_vm.contentCollapsed),\n      expression: "!contentCollapsed"\n    }],\n    staticClass: "lv-sidebar-content"\n  }, [_vm._t("default")], 2)])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/M2RiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibHYtc2lkZWJhclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImx2LXNpZGViYXItaGVhZGVyXCJcbiAgfSwgW19jKCdoNCcsIFtfdm0uX3YoX3ZtLl9zKF92bS50aXRsZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIGNsYXNzOiBfdm0udG9nZ2xlQ2xhc3NPYmosXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLnRvZ2dsZUNvbGxhcHNlXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAg4payXFxuICAgIFwiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgIHZhbHVlOiAoIV92bS5jb250ZW50Q29sbGFwc2VkKSxcbiAgICAgIGV4cHJlc3Npb246IFwiIWNvbnRlbnRDb2xsYXBzZWRcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImx2LXNpZGViYXItY29udGVudFwiXG4gIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMildKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTRmNDkxZmRmXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWVcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "lv-viewer-controls"\n  }, [_c(\'controls\', {\n    attrs: {\n      "position": "top",\n      "layout": "row",\n      "buttons": _vm.buttons\n    }\n  })], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvY29udHJvbHMvVmlld2VyLnZ1ZT84YmIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsdi12aWV3ZXItY29udHJvbHNcIlxuICB9LCBbX2MoJ2NvbnRyb2xzJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInBvc2l0aW9uXCI6IFwidG9wXCIsXG4gICAgICBcImxheW91dFwiOiBcInJvd1wiLFxuICAgICAgXCJidXR0b25zXCI6IF92bS5idXR0b25zXG4gICAgfVxuICB9KV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNjU5MDUxY2VcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9jb250cm9scy9WaWV3ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lv-selection-sidebar"\n    }\n  }, [_c(\'sidebar\', {\n    attrs: {\n      "title": "Selections"\n    }\n  }, [_c(\'ul\', _vm._l((_vm.selections), function(s) {\n    return _c(\'li\', {\n      key: s.id,\n      on: {\n        "mouseover": function($event) {\n          _vm.highlightSelection(s, true)\n        },\n        "mouseleave": function($event) {\n          _vm.highlightSelection(s, false)\n        }\n      }\n    }, [_c(\'div\', {\n      staticClass: "thumbnail-container"\n    }, [_c(\'img\', {\n      attrs: {\n        "src": _vm.getImageUri(s.rect)\n      }\n    })]), _vm._v(" "), _c(\'div\', {\n      staticClass: "buttons"\n    }, [_c(\'span\', {\n      staticClass: "btn btn-control",\n      on: {\n        "click": function($event) {\n          _vm.editSelection(s)\n        }\n      }\n    }, [_c(\'icon\', {\n      attrs: {\n        "name": "pencil"\n      }\n    })], 1), _vm._v(" "), _c(\'span\', {\n      staticClass: "btn btn-control",\n      on: {\n        "click": function($event) {\n          _vm.deleteSelection(s)\n        }\n      }\n    }, [_c(\'icon\', {\n      attrs: {\n        "name": "times-circle"\n      }\n    })], 1)])])\n  }))])], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT9lZmI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQyIsImZpbGUiOiI1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwibHYtc2VsZWN0aW9uLXNpZGViYXJcIlxuICAgIH1cbiAgfSwgW19jKCdzaWRlYmFyJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInRpdGxlXCI6IFwiU2VsZWN0aW9uc1wiXG4gICAgfVxuICB9LCBbX2MoJ3VsJywgX3ZtLl9sKChfdm0uc2VsZWN0aW9ucyksIGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gX2MoJ2xpJywge1xuICAgICAga2V5OiBzLmlkLFxuICAgICAgb246IHtcbiAgICAgICAgXCJtb3VzZW92ZXJcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmhpZ2hsaWdodFNlbGVjdGlvbihzLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICBcIm1vdXNlbGVhdmVcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmhpZ2hsaWdodFNlbGVjdGlvbihzLCBmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwidGh1bWJuYWlsLWNvbnRhaW5lclwiXG4gICAgfSwgW19jKCdpbWcnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcInNyY1wiOiBfdm0uZ2V0SW1hZ2VVcmkocy5yZWN0KVxuICAgICAgfVxuICAgIH0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJidXR0b25zXCJcbiAgICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJidG4gYnRuLWNvbnRyb2xcIixcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmVkaXRTZWxlY3Rpb24ocylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygnaWNvbicsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlbmNpbFwiXG4gICAgICB9XG4gICAgfSldLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJidG4gYnRuLWNvbnRyb2xcIixcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmRlbGV0ZVNlbGVjdGlvbihzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW19jKCdpY29uJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwidGltZXMtY2lyY2xlXCJcbiAgICAgIH1cbiAgICB9KV0sIDEpXSldKVxuICB9KSldKV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNzZiZjExYTFcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lv-help-modal"\n    }\n  }, [_c(\'modal\', {\n    attrs: {\n      "id": _vm.id,\n      "title": "Help"\n    }\n  }, [_c(\'h4\', [_vm._v("Viewer controls")]), _vm._v(" "), _c(\'p\', [_vm._v("The following controls are provided to the left of the viewer:")]), _vm._v(" "), _c(\'ul\', [_c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "plus-circle"\n    }\n  }), _vm._v("Zoom in")], 1), _vm._v(" "), _c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "minus-circle"\n    }\n  }), _vm._v("Zoom out")], 1), _vm._v(" "), _c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "refresh"\n    }\n  }), _vm._v("Reset zoom")], 1), _vm._v(" "), _c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "expand"\n    }\n  }), _vm._v("Fullscreen")], 1), _vm._v(" "), _c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "question-circle"\n    }\n  }), _vm._v("Help")], 1)]), _vm._v(" "), (_vm.mode === \'selection\') ? _c(\'div\', [_c(\'h4\', [_vm._v("Selection mode")]), _vm._v(" "), _c(\'p\', [_vm._v("\\n        When using the viewer in selection mode an area of the image can\\n        be selected by clicking (or tapping) on the image. The following \\n        controls are provided to the right of the selection box:\\n      ")]), _vm._v(" "), _c(\'ul\', [_c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "check-circle"\n    }\n  }), _vm._v("Confirm selection")], 1), _vm._v(" "), _c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "times-circle"\n    }\n  }), _vm._v("Cancel selection")], 1)]), _vm._v(" "), _c(\'p\', [_vm._v("\\n        Once a selection has been confirmed it will appear in the \\n        selections sidebar to the right of the screen, where the following\\n        controls are provided:\\n      ")]), _vm._v(" "), _c(\'ul\', [_c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "pencil"\n    }\n  }), _vm._v("Edit selection")], 1), _vm._v(" "), _c(\'li\', [_c(\'icon\', {\n    attrs: {\n      "name": "times-circle"\n    }\n  }), _vm._v("Delete selection")], 1)])]) : _vm._e()])], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL0hlbHAudnVlP2RiOWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjYwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsdi1oZWxwLW1vZGFsXCJcbiAgICB9XG4gIH0sIFtfYygnbW9kYWwnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogX3ZtLmlkLFxuICAgICAgXCJ0aXRsZVwiOiBcIkhlbHBcIlxuICAgIH1cbiAgfSwgW19jKCdoNCcsIFtfdm0uX3YoXCJWaWV3ZXIgY29udHJvbHNcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCBbX3ZtLl92KFwiVGhlIGZvbGxvd2luZyBjb250cm9scyBhcmUgcHJvdmlkZWQgdG8gdGhlIGxlZnQgb2YgdGhlIHZpZXdlcjpcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3VsJywgW19jKCdsaScsIFtfYygnaWNvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJuYW1lXCI6IFwicGx1cy1jaXJjbGVcIlxuICAgIH1cbiAgfSksIF92bS5fdihcIlpvb20gaW5cIildLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2xpJywgW19jKCdpY29uJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJtaW51cy1jaXJjbGVcIlxuICAgIH1cbiAgfSksIF92bS5fdihcIlpvb20gb3V0XCIpXSwgMSksIF92bS5fdihcIiBcIiksIF9jKCdsaScsIFtfYygnaWNvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJuYW1lXCI6IFwicmVmcmVzaFwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiUmVzZXQgem9vbVwiKV0sIDEpLCBfdm0uX3YoXCIgXCIpLCBfYygnbGknLCBbX2MoJ2ljb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwibmFtZVwiOiBcImV4cGFuZFwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiRnVsbHNjcmVlblwiKV0sIDEpLCBfdm0uX3YoXCIgXCIpLCBfYygnbGknLCBbX2MoJ2ljb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwibmFtZVwiOiBcInF1ZXN0aW9uLWNpcmNsZVwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiSGVscFwiKV0sIDEpXSksIF92bS5fdihcIiBcIiksIChfdm0ubW9kZSA9PT0gJ3NlbGVjdGlvbicpID8gX2MoJ2RpdicsIFtfYygnaDQnLCBbX3ZtLl92KFwiU2VsZWN0aW9uIG1vZGVcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCBbX3ZtLl92KFwiXFxuICAgICAgICBXaGVuIHVzaW5nIHRoZSB2aWV3ZXIgaW4gc2VsZWN0aW9uIG1vZGUgYW4gYXJlYSBvZiB0aGUgaW1hZ2UgY2FuXFxuICAgICAgICBiZSBzZWxlY3RlZCBieSBjbGlja2luZyAob3IgdGFwcGluZykgb24gdGhlIGltYWdlLiBUaGUgZm9sbG93aW5nIFxcbiAgICAgICAgY29udHJvbHMgYXJlIHByb3ZpZGVkIHRvIHRoZSByaWdodCBvZiB0aGUgc2VsZWN0aW9uIGJveDpcXG4gICAgICBcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3VsJywgW19jKCdsaScsIFtfYygnaWNvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJuYW1lXCI6IFwiY2hlY2stY2lyY2xlXCJcbiAgICB9XG4gIH0pLCBfdm0uX3YoXCJDb25maXJtIHNlbGVjdGlvblwiKV0sIDEpLCBfdm0uX3YoXCIgXCIpLCBfYygnbGknLCBbX2MoJ2ljb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwibmFtZVwiOiBcInRpbWVzLWNpcmNsZVwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiQ2FuY2VsIHNlbGVjdGlvblwiKV0sIDEpXSksIF92bS5fdihcIiBcIiksIF9jKCdwJywgW192bS5fdihcIlxcbiAgICAgICAgT25jZSBhIHNlbGVjdGlvbiBoYXMgYmVlbiBjb25maXJtZWQgaXQgd2lsbCBhcHBlYXIgaW4gdGhlIFxcbiAgICAgICAgc2VsZWN0aW9ucyBzaWRlYmFyIHRvIHRoZSByaWdodCBvZiB0aGUgc2NyZWVuLCB3aGVyZSB0aGUgZm9sbG93aW5nXFxuICAgICAgICBjb250cm9scyBhcmUgcHJvdmlkZWQ6XFxuICAgICAgXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd1bCcsIFtfYygnbGknLCBbX2MoJ2ljb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwibmFtZVwiOiBcInBlbmNpbFwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiRWRpdCBzZWxlY3Rpb25cIildLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2xpJywgW19jKCdpY29uJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJ0aW1lcy1jaXJjbGVcIlxuICAgIH1cbiAgfSksIF92bS5fdihcIkRlbGV0ZSBzZWxlY3Rpb25cIildLCAxKV0pXSkgOiBfdm0uX2UoKV0pXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi04ODkwYmVlNlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21vZGFscy9IZWxwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lv-viewer"\n    }\n  }, [_c(\'viewer-controls\', {\n    ref: "viewerControls",\n    attrs: {\n      "showHelp": _vm.showHelp,\n      "showInfo": _vm.manifestId.length > 0,\n      "zoomInButton": _vm.normalizedViewerOpts.zoomInButton,\n      "zoomOutButton": _vm.normalizedViewerOpts.zoomOutButton,\n      "homeButton": _vm.normalizedViewerOpts.homeButton,\n      "fullPageButton": _vm.normalizedViewerOpts.fullPageButton,\n      "helpButton": _vm.normalizedViewerOpts.helpButton,\n      "infoButton": _vm.normalizedViewerOpts.infoButton\n    },\n    on: {\n      "helpclicked": _vm.handleHelpControlClick,\n      "infoclicked": _vm.handleInfoControlClick\n    }\n  }), _vm._v(" "), _c(\'pan-controls\', {\n    ref: "panControls",\n    attrs: {\n      "panBy": _vm.panBy\n    }\n  }), _vm._v(" "), (_vm.manifestId) ? _c(\'metadata-modal\', {\n    attrs: {\n      "id": _vm.metadataModalId,\n      "scheme": _vm.scheme,\n      "server": _vm.server,\n      "presentation-api-prefix": _vm.presentationApiPrefix,\n      "manifestId": _vm.manifestId\n    }\n  }) : _vm._e(), _vm._v(" "), (_vm.showHelp) ? _c(\'help-modal\', {\n    attrs: {\n      "id": _vm.helpModalId,\n      "mode": _vm.mode\n    }\n  }) : _vm._e(), _vm._v(" "), _c(\'div\', {\n    attrs: {\n      "id": "lv-sidebars"\n    }\n  }, [_c(\'task-sidebar\', {\n    attrs: {\n      "objective": _vm.objective,\n      "guidance": _vm.guidance,\n      "showNote": _vm.showNote\n    },\n    on: {\n      "submit": _vm.submit\n    }\n  }), _vm._v(" "), (_vm.mode === \'selection\') ? _c(\'selection-sidebar\') : _vm._e()], 1), _vm._v(" "), _c(\'div\', {\n    ref: "confirmSelection",\n    staticClass: "selection-btn",\n    attrs: {\n      "id": "confirm-selection"\n    }\n  }, [_c(\'icon\', {\n    attrs: {\n      "name": "check-circle"\n    }\n  })], 1), _vm._v(" "), _c(\'div\', {\n    ref: "cancelSelection",\n    staticClass: "selection-btn",\n    attrs: {\n      "id": "cancel-selection"\n    }\n  }, [_c(\'icon\', {\n    attrs: {\n      "name": "times-circle"\n    }\n  })], 1), _vm._v(" "), _c(\'div\', {\n    ref: "viewer",\n    attrs: {\n      "id": "lv-viewer-container"\n    }\n  })], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT8xODYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjYxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsdi12aWV3ZXJcIlxuICAgIH1cbiAgfSwgW19jKCd2aWV3ZXItY29udHJvbHMnLCB7XG4gICAgcmVmOiBcInZpZXdlckNvbnRyb2xzXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwic2hvd0hlbHBcIjogX3ZtLnNob3dIZWxwLFxuICAgICAgXCJzaG93SW5mb1wiOiBfdm0ubWFuaWZlc3RJZC5sZW5ndGggPiAwLFxuICAgICAgXCJ6b29tSW5CdXR0b25cIjogX3ZtLm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLnpvb21JbkJ1dHRvbixcbiAgICAgIFwiem9vbU91dEJ1dHRvblwiOiBfdm0ubm9ybWFsaXplZFZpZXdlck9wdHMuem9vbU91dEJ1dHRvbixcbiAgICAgIFwiaG9tZUJ1dHRvblwiOiBfdm0ubm9ybWFsaXplZFZpZXdlck9wdHMuaG9tZUJ1dHRvbixcbiAgICAgIFwiZnVsbFBhZ2VCdXR0b25cIjogX3ZtLm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLmZ1bGxQYWdlQnV0dG9uLFxuICAgICAgXCJoZWxwQnV0dG9uXCI6IF92bS5ub3JtYWxpemVkVmlld2VyT3B0cy5oZWxwQnV0dG9uLFxuICAgICAgXCJpbmZvQnV0dG9uXCI6IF92bS5ub3JtYWxpemVkVmlld2VyT3B0cy5pbmZvQnV0dG9uXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJoZWxwY2xpY2tlZFwiOiBfdm0uaGFuZGxlSGVscENvbnRyb2xDbGljayxcbiAgICAgIFwiaW5mb2NsaWNrZWRcIjogX3ZtLmhhbmRsZUluZm9Db250cm9sQ2xpY2tcbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygncGFuLWNvbnRyb2xzJywge1xuICAgIHJlZjogXCJwYW5Db250cm9sc1wiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInBhbkJ5XCI6IF92bS5wYW5CeVxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIChfdm0ubWFuaWZlc3RJZCkgPyBfYygnbWV0YWRhdGEtbW9kYWwnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogX3ZtLm1ldGFkYXRhTW9kYWxJZCxcbiAgICAgIFwic2NoZW1lXCI6IF92bS5zY2hlbWUsXG4gICAgICBcInNlcnZlclwiOiBfdm0uc2VydmVyLFxuICAgICAgXCJwcmVzZW50YXRpb24tYXBpLXByZWZpeFwiOiBfdm0ucHJlc2VudGF0aW9uQXBpUHJlZml4LFxuICAgICAgXCJtYW5pZmVzdElkXCI6IF92bS5tYW5pZmVzdElkXG4gICAgfVxuICB9KSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLnNob3dIZWxwKSA/IF9jKCdoZWxwLW1vZGFsJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IF92bS5oZWxwTW9kYWxJZCxcbiAgICAgIFwibW9kZVwiOiBfdm0ubW9kZVxuICAgIH1cbiAgfSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImx2LXNpZGViYXJzXCJcbiAgICB9XG4gIH0sIFtfYygndGFzay1zaWRlYmFyJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm9iamVjdGl2ZVwiOiBfdm0ub2JqZWN0aXZlLFxuICAgICAgXCJndWlkYW5jZVwiOiBfdm0uZ3VpZGFuY2UsXG4gICAgICBcInNob3dOb3RlXCI6IF92bS5zaG93Tm90ZVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwic3VibWl0XCI6IF92bS5zdWJtaXRcbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLm1vZGUgPT09ICdzZWxlY3Rpb24nKSA/IF9jKCdzZWxlY3Rpb24tc2lkZWJhcicpIDogX3ZtLl9lKCldLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICByZWY6IFwiY29uZmlybVNlbGVjdGlvblwiLFxuICAgIHN0YXRpY0NsYXNzOiBcInNlbGVjdGlvbi1idG5cIixcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImNvbmZpcm0tc2VsZWN0aW9uXCJcbiAgICB9XG4gIH0sIFtfYygnaWNvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJuYW1lXCI6IFwiY2hlY2stY2lyY2xlXCJcbiAgICB9XG4gIH0pXSwgMSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgcmVmOiBcImNhbmNlbFNlbGVjdGlvblwiLFxuICAgIHN0YXRpY0NsYXNzOiBcInNlbGVjdGlvbi1idG5cIixcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImNhbmNlbC1zZWxlY3Rpb25cIlxuICAgIH1cbiAgfSwgW19jKCdpY29uJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJ0aW1lcy1jaXJjbGVcIlxuICAgIH1cbiAgfSldLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICByZWY6IFwidmlld2VyXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsdi12aWV3ZXItY29udGFpbmVyXCJcbiAgICB9XG4gIH0pXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1hYWQ0MWI0MlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL1ZpZXdlci52dWVcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "lv-pan-controls"\n  }, [_c(\'controls\', {\n    attrs: {\n      "position": "bottom",\n      "scale": "1",\n      "buttons": _vm.buttons\n    }\n  })], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvY29udHJvbHMvUGFuLnZ1ZT83NTVhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsdi1wYW4tY29udHJvbHNcIlxuICB9LCBbX2MoJ2NvbnRyb2xzJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInBvc2l0aW9uXCI6IFwiYm90dG9tXCIsXG4gICAgICBcInNjYWxlXCI6IFwiMVwiLFxuICAgICAgXCJidXR0b25zXCI6IF92bS5idXR0b25zXG4gICAgfVxuICB9KV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYmViZDRkZGVcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9jb250cm9scy9QYW4udnVlXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lv-metadata-modal"\n    }\n  }, [_c(\'modal\', {\n    attrs: {\n      "id": _vm.id,\n      "title": "Metadata"\n    }\n  }, [_vm._l((_vm.manifestData.metadata), function(m) {\n    return _c(\'ul\', {\n      key: m.label\n    }, [_c(\'li\', [_c(\'strong\', [_vm._v(_vm._s(m.label) + ":")]), _vm._v("\\n         \\n        "), _c(\'span\', {\n      domProps: {\n        "innerHTML": _vm._s(m.value)\n      }\n    })])])\n  }), _vm._v(" "), _c(\'div\', {\n    attrs: {\n      "id": "rights"\n    }\n  }, [_c(\'img\', {\n    attrs: {\n      "src": _vm.manifestData.logo\n    }\n  }), _vm._v(" "), _c(\'p\', {\n    domProps: {\n      "innerHTML": _vm._s(_vm.manifestData.attribution)\n    }\n  }), _vm._v(" "), _c(\'p\', {\n    domProps: {\n      "innerHTML": _vm._s(_vm.manifestData.license)\n    }\n  })])], 2)], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL01ldGFkYXRhLnZ1ZT9lZGYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsdi1tZXRhZGF0YS1tb2RhbFwiXG4gICAgfVxuICB9LCBbX2MoJ21vZGFsJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IF92bS5pZCxcbiAgICAgIFwidGl0bGVcIjogXCJNZXRhZGF0YVwiXG4gICAgfVxuICB9LCBbX3ZtLl9sKChfdm0ubWFuaWZlc3REYXRhLm1ldGFkYXRhKSwgZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBfYygndWwnLCB7XG4gICAgICBrZXk6IG0ubGFiZWxcbiAgICB9LCBbX2MoJ2xpJywgW19jKCdzdHJvbmcnLCBbX3ZtLl92KF92bS5fcyhtLmxhYmVsKSArIFwiOlwiKV0pLCBfdm0uX3YoXCJcXG4gICAgICAgIMKgXFxuICAgICAgICBcIiksIF9jKCdzcGFuJywge1xuICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKG0udmFsdWUpXG4gICAgICB9XG4gICAgfSldKV0pXG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwicmlnaHRzXCJcbiAgICB9XG4gIH0sIFtfYygnaW1nJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInNyY1wiOiBfdm0ubWFuaWZlc3REYXRhLmxvZ29cbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygncCcsIHtcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKF92bS5tYW5pZmVzdERhdGEuYXR0cmlidXRpb24pXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCB7XG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwiaW5uZXJIVE1MXCI6IF92bS5fcyhfdm0ubWFuaWZlc3REYXRhLmxpY2Vuc2UpXG4gICAgfVxuICB9KV0pXSwgMildLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWVmOWMyOTBhXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL01ldGFkYXRhLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(39);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(65)(\"e61d7c06\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT82MjlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0Esb0NBQTJMO0FBQzNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTQ2ZTcyMGI4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BcHAudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJlNjFkN2MwNlwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00NmU3MjBiOFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(66)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz82YjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcz9lNmFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\nvar bind = __webpack_require__(20);\nvar Axios = __webpack_require__(69);\nvar defaults = __webpack_require__(8);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(17);\naxios.CancelToken = __webpack_require__(68);\naxios.isCancel = __webpack_require__(18);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(83);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvYXhpb3MuanM/ODgyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvYXhpb3MuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Cancel = __webpack_require__(17);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzPzdjZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar defaults = __webpack_require__(8);\nvar utils = __webpack_require__(2);\nvar InterceptorManager = __webpack_require__(70);\nvar dispatchRequest = __webpack_require__(71);\nvar isAbsoluteURL = __webpack_require__(79);\nvar combineURLs = __webpack_require__(77);\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);\n  config.method = config.method.toLowerCase();\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9BeGlvcy5qcz8yZDM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaURBQWlELGdCQUFnQjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCB7IG1ldGhvZDogJ2dldCcgfSwgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NvcmUvQXhpb3MuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanM/MzcxYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\nvar transformData = __webpack_require__(74);\nvar isCancel = __webpack_require__(18);\nvar defaults = __webpack_require__(8);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanM/MWJiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnMgfHwge31cbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanM/ZjA4NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar createError = __webpack_require__(19);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanM/YjYzYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjczLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzPzE2NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsImZpbGUiOiI3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9idG9hLmpzPzI1YzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      }\n\n      if (!utils.isArray(val)) {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcz9jOTdlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcz8wMmYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzP2UzNmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QyxPQUFPOztBQUVQO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw2QkFBNkIsYUFBYSxFQUFFO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzPzcyNTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanM/ZTc1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI4MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzPzI2OGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjgxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(2);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanM/NGNmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanM/MGU3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(29);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\nvar icons = {};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'icon',\n  props: {\n    name: {\n      type: String,\n      validator: function validator(val) {\n        if (val) {\n          if (!(val in icons)) {\n            __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */].util.warn('Invalid prop: prop \"icon\" is referring to an unregistered icon \"' + val + '\".' + '\\nPlesase make sure you have imported this icon before using it.', this);\n            return false;\n          }\n          return true;\n        }\n        return null;\n      }\n    },\n    scale: [Number, String],\n    spin: Boolean,\n    inverse: Boolean,\n    flip: {\n      validator: function validator(val) {\n        return val === 'horizontal' || val === 'vertical';\n      }\n    },\n    label: String\n  },\n  data: function data() {\n    return {\n      x: false,\n      y: false,\n      childrenWidth: 0,\n      childrenHeight: 0,\n      outerScale: 1\n    };\n  },\n\n  computed: {\n    normalizedScale: function normalizedScale() {\n      var scale = this.scale;\n      scale = typeof scale === 'undefined' ? 1 : Number(scale);\n      if (isNaN(scale) || scale <= 0) {\n        __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */].util.warn('Invalid prop: prop \"scale\" should be a number over 0.', this);\n        return this.outerScale;\n      }\n      return scale * this.outerScale;\n    },\n    clazz: function clazz() {\n      return {\n        'fa-icon': true,\n        'fa-spin': this.spin,\n        'fa-flip-horizontal': this.flip === 'horizontal',\n        'fa-flip-vertical': this.flip === 'vertical',\n        'fa-inverse': this.inverse\n      };\n    },\n    icon: function icon() {\n      if (this.name) {\n        return icons[this.name];\n      }\n      return null;\n    },\n    box: function box() {\n      if (this.icon) {\n        return '0 0 ' + this.icon.width + ' ' + this.icon.height;\n      }\n      return '0 0 ' + this.width + ' ' + this.height;\n    },\n    ratio: function ratio() {\n      if (!this.icon) {\n        return 1;\n      }\n      var _icon = this.icon,\n          width = _icon.width,\n          height = _icon.height;\n\n      return Math.max(width, height) / 16;\n    },\n    width: function width() {\n      return this.childrenWidth || this.icon && this.icon.width / this.ratio * this.normalizedScale || 0;\n    },\n    height: function height() {\n      return this.childrenHeight || this.icon && this.icon.height / this.ratio * this.normalizedScale || 0;\n    },\n    style: function style() {\n      if (this.normalizedScale === 1) {\n        return false;\n      }\n      return {\n        fontSize: this.normalizedScale + 'em'\n      };\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    if (this.icon) {\n      return;\n    }\n    this.$children.forEach(function (child) {\n      child.outerScale = _this.normalizedScale;\n    });\n    var width = 0;\n    var height = 0;\n    this.$children.forEach(function (child) {\n      width = Math.max(width, child.width);\n      height = Math.max(height, child.height);\n    });\n    this.childrenWidth = width;\n    this.childrenHeight = height;\n    this.$children.forEach(function (child) {\n      child.x = (width - child.width) / 2;\n      child.y = (height - child.height) / 2;\n    });\n  },\n  register: function register(data) {\n    for (var name in data) {\n      var icon = data[name];\n\n      if (!icon.paths) {\n        icon.paths = [];\n      }\n      if (icon.d) {\n        icon.paths.push({ d: icon.d });\n      }\n\n      if (!icon.polygons) {\n        icon.polygons = [];\n      }\n      if (icon.points) {\n        icon.polygons.push({ points: icon.points });\n      }\n\n      icons[name] = icon;\n    }\n  },\n\n  icons: icons\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vSWNvbi52dWU/NDBhMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBOztBQUVBOztBQUVBO1FBRUE7OztZQUdBO3lDQUNBO2lCQUNBOytCQUNBO2dKQUNBLGlGQUNBO21CQUNBO0FBQ0E7aUJBQ0E7QUFDQTtlQUNBO0FBRUE7QUFiQTtvQkFjQTtVQUNBO2FBQ0E7O3lDQUVBOytDQUNBO0FBRUE7QUFKQTtXQU1BO0FBeEJBO3dCQXlCQTs7U0FFQTtTQUNBO3FCQUNBO3NCQUNBO2tCQUVBO0FBTkE7QUFPQTs7O2dEQUVBO3VCQUNBO3dEQUNBO3NDQUNBO2dJQUNBO29CQUNBO0FBQ0E7MEJBQ0E7QUFDQTs0QkFDQTs7bUJBRUE7d0JBQ0E7NENBQ0E7MENBQ0E7MkJBRUE7QUFOQTtBQU9BOzBCQUNBO3FCQUNBOzBCQUNBO0FBQ0E7YUFDQTtBQUNBO3dCQUNBO3FCQUNBOzBEQUNBO0FBQ0E7OENBQ0E7QUFDQTs7c0JBRUE7ZUFDQTtBQUNBO0FBSEEsdUJBSUE7Ozs7dUNBQ0E7QUFDQTs0QkFDQTt1R0FDQTtBQUNBOzhCQUNBO3lHQUNBO0FBQ0E7NEJBQ0E7c0NBQ0E7ZUFDQTtBQUNBOzt5Q0FHQTtBQUZBO0FBSUE7QUFwREE7O0FBcURBOzttQkFDQTtBQUNBO0FBQ0E7NENBQ0E7K0JBQ0E7QUFDQTtnQkFDQTtpQkFDQTs0Q0FDQTtvQ0FDQTtzQ0FDQTtBQUNBO3lCQUNBOzBCQUNBOzRDQUNBO3dDQUNBOzBDQUNBO0FBQ0E7QUFDQTtvQ0FDQTsyQkFDQTtzQkFFQTs7dUJBQ0E7cUJBQ0E7QUFDQTtrQkFDQTtrQ0FDQTtBQUVBOzswQkFDQTt3QkFDQTtBQUNBO3VCQUNBOzBDQUNBO0FBRUE7O29CQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQWxJQSIsImZpbGUiOiI4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgOmNsYXNzPVwiY2xhenpcIiA6cm9sZT1cImxhYmVsID8gJ2ltZycgOiAncHJlc2VudGF0aW9uJ1wiIDphcmlhLWxhYmVsPVwibGFiZWxcIiA6eD1cInhcIiA6eT1cInlcIiA6d2lkdGg9XCJ3aWR0aFwiIDpoZWlnaHQ9XCJoZWlnaHRcIiA6dmlld0JveD1cImJveFwiIDpzdHlsZT1cInN0eWxlXCI+XG4gICAgPHNsb3Q+XG4gICAgICA8dGVtcGxhdGUgdi1pZj1cImljb24gJiYgaWNvbi5wYXRoc1wiPlxuICAgICAgICA8cGF0aCB2LWZvcj1cInBhdGggaW4gaWNvbi5wYXRoc1wiIHYtYmluZD1cInBhdGhcIi8+XG4gICAgICA8L3RlbXBsYXRlPlxuICAgICAgPHRlbXBsYXRlIHYtaWY9XCJpY29uICYmIGljb24ucG9seWdvbnNcIj5cbiAgICAgICAgPHBvbHlnb24gdi1mb3I9XCJwb2x5Z29uIGluIGljb24ucG9seWdvbnNcIiB2LWJpbmQ9XCJwb2x5Z29uXCIvPlxuICAgICAgPC90ZW1wbGF0ZT5cYlxuICAgICAgPHRlbXBsYXRlIHYtaWY9XCJpY29uICYmIGljb24ucmF3XCI+PGcgdi1odG1sPVwiaWNvbi5yYXdcIj48L2c+PC90ZW1wbGF0ZT5cbiAgICA8L3Nsb3Q+XG4gIDwvc3ZnPlxuPC90ZW1wbGF0ZT5cblxuPHN0eWxlPlxuLmZhLWljb24ge1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGZpbGw6IGN1cnJlbnRDb2xvcjtcbn1cblxuLmZhLWZsaXAtaG9yaXpvbnRhbCB7XG4gIHRyYW5zZm9ybTogc2NhbGUoLTEsIDEpO1xufVxuXG4uZmEtZmxpcC12ZXJ0aWNhbCB7XG4gIHRyYW5zZm9ybTogc2NhbGUoMSwgLTEpO1xufVxuXG4uZmEtc3BpbiB7XG4gIGFuaW1hdGlvbjogZmEtc3BpbiAxcyAwcyBpbmZpbml0ZSBsaW5lYXI7XG59XG5cbi5mYS1pbnZlcnNlIHtcbiAgY29sb3I6ICNmZmY7XG59XG5cbkBrZXlmcmFtZXMgZmEtc3BpbiB7XG4gIDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgfVxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICB9XG59XG48L3N0eWxlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5cbmxldCBpY29ucyA9IHt9XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ljb24nLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbGlkYXRvciAodmFsKSB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICBpZiAoISh2YWwgaW4gaWNvbnMpKSB7XG4gICAgICAgICAgICBWdWUudXRpbC53YXJuKGBJbnZhbGlkIHByb3A6IHByb3AgXCJpY29uXCIgaXMgcmVmZXJyaW5nIHRvIGFuIHVucmVnaXN0ZXJlZCBpY29uIFwiJHt2YWx9XCIuYCArXG4gICAgICAgICAgICAgIGBcXG5QbGVzYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSBpbXBvcnRlZCB0aGlzIGljb24gYmVmb3JlIHVzaW5nIGl0LmAsIHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgc3BpbjogQm9vbGVhbixcbiAgICBpbnZlcnNlOiBCb29sZWFuLFxuICAgIGZsaXA6IHtcbiAgICAgIHZhbGlkYXRvciAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09ICdob3Jpem9udGFsJyB8fCB2YWwgPT09ICd2ZXJ0aWNhbCdcbiAgICAgIH1cbiAgICB9LFxuICAgIGxhYmVsOiBTdHJpbmdcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGZhbHNlLFxuICAgICAgeTogZmFsc2UsXG4gICAgICBjaGlsZHJlbldpZHRoOiAwLFxuICAgICAgY2hpbGRyZW5IZWlnaHQ6IDAsXG4gICAgICBvdXRlclNjYWxlOiAxXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG5vcm1hbGl6ZWRTY2FsZSAoKSB7XG4gICAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlXG4gICAgICBzY2FsZSA9IHR5cGVvZiBzY2FsZSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogTnVtYmVyKHNjYWxlKVxuICAgICAgaWYgKGlzTmFOKHNjYWxlKSB8fCBzY2FsZSA8PSAwKSB7XG4gICAgICAgIFZ1ZS51dGlsLndhcm4oYEludmFsaWQgcHJvcDogcHJvcCBcInNjYWxlXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG92ZXIgMC5gLCB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5vdXRlclNjYWxlXG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGUgKiB0aGlzLm91dGVyU2NhbGVcbiAgICB9LFxuICAgIGNsYXp6ICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdmYS1pY29uJzogdHJ1ZSxcbiAgICAgICAgJ2ZhLXNwaW4nOiB0aGlzLnNwaW4sXG4gICAgICAgICdmYS1mbGlwLWhvcml6b250YWwnOiB0aGlzLmZsaXAgPT09ICdob3Jpem9udGFsJyxcbiAgICAgICAgJ2ZhLWZsaXAtdmVydGljYWwnOiB0aGlzLmZsaXAgPT09ICd2ZXJ0aWNhbCcsXG4gICAgICAgICdmYS1pbnZlcnNlJzogdGhpcy5pbnZlcnNlXG4gICAgICB9XG4gICAgfSxcbiAgICBpY29uICgpIHtcbiAgICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGljb25zW3RoaXMubmFtZV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSxcbiAgICBib3ggKCkge1xuICAgICAgaWYgKHRoaXMuaWNvbikge1xuICAgICAgICByZXR1cm4gYDAgMCAke3RoaXMuaWNvbi53aWR0aH0gJHt0aGlzLmljb24uaGVpZ2h0fWBcbiAgICAgIH1cbiAgICAgIHJldHVybiBgMCAwICR7dGhpcy53aWR0aH0gJHt0aGlzLmhlaWdodH1gXG4gICAgfSxcbiAgICByYXRpbyAoKSB7XG4gICAgICBpZiAoIXRoaXMuaWNvbikge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5pY29uXG4gICAgICByZXR1cm4gTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgLyAxNlxuICAgIH0sXG4gICAgd2lkdGggKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5XaWR0aCB8fCB0aGlzLmljb24gJiYgdGhpcy5pY29uLndpZHRoIC8gdGhpcy5yYXRpbyAqIHRoaXMubm9ybWFsaXplZFNjYWxlIHx8IDBcbiAgICB9LFxuICAgIGhlaWdodCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbkhlaWdodCB8fCB0aGlzLmljb24gJiYgdGhpcy5pY29uLmhlaWdodCAvIHRoaXMucmF0aW8gKiB0aGlzLm5vcm1hbGl6ZWRTY2FsZSB8fCAwXG4gICAgfSxcbiAgICBzdHlsZSAoKSB7XG4gICAgICBpZiAodGhpcy5ub3JtYWxpemVkU2NhbGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb250U2l6ZTogdGhpcy5ub3JtYWxpemVkU2NhbGUgKyAnZW0nXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICBpZiAodGhpcy5pY29uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC5vdXRlclNjYWxlID0gdGhpcy5ub3JtYWxpemVkU2NhbGVcbiAgICB9KVxuICAgIGxldCB3aWR0aCA9IDBcbiAgICBsZXQgaGVpZ2h0ID0gMFxuICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY2hpbGQud2lkdGgpXG4gICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGNoaWxkLmhlaWdodClcbiAgICB9KVxuICAgIHRoaXMuY2hpbGRyZW5XaWR0aCA9IHdpZHRoXG4gICAgdGhpcy5jaGlsZHJlbkhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY2hpbGQueCA9ICh3aWR0aCAtIGNoaWxkLndpZHRoKSAvIDJcbiAgICAgIGNoaWxkLnkgPSAoaGVpZ2h0IC0gY2hpbGQuaGVpZ2h0KSAvIDJcbiAgICB9KVxuICB9LFxuICByZWdpc3RlciAoZGF0YSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gZGF0YSkge1xuICAgICAgbGV0IGljb24gPSBkYXRhW25hbWVdXG5cbiAgICAgIGlmICghaWNvbi5wYXRocykge1xuICAgICAgICBpY29uLnBhdGhzID0gW11cbiAgICAgIH1cbiAgICAgIGlmIChpY29uLmQpIHtcbiAgICAgICAgaWNvbi5wYXRocy5wdXNoKHsgZDogaWNvbi5kIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICghaWNvbi5wb2x5Z29ucykge1xuICAgICAgICBpY29uLnBvbHlnb25zID0gW11cbiAgICAgIH1cbiAgICAgIGlmIChpY29uLnBvaW50cykge1xuICAgICAgICBpY29uLnBvbHlnb25zLnB1c2goeyBwb2ludHM6IGljb24ucG9pbnRzIH0pXG4gICAgICB9XG5cbiAgICAgIGljb25zW25hbWVdID0gaWNvblxuICAgIH1cbiAgfSxcbiAgaWNvbnNcbn1cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIEljb24udnVlPzhhMzQ3MmJjIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_icons_plus_circle__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_awesome_icons_minus_circle__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_awesome_icons_refresh__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_vue_awesome_icons_expand__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue_awesome_icons_question_circle__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_awesome_icons_info_circle__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_vue_awesome_icons_chevron_up__ = __webpack_require__(113);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_vue_awesome_icons_chevron_down__ = __webpack_require__(110);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vue_awesome_icons_chevron_left__ = __webpack_require__(111);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_vue_awesome_icons_chevron_right__ = __webpack_require__(112);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_axios__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__Modal_vue__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__Modal_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__Modal_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      manifestData: {}\n    };\n  },\n\n  props: {\n    buttons: {\n      type: Array,\n      required: true\n    },\n    scale: {\n      type: [String, Number],\n      default: 1.25\n    },\n    position: {\n      type: String,\n      default: 'bottom'\n    }\n  },\n\n  components: {\n    Icon: __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default.a\n  },\n\n  methods: {\n    handleClick: function handleClick(func) {\n      if (typeof func !== 'undefined') {\n        func();\n      }\n    }\n  },\n\n  mounted: function mounted() {\n    this.$refs.controls.classList.add(this.position);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQ29udHJvbHMudnVlP2Q3NjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTt3QkFFQTs7b0JBR0E7QUFGQTtBQUlBOzs7O1lBR0E7Z0JBRUE7QUFIQTs7cUJBS0E7ZUFFQTtBQUhBOztZQUtBO2VBSUE7QUFMQTtBQVRBOzs7QUFrQkE7QUFIQTs7OzRDQUtBO3VDQUNBO0FBQ0E7QUFDQTtBQUdBO0FBUEE7OzhCQVFBOzJDQUNBO0FBQ0E7QUFwQ0EiLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgcmVmPVwiY29udHJvbHNcIiBjbGFzcz1cImx2LWNvbnRyb2xzXCI+XG5cbiAgICAgIDxidXR0b25cbiAgICAgICAgOmlkPVwiYi5pZFwiXG4gICAgICAgIHYtZm9yPVwiYiBpbiBidXR0b25zXCJcbiAgICAgICAgOmtleT1cImIuaWRcIlxuICAgICAgICBjbGFzcz1cImhpbnQtLXJpZ2h0IGhpbnQtLW5vLWFuaW1hdGUgYnRuIGJ0bi1jb250cm9sXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJiLnRvb2x0aXBcIlxuICAgICAgICBAY2xpY2s9XCJoYW5kbGVDbGljayhiLmNsaWNrKVwiPlxuICAgICAgICA8aWNvbiA6bmFtZT1cImIuaWNvblwiIDpzY2FsZT1cInNjYWxlXCI+PC9pY29uPlxuICAgICAgPC9idXR0b24+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEljb24gZnJvbSAndnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvcGx1cy1jaXJjbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL21pbnVzLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvcmVmcmVzaCdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvZXhwYW5kJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9xdWVzdGlvbi1jaXJjbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2luZm8tY2lyY2xlJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLXVwJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLWRvd24nXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2NoZXZyb24tbGVmdCdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvY2hldnJvbi1yaWdodCdcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hbmlmZXN0RGF0YToge31cbiAgICB9XG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICBidXR0b25zOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6IDEuMjVcbiAgICB9LFxuICAgIHBvc2l0aW9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYm90dG9tJ1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgSWNvblxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVDbGljayAoZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmdW5jKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy4kcmVmcy5jb250cm9scy5jbGFzc0xpc3QuYWRkKHRoaXMucG9zaXRpb24pXG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0ICd+aGludC5jc3MnO1xuQGltcG9ydCAnLi4vYXNzZXRzL3N0eWxlL3BhcnRpYWxzL2J1dHRvbnMnO1xuXG4ubHYtY29udHJvbHMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBtYXJnaW46IDFyZW07XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogMjtcbiAgYm9yZGVyLXJhZGl1czogMjVweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgcGFkZGluZzogMCAwLjVyZW07XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG5cbiAgJi5ib3R0b20ge1xuICAgIGJvdHRvbTogMDtcbiAgfVxuXG4gICYudG9wIHtcbiAgICB0b3A6IDA7XG4gIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gQ29udHJvbHMudnVlPzVmMTRlNDY5Il0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      show: false\n    };\n  },\n\n  props: {\n    title: String,\n    id: {\n      type: String,\n      requried: true\n    }\n  },\n\n  created: function created() {\n    var _this = this;\n\n    this.$root.$on('show::modal', function (id, triggerEl) {\n      if (id === _this.id) {\n        _this.show = true;\n      }\n    });\n    this.$root.$on('hide::modal', function (id) {\n      if (id === _this.id) {\n        _this.show = false;\n      }\n    });\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vTW9kYWwudnVlP2Q1NWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBO3dCQUVBOztZQUdBO0FBRkE7QUFJQTs7O1dBRUE7O1lBRUE7Z0JBSUE7QUFMQTtBQUZBOzs7QUFRQTs7MkRBQ0E7MkJBQ0E7cUJBQ0E7QUFDQTtBQUNBO2dEQUNBOzJCQUNBO3FCQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8dHJhbnNpdGlvbiBuYW1lPVwibW9kYWxcIj5cbiAgPGRpdiA6aWQ9XCJpZFwiIGNsYXNzPVwibW9kYWxcIiB2LXNob3c9XCJzaG93XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtbWFza1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtd3JhcHBlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250YWluZXJcIj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgPGgzPnt7IHRpdGxlIH19PC9oMz5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNsb3NlXCIgQGNsaWNrPVwic2hvdyA9IGZhbHNlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XG4gICAgICAgICAgICAgIDxzbG90PlxuICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZm9vdGVyXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0blwiIEBjbGljaz1cInNob3cgPSBmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgT0tcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDwvdHJhbnNpdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvdzogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1cmllZDogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkKCkge1xuICAgIHRoaXMuJHJvb3QuJG9uKCdzaG93Ojptb2RhbCcsIChpZCwgdHJpZ2dlckVsKSA9PiB7XG4gICAgICBpZiAoaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuJHJvb3QuJG9uKCdoaWRlOjptb2RhbCcsIGlkID0+IHtcbiAgICAgIGlmIChpZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4uL2Fzc2V0cy9zdHlsZS9zZXR0aW5ncyc7XG5AaW1wb3J0ICcuLi9hc3NldHMvc3R5bGUvcGFydGlhbHMvYnV0dG9ucyc7XG5cbi5tb2RhbCB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgaGVpZ2h0OiAxMDAlO1xuICB3aWR0aDogMTAwJTtcblxuICAubW9kYWwtbWFzayB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHotaW5kZXg6IDk5OTg7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgLjUpO1xuICAgIGRpc3BsYXk6IHRhYmxlO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjNzIGVhc2U7XG4gIH1cblxuICAubW9kYWwtd3JhcHBlciB7XG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICB9XG5cbiAgLm1vZGFsLWNvbnRhaW5lciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGNvbG9yOiAjZmZmO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICRncmF5LWRhcms7XG4gICAgbWFyZ2luLXRvcDogMmVtO1xuICAgIG1heC1oZWlnaHQ6IDYwMHB4O1xuICAgIHdpZHRoOiBhdXRvO1xuICAgIG1hcmdpbjogMHB4IGF1dG87XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAuMzMpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICRncmF5LWxpZ2h0O1xuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcblxuICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDU3NnB4KSB7XG4gICAgICBtYXgtd2lkdGg6IDUwMHB4O1xuICAgICAgbWFyZ2luOiAzMHB4IGF1dG87XG4gICAgfVxuXG4gICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcbiAgICAgIG1heC13aWR0aDogODAwcHg7XG4gICAgfVxuICB9XG5cbiAgLm1vZGFsLWhlYWRlciB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBwYWRkaW5nOiAyMHB4IDMwcHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICRncmF5LWxpZ2h0O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xuICAgICAgbWFyZ2luOiAwO1xuICAgIH1cblxuICAgIC5jbG9zZSB7XG4gICAgICBwYWRkaW5nOiAwO1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgYmFja2dyb3VuZDogMCAwO1xuICAgICAgYm9yZGVyOiAwO1xuICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgZm9udC1zaXplOiAxLjVyZW07XG4gICAgICBmb250LXdlaWdodDogMjAwO1xuICAgICAgbGluZS1oZWlnaHQ6IDE7XG4gICAgfVxuICB9XG5cbiAgLm1vZGFsLWJvZHkge1xuICAgIHBhZGRpbmc6IDIwcHggMzBweDtcbiAgICBvdmVyZmxvdzogYXV0bztcbiAgfVxuXG4gIC5tb2RhbC1mb290ZXIge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gICAgcGFkZGluZzogMjBweCAzMHB4O1xuICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAkZ3JheS1saWdodDtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG59XG5cbi5tb2RhbC1lbnRlciB7XG4gIG9wYWNpdHk6IDA7XG59XG5cbi5tb2RhbC1sZWF2ZS1hY3RpdmUge1xuICBvcGFjaXR5OiAwO1xufVxuXG4ubW9kYWwtZW50ZXIgLm1vZGFsLWNvbnRhaW5lcixcbi5tb2RhbC1sZWF2ZS1hY3RpdmUgLm1vZGFsLWNvbnRhaW5lciB7XG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwcHgpIHNjYWxlKDAuOSk7XG59XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIE1vZGFsLnZ1ZT8zMmNkMzUwMyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  data: function data() {\n    return {\n      contentCollapsed: false\n    };\n  },\n\n  props: {\n    title: {\n      type: String,\n      required: true\n    }\n  },\n\n  computed: {\n    toggleClassObj: function toggleClassObj() {\n      return {\n        toggle: true,\n        active: this.contentCollapsed\n      };\n    }\n  },\n\n  methods: {\n    toggleCollapse: function toggleCollapse() {\n      this.contentCollapsed = !this.contentCollapsed;\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vU2lkZWJhci52dWU/ODJjYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7d0JBRUE7O3dCQUdBO0FBRkE7QUFJQTs7OztZQUdBO2dCQUlBO0FBTEE7QUFEQTs7OzhDQVFBOztnQkFFQTtxQkFFQTtBQUhBO0FBTUE7QUFSQTs7OzhDQVVBO29DQUNBO0FBRUE7QUFKQTtBQXZCQSIsImZpbGUiOiI4Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImx2LXNpZGViYXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwibHYtc2lkZWJhci1oZWFkZXJcIj5cbiAgICAgIDxoND57eyB0aXRsZSB9fTwvaDQ+XG4gICAgICA8c3BhblxuICAgICAgICA6Y2xhc3M9XCJ0b2dnbGVDbGFzc09ialwiXG4gICAgICAgIEBjbGljaz1cInRvZ2dsZUNvbGxhcHNlXCI+XG4gICAgICAgICYjeDI1QjI7XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImx2LXNpZGViYXItY29udGVudFwiIHYtc2hvdz1cIiFjb250ZW50Q29sbGFwc2VkXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50Q29sbGFwc2VkOiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICBwcm9wczoge1xuICAgIHRpdGxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHRvZ2dsZUNsYXNzT2JqOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2dnbGU6IHRydWUsXG4gICAgICAgIGFjdGl2ZTogdGhpcy5jb250ZW50Q29sbGFwc2VkXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICB0b2dnbGVDb2xsYXBzZSAoKSB7XG4gICAgICB0aGlzLmNvbnRlbnRDb2xsYXBzZWQgPSAhdGhpcy5jb250ZW50Q29sbGFwc2VkXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuLmx2LXNpZGViYXIge1xuICBmb250LXNpemU6IDE0cHg7XG4gIGNvbG9yOiAjRkZGRkZGO1xuICBvdmVyZmxvdy15OiBhdXRvO1xuICBtYXgtaGVpZ2h0OiAxMDAlO1xuICBib3JkZXI6IDJweCBzb2xpZCByZ2IoODUsIDg1LCA4NSk7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIG1hcmdpbjogMXJlbTtcblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA5OTJweCkge1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIH1cblxuICAubHYtc2lkZWJhci1oZWFkZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcGFkZGluZzogMC42cmVtO1xuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICAgIGxldHRlci1zcGFjaW5nOiAxcHg7XG5cbiAgICBoNCB7XG4gICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgICAgbWFyZ2luOiAwO1xuICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICB9XG4gIH1cblxuICAubHYtc2lkZWJhci1jb250ZW50IHtcbiAgICBwYWRkaW5nOiAwLjZlbTtcbiAgfVxuXG4gIC50b2dnbGUge1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBjb2xvcjogI0ZGRkZGRjtcbiAgICBmbG9hdDogcmlnaHQ7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDUwMG1zO1xuXG4gICAgJi5hY3RpdmUge1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcbiAgICB9XG4gIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gU2lkZWJhci52dWU/MzI4OWUwYmMiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_uuid_v4__ = __webpack_require__(109);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_uuid_v4___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_uuid_v4__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_vue_awesome_components_Icon_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_awesome_icons_times_circle__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_awesome_icons_check_circle__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_openseadragon__ = __webpack_require__(105);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_openseadragon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_openseadragon__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_openseadragonselection_dist_openseadragonselection__ = __webpack_require__(106);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_openseadragonselection_dist_openseadragonselection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_openseadragonselection_dist_openseadragonselection__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_modals_Metadata_vue__ = __webpack_require__(49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_modals_Metadata_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__components_modals_Metadata_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_modals_Help_vue__ = __webpack_require__(48);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_modals_Help_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__components_modals_Help_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_controls_Viewer_vue__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_controls_Viewer_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__components_controls_Viewer_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_controls_Pan_vue__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_controls_Pan_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__components_controls_Pan_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_sidebars_Selection_vue__ = __webpack_require__(50);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_sidebars_Selection_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__components_sidebars_Selection_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_sidebars_Task_vue__ = __webpack_require__(51);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_sidebars_Task_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__components_sidebars_Task_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__store_js__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      metadataModalId: 'lc-metadata-modal',\n      helpModalId: 'lc-help-modal'\n    };\n  },\n\n  props: {\n    viewerOpts: Object,\n    mode: {\n      type: String,\n      default: 'selection'\n    },\n    objective: {\n      type: String,\n      default: null\n    },\n    guidance: {\n      type: String,\n      default: null\n    },\n    scheme: {\n      type: String,\n      default: 'http'\n    },\n    server: {\n      type: String,\n      default: null\n    },\n    imageApiPrefix: {\n      type: String,\n      default: null\n    },\n    presentationApiPrefix: {\n      type: String,\n      default: null\n    },\n    imageId: {\n      type: String,\n      default: null\n    },\n    manifestId: {\n      type: String,\n      default: null\n    },\n    confirmBeforeUnload: {\n      type: Boolean,\n      default: false\n    },\n    showHelp: {\n      type: Boolean,\n      default: true\n    },\n    showNote: {\n      type: Boolean,\n      default: false\n    },\n    panBy: {\n      type: Number,\n      default: 0.1\n    }\n  },\n\n  components: {\n    MetadataModal: __WEBPACK_IMPORTED_MODULE_6__components_modals_Metadata_vue___default.a,\n    HelpModal: __WEBPACK_IMPORTED_MODULE_7__components_modals_Help_vue___default.a,\n    ViewerControls: __WEBPACK_IMPORTED_MODULE_8__components_controls_Viewer_vue___default.a,\n    PanControls: __WEBPACK_IMPORTED_MODULE_9__components_controls_Pan_vue___default.a,\n    SelectionSidebar: __WEBPACK_IMPORTED_MODULE_10__components_sidebars_Selection_vue___default.a,\n    TaskSidebar: __WEBPACK_IMPORTED_MODULE_11__components_sidebars_Task_vue___default.a,\n    Icon: __WEBPACK_IMPORTED_MODULE_1_vue_awesome_components_Icon_vue___default.a\n  },\n\n  computed: {\n    normalizedViewerOpts: function normalizedViewerOpts() {\n      var defaultOpts = {\n        zoomInButton: 'zoom-in',\n        zoomOutButton: 'zoom-out',\n        homeButton: 'reset-zoom',\n        fullPageButton: 'toggle-fullscreen',\n        helpButton: 'show-help',\n        infoButton: 'show-info',\n        panVertical: false,\n        panHorizontal: false,\n        gestureSettingsMouse: {\n          clickToZoom: false\n        },\n        gestureSettingsTouch: {\n          dblClickToZoom: false\n        },\n        gestureSettingsPen: {\n          dblClickToZoom: false\n        }\n      };\n      return Object.assign(defaultOpts, this.viewerOpts);\n    },\n    imgSource: function imgSource() {\n      var imgSource = this.scheme + '://' + (this.server + '/') + (this.imageApiPrefix + '/') + ('' + this.imageId);\n      __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].commit('SET_ITEM', { key: 'imgSource', value: imgSource });\n      return imgSource;\n    }\n  },\n\n  methods: {\n    loadImage: function loadImage() {\n      var viewer = __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].state.viewer;\n      viewer.open({\n        type: 'image',\n        tileSource: this.imgSource + '/info.json',\n        buildPyramid: false\n      });\n    },\n    attachControls: function attachControls() {\n      // TODO: this works for fullscreen controls but should possibly use\n      // https://openseadragon.github.io/docs/OpenSeadragon.Control.html\n      var viewer = __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].state.viewer;\n      viewer.container.prepend(this.$refs.viewerControls.$el);\n      viewer.container.prepend(this.$refs.panControls.$el);\n    },\n    handleHelpControlClick: function handleHelpControlClick() {\n      this.$root.$emit('show::modal', this.helpModalId);\n    },\n    handleInfoControlClick: function handleInfoControlClick() {\n      this.$root.$emit('show::modal', this.metadataModalId);\n    },\n    setupHandlers: function setupHandlers() {\n      var _this = this;\n\n      // Draw an overlay on selection confirmed\n      var viewer = __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].state.viewer;\n      viewer.addHandler('selection', function (s) {\n        // Convert Viewport to Image rect\n        var rect = new __WEBPACK_IMPORTED_MODULE_4_openseadragon___default.a.Rect(s.x, s.y, s.width, s.height);\n        _this.addOverlay(rect, 'selection');\n      });\n\n      // Hide loading icon after tile drawn\n      // this.viewer.addHandler('tile-drawn', () => {\n      //   this.loading(false)\n      // })\n\n      // Don't focus on HUD after fullscreen toggled\n      viewer.addHandler('full-screen', function (evt) {\n        document.querySelector('.openseadragon-canvas').focus();\n      });\n\n      // Confirm before leaving if any overlays have been drawn or forms filled\n      window.onbeforeunload = function () {\n        var msg = 'Unsaved changes will be lost.';\n        if (!_this.confirmBeforeUnload) {\n          return null;\n        }\n\n        // TODO: Check for selection overlays only\n        if (viewer.currentOverlays.length) {\n          return msg;\n        }\n\n        [].forEach.call(document.querySelectorAll('input'), function (input) {\n          if (input.value.length) {\n            return msg;\n          }\n        });\n      };\n    },\n    configureSelector: function configureSelector() {\n      var viewer = __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].state.viewer;\n      var selector = viewer.selection({\n        showConfirmDenyButtons: false,\n        restrictToImage: true,\n        returnPixelCoordinates: false,\n        navImages: {\n          selection: {\n            REST: null,\n            GROUP: null,\n            HOVER: null,\n            DOWN: null\n          }\n        }\n      });\n      __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].commit('SET_ITEM', { key: 'selector', value: selector });\n      selector.enable();\n      var confirmBtn = new __WEBPACK_IMPORTED_MODULE_4_openseadragon___default.a.Button({\n        element: this.$refs.confirmSelection,\n        clickTimeThreshold: viewer.clickTimeThreshold,\n        clickDistThreshold: viewer.clickDistThreshold,\n        tooltip: 'Confirm',\n        onRelease: selector.confirm.bind(selector)\n      });\n      selector.element.appendChild(this.$refs.confirmSelection);\n      var cancelBtn = new __WEBPACK_IMPORTED_MODULE_4_openseadragon___default.a.Button({\n        element: this.$refs.cancelSelection,\n        clickTimeThreshold: viewer.clickTimeThreshold,\n        clickDistThreshold: viewer.clickDistThreshold,\n        tooltip: 'Delete',\n        onRelease: selector.cancel.bind(selector)\n      });\n      selector.element.appendChild(this.$refs.cancelSelection);\n    },\n    addOverlay: function addOverlay(rect, cls) {\n      var viewer = __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].state.viewer;\n      var el = document.createElement('div');\n      el.id = __WEBPACK_IMPORTED_MODULE_0_uuid_v4___default()();\n      el.classList.add('overlay');\n      el.classList.add(cls);\n      viewer.addOverlay({ element: el, location: rect });\n    },\n    handleOverlayClick: function handleOverlayClick(evt) {\n      var viewer = __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].state.viewer;\n      if (this.selection) {\n        viewer.removeOverlay(this.id);\n      }\n      evt.preventDefault();\n    },\n    submit: function submit(obj) {\n      this.$emit('submit', obj);\n    }\n  },\n\n  watch: {\n    imgSource: function imgSource() {\n      this.loadImage();\n    }\n  },\n\n  mounted: function mounted() {\n    var opts = this.normalizedViewerOpts;\n    opts.element = this.$refs.viewer;\n\n    var viewer = __WEBPACK_IMPORTED_MODULE_4_openseadragon___default()(opts);\n    __WEBPACK_IMPORTED_MODULE_12__store_js__[\"a\" /* store */].commit('SET_ITEM', { key: 'viewer', value: viewer });\n\n    this.configureSelector();\n    this.loadImage();\n    this.attachControls();\n    this.setupHandlers();\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vVmlld2VyLnZ1ZT85MDhmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTt3QkFFQTs7dUJBRUE7bUJBRUE7QUFIQTtBQUtBOzs7Z0JBRUE7O1lBRUE7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFJQTtBQUxBO0FBbERBOzs7QUF5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFUQTs7OzBEQVdBOztzQkFFQTt1QkFDQTtvQkFDQTt3QkFDQTtvQkFDQTtvQkFDQTtxQkFDQTt1QkFDQTs7dUJBR0E7QUFGQTs7MEJBS0E7QUFGQTs7MEJBTUE7QUFIQTtBQWZBOzZDQW1CQTtBQUNBO29DQUNBOzJCQUNBLHVCQUNBLHNCQUNBLG1DQUNBOzhHQUNBO2FBQ0E7QUFHQTtBQWhDQTs7O29DQWtDQTttRkFDQTs7Y0FFQTt5QkFDQTtzQkFFQTtBQUpBO0FBS0E7OENBQ0E7QUFDQTtBQUNBO21GQUNBO3lEQUNBO3NEQUNBO0FBQ0E7OERBQ0E7MkNBQ0E7QUFDQTs4REFDQTsyQ0FDQTtBQUNBOztBQUNBOztBQUNBO21GQUNBO2tEQUNBO0FBQ0E7dUdBQ0E7K0JBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtzREFDQTt3REFDQTtBQUVBOztBQUNBOzBDQUNBO2tCQUNBO3dDQUNBO2lCQUNBO0FBRUE7O0FBQ0E7MkNBQ0E7aUJBQ0E7QUFFQTs7NkVBQ0E7a0NBQ0E7bUJBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtvREFDQTttRkFDQTs7Z0NBRUE7eUJBQ0E7Z0NBQ0E7OztrQkFHQTttQkFDQTttQkFDQTtrQkFJQTtBQVBBO0FBREE7QUFKQTs2R0FhQTtlQUNBOzs0QkFFQTttQ0FDQTttQ0FDQTtpQkFDQTt5Q0FFQTtBQU5BOzhDQU9BOzs0QkFFQTttQ0FDQTttQ0FDQTtpQkFDQTt3Q0FFQTtBQU5BOzhDQU9BO0FBQ0E7K0NBQ0E7bUZBQ0E7c0NBQ0E7Y0FDQTt1QkFDQTt1QkFDQTtpREFDQTtBQUNBO3lEQUNBO21GQUNBOzBCQUNBO2tDQUNBO0FBQ0E7VUFDQTtBQUNBO2lDQUNBOzJCQUNBO0FBR0E7QUFqSEE7OztvQ0FtSEE7V0FDQTtBQUdBO0FBTEE7OzhCQU1BO29CQUNBOzhCQUVBOzt1RUFDQTt5R0FFQTs7U0FDQTtTQUNBO1NBQ0E7U0FDQTtBQUNBO0FBOU9BIiwiZmlsZSI6Ijg4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGlkPVwibHYtdmlld2VyXCI+XG5cbiAgICA8dmlld2VyLWNvbnRyb2xzXG4gICAgICByZWY9XCJ2aWV3ZXJDb250cm9sc1wiXG4gICAgICA6c2hvd0hlbHA9XCJzaG93SGVscFwiXG4gICAgICA6c2hvd0luZm89XCJtYW5pZmVzdElkLmxlbmd0aCA+IDBcIlxuICAgICAgOnpvb21JbkJ1dHRvbj1cIm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLnpvb21JbkJ1dHRvblwiXG4gICAgICA6em9vbU91dEJ1dHRvbj1cIm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLnpvb21PdXRCdXR0b25cIlxuICAgICAgOmhvbWVCdXR0b249XCJub3JtYWxpemVkVmlld2VyT3B0cy5ob21lQnV0dG9uXCJcbiAgICAgIDpmdWxsUGFnZUJ1dHRvbj1cIm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLmZ1bGxQYWdlQnV0dG9uXCJcbiAgICAgIDpoZWxwQnV0dG9uPVwibm9ybWFsaXplZFZpZXdlck9wdHMuaGVscEJ1dHRvblwiXG4gICAgICA6aW5mb0J1dHRvbj1cIm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLmluZm9CdXR0b25cIlxuICAgICAgQGhlbHBjbGlja2VkPVwiaGFuZGxlSGVscENvbnRyb2xDbGlja1wiXG4gICAgICBAaW5mb2NsaWNrZWQ9XCJoYW5kbGVJbmZvQ29udHJvbENsaWNrXCI+XG4gICAgPC92aWV3ZXItY29udHJvbHM+XG5cbiAgICA8cGFuLWNvbnRyb2xzXG4gICAgICByZWY9XCJwYW5Db250cm9sc1wiXG4gICAgICA6cGFuQnk9XCJwYW5CeVwiPlxuICAgIDwvcGFuLWNvbnRyb2xzPlxuXG4gICAgPG1ldGFkYXRhLW1vZGFsXG4gICAgICB2LWlmPVwibWFuaWZlc3RJZFwiXG4gICAgICA6aWQ9XCJtZXRhZGF0YU1vZGFsSWRcIlxuICAgICAgOnNjaGVtZT1cInNjaGVtZVwiXG4gICAgICA6c2VydmVyPVwic2VydmVyXCJcbiAgICAgIDpwcmVzZW50YXRpb24tYXBpLXByZWZpeD1cInByZXNlbnRhdGlvbkFwaVByZWZpeFwiXG4gICAgICA6bWFuaWZlc3RJZD1cIm1hbmlmZXN0SWRcIj5cbiAgICA8L21ldGFkYXRhLW1vZGFsPlxuXG4gICAgPGhlbHAtbW9kYWxcbiAgICAgIHYtaWY9XCJzaG93SGVscFwiXG4gICAgICA6aWQ9XCJoZWxwTW9kYWxJZFwiXG4gICAgICA6bW9kZT1cIm1vZGVcIj5cbiAgICA8L2hlbHAtbW9kYWw+XG5cbiAgICA8ZGl2IGlkPVwibHYtc2lkZWJhcnNcIj5cblxuICAgICAgPHRhc2stc2lkZWJhclxuICAgICAgICA6b2JqZWN0aXZlPVwib2JqZWN0aXZlXCJcbiAgICAgICAgOmd1aWRhbmNlPVwiZ3VpZGFuY2VcIlxuICAgICAgICA6c2hvd05vdGU9XCJzaG93Tm90ZVwiXG4gICAgICAgIEBzdWJtaXQ9XCJzdWJtaXRcIj5cbiAgICAgIDwvdGFzay1zaWRlYmFyPlxuXG4gICAgICA8c2VsZWN0aW9uLXNpZGViYXJcbiAgICAgICAgdi1pZj1cIm1vZGUgPT09ICdzZWxlY3Rpb24nXCI+XG4gICAgICA8L3NlbGVjdGlvbi1zaWRlYmFyPlxuXG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cInNlbGVjdGlvbi1idG5cIlxuICAgICAgaWQ9XCJjb25maXJtLXNlbGVjdGlvblwiXG4gICAgICByZWY9XCJjb25maXJtU2VsZWN0aW9uXCI+XG4gICAgICA8aWNvbiBuYW1lPVwiY2hlY2stY2lyY2xlXCI+PC9pY29uPlxuICAgIDwvZGl2PlxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwic2VsZWN0aW9uLWJ0blwiXG4gICAgICBpZD1cImNhbmNlbC1zZWxlY3Rpb25cIlxuICAgICAgcmVmPVwiY2FuY2VsU2VsZWN0aW9uXCI+XG4gICAgICA8aWNvbiBuYW1lPVwidGltZXMtY2lyY2xlXCI+PC9pY29uPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBSZW5kZXIgdmlld2VyIGFmdGVyIGFsbCBvdGhlciBjb21wb25lbnRzIC0tPlxuICAgIDxkaXYgaWQ9XCJsdi12aWV3ZXItY29udGFpbmVyXCIgcmVmPVwidmlld2VyXCI+PC9kaXY+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHV1aWQgZnJvbSAndXVpZC92NCdcbmltcG9ydCBJY29uIGZyb20gJ3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL3RpbWVzLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvY2hlY2stY2lyY2xlJ1xuaW1wb3J0IE9wZW5TZWFkcmFnb24gZnJvbSAnb3BlbnNlYWRyYWdvbidcbmltcG9ydCAnb3BlbnNlYWRyYWdvbnNlbGVjdGlvbi9kaXN0L29wZW5zZWFkcmFnb25zZWxlY3Rpb24nXG5pbXBvcnQgTWV0YWRhdGFNb2RhbCBmcm9tICdAL2NvbXBvbmVudHMvbW9kYWxzL01ldGFkYXRhLnZ1ZSdcbmltcG9ydCBIZWxwTW9kYWwgZnJvbSAnQC9jb21wb25lbnRzL21vZGFscy9IZWxwLnZ1ZSdcbmltcG9ydCBWaWV3ZXJDb250cm9scyBmcm9tICdAL2NvbXBvbmVudHMvY29udHJvbHMvVmlld2VyLnZ1ZSdcbmltcG9ydCBQYW5Db250cm9scyBmcm9tICdAL2NvbXBvbmVudHMvY29udHJvbHMvUGFuLnZ1ZSdcbmltcG9ydCBTZWxlY3Rpb25TaWRlYmFyIGZyb20gJ0AvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlJ1xuaW1wb3J0IFRhc2tTaWRlYmFyIGZyb20gJ0AvY29tcG9uZW50cy9zaWRlYmFycy9UYXNrLnZ1ZSdcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSAnQC9zdG9yZS5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFkYXRhTW9kYWxJZDogJ2xjLW1ldGFkYXRhLW1vZGFsJyxcbiAgICAgIGhlbHBNb2RhbElkOiAnbGMtaGVscC1tb2RhbCdcbiAgICB9XG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICB2aWV3ZXJPcHRzOiBPYmplY3QsXG4gICAgbW9kZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3NlbGVjdGlvbidcbiAgICB9LFxuICAgIG9iamVjdGl2ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgZ3VpZGFuY2U6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHNjaGVtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2h0dHAnXG4gICAgfSxcbiAgICBzZXJ2ZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGltYWdlQXBpUHJlZml4OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBwcmVzZW50YXRpb25BcGlQcmVmaXg6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGltYWdlSWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIG1hbmlmZXN0SWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGNvbmZpcm1CZWZvcmVVbmxvYWQgOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHNob3dIZWxwOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgc2hvd05vdGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgcGFuQnk6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgTWV0YWRhdGFNb2RhbCxcbiAgICBIZWxwTW9kYWwsXG4gICAgVmlld2VyQ29udHJvbHMsXG4gICAgUGFuQ29udHJvbHMsXG4gICAgU2VsZWN0aW9uU2lkZWJhcixcbiAgICBUYXNrU2lkZWJhcixcbiAgICBJY29uXG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBub3JtYWxpemVkVmlld2VyT3B0czogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGVmYXVsdE9wdHMgPSB7XG4gICAgICAgIHpvb21JbkJ1dHRvbjogJ3pvb20taW4nLFxuICAgICAgICB6b29tT3V0QnV0dG9uOiAnem9vbS1vdXQnLFxuICAgICAgICBob21lQnV0dG9uOiAncmVzZXQtem9vbScsXG4gICAgICAgIGZ1bGxQYWdlQnV0dG9uOiAndG9nZ2xlLWZ1bGxzY3JlZW4nLFxuICAgICAgICBoZWxwQnV0dG9uOiAnc2hvdy1oZWxwJyxcbiAgICAgICAgaW5mb0J1dHRvbjogJ3Nob3ctaW5mbycsXG4gICAgICAgIHBhblZlcnRpY2FsOiBmYWxzZSxcbiAgICAgICAgcGFuSG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIGdlc3R1cmVTZXR0aW5nc01vdXNlOiB7XG4gICAgICAgICAgY2xpY2tUb1pvb206IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGdlc3R1cmVTZXR0aW5nc1RvdWNoOiB7XG4gICAgICAgICAgZGJsQ2xpY2tUb1pvb206IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGdlc3R1cmVTZXR0aW5nc1Blbjoge1xuICAgICAgICAgIGRibENsaWNrVG9ab29tOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0cywgdGhpcy52aWV3ZXJPcHRzKVxuICAgIH0sXG4gICAgaW1nU291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBpbWdTb3VyY2UgPSBgJHt0aGlzLnNjaGVtZX06Ly9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMuc2VydmVyfS9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMuaW1hZ2VBcGlQcmVmaXh9L2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5pbWFnZUlkfWBcbiAgICAgIHN0b3JlLmNvbW1pdCgnU0VUX0lURU0nLCB7IGtleTogJ2ltZ1NvdXJjZScsIHZhbHVlOiBpbWdTb3VyY2UgfSlcbiAgICAgIHJldHVybiBpbWdTb3VyY2VcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGxvYWRJbWFnZSAoKSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIHZpZXdlci5vcGVuKHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgdGlsZVNvdXJjZTogYCR7dGhpcy5pbWdTb3VyY2V9L2luZm8uanNvbmAsXG4gICAgICAgIGJ1aWxkUHlyYW1pZDogZmFsc2VcbiAgICAgIH0pXG4gICAgfSxcbiAgICBhdHRhY2hDb250cm9scyAoKSB7XG4gICAgICAvLyBUT0RPOiB0aGlzIHdvcmtzIGZvciBmdWxsc2NyZWVuIGNvbnRyb2xzIGJ1dCBzaG91bGQgcG9zc2libHkgdXNlXG4gICAgICAvLyBodHRwczovL29wZW5zZWFkcmFnb24uZ2l0aHViLmlvL2RvY3MvT3BlblNlYWRyYWdvbi5Db250cm9sLmh0bWxcbiAgICAgIGNvbnN0IHZpZXdlciA9IHN0b3JlLnN0YXRlLnZpZXdlclxuICAgICAgdmlld2VyLmNvbnRhaW5lci5wcmVwZW5kKHRoaXMuJHJlZnMudmlld2VyQ29udHJvbHMuJGVsKVxuICAgICAgdmlld2VyLmNvbnRhaW5lci5wcmVwZW5kKHRoaXMuJHJlZnMucGFuQ29udHJvbHMuJGVsKVxuICAgIH0sXG4gICAgaGFuZGxlSGVscENvbnRyb2xDbGljayAoKSB7XG4gICAgICB0aGlzLiRyb290LiRlbWl0KCdzaG93Ojptb2RhbCcsIHRoaXMuaGVscE1vZGFsSWQpXG4gICAgfSxcbiAgICBoYW5kbGVJbmZvQ29udHJvbENsaWNrICgpIHtcbiAgICAgIHRoaXMuJHJvb3QuJGVtaXQoJ3Nob3c6Om1vZGFsJywgdGhpcy5tZXRhZGF0YU1vZGFsSWQpXG4gICAgfSxcbiAgICBzZXR1cEhhbmRsZXJzICgpIHtcbiAgICAgIC8vIERyYXcgYW4gb3ZlcmxheSBvbiBzZWxlY3Rpb24gY29uZmlybWVkXG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIHZpZXdlci5hZGRIYW5kbGVyKCdzZWxlY3Rpb24nLCAocykgPT4ge1xuICAgICAgICAvLyBDb252ZXJ0IFZpZXdwb3J0IHRvIEltYWdlIHJlY3RcbiAgICAgICAgY29uc3QgcmVjdCA9IG5ldyBPcGVuU2VhZHJhZ29uLlJlY3Qocy54LCBzLnksIHMud2lkdGgsIHMuaGVpZ2h0KVxuICAgICAgICB0aGlzLmFkZE92ZXJsYXkocmVjdCwgJ3NlbGVjdGlvbicpXG4gICAgICB9KVxuXG4gICAgICAvLyBIaWRlIGxvYWRpbmcgaWNvbiBhZnRlciB0aWxlIGRyYXduXG4gICAgICAvLyB0aGlzLnZpZXdlci5hZGRIYW5kbGVyKCd0aWxlLWRyYXduJywgKCkgPT4ge1xuICAgICAgLy8gICB0aGlzLmxvYWRpbmcoZmFsc2UpXG4gICAgICAvLyB9KVxuXG4gICAgICAvLyBEb24ndCBmb2N1cyBvbiBIVUQgYWZ0ZXIgZnVsbHNjcmVlbiB0b2dnbGVkXG4gICAgICB2aWV3ZXIuYWRkSGFuZGxlcignZnVsbC1zY3JlZW4nLCAoZXZ0KSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcGVuc2VhZHJhZ29uLWNhbnZhcycpLmZvY3VzKClcbiAgICAgIH0pXG5cbiAgICAgIC8vIENvbmZpcm0gYmVmb3JlIGxlYXZpbmcgaWYgYW55IG92ZXJsYXlzIGhhdmUgYmVlbiBkcmF3biBvciBmb3JtcyBmaWxsZWRcbiAgICAgIHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbXNnID0gJ1Vuc2F2ZWQgY2hhbmdlcyB3aWxsIGJlIGxvc3QuJ1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlybUJlZm9yZVVubG9hZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgZm9yIHNlbGVjdGlvbiBvdmVybGF5cyBvbmx5XG4gICAgICAgIGlmICh2aWV3ZXIuY3VycmVudE92ZXJsYXlzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBtc2dcbiAgICAgICAgfVxuXG4gICAgICAgIFtdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpLCBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2dcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgY29uZmlndXJlU2VsZWN0b3IgKCkge1xuICAgICAgY29uc3Qgdmlld2VyID0gc3RvcmUuc3RhdGUudmlld2VyXG4gICAgICBjb25zdCBzZWxlY3RvciA9IHZpZXdlci5zZWxlY3Rpb24oe1xuICAgICAgICBzaG93Q29uZmlybURlbnlCdXR0b25zOiBmYWxzZSxcbiAgICAgICAgcmVzdHJpY3RUb0ltYWdlOiB0cnVlLFxuICAgICAgICByZXR1cm5QaXhlbENvb3JkaW5hdGVzOiBmYWxzZSxcbiAgICAgICAgbmF2SW1hZ2VzOiB7XG4gICAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICBSRVNUOiBudWxsLFxuICAgICAgICAgICAgR1JPVVA6IG51bGwsXG4gICAgICAgICAgICBIT1ZFUjogbnVsbCxcbiAgICAgICAgICAgIERPV046IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBzdG9yZS5jb21taXQoJ1NFVF9JVEVNJywgeyBrZXk6ICdzZWxlY3RvcicsIHZhbHVlOiBzZWxlY3RvciB9KVxuICAgICAgc2VsZWN0b3IuZW5hYmxlKClcbiAgICAgIGNvbnN0IGNvbmZpcm1CdG4gPSBuZXcgT3BlblNlYWRyYWdvbi5CdXR0b24oe1xuICAgICAgICBlbGVtZW50OiB0aGlzLiRyZWZzLmNvbmZpcm1TZWxlY3Rpb24sXG4gICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdmlld2VyLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB2aWV3ZXIuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICB0b29sdGlwOiAnQ29uZmlybScsXG4gICAgICAgIG9uUmVsZWFzZTogc2VsZWN0b3IuY29uZmlybS5iaW5kKHNlbGVjdG9yKVxuICAgICAgfSlcbiAgICAgIHNlbGVjdG9yLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy4kcmVmcy5jb25maXJtU2VsZWN0aW9uKVxuICAgICAgY29uc3QgY2FuY2VsQnRuID0gbmV3IE9wZW5TZWFkcmFnb24uQnV0dG9uKHtcbiAgICAgICAgZWxlbWVudDogdGhpcy4kcmVmcy5jYW5jZWxTZWxlY3Rpb24sXG4gICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdmlld2VyLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB2aWV3ZXIuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICB0b29sdGlwOiAnRGVsZXRlJyxcbiAgICAgICAgb25SZWxlYXNlOiBzZWxlY3Rvci5jYW5jZWwuYmluZChzZWxlY3RvcilcbiAgICAgIH0pXG4gICAgICBzZWxlY3Rvci5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuJHJlZnMuY2FuY2VsU2VsZWN0aW9uKVxuICAgIH0sXG4gICAgYWRkT3ZlcmxheShyZWN0LCBjbHMpIHtcbiAgICAgIGNvbnN0IHZpZXdlciA9IHN0b3JlLnN0YXRlLnZpZXdlclxuICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZWwuaWQgPSB1dWlkKClcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ292ZXJsYXknKVxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpXG4gICAgICB2aWV3ZXIuYWRkT3ZlcmxheSh7IGVsZW1lbnQ6IGVsLCBsb2NhdGlvbjogcmVjdCB9KVxuICAgIH0sXG4gICAgaGFuZGxlT3ZlcmxheUNsaWNrIChldnQpIHtcbiAgICAgIGNvbnN0IHZpZXdlciA9IHN0b3JlLnN0YXRlLnZpZXdlclxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgIHZpZXdlci5yZW1vdmVPdmVybGF5KHRoaXMuaWQpXG4gICAgICB9XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgIH0sXG4gICAgc3VibWl0IChvYmopIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdCcsIG9iailcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbWdTb3VyY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubG9hZEltYWdlKClcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgbGV0IG9wdHMgPSB0aGlzLm5vcm1hbGl6ZWRWaWV3ZXJPcHRzXG4gICAgb3B0cy5lbGVtZW50ID0gdGhpcy4kcmVmcy52aWV3ZXJcblxuICAgIGNvbnN0IHZpZXdlciA9IE9wZW5TZWFkcmFnb24ob3B0cylcbiAgICBzdG9yZS5jb21taXQoJ1NFVF9JVEVNJywgeyBrZXk6ICd2aWV3ZXInLCB2YWx1ZTogdmlld2VyIH0pXG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNlbGVjdG9yKClcbiAgICB0aGlzLmxvYWRJbWFnZSgpXG4gICAgdGhpcy5hdHRhY2hDb250cm9scygpXG4gICAgdGhpcy5zZXR1cEhhbmRsZXJzKClcbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi4vYXNzZXRzL3N0eWxlL3NldHRpbmdzJztcblxuI2x2LXZpZXdlciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IGF1dG87XG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbiNsdi12aWV3ZXItY29udGFpbmVyIHtcbiAgaGVpZ2h0OiAxMDAlO1xufVxuXG4jbHYtc2lkZWJhcnMge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHotaW5kZXg6IDI7XG4gIHJpZ2h0OiAwO1xuICB3aWR0aDogMzUlO1xuICBtYXJnaW46IDAuOHJlbTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgbWF4LXdpZHRoOiAzNTBweDtcbn1cblxuLm9wZW5zZWFkcmFnb24tY29udGFpbmVyIHtcbiAgaGVpZ2h0OiAxMDB2aDtcbiAgbWluLWhlaWdodDogNjAwcHg7XG5cbiAgLm9wZW5zZWFkcmFnb24tbWVzc2FnZSB7XG4gICAgY29sb3I6ICNGRkY7XG4gIH1cblxuICAuc2VsZWN0aW9uLWJveCB7XG4gICAgdHJhbnNmb3JtOiBub25lICFpbXBvcnRhbnQ7ICAvKiogRGlzYWJsZSByb3RhdGlvbiAqL1xuICAgIHotaW5kZXg6IDEwO1xuICAgIG91dGxpbmU6IDk5OTlweCBzb2xpZCByZ2JhKCMwMDAsIC42KTtcblxuICAgIC5zZWxlY3Rpb24tYnRuIHtcbiAgICAgIGNvbG9yOiAjZmZmO1xuICAgICAgZGlzcGxheTogZmxleCAhaW1wb3J0YW50O1xuICAgICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XG4gICAgICByaWdodDogMDtcblxuICAgICAgJiNjb25maXJtLXNlbGVjdGlvbiB7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpIHRyYW5zbGF0ZVkoMTVweCk7XG4gICAgICB9XG5cbiAgICAgICYjY2FuY2VsLXNlbGVjdGlvbiB7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpIHRyYW5zbGF0ZVkoLTE1cHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC5vdmVybGF5IHtcbiAgICB6LWluZGV4OiA1O1xuXG4gICAgJi5zZWxlY3Rpb24ge1xuICAgICAgYm9yZGVyOiAycHggc29saWQgJGJsdWU7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCRibHVlLCAwLjIpO1xuICAgICAgb3BhY2l0eTogLjY7XG4gICAgfVxuXG4gICAgJi5oaWdobGlnaHQge1xuICAgICAgYm9yZGVyLWNvbG9yOiAkZ3JlZW47XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCRncmVlbiwgMC4yKTtcbiAgICB9XG4gIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gVmlld2VyLnZ1ZT83NTgxMGQ1ZSJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Controls_vue__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Controls_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Controls_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__store__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    panBy: {\n      type: Number,\n      required: true\n    }\n  },\n\n  components: {\n    Controls: __WEBPACK_IMPORTED_MODULE_0__components_Controls_vue___default.a\n  },\n\n  computed: {\n    buttons: function buttons() {\n      var _this = this;\n\n      var viewer = __WEBPACK_IMPORTED_MODULE_1__store__[\"a\" /* store */].state.viewer;\n      var buttons = [{\n        id: 'pan-up',\n        tooltip: 'Move up',\n        icon: 'chevron-up',\n        click: function click() {\n          viewer.viewport.panBy(new OpenSeadragon.Point(0, -_this.panBy));\n        }\n      }, {\n        id: 'pan-down',\n        tooltip: 'Move down',\n        icon: 'chevron-down',\n        click: function click() {\n          viewer.viewport.panBy(new OpenSeadragon.Point(0, _this.panBy));\n        }\n      }, {\n        id: 'pan-left',\n        tooltip: 'Move left',\n        icon: 'chevron-left',\n        click: function click() {\n          viewer.viewport.panBy(new OpenSeadragon.Point(-_this.panBy, 0));\n        }\n      }, {\n        id: 'pan-right',\n        tooltip: 'Move right',\n        icon: 'chevron-right',\n        click: function click() {\n          viewer.viewport.panBy(new OpenSeadragon.Point(_this.panBy, 0));\n        }\n      }];\n      return buttons;\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vUGFuLnZ1ZT81NmZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTs7QUFFQTs7O1lBSUE7Z0JBSUE7QUFMQTtBQURBOzs7QUFVQTtBQUhBOzs7O0FBS0E7OytFQUNBOztZQUdBO2lCQUNBO2NBQ0E7Z0NBQ0E7a0VBQ0E7QUFFQTtBQVBBLE9BREE7WUFVQTtpQkFDQTtjQUNBO2dDQUNBO2lFQUNBO0FBRUE7QUFQQTtZQVNBO2lCQUNBO2NBQ0E7Z0NBQ0E7c0VBQ0E7QUFFQTtBQVBBO1lBU0E7aUJBQ0E7Y0FDQTtnQ0FDQTtxRUFDQTtBQUdBO0FBUkE7YUFTQTtBQUVBO0FBdkNBO0FBWkEiLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJsdi1wYW4tY29udHJvbHNcIj5cblxuICAgIDxjb250cm9sc1xuICAgICAgcG9zaXRpb249XCJib3R0b21cIlxuICAgICAgc2NhbGU9XCIxXCJcbiAgICAgIDpidXR0b25zPVwiYnV0dG9uc1wiPlxuICAgIDwvY29udHJvbHM+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENvbnRyb2xzIGZyb20gJ0AvY29tcG9uZW50cy9Db250cm9scy52dWUnXG5pbXBvcnQgeyBzdG9yZSB9IGZyb20gJ0Avc3RvcmUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICBwYW5CeToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIENvbnRyb2xzXG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBidXR0b25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIGxldCBidXR0b25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdwYW4tdXAnLFxuICAgICAgICAgIHRvb2x0aXA6ICdNb3ZlIHVwJyxcbiAgICAgICAgICBpY29uOiAnY2hldnJvbi11cCcsXG4gICAgICAgICAgY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHZpZXdlci52aWV3cG9ydC5wYW5CeShuZXcgT3BlblNlYWRyYWdvbi5Qb2ludCgwLCAtdGhpcy5wYW5CeSkpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdwYW4tZG93bicsXG4gICAgICAgICAgdG9vbHRpcDogJ01vdmUgZG93bicsXG4gICAgICAgICAgaWNvbjogJ2NoZXZyb24tZG93bicsXG4gICAgICAgICAgY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHZpZXdlci52aWV3cG9ydC5wYW5CeShuZXcgT3BlblNlYWRyYWdvbi5Qb2ludCgwLCB0aGlzLnBhbkJ5KSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3Bhbi1sZWZ0JyxcbiAgICAgICAgICB0b29sdGlwOiAnTW92ZSBsZWZ0JyxcbiAgICAgICAgICBpY29uOiAnY2hldnJvbi1sZWZ0JyxcbiAgICAgICAgICBjbGljazogKCkgPT4ge1xuICAgICAgICAgICAgdmlld2VyLnZpZXdwb3J0LnBhbkJ5KG5ldyBPcGVuU2VhZHJhZ29uLlBvaW50KC10aGlzLnBhbkJ5LCAwKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3Bhbi1yaWdodCcsXG4gICAgICAgICAgdG9vbHRpcDogJ01vdmUgcmlnaHQnLFxuICAgICAgICAgIGljb246ICdjaGV2cm9uLXJpZ2h0JyxcbiAgICAgICAgICBjbGljazogKCkgPT4ge1xuICAgICAgICAgICAgdmlld2VyLnZpZXdwb3J0LnBhbkJ5KG5ldyBPcGVuU2VhZHJhZ29uLlBvaW50KHRoaXMucGFuQnksIDApKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgICAgcmV0dXJuIGJ1dHRvbnNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFBhbi52dWU/NDk4NGZhOTgiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Controls_vue__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Controls_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Controls_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__store__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    showHelp: {\n      type: Boolean,\n      required: true\n    },\n    showInfo: {\n      type: Boolean,\n      required: true\n    },\n    zoomInButton: {\n      type: String,\n      required: true\n    },\n    zoomOutButton: {\n      type: String,\n      required: true\n    },\n    homeButton: {\n      type: String,\n      required: true\n    },\n    fullPageButton: {\n      type: String,\n      required: true\n    },\n    helpButton: {\n      type: String,\n      required: true\n    },\n    infoButton: {\n      type: String,\n      required: true\n    }\n  },\n\n  components: {\n    Controls: __WEBPACK_IMPORTED_MODULE_0__components_Controls_vue___default.a\n  },\n\n  computed: {\n    buttons: function buttons() {\n      var _this = this;\n\n      var viewer = __WEBPACK_IMPORTED_MODULE_1__store__[\"a\" /* store */].state.viewer;\n      console.log(viewer.fullPageButton);\n      var buttons = [{\n        id: this.zoomInButton,\n        tooltip: 'Zoom in',\n        icon: 'plus-circle'\n      }, {\n        id: this.zoomOutButton,\n        tooltip: 'Zoom out',\n        icon: 'minus-circle'\n      }, {\n        id: this.homeButton,\n        tooltip: 'Reset zoom',\n        icon: 'refresh'\n      }, {\n        id: this.fullPageButton,\n        tooltip: 'Fullscreen',\n        icon: 'expand'\n      }];\n\n      if (this.showHelp) {\n        buttons.push({\n          id: this.helpButton,\n          tooltip: 'Help',\n          icon: 'question-circle',\n          click: function click() {\n            _this.$emit('helpclicked');\n          }\n        });\n      }\n\n      if (this.showInfo) {\n        buttons.push({\n          id: this.infoButton,\n          tooltip: 'Details',\n          icon: 'info-circle',\n          click: function click() {\n            _this.$emit('infoclicked');\n          }\n        });\n      }\n      return buttons;\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vVmlld2VyLnZ1ZT9kNThmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTs7QUFFQTs7O1lBSUE7Z0JBRUE7QUFIQTs7WUFLQTtnQkFFQTtBQUhBOztZQUtBO2dCQUVBO0FBSEE7O1lBS0E7Z0JBRUE7QUFIQTs7WUFLQTtnQkFFQTtBQUhBOztZQUtBO2dCQUVBO0FBSEE7O1lBS0E7Z0JBRUE7QUFIQTs7WUFLQTtnQkFJQTtBQUxBO0FBN0JBOzs7QUFzQ0E7QUFIQTs7OztBQUtBOzsrRUFDQTt5QkFDQTs7aUJBR0E7aUJBQ0E7Y0FFQTtBQUpBLE9BREE7aUJBT0E7aUJBQ0E7Y0FFQTtBQUpBO2lCQU1BO2lCQUNBO2NBRUE7QUFKQTtpQkFNQTtpQkFDQTtjQUlBO0FBTkE7O3lCQU9BOzttQkFFQTttQkFDQTtnQkFDQTtrQ0FDQTt3QkFDQTtBQUVBO0FBUEE7QUFTQTs7eUJBQ0E7O21CQUVBO21CQUNBO2dCQUNBO2tDQUNBO3dCQUNBO0FBRUE7QUFQQTtBQVFBO2FBQ0E7QUFFQTtBQWxEQTtBQXhDQSIsImZpbGUiOiI5MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImx2LXZpZXdlci1jb250cm9sc1wiPlxuXG4gICAgPGNvbnRyb2xzXG4gICAgICBwb3NpdGlvbj1cInRvcFwiXG4gICAgICBsYXlvdXQ9XCJyb3dcIlxuICAgICAgOmJ1dHRvbnM9XCJidXR0b25zXCI+XG4gICAgPC9jb250cm9scz5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnQC9jb21wb25lbnRzL0NvbnRyb2xzLnZ1ZSdcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSAnQC9zdG9yZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHNob3dIZWxwOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHNob3dJbmZvOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHpvb21JbkJ1dHRvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHpvb21PdXRCdXR0b246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBob21lQnV0dG9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgZnVsbFBhZ2VCdXR0b246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBoZWxwQnV0dG9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgaW5mb0J1dHRvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIENvbnRyb2xzXG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBidXR0b25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIGNvbnNvbGUubG9nKHZpZXdlci5mdWxsUGFnZUJ1dHRvbilcbiAgICAgIGxldCBidXR0b25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IHRoaXMuem9vbUluQnV0dG9uLFxuICAgICAgICAgIHRvb2x0aXA6ICdab29tIGluJyxcbiAgICAgICAgICBpY29uOiAncGx1cy1jaXJjbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogdGhpcy56b29tT3V0QnV0dG9uLFxuICAgICAgICAgIHRvb2x0aXA6ICdab29tIG91dCcsXG4gICAgICAgICAgaWNvbjogJ21pbnVzLWNpcmNsZSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiB0aGlzLmhvbWVCdXR0b24sXG4gICAgICAgICAgdG9vbHRpcDogJ1Jlc2V0IHpvb20nLFxuICAgICAgICAgIGljb246ICdyZWZyZXNoJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IHRoaXMuZnVsbFBhZ2VCdXR0b24sXG4gICAgICAgICAgdG9vbHRpcDogJ0Z1bGxzY3JlZW4nLFxuICAgICAgICAgIGljb246ICdleHBhbmQnXG4gICAgICAgIH1cbiAgICAgIF1cblxuICAgICAgaWYgKHRoaXMuc2hvd0hlbHApIHtcbiAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogdGhpcy5oZWxwQnV0dG9uLFxuICAgICAgICAgIHRvb2x0aXA6ICdIZWxwJyxcbiAgICAgICAgICBpY29uOiAncXVlc3Rpb24tY2lyY2xlJyxcbiAgICAgICAgICBjbGljazogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaGVscGNsaWNrZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd0luZm8pIHtcbiAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogdGhpcy5pbmZvQnV0dG9uLFxuICAgICAgICAgIHRvb2x0aXA6ICdEZXRhaWxzJyxcbiAgICAgICAgICBpY29uOiAnaW5mby1jaXJjbGUnLFxuICAgICAgICAgIGNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdpbmZvY2xpY2tlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1dHRvbnNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFZpZXdlci52dWU/MTg0ZTU5NWMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_icons_plus_circle__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_awesome_icons_minus_circle__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_awesome_icons_pencil__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_vue_awesome_icons_refresh__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue_awesome_icons_expand__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_awesome_icons_question_circle__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_vue_awesome_icons_info_circle__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_vue_awesome_icons_check_circle__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vue_awesome_icons_times_circle__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_Modal_vue__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_Modal_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__components_Modal_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  data: function data() {\n    return {\n      manifestData: {}\n    };\n  },\n\n  props: {\n    id: {\n      type: String,\n      requried: true\n    },\n    mode: {\n      type: String,\n      requried: true\n    }\n  },\n\n  components: {\n    Icon: __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default.a,\n    Modal: __WEBPACK_IMPORTED_MODULE_10__components_Modal_vue___default.a\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vSGVscC52dWU/Yjg2NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7d0JBRUE7O29CQUdBO0FBRkE7QUFJQTs7OztZQUdBO2dCQUVBO0FBSEE7O1lBS0E7Z0JBSUE7QUFMQTtBQUxBOzs7QUFZQTtBQUVBO0FBSEE7QUFsQkEiLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJsdi1oZWxwLW1vZGFsXCI+XG4gICAgPG1vZGFsIDppZD1cImlkXCIgdGl0bGU9XCJIZWxwXCI+XG4gICAgICA8aDQ+Vmlld2VyIGNvbnRyb2xzPC9oND5cbiAgICAgIDxwPlRoZSBmb2xsb3dpbmcgY29udHJvbHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBsZWZ0IG9mIHRoZSB2aWV3ZXI6PC9wPlxuICAgICAgPHVsPlxuICAgICAgICA8bGk+PGljb24gbmFtZT1cInBsdXMtY2lyY2xlXCI+PC9pY29uPlpvb20gaW48L2xpPlxuICAgICAgICA8bGk+PGljb24gbmFtZT1cIm1pbnVzLWNpcmNsZVwiPjwvaWNvbj5ab29tIG91dDwvbGk+XG4gICAgICAgIDxsaT48aWNvbiBuYW1lPVwicmVmcmVzaFwiPjwvaWNvbj5SZXNldCB6b29tPC9saT5cbiAgICAgICAgPGxpPjxpY29uIG5hbWU9XCJleHBhbmRcIj48L2ljb24+RnVsbHNjcmVlbjwvbGk+XG4gICAgICAgIDxsaT48aWNvbiBuYW1lPVwicXVlc3Rpb24tY2lyY2xlXCI+PC9pY29uPkhlbHA8L2xpPlxuICAgICAgPC91bD5cbiAgICAgIDxkaXYgdi1pZj1cIm1vZGUgPT09ICdzZWxlY3Rpb24nXCI+XG4gICAgICAgIDxoND5TZWxlY3Rpb24gbW9kZTwvaDQ+XG4gICAgICAgIDxwPlxuICAgICAgICAgIFdoZW4gdXNpbmcgdGhlIHZpZXdlciBpbiBzZWxlY3Rpb24gbW9kZSBhbiBhcmVhIG9mIHRoZSBpbWFnZSBjYW5cbiAgICAgICAgICBiZSBzZWxlY3RlZCBieSBjbGlja2luZyAob3IgdGFwcGluZykgb24gdGhlIGltYWdlLiBUaGUgZm9sbG93aW5nIFxuICAgICAgICAgIGNvbnRyb2xzIGFyZSBwcm92aWRlZCB0byB0aGUgcmlnaHQgb2YgdGhlIHNlbGVjdGlvbiBib3g6XG4gICAgICAgIDwvcD5cbiAgICAgICAgPHVsPlxuICAgICAgICAgIDxsaT48aWNvbiBuYW1lPVwiY2hlY2stY2lyY2xlXCI+PC9pY29uPkNvbmZpcm0gc2VsZWN0aW9uPC9saT5cbiAgICAgICAgICA8bGk+PGljb24gbmFtZT1cInRpbWVzLWNpcmNsZVwiPjwvaWNvbj5DYW5jZWwgc2VsZWN0aW9uPC9saT5cbiAgICAgICAgPC91bD5cbiAgICAgICAgPHA+XG4gICAgICAgICAgT25jZSBhIHNlbGVjdGlvbiBoYXMgYmVlbiBjb25maXJtZWQgaXQgd2lsbCBhcHBlYXIgaW4gdGhlIFxuICAgICAgICAgIHNlbGVjdGlvbnMgc2lkZWJhciB0byB0aGUgcmlnaHQgb2YgdGhlIHNjcmVlbiwgd2hlcmUgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGNvbnRyb2xzIGFyZSBwcm92aWRlZDpcbiAgICAgICAgPC9wPlxuICAgICAgICA8dWw+XG4gICAgICAgICAgPGxpPjxpY29uIG5hbWU9XCJwZW5jaWxcIj48L2ljb24+RWRpdCBzZWxlY3Rpb248L2xpPlxuICAgICAgICAgIDxsaT48aWNvbiBuYW1lPVwidGltZXMtY2lyY2xlXCI+PC9pY29uPkRlbGV0ZSBzZWxlY3Rpb248L2xpPlxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgPC9tb2RhbD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEljb24gZnJvbSAndnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvcGx1cy1jaXJjbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL21pbnVzLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvcGVuY2lsJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9yZWZyZXNoJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9leHBhbmQnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL3F1ZXN0aW9uLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvaW5mby1jaXJjbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2NoZWNrLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvdGltZXMtY2lyY2xlJ1xuaW1wb3J0IE1vZGFsIGZyb20gJ0AvY29tcG9uZW50cy9Nb2RhbC52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYW5pZmVzdERhdGE6IHt9XG4gICAgfVxuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVyaWVkOiB0cnVlXG4gICAgfSxcbiAgICBtb2RlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1cmllZDogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgSWNvbixcbiAgICBNb2RhbFxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuI2x2LWhlbHAtbW9kYWwge1xuICB1bCB7XG4gICAgcGFkZGluZy1sZWZ0OiAwO1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIH1cblxuICBsaSB7XG4gICAgbWFyZ2luOiAwO1xuICB9XG5cbiAgc3ZnIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgfVxufVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBIZWxwLnZ1ZT8yYmMzYjYzMiJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Modal_vue__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Modal_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__components_Modal_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      manifestData: {}\n    };\n  },\n\n  methods: {\n    fetchManifest: function fetchManifest() {\n      var _this = this;\n\n      var url = this.scheme + '://' + (this.server + '/') + (this.presentationApiPrefix + '/') + (this.manifestId + '/') + 'manifest.json';\n      __WEBPACK_IMPORTED_MODULE_0_axios___default.a.get(url).then(function (r) {\n        _this.manifestData = r.data;\n      }).catch(function (error) {\n        console.log(error);\n      });\n    }\n  },\n\n  props: {\n    id: {\n      type: String,\n      requried: true\n    },\n    scheme: {\n      type: String,\n      required: true\n    },\n    server: {\n      type: String,\n      required: true\n    },\n    presentationApiPrefix: {\n      type: String,\n      required: true\n    },\n    manifestId: {\n      type: String,\n      required: true\n    }\n  },\n\n  components: {\n    Modal: __WEBPACK_IMPORTED_MODULE_1__components_Modal_vue___default.a\n  },\n\n  created: function created() {\n    this.fetchManifest();\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vTWV0YWRhdGEudnVlPzZlYjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTs7QUFFQTt3QkFFQTs7b0JBR0E7QUFGQTtBQUlBOzs7O0FBRUE7O3FCQUNBLHVCQUNBLHNCQUNBLHFDQUVBOytFQUNBOytCQUNBO2dDQUNBO29CQUNBO0FBQ0E7QUFHQTtBQWRBOzs7O1lBaUJBO2dCQUVBO0FBSEE7O1lBS0E7Z0JBRUE7QUFIQTs7WUFLQTtnQkFFQTtBQUhBOztZQUtBO2dCQUVBO0FBSEE7O1lBS0E7Z0JBSUE7QUFMQTtBQWpCQTs7O0FBMEJBO0FBSEE7OzhCQUlBO1NBQ0E7QUFDQTtBQW5EQSIsImZpbGUiOiI5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBpZD1cImx2LW1ldGFkYXRhLW1vZGFsXCI+XG4gICAgPG1vZGFsXG4gICAgICA6aWQ9XCJpZFwiXG4gICAgICB0aXRsZT1cIk1ldGFkYXRhXCI+XG4gICAgICA8dWwgdi1mb3I9XCJtIGluIG1hbmlmZXN0RGF0YS5tZXRhZGF0YVwiIDprZXk9XCJtLmxhYmVsXCI+XG4gICAgICAgIDxsaT5cbiAgICAgICAgICA8c3Ryb25nPnt7IG0ubGFiZWwgfX06PC9zdHJvbmc+XG4gICAgICAgICAgJm5ic3A7XG4gICAgICAgICAgPHNwYW4gdi1odG1sPVwibS52YWx1ZVwiPjwvc3Bhbj48L2xpPlxuICAgICAgPC91bD5cbiAgICAgIDxkaXYgaWQ9XCJyaWdodHNcIj5cbiAgICAgICAgPGltZyA6c3JjPVwibWFuaWZlc3REYXRhLmxvZ29cIj5cbiAgICAgICAgPHAgdi1odG1sPVwibWFuaWZlc3REYXRhLmF0dHJpYnV0aW9uXCI+PC9wPlxuICAgICAgICA8cCB2LWh0bWw9XCJtYW5pZmVzdERhdGEubGljZW5zZVwiPjwvcD5cbiAgICAgPC9kaXY+XG4gICAgPC9tb2RhbD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IE1vZGFsIGZyb20gJ0AvY29tcG9uZW50cy9Nb2RhbC52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYW5pZmVzdERhdGE6IHt9XG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBmZXRjaE1hbmlmZXN0ICgpIHtcbiAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2NoZW1lfTovL2AgKyBcbiAgICAgICAgICAgICAgICAgIGAke3RoaXMuc2VydmVyfS9gICsgXG4gICAgICAgICAgICAgICAgICBgJHt0aGlzLnByZXNlbnRhdGlvbkFwaVByZWZpeH0vYCArXG4gICAgICAgICAgICAgICAgICBgJHt0aGlzLm1hbmlmZXN0SWR9L2AgKyBcbiAgICAgICAgICAgICAgICAgIGBtYW5pZmVzdC5qc29uYFxuICAgICAgYXhpb3MuZ2V0KHVybCkudGhlbigocikgPT4ge1xuICAgICAgICB0aGlzLm1hbmlmZXN0RGF0YSA9IHIuZGF0YVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVyaWVkOiB0cnVlXG4gICAgfSxcbiAgICBzY2hlbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBzZXJ2ZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBwcmVzZW50YXRpb25BcGlQcmVmaXg6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBtYW5pZmVzdElkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgTW9kYWxcbiAgfSxcblxuICBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmZldGNoTWFuaWZlc3QoKVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuI2x2LW1ldGFkYXRhLW1vZGFsIHtcbiAgdWwge1xuICAgIHBhZGRpbmctbGVmdDogMDtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICB9XG5cbiAgI3JpZ2h0cyB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbjogMnJlbTtcbiAgfVxuXG4gIGxpIHtcbiAgICBtYXJnaW46IDA7XG4gIH1cbn1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gTWV0YWRhdGEudnVlPzk4MmY1Y2RjIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_icons_times_circle__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_awesome_icons_pencil__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__store_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_getSelections_js__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_deleteSelection_js__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_editSelection_js__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_highlightSelection_js__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_getImageUri_js__ = __webpack_require__(37);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  computed: {\n    selections: function selections() {\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_getSelections_js__["a" /* default */])();\n    }\n  },\n\n  components: {\n    Icon: __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default.a,\n    Sidebar: __WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue___default.a\n  },\n\n  methods: {\n    deleteSelection: __WEBPACK_IMPORTED_MODULE_6__utils_deleteSelection_js__["a" /* default */],\n    editSelection: __WEBPACK_IMPORTED_MODULE_7__utils_editSelection_js__["a" /* default */],\n    highlightSelection: __WEBPACK_IMPORTED_MODULE_8__utils_highlightSelection_js__["a" /* default */],\n    getImageUri: __WEBPACK_IMPORTED_MODULE_9__utils_getImageUri_js__["a" /* default */]\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vU2VsZWN0aW9uLnZ1ZT8yYTIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztzQ0FHQTthQUNBO0FBR0E7QUFMQTs7O0FBT0E7QUFHQTtBQUpBOzs7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUxBO0FBWkEiLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJsdi1zZWxlY3Rpb24tc2lkZWJhclwiPlxuICAgIDxzaWRlYmFyIHRpdGxlPVwiU2VsZWN0aW9uc1wiPlxuICAgICAgPHVsPlxuICAgICAgICA8bGlcbiAgICAgICAgICB2LWZvcj1cInMgaW4gc2VsZWN0aW9uc1wiXG4gICAgICAgICAgOmtleT1cInMuaWRcIlxuICAgICAgICAgIEBtb3VzZW92ZXI9XCJoaWdobGlnaHRTZWxlY3Rpb24ocywgdHJ1ZSlcIlxuICAgICAgICAgIEBtb3VzZWxlYXZlPVwiaGlnaGxpZ2h0U2VsZWN0aW9uKHMsIGZhbHNlKVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aHVtYm5haWwtY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8aW1nIDpzcmM9XCJnZXRJbWFnZVVyaShzLnJlY3QpXCI+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgIEBjbGljaz1cImVkaXRTZWxlY3Rpb24ocylcIlxuICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tY29udHJvbFwiPlxuICAgICAgICAgICAgICA8aWNvbiBuYW1lPVwicGVuY2lsXCI+PC9pY29uPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgQGNsaWNrPVwiZGVsZXRlU2VsZWN0aW9uKHMpXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLWNvbnRyb2xcIj5cbiAgICAgICAgICAgICAgPGljb24gbmFtZT1cInRpbWVzLWNpcmNsZVwiPjwvaWNvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9saT5cbiAgICAgIDwvdWw+XG4gICAgPC9zaWRlYmFyPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgSWNvbiBmcm9tICd2dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy90aW1lcy1jaXJjbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL3BlbmNpbCdcbmltcG9ydCBTaWRlYmFyIGZyb20gJ0AvY29tcG9uZW50cy9TaWRlYmFyLnZ1ZSdcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSAnQC9zdG9yZS5qcydcbmltcG9ydCBnZXRTZWxlY3Rpb25zIGZyb20gJ0AvdXRpbHMvZ2V0U2VsZWN0aW9ucy5qcydcbmltcG9ydCBkZWxldGVTZWxlY3Rpb24gZnJvbSAnQC91dGlscy9kZWxldGVTZWxlY3Rpb24uanMnXG5pbXBvcnQgZWRpdFNlbGVjdGlvbiBmcm9tICdAL3V0aWxzL2VkaXRTZWxlY3Rpb24uanMnXG5pbXBvcnQgaGlnaGxpZ2h0U2VsZWN0aW9uIGZyb20gJ0AvdXRpbHMvaGlnaGxpZ2h0U2VsZWN0aW9uLmpzJ1xuaW1wb3J0IGdldEltYWdlVXJpIGZyb20gJ0AvdXRpbHMvZ2V0SW1hZ2VVcmkuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZWxlY3Rpb25zICgpIHtcbiAgICAgIHJldHVybiBnZXRTZWxlY3Rpb25zKClcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIEljb24sXG4gICAgU2lkZWJhclxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBkZWxldGVTZWxlY3Rpb24sXG4gICAgZWRpdFNlbGVjdGlvbixcbiAgICBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgZ2V0SW1hZ2VVcmlcbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgJy4uLy4uL2Fzc2V0cy9zdHlsZS9zZXR0aW5ncyc7XG5AaW1wb3J0ICcuLi8uLi9hc3NldHMvc3R5bGUvcGFydGlhbHMvYnV0dG9ucyc7XG5cbiNsdi1zZWxlY3Rpb24tc2lkZWJhciB7XG4gIHVsIHtcbiAgICBtYXJnaW46IDA7XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICBtaW4taGVpZ2h0OiAxMDBweDtcbiAgICBtYXgtaGVpZ2h0OiAyNTBweDtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgYm9yZGVyOiAxcHggc29saWQgJGdyYXk7XG5cbiAgICBsaSB7XG4gICAgICBwYWRkaW5nOiAwLjhyZW07XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgZGFya2VuKCRncmF5LCAyNSUpO1xuICAgIH1cbiAgfVxuXG4gIC5idXR0b25zIHtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleDogMCAwIDMzLjMzMzMlO1xuICB9XG5cbiAgYnV0dG9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1hcmdpbi1yaWdodDogYXV0bztcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgfVxuXG4gIC50aHVtYm5haWwtY29udGFpbmVyIHtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleDogMSAxIGF1dG87XG4gICAgaGVpZ2h0OiA1MHB4O1xuXG4gICAgaW1nIHtcbiAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgIG1heC1oZWlnaHQ6IDEwMCU7XG4gICAgfVxuICB9XG59XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFNlbGVjdGlvbi52dWU/ODhkMWEwYzIiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__store__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Sidebar_vue__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Sidebar_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__components_Sidebar_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_getData__ = __webpack_require__(36);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  data: function data() {\n    return {\n      collapseNote: true\n    };\n  },\n\n  components: {\n    Sidebar: __WEBPACK_IMPORTED_MODULE_1__components_Sidebar_vue___default.a\n  },\n\n  props: {\n    objective: {\n      type: String,\n      required: true\n    },\n    guidance: {\n      type: String,\n      required: true\n    },\n    showNote: {\n      type: Boolean,\n      required: true\n    }\n  },\n\n  methods: {\n    toggleCollapseNote: function toggleCollapseNote() {\n      this.collapseNote = !this.collapseNote;\n    },\n    updateNote: function updateNote(evt) {\n      __WEBPACK_IMPORTED_MODULE_0__store__["a" /* store */].commit(\'SET_ITEM\', { key: \'note\', value: evt.target.value });\n    },\n    submit: function submit() {\n      var data = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_getData__["a" /* default */])();\n      this.$emit(\'submit\', data);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vVGFzay52dWU/YjM4MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUNBOztBQUVBO3dCQUVBOztvQkFHQTtBQUZBO0FBSUE7OztBQUlBO0FBSEE7Ozs7WUFNQTtnQkFFQTtBQUhBOztZQUtBO2dCQUVBO0FBSEE7O1lBS0E7Z0JBSUE7QUFMQTtBQVRBOzs7c0RBZ0JBO2dDQUNBO0FBQ0E7eUNBQ0E7Z0hBQ0E7QUFDQTs4QkFDQTtpQkFDQTsyQkFDQTtBQUVBO0FBWEE7QUExQkEiLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJsdi10YXNrLXNpZGViYXJcIj5cbiAgICA8c2lkZWJhciB0aXRsZT1cIlRhc2tcIj5cbiAgICAgIDxoND57eyBvYmplY3RpdmUgfX08L2g0PlxuICAgICAgPHA+e3sgZ3VpZGFuY2UgfX08L3A+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuXCIgQGNsaWNrPVwidG9nZ2xlQ29sbGFwc2VOb3RlXCIgdi1pZj1cInNob3dOb3RlXCI+XG4gICAgICAgIEFkZCBhIG5vdGVcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGRpdlxuICAgICAgICB2LXNob3c9XCJzaG93Tm90ZVwiXG4gICAgICAgIHYtaWY9XCIhY29sbGFwc2VOb3RlXCI+XG4gICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgIHJvd3M9XCIzXCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkxlYXZlIGEgbm90ZS4uLlwiXG4gICAgICAgICAgQGlucHV0PVwidXBkYXRlTm90ZVwiPlxuICAgICAgICA8L3RleHRhcmVhPlxuICAgICAgPC9kaXY+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1ncmVlblwiIEBjbGljaz1cInN1Ym1pdFwiPlxuICAgICAgICBTdWJtaXRcbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvc2lkZWJhcj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgc3RvcmUgfSBmcm9tICdAL3N0b3JlJ1xuaW1wb3J0IFNpZGViYXIgZnJvbSAnQC9jb21wb25lbnRzL1NpZGViYXIudnVlJ1xuaW1wb3J0IGdldERhdGEgZnJvbSAnQC91dGlscy9nZXREYXRhJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sbGFwc2VOb3RlOiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBTaWRlYmFyXG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICBvYmplY3RpdmU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBndWlkYW5jZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHNob3dOb3RlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHRvZ2dsZUNvbGxhcHNlTm90ZSAoKSB7XG4gICAgICB0aGlzLmNvbGxhcHNlTm90ZSA9ICF0aGlzLmNvbGxhcHNlTm90ZVxuICAgIH0sXG4gICAgdXBkYXRlTm90ZSAoZXZ0KSB7XG4gICAgICBzdG9yZS5jb21taXQoJ1NFVF9JVEVNJywgeyBrZXk6ICdub3RlJywgdmFsdWU6IGV2dC50YXJnZXQudmFsdWUgfSlcbiAgICB9LFxuICAgIHN1Ym1pdCAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gZ2V0RGF0YSgpXG4gICAgICB0aGlzLiRlbWl0KCdzdWJtaXQnLCBkYXRhKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgJy4uLy4uL2Fzc2V0cy9zdHlsZS9zZXR0aW5ncyc7XG5AaW1wb3J0ICcuLi8uLi9hc3NldHMvc3R5bGUvcGFydGlhbHMvYnV0dG9ucyc7XG5AaW1wb3J0ICcuLi8uLi9hc3NldHMvc3R5bGUvcGFydGlhbHMvZm9ybXMnO1xuXG4jbHYtdGFzay1zaWRlYmFyIHtcbiAgdWwge1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgbWluLWhlaWdodDogMTAwcHg7XG4gICAgbWF4LWhlaWdodDogMzAwcHg7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICBwYWRkaW5nOiAwLjhyZW07XG4gICAgbWFyZ2luOiAwO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICRncmF5O1xuXG5cbiAgICBsaSB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcblxuICAgICAgJjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC43NXJlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoNCB7XG4gICAgbWFyZ2luOiAwO1xuICB9XG5cbiAgLmJ0biB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgbWFyZ2luLXRvcDogMC42cmVtO1xuICB9XG5cbiAgc3ZnIHtcbiAgICBtYXJnaW4tbGVmdDogNXB4O1xuICB9XG5cbiAgYnV0dG9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1hcmdpbi1yaWdodDogYXV0bztcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgfVxuXG4gIC5zbGlkZS1sZWF2ZS1hY3RpdmUsXG4gIC5zbGlkZS1lbnRlci1hY3RpdmUge1xuICAgIHRyYW5zaXRpb246IDFzO1xuICB9XG4gIC5zbGlkZS1lbnRlciB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAxMDAlLCAwKTtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbiAgLnNsaWRlLWxlYXZlLXRvIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0xMDAlLCAwKTtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICB9XG59XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFRhc2sudnVlPzA0YzcyM2Q1Il0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, ".btn{cursor:default;font-size:14px;background-color:transparent;border:1px solid #fff;color:#fff;padding:8px 26px;text-align:center;text-decoration:none;display:inline-block;touch-action:manipulation}.btn.btn-green{background-color:#4daf7c;border-color:#4daf7c}.btn.btn-green:focus,.btn.btn-green:hover{background-color:#3d8c63;border-color:#3d8c63}.btn.btn-control{display:flex;background:none;text-shadow:0 0 5px #000;font-size:1.25rem;padding:.5rem .75rem;border:none;outline:none!important;opacity:.8}.btn.btn-control:focus,.btn.btn-control:hover{opacity:1}.modal{position:absolute;height:100%;width:100%}.modal .modal-mask{position:fixed;z-index:9998;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);display:table;transition:opacity .3s ease}.modal .modal-wrapper{display:table-cell;vertical-align:middle}.modal .modal-container{display:flex;flex-direction:column;color:#fff;background-color:#0a0a0a;margin-top:2em;max-height:600px;width:auto;margin:0 auto;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,.33);border:1px solid #d6d6d6;transition:all .3s ease}@media screen and (min-width:576px){.modal .modal-container{max-width:500px;margin:30px auto}}@media screen and (min-width:992px){.modal .modal-container{max-width:800px}}.modal .modal-header{margin-top:0;padding:20px 30px;border-bottom:1px solid #d6d6d6;flex-direction:row;display:flex;justify-content:space-between;align-items:center}.modal .modal-header h1,.modal .modal-header h2,.modal .modal-header h3,.modal .modal-header h4,.modal .modal-header h5,.modal .modal-header h6{margin:0}.modal .modal-header .close{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none;float:right;font-size:1.5rem;font-weight:200;line-height:1}.modal .modal-body{padding:20px 30px;overflow:auto}.modal .modal-footer{margin-top:0;padding:20px 30px;border-top:1px solid #d6d6d6;flex-direction:row;display:flex;justify-content:flex-end;align-items:center}.modal-enter,.modal-leave-active{opacity:0}.modal-enter .modal-container,.modal-leave-active .modal-container{-webkit-transform:scale(1.1);transform:translateY(-10px) scale(.9)}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlPzRkM2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSw4QkFBK0IsZUFBZSxlQUFlLDZCQUE2QixzQkFBc0IsV0FBVyxpQkFBaUIsa0JBQWtCLHFCQUFxQixxQkFBcUIsMEJBQTBCLGVBQWUseUJBQXlCLHFCQUFxQiwwQ0FBMEMseUJBQXlCLHFCQUFxQixpQkFBaUIsYUFBYSxnQkFBZ0IseUJBQXlCLGtCQUFrQixxQkFBcUIsWUFBWSx1QkFBdUIsV0FBVyw4Q0FBOEMsVUFBVSxPQUFPLGtCQUFrQixZQUFZLFdBQVcsbUJBQW1CLGVBQWUsYUFBYSxNQUFNLE9BQU8sV0FBVyxZQUFZLGdDQUFnQyxjQUFjLDRCQUE0QixzQkFBc0IsbUJBQW1CLHNCQUFzQix3QkFBd0IsYUFBYSxzQkFBc0IsV0FBVyx5QkFBeUIsZUFBZSxpQkFBaUIsV0FBVyxjQUFjLGdCQUFnQixxQ0FBcUMseUJBQXlCLHdCQUF3QixvQ0FBb0Msd0JBQXdCLGdCQUFnQixrQkFBa0Isb0NBQW9DLHdCQUF3QixpQkFBaUIscUJBQXFCLGFBQWEsa0JBQWtCLGdDQUFnQyxtQkFBbUIsYUFBYSw4QkFBOEIsbUJBQW1CLGdKQUFnSixTQUFTLDRCQUE0QixVQUFVLGVBQWUsZUFBZSxTQUFTLHdCQUF3QixZQUFZLGlCQUFpQixnQkFBZ0IsY0FBYyxtQkFBbUIsa0JBQWtCLGNBQWMscUJBQXFCLGFBQWEsa0JBQWtCLDZCQUE2QixtQkFBbUIsYUFBYSx5QkFBeUIsbUJBQW1CLGlDQUFpQyxVQUFVLG1FQUFtRSw2QkFBNkIsc0NBQXNDOztBQUUvbEUiLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYnRue2N1cnNvcjpkZWZhdWx0O2ZvbnQtc2l6ZToxNHB4O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjFweCBzb2xpZCAjZmZmO2NvbG9yOiNmZmY7cGFkZGluZzo4cHggMjZweDt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jazt0b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9ufS5idG4uYnRuLWdyZWVue2JhY2tncm91bmQtY29sb3I6IzRkYWY3Yztib3JkZXItY29sb3I6IzRkYWY3Y30uYnRuLmJ0bi1ncmVlbjpmb2N1cywuYnRuLmJ0bi1ncmVlbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMzZDhjNjM7Ym9yZGVyLWNvbG9yOiMzZDhjNjN9LmJ0bi5idG4tY29udHJvbHtkaXNwbGF5OmZsZXg7YmFja2dyb3VuZDpub25lO3RleHQtc2hhZG93OjAgMCA1cHggIzAwMDtmb250LXNpemU6MS4yNXJlbTtwYWRkaW5nOi41cmVtIC43NXJlbTtib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmUhaW1wb3J0YW50O29wYWNpdHk6Ljh9LmJ0bi5idG4tY29udHJvbDpmb2N1cywuYnRuLmJ0bi1jb250cm9sOmhvdmVye29wYWNpdHk6MX0ubW9kYWx7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJX0ubW9kYWwgLm1vZGFsLW1hc2t7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDo5OTk4O3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuNSk7ZGlzcGxheTp0YWJsZTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGVhc2V9Lm1vZGFsIC5tb2RhbC13cmFwcGVye2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1vZGFsIC5tb2RhbC1jb250YWluZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzBhMGEwYTttYXJnaW4tdG9wOjJlbTttYXgtaGVpZ2h0OjYwMHB4O3dpZHRoOmF1dG87bWFyZ2luOjAgYXV0bztvdmVyZmxvdzpoaWRkZW47Ym94LXNoYWRvdzowIDJweCA4cHggcmdiYSgwLDAsMCwuMzMpO2JvcmRlcjoxcHggc29saWQgI2Q2ZDZkNjt0cmFuc2l0aW9uOmFsbCAuM3MgZWFzZX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjU3NnB4KXsubW9kYWwgLm1vZGFsLWNvbnRhaW5lcnttYXgtd2lkdGg6NTAwcHg7bWFyZ2luOjMwcHggYXV0b319QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo5OTJweCl7Lm1vZGFsIC5tb2RhbC1jb250YWluZXJ7bWF4LXdpZHRoOjgwMHB4fX0ubW9kYWwgLm1vZGFsLWhlYWRlcnttYXJnaW4tdG9wOjA7cGFkZGluZzoyMHB4IDMwcHg7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2Q2ZDZkNjtmbGV4LWRpcmVjdGlvbjpyb3c7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcn0ubW9kYWwgLm1vZGFsLWhlYWRlciBoMSwubW9kYWwgLm1vZGFsLWhlYWRlciBoMiwubW9kYWwgLm1vZGFsLWhlYWRlciBoMywubW9kYWwgLm1vZGFsLWhlYWRlciBoNCwubW9kYWwgLm1vZGFsLWhlYWRlciBoNSwubW9kYWwgLm1vZGFsLWhlYWRlciBoNnttYXJnaW46MH0ubW9kYWwgLm1vZGFsLWhlYWRlciAuY2xvc2V7cGFkZGluZzowO2N1cnNvcjpwb2ludGVyO2JhY2tncm91bmQ6MCAwO2JvcmRlcjowOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2Zsb2F0OnJpZ2h0O2ZvbnQtc2l6ZToxLjVyZW07Zm9udC13ZWlnaHQ6MjAwO2xpbmUtaGVpZ2h0OjF9Lm1vZGFsIC5tb2RhbC1ib2R5e3BhZGRpbmc6MjBweCAzMHB4O292ZXJmbG93OmF1dG99Lm1vZGFsIC5tb2RhbC1mb290ZXJ7bWFyZ2luLXRvcDowO3BhZGRpbmc6MjBweCAzMHB4O2JvcmRlci10b3A6MXB4IHNvbGlkICNkNmQ2ZDY7ZmxleC1kaXJlY3Rpb246cm93O2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7YWxpZ24taXRlbXM6Y2VudGVyfS5tb2RhbC1lbnRlciwubW9kYWwtbGVhdmUtYWN0aXZle29wYWNpdHk6MH0ubW9kYWwtZW50ZXIgLm1vZGFsLWNvbnRhaW5lciwubW9kYWwtbGVhdmUtYWN0aXZlIC5tb2RhbC1jb250YWluZXJ7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4xKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTBweCkgc2NhbGUoLjkpfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0wNjBjMDUyMFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL01vZGFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, "/*! Hint.css - v2.5.0 - 2017-04-23\\n* http://kushagragour.in/lab/hint/\\n* Copyright (c) 2017 Kushagra Gour */[class*=hint--][data-v-33163bc3]{position:relative;display:inline-block}[class*=hint--][data-v-33163bc3]:after,[class*=hint--][data-v-33163bc3]:before{position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);visibility:hidden;opacity:0;z-index:1000000;pointer-events:none;transition:.3s ease;transition-delay:0ms}[class*=hint--][data-v-33163bc3]:hover:after,[class*=hint--][data-v-33163bc3]:hover:before{visibility:visible;opacity:1;transition-delay:.1s}[class*=hint--][data-v-33163bc3]:before{content:\\"\\";position:absolute;background:transparent;border:6px solid transparent;z-index:1000001}[class*=hint--][data-v-33163bc3]:after{background:#383838;color:#fff;padding:8px 10px;font-size:12px;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;line-height:12px;white-space:nowrap}[class*=hint--][aria-label][data-v-33163bc3]:after{content:attr(aria-label)}[class*=hint--][data-hint][data-v-33163bc3]:after{content:attr(data-hint)}[aria-label=\\"\\"][data-v-33163bc3]:after,[aria-label=\\"\\"][data-v-33163bc3]:before,[data-hint=\\"\\"][data-v-33163bc3]:after,[data-hint=\\"\\"][data-v-33163bc3]:before{display:none!important}.hint--top-left[data-v-33163bc3]:before,.hint--top-right[data-v-33163bc3]:before,.hint--top[data-v-33163bc3]:before{border-top-color:#383838}.hint--bottom-left[data-v-33163bc3]:before,.hint--bottom-right[data-v-33163bc3]:before,.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#383838}.hint--left[data-v-33163bc3]:before{border-left-color:#383838}.hint--right[data-v-33163bc3]:before{border-right-color:#383838}.hint--top[data-v-33163bc3]:before{margin-bottom:-11px}.hint--top[data-v-33163bc3]:after,.hint--top[data-v-33163bc3]:before{bottom:100%;left:50%}.hint--top[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--top[data-v-33163bc3]:after{-webkit-transform:translateX(-50%);transform:translateX(-50%)}.hint--top[data-v-33163bc3]:hover:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--top[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-50%) translateY(-8px);transform:translateX(-50%) translateY(-8px)}.hint--bottom[data-v-33163bc3]:before{margin-top:-11px}.hint--bottom[data-v-33163bc3]:after,.hint--bottom[data-v-33163bc3]:before{top:100%;left:50%}.hint--bottom[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--bottom[data-v-33163bc3]:after{-webkit-transform:translateX(-50%);transform:translateX(-50%)}.hint--bottom[data-v-33163bc3]:hover:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--bottom[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-50%) translateY(8px);transform:translateX(-50%) translateY(8px)}.hint--right[data-v-33163bc3]:before{margin-left:-11px;margin-bottom:-6px}.hint--right[data-v-33163bc3]:after{margin-bottom:-14px}.hint--right[data-v-33163bc3]:after,.hint--right[data-v-33163bc3]:before{left:100%;bottom:50%}.hint--right[data-v-33163bc3]:hover:after,.hint--right[data-v-33163bc3]:hover:before{-webkit-transform:translateX(8px);transform:translateX(8px)}.hint--left[data-v-33163bc3]:before{margin-right:-11px;margin-bottom:-6px}.hint--left[data-v-33163bc3]:after{margin-bottom:-14px}.hint--left[data-v-33163bc3]:after,.hint--left[data-v-33163bc3]:before{right:100%;bottom:50%}.hint--left[data-v-33163bc3]:hover:after,.hint--left[data-v-33163bc3]:hover:before{-webkit-transform:translateX(-8px);transform:translateX(-8px)}.hint--top-left[data-v-33163bc3]:before{margin-bottom:-11px}.hint--top-left[data-v-33163bc3]:after,.hint--top-left[data-v-33163bc3]:before{bottom:100%;left:50%}.hint--top-left[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--top-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%);transform:translateX(-100%);margin-left:12px}.hint--top-left[data-v-33163bc3]:hover:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--top-left[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-100%) translateY(-8px);transform:translateX(-100%) translateY(-8px)}.hint--top-right[data-v-33163bc3]:before{margin-bottom:-11px}.hint--top-right[data-v-33163bc3]:after,.hint--top-right[data-v-33163bc3]:before{bottom:100%;left:50%}.hint--top-right[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--top-right[data-v-33163bc3]:after{-webkit-transform:translateX(0);transform:translateX(0);margin-left:-12px}.hint--top-right[data-v-33163bc3]:hover:after,.hint--top-right[data-v-33163bc3]:hover:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--bottom-left[data-v-33163bc3]:before{margin-top:-11px}.hint--bottom-left[data-v-33163bc3]:after,.hint--bottom-left[data-v-33163bc3]:before{top:100%;left:50%}.hint--bottom-left[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--bottom-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%);transform:translateX(-100%);margin-left:12px}.hint--bottom-left[data-v-33163bc3]:hover:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--bottom-left[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-100%) translateY(8px);transform:translateX(-100%) translateY(8px)}.hint--bottom-right[data-v-33163bc3]:before{margin-top:-11px}.hint--bottom-right[data-v-33163bc3]:after,.hint--bottom-right[data-v-33163bc3]:before{top:100%;left:50%}.hint--bottom-right[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--bottom-right[data-v-33163bc3]:after{-webkit-transform:translateX(0);transform:translateX(0);margin-left:-12px}.hint--bottom-right[data-v-33163bc3]:hover:after,.hint--bottom-right[data-v-33163bc3]:hover:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--large[data-v-33163bc3]:after,.hint--medium[data-v-33163bc3]:after,.hint--small[data-v-33163bc3]:after{white-space:normal;line-height:1.4em;word-wrap:break-word}.hint--small[data-v-33163bc3]:after{width:80px}.hint--medium[data-v-33163bc3]:after{width:150px}.hint--large[data-v-33163bc3]:after{width:300px}[class*=hint--][data-v-33163bc3]:after{text-shadow:0 -1px 0 #000;box-shadow:4px 4px 8px rgba(0,0,0,.3)}.hint--error[data-v-33163bc3]:after{background-color:#b34e4d;text-shadow:0 -1px 0 #592726}.hint--error.hint--top-left[data-v-33163bc3]:before,.hint--error.hint--top-right[data-v-33163bc3]:before,.hint--error.hint--top[data-v-33163bc3]:before{border-top-color:#b34e4d}.hint--error.hint--bottom-left[data-v-33163bc3]:before,.hint--error.hint--bottom-right[data-v-33163bc3]:before,.hint--error.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#b34e4d}.hint--error.hint--left[data-v-33163bc3]:before{border-left-color:#b34e4d}.hint--error.hint--right[data-v-33163bc3]:before{border-right-color:#b34e4d}.hint--warning[data-v-33163bc3]:after{background-color:#c09854;text-shadow:0 -1px 0 #6c5328}.hint--warning.hint--top-left[data-v-33163bc3]:before,.hint--warning.hint--top-right[data-v-33163bc3]:before,.hint--warning.hint--top[data-v-33163bc3]:before{border-top-color:#c09854}.hint--warning.hint--bottom-left[data-v-33163bc3]:before,.hint--warning.hint--bottom-right[data-v-33163bc3]:before,.hint--warning.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#c09854}.hint--warning.hint--left[data-v-33163bc3]:before{border-left-color:#c09854}.hint--warning.hint--right[data-v-33163bc3]:before{border-right-color:#c09854}.hint--info[data-v-33163bc3]:after{background-color:#3986ac;text-shadow:0 -1px 0 #1a3c4d}.hint--info.hint--top-left[data-v-33163bc3]:before,.hint--info.hint--top-right[data-v-33163bc3]:before,.hint--info.hint--top[data-v-33163bc3]:before{border-top-color:#3986ac}.hint--info.hint--bottom-left[data-v-33163bc3]:before,.hint--info.hint--bottom-right[data-v-33163bc3]:before,.hint--info.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#3986ac}.hint--info.hint--left[data-v-33163bc3]:before{border-left-color:#3986ac}.hint--info.hint--right[data-v-33163bc3]:before{border-right-color:#3986ac}.hint--success[data-v-33163bc3]:after{background-color:#458746;text-shadow:0 -1px 0 #1a321a}.hint--success.hint--top-left[data-v-33163bc3]:before,.hint--success.hint--top-right[data-v-33163bc3]:before,.hint--success.hint--top[data-v-33163bc3]:before{border-top-color:#458746}.hint--success.hint--bottom-left[data-v-33163bc3]:before,.hint--success.hint--bottom-right[data-v-33163bc3]:before,.hint--success.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#458746}.hint--success.hint--left[data-v-33163bc3]:before{border-left-color:#458746}.hint--success.hint--right[data-v-33163bc3]:before{border-right-color:#458746}.hint--always[data-v-33163bc3]:after,.hint--always[data-v-33163bc3]:before{opacity:1;visibility:visible}.hint--always.hint--top[data-v-33163bc3]:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--always.hint--top[data-v-33163bc3]:after{-webkit-transform:translateX(-50%) translateY(-8px);transform:translateX(-50%) translateY(-8px)}.hint--always.hint--top-left[data-v-33163bc3]:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--always.hint--top-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%) translateY(-8px);transform:translateX(-100%) translateY(-8px)}.hint--always.hint--top-right[data-v-33163bc3]:after,.hint--always.hint--top-right[data-v-33163bc3]:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--always.hint--bottom[data-v-33163bc3]:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--always.hint--bottom[data-v-33163bc3]:after{-webkit-transform:translateX(-50%) translateY(8px);transform:translateX(-50%) translateY(8px)}.hint--always.hint--bottom-left[data-v-33163bc3]:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--always.hint--bottom-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%) translateY(8px);transform:translateX(-100%) translateY(8px)}.hint--always.hint--bottom-right[data-v-33163bc3]:after,.hint--always.hint--bottom-right[data-v-33163bc3]:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--always.hint--left[data-v-33163bc3]:after,.hint--always.hint--left[data-v-33163bc3]:before{-webkit-transform:translateX(-8px);transform:translateX(-8px)}.hint--always.hint--right[data-v-33163bc3]:after,.hint--always.hint--right[data-v-33163bc3]:before{-webkit-transform:translateX(8px);transform:translateX(8px)}.hint--rounded[data-v-33163bc3]:after{border-radius:4px}.hint--no-animate[data-v-33163bc3]:after,.hint--no-animate[data-v-33163bc3]:before{transition-duration:0ms}.hint--bounce[data-v-33163bc3]:after,.hint--bounce[data-v-33163bc3]:before{transition:opacity .3s ease,visibility .3s ease,transform .3s cubic-bezier(.71,1.7,.77,1.24)}.btn[data-v-33163bc3]{cursor:default;font-size:14px;background-color:transparent;border:1px solid #fff;color:#fff;padding:8px 26px;text-align:center;text-decoration:none;display:inline-block;touch-action:manipulation}.btn.btn-green[data-v-33163bc3]{background-color:#4daf7c;border-color:#4daf7c}.btn.btn-green[data-v-33163bc3]:focus,.btn.btn-green[data-v-33163bc3]:hover{background-color:#3d8c63;border-color:#3d8c63}.btn.btn-control[data-v-33163bc3]{display:flex;background:none;text-shadow:0 0 5px #000;font-size:1.25rem;padding:.5rem .75rem;border:none;outline:none!important;opacity:.8}.btn.btn-control[data-v-33163bc3]:focus,.btn.btn-control[data-v-33163bc3]:hover{opacity:1}.lv-controls[data-v-33163bc3]{display:flex;margin:1rem;position:absolute;z-index:2;border-radius:25px;background-color:rgba(0,0,0,.75);padding:0 .5rem}@media screen and (min-width:992px){.lv-controls[data-v-33163bc3]{padding:0}}.lv-controls.bottom[data-v-33163bc3]{bottom:0}.lv-controls.top[data-v-33163bc3]{top:0}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlPzI1ZjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSx1S0FBd0ssa0JBQWtCLHFCQUFxQiwrRUFBK0Usa0JBQWtCLGdDQUFnQyx3QkFBd0Isa0JBQWtCLFVBQVUsZ0JBQWdCLG9CQUFvQixvQkFBb0IscUJBQXFCLDJGQUEyRixtQkFBbUIsVUFBVSxxQkFBcUIsd0NBQXdDLGFBQWEsa0JBQWtCLHVCQUF1Qiw2QkFBNkIsZ0JBQWdCLHVDQUF1QyxtQkFBbUIsV0FBVyxpQkFBaUIsZUFBZSxzREFBc0QsaUJBQWlCLG1CQUFtQixtREFBbUQseUJBQXlCLGtEQUFrRCx3QkFBd0Isb0tBQW9LLHVCQUF1QixvSEFBb0gseUJBQXlCLDZIQUE2SCw0QkFBNEIsb0NBQW9DLDBCQUEwQixxQ0FBcUMsMkJBQTJCLG1DQUFtQyxvQkFBb0IscUVBQXFFLFlBQVksU0FBUyxtQ0FBbUMscUJBQXFCLGtDQUFrQyxtQ0FBbUMsMkJBQTJCLHlDQUF5QyxtQ0FBbUMsMkJBQTJCLHdDQUF3QyxvREFBb0QsNENBQTRDLHNDQUFzQyxpQkFBaUIsMkVBQTJFLFNBQVMsU0FBUyxzQ0FBc0MscUJBQXFCLHFDQUFxQyxtQ0FBbUMsMkJBQTJCLDRDQUE0QyxrQ0FBa0MsMEJBQTBCLDJDQUEyQyxtREFBbUQsMkNBQTJDLHFDQUFxQyxrQkFBa0IsbUJBQW1CLG9DQUFvQyxvQkFBb0IseUVBQXlFLFVBQVUsV0FBVyxxRkFBcUYsa0NBQWtDLDBCQUEwQixvQ0FBb0MsbUJBQW1CLG1CQUFtQixtQ0FBbUMsb0JBQW9CLHVFQUF1RSxXQUFXLFdBQVcsbUZBQW1GLG1DQUFtQywyQkFBMkIsd0NBQXdDLG9CQUFvQiwrRUFBK0UsWUFBWSxTQUFTLHdDQUF3QyxxQkFBcUIsdUNBQXVDLG9DQUFvQyw0QkFBNEIsaUJBQWlCLDhDQUE4QyxtQ0FBbUMsMkJBQTJCLDZDQUE2QyxxREFBcUQsNkNBQTZDLHlDQUF5QyxvQkFBb0IsaUZBQWlGLFlBQVksU0FBUyx5Q0FBeUMscUJBQXFCLHdDQUF3QyxnQ0FBZ0Msd0JBQXdCLGtCQUFrQiw2RkFBNkYsbUNBQW1DLDJCQUEyQiwyQ0FBMkMsaUJBQWlCLHFGQUFxRixTQUFTLFNBQVMsMkNBQTJDLHFCQUFxQiwwQ0FBMEMsb0NBQW9DLDRCQUE0QixpQkFBaUIsaURBQWlELGtDQUFrQywwQkFBMEIsZ0RBQWdELG9EQUFvRCw0Q0FBNEMsNENBQTRDLGlCQUFpQix1RkFBdUYsU0FBUyxTQUFTLDRDQUE0QyxxQkFBcUIsMkNBQTJDLGdDQUFnQyx3QkFBd0Isa0JBQWtCLG1HQUFtRyxrQ0FBa0MsMEJBQTBCLDZHQUE2RyxtQkFBbUIsa0JBQWtCLHFCQUFxQixvQ0FBb0MsV0FBVyxxQ0FBcUMsWUFBWSxvQ0FBb0MsWUFBWSx1Q0FBdUMsMEJBQTBCLHNDQUFzQyxvQ0FBb0MseUJBQXlCLDZCQUE2Qix3SkFBd0oseUJBQXlCLGlLQUFpSyw0QkFBNEIsZ0RBQWdELDBCQUEwQixpREFBaUQsMkJBQTJCLHNDQUFzQyx5QkFBeUIsNkJBQTZCLDhKQUE4Six5QkFBeUIsdUtBQXVLLDRCQUE0QixrREFBa0QsMEJBQTBCLG1EQUFtRCwyQkFBMkIsbUNBQW1DLHlCQUF5Qiw2QkFBNkIscUpBQXFKLHlCQUF5Qiw4SkFBOEosNEJBQTRCLCtDQUErQywwQkFBMEIsZ0RBQWdELDJCQUEyQixzQ0FBc0MseUJBQXlCLDZCQUE2Qiw4SkFBOEoseUJBQXlCLHVLQUF1Syw0QkFBNEIsa0RBQWtELDBCQUEwQixtREFBbUQsMkJBQTJCLDJFQUEyRSxVQUFVLG1CQUFtQixnREFBZ0QsbUNBQW1DLDJCQUEyQiwrQ0FBK0Msb0RBQW9ELDRDQUE0QyxxREFBcUQsbUNBQW1DLDJCQUEyQixvREFBb0QscURBQXFELDZDQUE2QywyR0FBMkcsbUNBQW1DLDJCQUEyQixtREFBbUQsa0NBQWtDLDBCQUEwQixrREFBa0QsbURBQW1ELDJDQUEyQyx3REFBd0Qsa0NBQWtDLDBCQUEwQix1REFBdUQsb0RBQW9ELDRDQUE0QyxpSEFBaUgsa0NBQWtDLDBCQUEwQixpR0FBaUcsbUNBQW1DLDJCQUEyQixtR0FBbUcsa0NBQWtDLDBCQUEwQixzQ0FBc0Msa0JBQWtCLG1GQUFtRix3QkFBd0IsMkVBQTJFLDZGQUE2RixzQkFBc0IsZUFBZSxlQUFlLDZCQUE2QixzQkFBc0IsV0FBVyxpQkFBaUIsa0JBQWtCLHFCQUFxQixxQkFBcUIsMEJBQTBCLGdDQUFnQyx5QkFBeUIscUJBQXFCLDRFQUE0RSx5QkFBeUIscUJBQXFCLGtDQUFrQyxhQUFhLGdCQUFnQix5QkFBeUIsa0JBQWtCLHFCQUFxQixZQUFZLHVCQUF1QixXQUFXLGdGQUFnRixVQUFVLDhCQUE4QixhQUFhLFlBQVksa0JBQWtCLFVBQVUsbUJBQW1CLGlDQUFpQyxnQkFBZ0Isb0NBQW9DLDhCQUE4QixXQUFXLHFDQUFxQyxTQUFTLGtDQUFrQyxNQUFNOztBQUV0N1ciLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiEgSGludC5jc3MgLSB2Mi41LjAgLSAyMDE3LTA0LTIzXFxuKiBodHRwOi8va3VzaGFncmFnb3VyLmluL2xhYi9oaW50L1xcbiogQ29weXJpZ2h0IChjKSAyMDE3IEt1c2hhZ3JhIEdvdXIgKi9bY2xhc3MqPWhpbnQtLV1bZGF0YS12LTMzMTYzYmMzXXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9ja31bY2xhc3MqPWhpbnQtLV1bZGF0YS12LTMzMTYzYmMzXTphZnRlcixbY2xhc3MqPWhpbnQtLV1bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt2aXNpYmlsaXR5OmhpZGRlbjtvcGFjaXR5OjA7ei1pbmRleDoxMDAwMDAwO3BvaW50ZXItZXZlbnRzOm5vbmU7dHJhbnNpdGlvbjouM3MgZWFzZTt0cmFuc2l0aW9uLWRlbGF5OjBtc31bY2xhc3MqPWhpbnQtLV1bZGF0YS12LTMzMTYzYmMzXTpob3ZlcjphZnRlcixbY2xhc3MqPWhpbnQtLV1bZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7dmlzaWJpbGl0eTp2aXNpYmxlO29wYWNpdHk6MTt0cmFuc2l0aW9uLWRlbGF5Oi4xc31bY2xhc3MqPWhpbnQtLV1bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2JvcmRlcjo2cHggc29saWQgdHJhbnNwYXJlbnQ7ei1pbmRleDoxMDAwMDAxfVtjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVye2JhY2tncm91bmQ6IzM4MzgzODtjb2xvcjojZmZmO3BhZGRpbmc6OHB4IDEwcHg7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7bGluZS1oZWlnaHQ6MTJweDt3aGl0ZS1zcGFjZTpub3dyYXB9W2NsYXNzKj1oaW50LS1dW2FyaWEtbGFiZWxdW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7Y29udGVudDphdHRyKGFyaWEtbGFiZWwpfVtjbGFzcyo9aGludC0tXVtkYXRhLWhpbnRdW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7Y29udGVudDphdHRyKGRhdGEtaGludCl9W2FyaWEtbGFiZWw9XFxcIlxcXCJdW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsW2FyaWEtbGFiZWw9XFxcIlxcXCJdW2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLFtkYXRhLWhpbnQ9XFxcIlxcXCJdW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsW2RhdGEtaGludD1cXFwiXFxcIl1bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7ZGlzcGxheTpub25lIWltcG9ydGFudH0uaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci10b3AtY29sb3I6IzM4MzgzOH0uaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1ib3R0b20tY29sb3I6IzM4MzgzOH0uaGludC0tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItbGVmdC1jb2xvcjojMzgzODM4fS5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItcmlnaHQtY29sb3I6IzM4MzgzOH0uaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle21hcmdpbi1ib3R0b206LTExcHh9LmhpbnQtLXRvcFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym90dG9tOjEwMCU7bGVmdDo1MCV9LmhpbnQtLXRvcFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtsZWZ0OmNhbGMoNTAlIC0gNnB4KX0uaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKX0uaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLXRvcFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC04cHgpfS5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bWFyZ2luLXRvcDotMTFweH0uaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXt0b3A6MTAwJTtsZWZ0OjUwJX0uaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2xlZnQ6Y2FsYyg1MCUgLSA2cHgpfS5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCl9LmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoOHB4KX0uaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bWFyZ2luLWxlZnQ6LTExcHg7bWFyZ2luLWJvdHRvbTotNnB4fS5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVye21hcmdpbi1ib3R0b206LTE0cHh9LmhpbnQtLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2xlZnQ6MTAwJTtib3R0b206NTAlfS5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyLC5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoOHB4KX0uaGludC0tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXttYXJnaW4tcmlnaHQ6LTExcHg7bWFyZ2luLWJvdHRvbTotNnB4fS5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7bWFyZ2luLWJvdHRvbTotMTRweH0uaGludC0tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle3JpZ2h0OjEwMCU7Ym90dG9tOjUwJX0uaGludC0tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyLC5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLThweCl9LmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle21hcmdpbi1ib3R0b206LTExcHh9LmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvdHRvbToxMDAlO2xlZnQ6NTAlfS5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtsZWZ0OmNhbGMoNTAlIC0gNnB4KX0uaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSk7bWFyZ2luLWxlZnQ6MTJweH0uaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KX0uaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKC04cHgpfS5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bWFyZ2luLWJvdHRvbTotMTFweH0uaGludC0tdG9wLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3R0b206MTAwJTtsZWZ0OjUwJX0uaGludC0tdG9wLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2xlZnQ6Y2FsYyg1MCUgLSA2cHgpfS5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApO21hcmdpbi1sZWZ0Oi0xMnB4fS5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjphZnRlciwuaGludC0tdG9wLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle21hcmdpbi10b3A6LTExcHh9LmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle3RvcDoxMDAlO2xlZnQ6NTAlfS5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtsZWZ0OmNhbGMoNTAlIC0gNnB4KX0uaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSk7bWFyZ2luLWxlZnQ6MTJweH0uaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCl9LmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSkgdHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKDhweCl9LmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXttYXJnaW4tdG9wOi0xMXB4fS5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tYm90dG9tLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle3RvcDoxMDAlO2xlZnQ6NTAlfS5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bGVmdDpjYWxjKDUwJSAtIDZweCl9LmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7bWFyZ2luLWxlZnQ6LTEycHh9LmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyLC5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCl9LmhpbnQtLWxhcmdlW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLW1lZGl1bVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1zbWFsbFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVye3doaXRlLXNwYWNlOm5vcm1hbDtsaW5lLWhlaWdodDoxLjRlbTt3b3JkLXdyYXA6YnJlYWstd29yZH0uaGludC0tc21hbGxbZGF0YS12LTMzMTYzYmMzXTphZnRlcnt3aWR0aDo4MHB4fS5oaW50LS1tZWRpdW1bZGF0YS12LTMzMTYzYmMzXTphZnRlcnt3aWR0aDoxNTBweH0uaGludC0tbGFyZ2VbZGF0YS12LTMzMTYzYmMzXTphZnRlcnt3aWR0aDozMDBweH1bY2xhc3MqPWhpbnQtLV1bZGF0YS12LTMzMTYzYmMzXTphZnRlcnt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMDAwO2JveC1zaGFkb3c6NHB4IDRweCA4cHggcmdiYSgwLDAsMCwuMyl9LmhpbnQtLWVycm9yW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7YmFja2dyb3VuZC1jb2xvcjojYjM0ZTRkO3RleHQtc2hhZG93OjAgLTFweCAwICM1OTI3MjZ9LmhpbnQtLWVycm9yLmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS1lcnJvci5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLWVycm9yLmhpbnQtLXRvcFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItdG9wLWNvbG9yOiNiMzRlNGR9LmhpbnQtLWVycm9yLmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS1lcnJvci5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLWVycm9yLmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItYm90dG9tLWNvbG9yOiNiMzRlNGR9LmhpbnQtLWVycm9yLmhpbnQtLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWxlZnQtY29sb3I6I2IzNGU0ZH0uaGludC0tZXJyb3IuaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXJpZ2h0LWNvbG9yOiNiMzRlNGR9LmhpbnQtLXdhcm5pbmdbZGF0YS12LTMzMTYzYmMzXTphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiNjMDk4NTQ7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzZjNTMyOH0uaGludC0td2FybmluZy5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0td2FybmluZy5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLXdhcm5pbmcuaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci10b3AtY29sb3I6I2MwOTg1NH0uaGludC0td2FybmluZy5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0td2FybmluZy5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLXdhcm5pbmcuaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1ib3R0b20tY29sb3I6I2MwOTg1NH0uaGludC0td2FybmluZy5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1sZWZ0LWNvbG9yOiNjMDk4NTR9LmhpbnQtLXdhcm5pbmcuaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXJpZ2h0LWNvbG9yOiNjMDk4NTR9LmhpbnQtLWluZm9bZGF0YS12LTMzMTYzYmMzXTphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiMzOTg2YWM7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzFhM2M0ZH0uaGludC0taW5mby5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0taW5mby5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLWluZm8uaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci10b3AtY29sb3I6IzM5ODZhY30uaGludC0taW5mby5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0taW5mby5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLWluZm8uaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1ib3R0b20tY29sb3I6IzM5ODZhY30uaGludC0taW5mby5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1sZWZ0LWNvbG9yOiMzOTg2YWN9LmhpbnQtLWluZm8uaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXJpZ2h0LWNvbG9yOiMzOTg2YWN9LmhpbnQtLXN1Y2Nlc3NbZGF0YS12LTMzMTYzYmMzXTphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiM0NTg3NDY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzFhMzIxYX0uaGludC0tc3VjY2Vzcy5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tc3VjY2Vzcy5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLXN1Y2Nlc3MuaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci10b3AtY29sb3I6IzQ1ODc0Nn0uaGludC0tc3VjY2Vzcy5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tc3VjY2Vzcy5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLXN1Y2Nlc3MuaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1ib3R0b20tY29sb3I6IzQ1ODc0Nn0uaGludC0tc3VjY2Vzcy5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1sZWZ0LWNvbG9yOiM0NTg3NDZ9LmhpbnQtLXN1Y2Nlc3MuaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXJpZ2h0LWNvbG9yOiM0NTg3NDZ9LmhpbnQtLWFsd2F5c1tkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1hbHdheXNbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7b3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZX0uaGludC0tYWx3YXlzLmhpbnQtLXRvcFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpfS5oaW50LS1hbHdheXMuaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLWFsd2F5cy5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpfS5oaW50LS1hbHdheXMuaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKC04cHgpfS5oaW50LS1hbHdheXMuaGludC0tdG9wLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWFsd2F5cy5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KX0uaGludC0tYWx3YXlzLmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoOHB4KX0uaGludC0tYWx3YXlzLmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoOHB4KX0uaGludC0tYWx3YXlzLmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpfS5oaW50LS1hbHdheXMuaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoOHB4KX0uaGludC0tYWx3YXlzLmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1hbHdheXMuaGludC0tYm90dG9tLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpfS5oaW50LS1hbHdheXMuaGludC0tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1hbHdheXMuaGludC0tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC04cHgpfS5oaW50LS1hbHdheXMuaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tYWx3YXlzLmhpbnQtLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg4cHgpfS5oaW50LS1yb3VuZGVkW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7Ym9yZGVyLXJhZGl1czo0cHh9LmhpbnQtLW5vLWFuaW1hdGVbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tbm8tYW5pbWF0ZVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXt0cmFuc2l0aW9uLWR1cmF0aW9uOjBtc30uaGludC0tYm91bmNlW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWJvdW5jZVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGVhc2UsdmlzaWJpbGl0eSAuM3MgZWFzZSx0cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguNzEsMS43LC43NywxLjI0KX0uYnRuW2RhdGEtdi0zMzE2M2JjM117Y3Vyc29yOmRlZmF1bHQ7Zm9udC1zaXplOjE0cHg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MXB4IHNvbGlkICNmZmY7Y29sb3I6I2ZmZjtwYWRkaW5nOjhweCAyNnB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RvdWNoLWFjdGlvbjptYW5pcHVsYXRpb259LmJ0bi5idG4tZ3JlZW5bZGF0YS12LTMzMTYzYmMzXXtiYWNrZ3JvdW5kLWNvbG9yOiM0ZGFmN2M7Ym9yZGVyLWNvbG9yOiM0ZGFmN2N9LmJ0bi5idG4tZ3JlZW5bZGF0YS12LTMzMTYzYmMzXTpmb2N1cywuYnRuLmJ0bi1ncmVlbltkYXRhLXYtMzMxNjNiYzNdOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzNkOGM2Mztib3JkZXItY29sb3I6IzNkOGM2M30uYnRuLmJ0bi1jb250cm9sW2RhdGEtdi0zMzE2M2JjM117ZGlzcGxheTpmbGV4O2JhY2tncm91bmQ6bm9uZTt0ZXh0LXNoYWRvdzowIDAgNXB4ICMwMDA7Zm9udC1zaXplOjEuMjVyZW07cGFkZGluZzouNXJlbSAuNzVyZW07Ym9yZGVyOm5vbmU7b3V0bGluZTpub25lIWltcG9ydGFudDtvcGFjaXR5Oi44fS5idG4uYnRuLWNvbnRyb2xbZGF0YS12LTMzMTYzYmMzXTpmb2N1cywuYnRuLmJ0bi1jb250cm9sW2RhdGEtdi0zMzE2M2JjM106aG92ZXJ7b3BhY2l0eToxfS5sdi1jb250cm9sc1tkYXRhLXYtMzMxNjNiYzNde2Rpc3BsYXk6ZmxleDttYXJnaW46MXJlbTtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7Ym9yZGVyLXJhZGl1czoyNXB4O2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuNzUpO3BhZGRpbmc6MCAuNXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjk5MnB4KXsubHYtY29udHJvbHNbZGF0YS12LTMzMTYzYmMzXXtwYWRkaW5nOjB9fS5sdi1jb250cm9scy5ib3R0b21bZGF0YS12LTMzMTYzYmMzXXtib3R0b206MH0ubHYtY29udHJvbHMudG9wW2RhdGEtdi0zMzE2M2JjM117dG9wOjB9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTMzMTYzYmMzXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9Db250cm9scy52dWVcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, ".btn[data-v-4ae81000]{cursor:default;font-size:14px;background-color:transparent;border:1px solid #fff;color:#fff;padding:8px 26px;text-align:center;text-decoration:none;display:inline-block;touch-action:manipulation}.btn.btn-green[data-v-4ae81000]{background-color:#4daf7c;border-color:#4daf7c}.btn.btn-green[data-v-4ae81000]:focus,.btn.btn-green[data-v-4ae81000]:hover{background-color:#3d8c63;border-color:#3d8c63}.btn.btn-control[data-v-4ae81000]{display:flex;background:none;text-shadow:0 0 5px #000;font-size:1.25rem;padding:.5rem .75rem;border:none;outline:none!important;opacity:.8}.btn.btn-control[data-v-4ae81000]:focus,.btn.btn-control[data-v-4ae81000]:hover{opacity:1}input[data-v-4ae81000],textarea[data-v-4ae81000]{margin:10px 0;display:block;width:100%;padding:10px;font-size:1rem;line-height:1.25;color:#707070;background-color:#fff;background-image:none;background-clip:padding-box;border:1px solid rgba(0,0,0,.15);transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;touch-action:manipulation;font-family:sans-serif;box-sizing:border-box}input[data-v-4ae81000]:focus,textarea[data-v-4ae81000]:focus{border-color:#3498db;outline:none;box-shadow:0 0 5px rgba(52,152,219,.5)}textarea[data-v-4ae81000]{overflow:auto}#lv-task-sidebar ul[data-v-4ae81000]{overflow-y:auto;min-height:100px;max-height:300px;list-style:none;padding:.8rem;margin:0;border:1px solid #707070}#lv-task-sidebar ul li[data-v-4ae81000]{display:flex;flex-direction:row;justify-content:space-between;align-content:center}#lv-task-sidebar ul li[data-v-4ae81000]:not(:last-child){margin-bottom:.75rem}#lv-task-sidebar h4[data-v-4ae81000]{margin:0}#lv-task-sidebar .btn[data-v-4ae81000]{width:100%;display:block;margin-top:.6rem}#lv-task-sidebar svg[data-v-4ae81000]{margin-left:5px}#lv-task-sidebar button[data-v-4ae81000]{display:flex;margin-right:auto;margin-left:auto}#lv-task-sidebar .slide-enter-active[data-v-4ae81000],#lv-task-sidebar .slide-leave-active[data-v-4ae81000]{transition:1s}#lv-task-sidebar .slide-enter[data-v-4ae81000]{transform:translate3d(0,100%,0);visibility:hidden}#lv-task-sidebar .slide-leave-to[data-v-4ae81000]{transform:translate3d(0,-100%,0);visibility:visible}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvVGFzay52dWU/OTJjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLCtDQUFnRCxlQUFlLGVBQWUsNkJBQTZCLHNCQUFzQixXQUFXLGlCQUFpQixrQkFBa0IscUJBQXFCLHFCQUFxQiwwQkFBMEIsZ0NBQWdDLHlCQUF5QixxQkFBcUIsNEVBQTRFLHlCQUF5QixxQkFBcUIsa0NBQWtDLGFBQWEsZ0JBQWdCLHlCQUF5QixrQkFBa0IscUJBQXFCLFlBQVksdUJBQXVCLFdBQVcsZ0ZBQWdGLFVBQVUsaURBQWlELGNBQWMsY0FBYyxXQUFXLGFBQWEsZUFBZSxpQkFBaUIsY0FBYyxzQkFBc0Isc0JBQXNCLDRCQUE0QixpQ0FBaUMscUVBQXFFLDBCQUEwQix1QkFBdUIsc0JBQXNCLDZEQUE2RCxxQkFBcUIsYUFBYSx1Q0FBdUMsMEJBQTBCLGNBQWMscUNBQXFDLGdCQUFnQixpQkFBaUIsaUJBQWlCLGdCQUFnQixjQUFjLFNBQVMseUJBQXlCLHdDQUF3QyxhQUFhLG1CQUFtQiw4QkFBOEIscUJBQXFCLHlEQUF5RCxxQkFBcUIscUNBQXFDLFNBQVMsdUNBQXVDLFdBQVcsY0FBYyxpQkFBaUIsc0NBQXNDLGdCQUFnQix5Q0FBeUMsYUFBYSxrQkFBa0IsaUJBQWlCLDRHQUE0RyxjQUFjLCtDQUErQyxnQ0FBZ0Msa0JBQWtCLGtEQUFrRCxpQ0FBaUMsbUJBQW1COztBQUV2cUUiLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYnRuW2RhdGEtdi00YWU4MTAwMF17Y3Vyc29yOmRlZmF1bHQ7Zm9udC1zaXplOjE0cHg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MXB4IHNvbGlkICNmZmY7Y29sb3I6I2ZmZjtwYWRkaW5nOjhweCAyNnB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RvdWNoLWFjdGlvbjptYW5pcHVsYXRpb259LmJ0bi5idG4tZ3JlZW5bZGF0YS12LTRhZTgxMDAwXXtiYWNrZ3JvdW5kLWNvbG9yOiM0ZGFmN2M7Ym9yZGVyLWNvbG9yOiM0ZGFmN2N9LmJ0bi5idG4tZ3JlZW5bZGF0YS12LTRhZTgxMDAwXTpmb2N1cywuYnRuLmJ0bi1ncmVlbltkYXRhLXYtNGFlODEwMDBdOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzNkOGM2Mztib3JkZXItY29sb3I6IzNkOGM2M30uYnRuLmJ0bi1jb250cm9sW2RhdGEtdi00YWU4MTAwMF17ZGlzcGxheTpmbGV4O2JhY2tncm91bmQ6bm9uZTt0ZXh0LXNoYWRvdzowIDAgNXB4ICMwMDA7Zm9udC1zaXplOjEuMjVyZW07cGFkZGluZzouNXJlbSAuNzVyZW07Ym9yZGVyOm5vbmU7b3V0bGluZTpub25lIWltcG9ydGFudDtvcGFjaXR5Oi44fS5idG4uYnRuLWNvbnRyb2xbZGF0YS12LTRhZTgxMDAwXTpmb2N1cywuYnRuLmJ0bi1jb250cm9sW2RhdGEtdi00YWU4MTAwMF06aG92ZXJ7b3BhY2l0eToxfWlucHV0W2RhdGEtdi00YWU4MTAwMF0sdGV4dGFyZWFbZGF0YS12LTRhZTgxMDAwXXttYXJnaW46MTBweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtwYWRkaW5nOjEwcHg7Zm9udC1zaXplOjFyZW07bGluZS1oZWlnaHQ6MS4yNTtjb2xvcjojNzA3MDcwO2JhY2tncm91bmQtY29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWltYWdlOm5vbmU7YmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JvcmRlcjoxcHggc29saWQgcmdiYSgwLDAsMCwuMTUpO3RyYW5zaXRpb246Ym9yZGVyLWNvbG9yIC4xNXMgZWFzZS1pbi1vdXQsYm94LXNoYWRvdyAuMTVzIGVhc2UtaW4tb3V0O3RvdWNoLWFjdGlvbjptYW5pcHVsYXRpb247Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtib3gtc2l6aW5nOmJvcmRlci1ib3h9aW5wdXRbZGF0YS12LTRhZTgxMDAwXTpmb2N1cyx0ZXh0YXJlYVtkYXRhLXYtNGFlODEwMDBdOmZvY3Vze2JvcmRlci1jb2xvcjojMzQ5OGRiO291dGxpbmU6bm9uZTtib3gtc2hhZG93OjAgMCA1cHggcmdiYSg1MiwxNTIsMjE5LC41KX10ZXh0YXJlYVtkYXRhLXYtNGFlODEwMDBde292ZXJmbG93OmF1dG99I2x2LXRhc2stc2lkZWJhciB1bFtkYXRhLXYtNGFlODEwMDBde292ZXJmbG93LXk6YXV0bzttaW4taGVpZ2h0OjEwMHB4O21heC1oZWlnaHQ6MzAwcHg7bGlzdC1zdHlsZTpub25lO3BhZGRpbmc6LjhyZW07bWFyZ2luOjA7Ym9yZGVyOjFweCBzb2xpZCAjNzA3MDcwfSNsdi10YXNrLXNpZGViYXIgdWwgbGlbZGF0YS12LTRhZTgxMDAwXXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWNvbnRlbnQ6Y2VudGVyfSNsdi10YXNrLXNpZGViYXIgdWwgbGlbZGF0YS12LTRhZTgxMDAwXTpub3QoOmxhc3QtY2hpbGQpe21hcmdpbi1ib3R0b206Ljc1cmVtfSNsdi10YXNrLXNpZGViYXIgaDRbZGF0YS12LTRhZTgxMDAwXXttYXJnaW46MH0jbHYtdGFzay1zaWRlYmFyIC5idG5bZGF0YS12LTRhZTgxMDAwXXt3aWR0aDoxMDAlO2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDouNnJlbX0jbHYtdGFzay1zaWRlYmFyIHN2Z1tkYXRhLXYtNGFlODEwMDBde21hcmdpbi1sZWZ0OjVweH0jbHYtdGFzay1zaWRlYmFyIGJ1dHRvbltkYXRhLXYtNGFlODEwMDBde2Rpc3BsYXk6ZmxleDttYXJnaW4tcmlnaHQ6YXV0bzttYXJnaW4tbGVmdDphdXRvfSNsdi10YXNrLXNpZGViYXIgLnNsaWRlLWVudGVyLWFjdGl2ZVtkYXRhLXYtNGFlODEwMDBdLCNsdi10YXNrLXNpZGViYXIgLnNsaWRlLWxlYXZlLWFjdGl2ZVtkYXRhLXYtNGFlODEwMDBde3RyYW5zaXRpb246MXN9I2x2LXRhc2stc2lkZWJhciAuc2xpZGUtZW50ZXJbZGF0YS12LTRhZTgxMDAwXXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwxMDAlLDApO3Zpc2liaWxpdHk6aGlkZGVufSNsdi10YXNrLXNpZGViYXIgLnNsaWRlLWxlYXZlLXRvW2RhdGEtdi00YWU4MTAwMF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTEwMCUsMCk7dmlzaWJpbGl0eTp2aXNpYmxlfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00YWU4MTAwMFwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvVGFzay52dWVcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, ".lv-sidebar[data-v-4f491fdf]{font-size:14px;color:#fff;overflow-y:auto;max-height:100%;border:2px solid #555;background-color:rgba(0,0,0,.75);margin:1rem}@media screen and (min-width:992px){.lv-sidebar[data-v-4f491fdf]{flex-direction:column}}.lv-sidebar .lv-sidebar-header[data-v-4f491fdf]{display:flex;flex-direction:row;justify-content:space-between;padding:.6rem;font-family:sans-serif;letter-spacing:1px}.lv-sidebar .lv-sidebar-header h4[data-v-4f491fdf]{text-transform:uppercase;margin:0;flex-direction:row}.lv-sidebar .lv-sidebar-content[data-v-4f491fdf]{padding:.6em}.lv-sidebar .toggle[data-v-4f491fdf]{cursor:default;background:none;border:none;color:#fff;float:right;transition:transform .5s}.lv-sidebar .toggle.active[data-v-4f491fdf]{transform:rotate(180deg)}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/OTE2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLHNEQUF1RCxlQUFlLFdBQVcsZ0JBQWdCLGdCQUFnQixzQkFBc0IsaUNBQWlDLFlBQVksb0NBQW9DLDZCQUE2Qix1QkFBdUIsZ0RBQWdELGFBQWEsbUJBQW1CLDhCQUE4QixjQUFjLHVCQUF1QixtQkFBbUIsbURBQW1ELHlCQUF5QixTQUFTLG1CQUFtQixpREFBaUQsYUFBYSxxQ0FBcUMsZUFBZSxnQkFBZ0IsWUFBWSxXQUFXLFlBQVkseUJBQXlCLDRDQUE0Qyx5QkFBeUI7O0FBRTd4QiIsImZpbGUiOiI5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5sdi1zaWRlYmFyW2RhdGEtdi00ZjQ5MWZkZl17Zm9udC1zaXplOjE0cHg7Y29sb3I6I2ZmZjtvdmVyZmxvdy15OmF1dG87bWF4LWhlaWdodDoxMDAlO2JvcmRlcjoycHggc29saWQgIzU1NTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjc1KTttYXJnaW46MXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjk5MnB4KXsubHYtc2lkZWJhcltkYXRhLXYtNGY0OTFmZGZde2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn19Lmx2LXNpZGViYXIgLmx2LXNpZGViYXItaGVhZGVyW2RhdGEtdi00ZjQ5MWZkZl17ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdztqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtwYWRkaW5nOi42cmVtO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7bGV0dGVyLXNwYWNpbmc6MXB4fS5sdi1zaWRlYmFyIC5sdi1zaWRlYmFyLWhlYWRlciBoNFtkYXRhLXYtNGY0OTFmZGZde3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZTttYXJnaW46MDtmbGV4LWRpcmVjdGlvbjpyb3d9Lmx2LXNpZGViYXIgLmx2LXNpZGViYXItY29udGVudFtkYXRhLXYtNGY0OTFmZGZde3BhZGRpbmc6LjZlbX0ubHYtc2lkZWJhciAudG9nZ2xlW2RhdGEtdi00ZjQ5MWZkZl17Y3Vyc29yOmRlZmF1bHQ7YmFja2dyb3VuZDpub25lO2JvcmRlcjpub25lO2NvbG9yOiNmZmY7ZmxvYXQ6cmlnaHQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzfS5sdi1zaWRlYmFyIC50b2dnbGUuYWN0aXZlW2RhdGEtdi00ZjQ5MWZkZl17dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00ZjQ5MWZkZlwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWVcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, ".btn[data-v-76bf11a1]{cursor:default;font-size:14px;background-color:transparent;border:1px solid #fff;color:#fff;padding:8px 26px;text-align:center;text-decoration:none;display:inline-block;touch-action:manipulation}.btn.btn-green[data-v-76bf11a1]{background-color:#4daf7c;border-color:#4daf7c}.btn.btn-green[data-v-76bf11a1]:focus,.btn.btn-green[data-v-76bf11a1]:hover{background-color:#3d8c63;border-color:#3d8c63}.btn.btn-control[data-v-76bf11a1]{display:flex;background:none;text-shadow:0 0 5px #000;font-size:1.25rem;padding:.5rem .75rem;border:none;outline:none!important;opacity:.8}.btn.btn-control[data-v-76bf11a1]:focus,.btn.btn-control[data-v-76bf11a1]:hover{opacity:1}#lv-selection-sidebar ul[data-v-76bf11a1]{margin:0;overflow-y:auto;min-height:100px;max-height:250px;list-style:none;padding:0;border:1px solid #707070}#lv-selection-sidebar ul li[data-v-76bf11a1]{padding:.8rem;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #303030}#lv-selection-sidebar .buttons[data-v-76bf11a1]{justify-content:flex-end;display:flex;flex:0 0 33.3333%}#lv-selection-sidebar button[data-v-76bf11a1]{display:flex;margin-right:auto;margin-left:auto}#lv-selection-sidebar .thumbnail-container[data-v-76bf11a1]{align-items:center;justify-content:center;display:flex;flex:1 1 auto;height:50px}#lv-selection-sidebar .thumbnail-container img[data-v-76bf11a1]{max-width:100%;max-height:100%}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT8zZGE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsK0NBQWdELGVBQWUsZUFBZSw2QkFBNkIsc0JBQXNCLFdBQVcsaUJBQWlCLGtCQUFrQixxQkFBcUIscUJBQXFCLDBCQUEwQixnQ0FBZ0MseUJBQXlCLHFCQUFxQiw0RUFBNEUseUJBQXlCLHFCQUFxQixrQ0FBa0MsYUFBYSxnQkFBZ0IseUJBQXlCLGtCQUFrQixxQkFBcUIsWUFBWSx1QkFBdUIsV0FBVyxnRkFBZ0YsVUFBVSwwQ0FBMEMsU0FBUyxnQkFBZ0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsVUFBVSx5QkFBeUIsNkNBQTZDLGNBQWMsYUFBYSxtQkFBbUIsbUJBQW1CLDhCQUE4QixnQ0FBZ0MsZ0RBQWdELHlCQUF5QixhQUFhLGtCQUFrQiw4Q0FBOEMsYUFBYSxrQkFBa0IsaUJBQWlCLDREQUE0RCxtQkFBbUIsdUJBQXVCLGFBQWEsY0FBYyxZQUFZLGdFQUFnRSxlQUFlLGdCQUFnQjs7QUFFeDdDIiwiZmlsZSI6Ijk5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmJ0bltkYXRhLXYtNzZiZjExYTFde2N1cnNvcjpkZWZhdWx0O2ZvbnQtc2l6ZToxNHB4O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjFweCBzb2xpZCAjZmZmO2NvbG9yOiNmZmY7cGFkZGluZzo4cHggMjZweDt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jazt0b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9ufS5idG4uYnRuLWdyZWVuW2RhdGEtdi03NmJmMTFhMV17YmFja2dyb3VuZC1jb2xvcjojNGRhZjdjO2JvcmRlci1jb2xvcjojNGRhZjdjfS5idG4uYnRuLWdyZWVuW2RhdGEtdi03NmJmMTFhMV06Zm9jdXMsLmJ0bi5idG4tZ3JlZW5bZGF0YS12LTc2YmYxMWExXTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMzZDhjNjM7Ym9yZGVyLWNvbG9yOiMzZDhjNjN9LmJ0bi5idG4tY29udHJvbFtkYXRhLXYtNzZiZjExYTFde2Rpc3BsYXk6ZmxleDtiYWNrZ3JvdW5kOm5vbmU7dGV4dC1zaGFkb3c6MCAwIDVweCAjMDAwO2ZvbnQtc2l6ZToxLjI1cmVtO3BhZGRpbmc6LjVyZW0gLjc1cmVtO2JvcmRlcjpub25lO291dGxpbmU6bm9uZSFpbXBvcnRhbnQ7b3BhY2l0eTouOH0uYnRuLmJ0bi1jb250cm9sW2RhdGEtdi03NmJmMTFhMV06Zm9jdXMsLmJ0bi5idG4tY29udHJvbFtkYXRhLXYtNzZiZjExYTFdOmhvdmVye29wYWNpdHk6MX0jbHYtc2VsZWN0aW9uLXNpZGViYXIgdWxbZGF0YS12LTc2YmYxMWExXXttYXJnaW46MDtvdmVyZmxvdy15OmF1dG87bWluLWhlaWdodDoxMDBweDttYXgtaGVpZ2h0OjI1MHB4O2xpc3Qtc3R5bGU6bm9uZTtwYWRkaW5nOjA7Ym9yZGVyOjFweCBzb2xpZCAjNzA3MDcwfSNsdi1zZWxlY3Rpb24tc2lkZWJhciB1bCBsaVtkYXRhLXYtNzZiZjExYTFde3BhZGRpbmc6LjhyZW07ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdzthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47Ym9yZGVyLWJvdHRvbToxcHggc29saWQgIzMwMzAzMH0jbHYtc2VsZWN0aW9uLXNpZGViYXIgLmJ1dHRvbnNbZGF0YS12LTc2YmYxMWExXXtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7ZGlzcGxheTpmbGV4O2ZsZXg6MCAwIDMzLjMzMzMlfSNsdi1zZWxlY3Rpb24tc2lkZWJhciBidXR0b25bZGF0YS12LTc2YmYxMWExXXtkaXNwbGF5OmZsZXg7bWFyZ2luLXJpZ2h0OmF1dG87bWFyZ2luLWxlZnQ6YXV0b30jbHYtc2VsZWN0aW9uLXNpZGViYXIgLnRodW1ibmFpbC1jb250YWluZXJbZGF0YS12LTc2YmYxMWExXXthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleDoxIDEgYXV0bztoZWlnaHQ6NTBweH0jbHYtc2VsZWN0aW9uLXNpZGViYXIgLnRodW1ibmFpbC1jb250YWluZXIgaW1nW2RhdGEtdi03NmJmMTFhMV17bWF4LXdpZHRoOjEwMCU7bWF4LWhlaWdodDoxMDAlfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi03NmJmMTFhMVwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, "#lv-help-modal ul[data-v-8890bee6]{padding-left:0;list-style:none}#lv-help-modal li[data-v-8890bee6]{margin:0}#lv-help-modal svg[data-v-8890bee6]{margin-right:8px}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL0hlbHAudnVlPzA4N2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSw0REFBNkQsZUFBZSxnQkFBZ0IsbUNBQW1DLFNBQVMsb0NBQW9DLGlCQUFpQjs7QUFFN0wiLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiI2x2LWhlbHAtbW9kYWwgdWxbZGF0YS12LTg4OTBiZWU2XXtwYWRkaW5nLWxlZnQ6MDtsaXN0LXN0eWxlOm5vbmV9I2x2LWhlbHAtbW9kYWwgbGlbZGF0YS12LTg4OTBiZWU2XXttYXJnaW46MH0jbHYtaGVscC1tb2RhbCBzdmdbZGF0YS12LTg4OTBiZWU2XXttYXJnaW4tcmlnaHQ6OHB4fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi04ODkwYmVlNlwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL0hlbHAudnVlXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, "#lv-viewer{display:flex;flex-direction:column;width:auto;background-color:#000;overflow:hidden}#lv-viewer,#lv-viewer-container{height:100%}#lv-sidebars{position:fixed;z-index:2;right:0;width:35%;margin:.8rem;overflow:hidden;max-width:350px}.openseadragon-container{height:100vh;min-height:600px}.openseadragon-container .openseadragon-message{color:#fff}.openseadragon-container .selection-box{transform:none!important;z-index:10;outline:9999px solid rgba(0,0,0,.6)}.openseadragon-container .selection-box .selection-btn{color:#fff;display:flex!important;position:absolute!important;right:0}.openseadragon-container .selection-box .selection-btn#confirm-selection{bottom:0;transform:translateX(20px) translateY(15px)}.openseadragon-container .selection-box .selection-btn#cancel-selection{top:0;transform:translateX(20px) translateY(-15px)}.openseadragon-container .overlay{z-index:5}.openseadragon-container .overlay.selection{border:2px solid #3498db;background-color:rgba(52,152,219,.2);opacity:.6}.openseadragon-container .overlay.highlight{border-color:#4daf7c;background-color:rgba(77,175,124,.2)}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT9iMTU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0Esb0NBQXFDLGFBQWEsc0JBQXNCLFdBQVcsc0JBQXNCLGdCQUFnQixnQ0FBZ0MsWUFBWSxhQUFhLGVBQWUsVUFBVSxRQUFRLFVBQVUsYUFBYSxnQkFBZ0IsZ0JBQWdCLHlCQUF5QixhQUFhLGlCQUFpQixnREFBZ0QsV0FBVyx3Q0FBd0MseUJBQXlCLFdBQVcsb0NBQW9DLHVEQUF1RCxXQUFXLHVCQUF1Qiw0QkFBNEIsUUFBUSx5RUFBeUUsU0FBUyw0Q0FBNEMsd0VBQXdFLE1BQU0sNkNBQTZDLGtDQUFrQyxVQUFVLDRDQUE0Qyx5QkFBeUIscUNBQXFDLFdBQVcsNENBQTRDLHFCQUFxQixxQ0FBcUM7O0FBRXptQyIsImZpbGUiOiIxMDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjbHYtdmlld2Vye2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6YXV0bztiYWNrZ3JvdW5kLWNvbG9yOiMwMDA7b3ZlcmZsb3c6aGlkZGVufSNsdi12aWV3ZXIsI2x2LXZpZXdlci1jb250YWluZXJ7aGVpZ2h0OjEwMCV9I2x2LXNpZGViYXJze3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MjtyaWdodDowO3dpZHRoOjM1JTttYXJnaW46LjhyZW07b3ZlcmZsb3c6aGlkZGVuO21heC13aWR0aDozNTBweH0ub3BlbnNlYWRyYWdvbi1jb250YWluZXJ7aGVpZ2h0OjEwMHZoO21pbi1oZWlnaHQ6NjAwcHh9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC5vcGVuc2VhZHJhZ29uLW1lc3NhZ2V7Y29sb3I6I2ZmZn0ub3BlbnNlYWRyYWdvbi1jb250YWluZXIgLnNlbGVjdGlvbi1ib3h7dHJhbnNmb3JtOm5vbmUhaW1wb3J0YW50O3otaW5kZXg6MTA7b3V0bGluZTo5OTk5cHggc29saWQgcmdiYSgwLDAsMCwuNil9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC5zZWxlY3Rpb24tYm94IC5zZWxlY3Rpb24tYnRue2NvbG9yOiNmZmY7ZGlzcGxheTpmbGV4IWltcG9ydGFudDtwb3NpdGlvbjphYnNvbHV0ZSFpbXBvcnRhbnQ7cmlnaHQ6MH0ub3BlbnNlYWRyYWdvbi1jb250YWluZXIgLnNlbGVjdGlvbi1ib3ggLnNlbGVjdGlvbi1idG4jY29uZmlybS1zZWxlY3Rpb257Ym90dG9tOjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjBweCkgdHJhbnNsYXRlWSgxNXB4KX0ub3BlbnNlYWRyYWdvbi1jb250YWluZXIgLnNlbGVjdGlvbi1ib3ggLnNlbGVjdGlvbi1idG4jY2FuY2VsLXNlbGVjdGlvbnt0b3A6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWCgyMHB4KSB0cmFuc2xhdGVZKC0xNXB4KX0ub3BlbnNlYWRyYWdvbi1jb250YWluZXIgLm92ZXJsYXl7ei1pbmRleDo1fS5vcGVuc2VhZHJhZ29uLWNvbnRhaW5lciAub3ZlcmxheS5zZWxlY3Rpb257Ym9yZGVyOjJweCBzb2xpZCAjMzQ5OGRiO2JhY2tncm91bmQtY29sb3I6cmdiYSg1MiwxNTIsMjE5LC4yKTtvcGFjaXR5Oi42fS5vcGVuc2VhZHJhZ29uLWNvbnRhaW5lciAub3ZlcmxheS5oaWdobGlnaHR7Ym9yZGVyLWNvbG9yOiM0ZGFmN2M7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDc3LDE3NSwxMjQsLjIpfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1hYWQ0MWI0MlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL1ZpZXdlci52dWVcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, "#lv-metadata-modal ul[data-v-ef9c290a]{padding-left:0;list-style:none}#lv-metadata-modal #rights[data-v-ef9c290a]{text-align:center;margin:2rem}#lv-metadata-modal li[data-v-ef9c290a]{margin:0}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL01ldGFkYXRhLnZ1ZT9mZDE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsZ0VBQWlFLGVBQWUsZ0JBQWdCLDRDQUE0QyxrQkFBa0IsWUFBWSx1Q0FBdUMsU0FBUzs7QUFFMU4iLCJmaWxlIjoiMTAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiI2x2LW1ldGFkYXRhLW1vZGFsIHVsW2RhdGEtdi1lZjljMjkwYV17cGFkZGluZy1sZWZ0OjA7bGlzdC1zdHlsZTpub25lfSNsdi1tZXRhZGF0YS1tb2RhbCAjcmlnaHRzW2RhdGEtdi1lZjljMjkwYV17dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luOjJyZW19I2x2LW1ldGFkYXRhLW1vZGFsIGxpW2RhdGEtdi1lZjljMjkwYV17bWFyZ2luOjB9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWVmOWMyOTBhXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tb2RhbHMvTWV0YWRhdGEudnVlXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.i, ".fa-icon{display:inline-block;fill:currentColor}.fa-flip-horizontal{transform:scaleX(-1)}.fa-flip-vertical{transform:scaleY(-1)}.fa-spin{animation:fa-spin 1s 0s infinite linear}.fa-inverse{color:#fff}@keyframes fa-spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlP2MxZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxrQ0FBbUMscUJBQXFCLGtCQUFrQixvQkFBb0IscUJBQXFCLGtCQUFrQixxQkFBcUIsU0FBUyx3Q0FBd0MsWUFBWSxXQUFXLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5Qjs7QUFFM1MiLCJmaWxlIjoiMTAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZmEtaWNvbntkaXNwbGF5OmlubGluZS1ibG9jaztmaWxsOmN1cnJlbnRDb2xvcn0uZmEtZmxpcC1ob3Jpem9udGFse3RyYW5zZm9ybTpzY2FsZVgoLTEpfS5mYS1mbGlwLXZlcnRpY2Fse3RyYW5zZm9ybTpzY2FsZVkoLTEpfS5mYS1zcGlue2FuaW1hdGlvbjpmYS1zcGluIDFzIDBzIGluZmluaXRlIGxpbmVhcn0uZmEtaW52ZXJzZXtjb2xvcjojZmZmfUBrZXlmcmFtZXMgZmEtc3BpbnswJXt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfXRve3RyYW5zZm9ybTpyb3RhdGUoMXR1cm4pfX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/bWluaW1pemUhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDY2NTk3MGJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL34vdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9pcy1idWZmZXIvaW5kZXguanM/NzQ1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTA0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9pcy1idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;//! openseadragon 2.2.1\n//! Built on 2016-07-01\n//! Git commit: v2.2.1-0-babdefd\n//! http://openseadragon.github.io\n//! License: http://openseadragon.github.io/license/\n\n/*\n * OpenSeadragon\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Portions of this source file taken from jQuery:\n *\n * Copyright 2011 John Resig\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * "Software"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*\n * Portions of this source file taken from mattsnider.com:\n *\n * Copyright (c) 2006-2013 Matt Snider\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n/**\n * @namespace OpenSeadragon\n * @version openseadragon 2.2.1\n * @classdesc The root namespace for OpenSeadragon.  All utility methods\n * and classes are defined on or below this namespace.\n *\n */\n\n\n// Typedefs\n\n /**\n  * All required and optional settings for instantiating a new instance of an OpenSeadragon image viewer.\n  *\n  * @typedef {Object} Options\n  * @memberof OpenSeadragon\n  *\n  * @property {String} id\n  *     Id of the element to append the viewer\'s container element to. If not provided, the \'element\' property must be provided.\n  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.\n  *\n  * @property {Element} element\n  *     The element to append the viewer\'s container element to. If not provided, the \'id\' property must be provided.\n  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.\n  *\n  * @property {Array|String|Function|Object} [tileSources=null]\n  *     Tile source(s) to open initially. This is a complex parameter; see\n  *     {@link OpenSeadragon.Viewer#open} for details.\n  *\n  * @property {Number} [tabIndex=0]\n  *     Tabbing order index to assign to the viewer element. Positive values are selected in increasing order. When tabIndex is 0\n  *     source order is used. A negative value omits the viewer from the tabbing order.\n  *\n  * @property {Array} overlays Array of objects defining permanent overlays of\n  *     the viewer. The overlays added via this option and later removed with\n  *     {@link OpenSeadragon.Viewer#removeOverlay} will be added back when a new\n  *     image is opened.\n  *     To add overlays which can be definitively removed, one must use\n  *     {@link OpenSeadragon.Viewer#addOverlay}\n  *     If displaying a sequence of images, the overlays can be associated\n  *     with a specific page by passing the overlays array to the page\'s\n  *     tile source configuration.\n  *     Expected properties:\n  *     * x, y, (or px, py for pixel coordinates) to define the location.\n  *     * width, height in point if using x,y or in pixels if using px,py. If width\n  *       and height are specified, the overlay size is adjusted when zooming,\n  *       otherwise the size stays the size of the content (or the size defined by CSS).\n  *     * className to associate a class to the overlay\n  *     * id to set the overlay element. If an element with this id already exists,\n  *       it is reused, otherwise it is created. If not specified, a new element is\n  *       created.\n  *     * placement a string to define the relative position to the viewport.\n  *       Only used if no width and height are specified. Default: \'TOP_LEFT\'.\n  *       See {@link OpenSeadragon.Placement} for possible values.\n  *\n  * @property {String} [xmlPath=null]\n  *     <strong>DEPRECATED</strong>. A relative path to load a DZI file from the server.\n  *     Prefer the newer Options.tileSources.\n  *\n  * @property {String} [prefixUrl=\'/images/\']\n  *     Prepends the prefixUrl to navImages paths, which is very useful\n  *     since the default paths are rarely useful for production\n  *     environments.\n  *\n  * @property {OpenSeadragon.NavImages} [navImages]\n  *     An object with a property for each button or other built-in navigation\n  *     control, eg the current \'zoomIn\', \'zoomOut\', \'home\', and \'fullpage\'.\n  *     Each of those in turn provides an image path for each state of the button\n  *     or navigation control, eg \'REST\', \'GROUP\', \'HOVER\', \'PRESS\'. Finally the\n  *     image paths, by default assume there is a folder on the servers root path\n  *     called \'/images\', eg \'/images/zoomin_rest.png\'.  If you need to adjust\n  *     these paths, prefer setting the option.prefixUrl rather than overriding\n  *     every image path directly through this setting.\n  *\n  * @property {Boolean} [debugMode=false]\n  *     TODO: provide an in-screen panel providing event detail feedback.\n  *\n  * @property {String} [debugGridColor=\'#437AB2\']\n  *\n  * @property {Number} [blendTime=0]\n  *     Specifies the duration of animation as higher or lower level tiles are\n  *     replacing the existing tile.\n  *\n  * @property {Boolean} [alwaysBlend=false]\n  *     Forces the tile to always blend.  By default the tiles skip blending\n  *     when the blendTime is surpassed and the current animation frame would\n  *     not complete the blend.\n  *\n  * @property {Boolean} [autoHideControls=true]\n  *     If the user stops interacting with the viewport, fade the navigation\n  *     controls.  Useful for presentation since the controls are by default\n  *     floated on top of the image the user is viewing.\n  *\n  * @property {Boolean} [immediateRender=false]\n  *     Render the best closest level first, ignoring the lowering levels which\n  *     provide the effect of very blurry to sharp. It is recommended to change\n  *     setting to true for mobile devices.\n  *\n  * @property {Number} [defaultZoomLevel=0]\n  *     Zoom level to use when image is first opened or the home button is clicked.\n  *     If 0, adjusts to fit viewer.\n  *\n  * @property {Number} [opacity=1]\n  *     Default opacity of the tiled images (1=opaque, 0=transparent)\n  *\n  * @property {String} [compositeOperation=null]\n  *     Valid values are \'source-over\', \'source-atop\', \'source-in\', \'source-out\',\n  *     \'destination-over\', \'destination-atop\', \'destination-in\',\n  *     \'destination-out\', \'lighter\', \'copy\' or \'xor\'\n  *\n  * @property {String|CanvasGradient|CanvasPattern|Function} [placeholderFillStyle=null]\n  *     Draws a colored rectangle behind the tile if it is not loaded yet.\n  *     You can pass a CSS color value like "#FF8800".\n  *     When passing a function the tiledImage and canvas context are available as argument which is useful when you draw a gradient or pattern.\n  *\n  * @property {Number} [degrees=0]\n  *     Initial rotation.\n  *\n  * @property {Number} [minZoomLevel=null]\n  *\n  * @property {Number} [maxZoomLevel=null]\n  *\n  * @property {Boolean} [homeFillsViewer=false]\n  *     Make the \'home\' button fill the viewer and clip the image, instead\n  *     of fitting the image to the viewer and letterboxing.\n  *\n  * @property {Boolean} [panHorizontal=true]\n  *     Allow horizontal pan.\n  *\n  * @property {Boolean} [panVertical=true]\n  *     Allow vertical pan.\n  *\n  * @property {Boolean} [constrainDuringPan=false]\n  *\n  * @property {Boolean} [wrapHorizontal=false]\n  *     Set to true to force the image to wrap horizontally within the viewport.\n  *     Useful for maps or images representing the surface of a sphere or cylinder.\n  *\n  * @property {Boolean} [wrapVertical=false]\n  *     Set to true to force the image to wrap vertically within the viewport.\n  *     Useful for maps or images representing the surface of a sphere or cylinder.\n  *\n  * @property {Number} [minZoomImageRatio=0.9]\n  *     The minimum percentage ( expressed as a number between 0 and 1 ) of\n  *     the viewport height or width at which the zoom out will be constrained.\n  *     Setting it to 0, for example will allow you to zoom out infinity.\n  *\n  * @property {Number} [maxZoomPixelRatio=1.1]\n  *     The maximum ratio to allow a zoom-in to affect the highest level pixel\n  *     ratio. This can be set to Infinity to allow \'infinite\' zooming into the\n  *     image though it is less effective visually if the HTML5 Canvas is not\n  *     availble on the viewing device.\n  *\n  * @property {Number} [smoothTileEdgesMinZoom=1.1]\n  *     A zoom percentage ( where 1 is 100% ) of the highest resolution level.\n  *     When zoomed in beyond this value alternative compositing will be used to\n  *     smooth out the edges between tiles. This will have a performance impact.\n  *     Can be set to Infinity to turn it off.\n  *     Note: This setting is ignored on iOS devices due to a known bug (See {@link https://github.com/openseadragon/openseadragon/issues/952})\n  *\n  * @property {Boolean} [iOSDevice=?]\n  *     True if running on an iOS device, false otherwise.\n  *     Used to disable certain features that behave differently on iOS devices.\n  *\n  * @property {Boolean} [autoResize=true]\n  *     Set to false to prevent polling for viewer size changes. Useful for providing custom resize behavior.\n  *\n  * @property {Boolean} [preserveImageSizeOnResize=false]\n  *     Set to true to have the image size preserved when the viewer is resized. This requires autoResize=true (default).\n  *\n  * @property {Number} [minScrollDeltaTime=50]\n  *     Number of milliseconds between canvas-scroll events. This value helps normalize the rate of canvas-scroll\n  *     events between different devices, causing the faster devices to slow down enough to make the zoom control\n  *     more manageable.\n  *\n  * @property {Number} [pixelsPerWheelLine=40]\n  *     For pixel-resolution scrolling devices, the number of pixels equal to one scroll line.\n  *\n  * @property {Number} [visibilityRatio=0.5]\n  *     The percentage ( as a number from 0 to 1 ) of the source image which\n  *     must be kept within the viewport.  If the image is dragged beyond that\n  *     limit, it will \'bounce\' back until the minimum visibility ratio is\n  *     achieved.  Setting this to 0 and wrapHorizontal ( or wrapVertical ) to\n  *     true will provide the effect of an infinitely scrolling viewport.\n  *\n  * @property {Object} [viewportMargins={}]\n  *     Pushes the "home" region in from the sides by the specified amounts.\n  *     Possible subproperties (Numbers, in screen coordinates): left, top, right, bottom.\n  *\n  * @property {Number} [imageLoaderLimit=0]\n  *     The maximum number of image requests to make concurrently. By default\n  *     it is set to 0 allowing the browser to make the maximum number of\n  *     image requests in parallel as allowed by the browsers policy.\n  *\n  * @property {Number} [clickTimeThreshold=300]\n  *      The number of milliseconds within which a pointer down-up event combination\n  *      will be treated as a click gesture.\n  *\n  * @property {Number} [clickDistThreshold=5]\n  *      The maximum distance allowed between a pointer down event and a pointer up event\n  *      to be treated as a click gesture.\n  *\n  * @property {Number} [dblClickTimeThreshold=300]\n  *      The number of milliseconds within which two pointer down-up event combinations\n  *      will be treated as a double-click gesture.\n  *\n  * @property {Number} [dblClickDistThreshold=20]\n  *      The maximum distance allowed between two pointer click events\n  *      to be treated as a double-click gesture.\n  *\n  * @property {Number} [springStiffness=6.5]\n  *\n  * @property {Number} [animationTime=1.2]\n  *     Specifies the animation duration per each {@link OpenSeadragon.Spring}\n  *     which occur when the image is dragged or zoomed.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsMouse]\n  *     Settings for gestures generated by a mouse pointer device. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsMouse.scrollToZoom=true] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsMouse.clickToZoom=true] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsMouse.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsMouse.pinchToZoom=false] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsMouse.flickEnabled=false] - Enable flick gesture\n  * @property {Number} [gestureSettingsMouse.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsMouse.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsMouse.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsTouch]\n  *     Settings for gestures generated by a touch pointer device. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsTouch.scrollToZoom=false] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsTouch.clickToZoom=false] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsTouch.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsTouch.pinchToZoom=true] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsTouch.flickEnabled=true] - Enable flick gesture\n  * @property {Number} [gestureSettingsTouch.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsTouch.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsTouch.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsPen]\n  *     Settings for gestures generated by a pen pointer device. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsPen.scrollToZoom=false] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsPen.clickToZoom=true] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsPen.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsPen.pinchToZoom=false] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsPen.flickEnabled=false] - Enable flick gesture\n  * @property {Number} [gestureSettingsPen.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsPen.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsPen.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsUnknown]\n  *     Settings for gestures generated by unknown pointer devices. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsUnknown.scrollToZoom=true] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsUnknown.clickToZoom=false] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsUnknown.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsUnknown.pinchToZoom=true] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsUnknown.flickEnabled=true] - Enable flick gesture\n  * @property {Number} [gestureSettingsUnknown.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsUnknown.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsUnknown.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {Number} [zoomPerClick=2.0]\n  *     The "zoom distance" per mouse click or touch tap. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the click-to-zoom feature (also see gestureSettings[Mouse|Touch|Pen].clickToZoom/dblClickToZoom).</em>\n  *\n  * @property {Number} [zoomPerScroll=1.2]\n  *     The "zoom distance" per mouse scroll or touch pinch. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the mouse-wheel zoom feature (also see gestureSettings[Mouse|Touch|Pen].scrollToZoom}).</em>\n  *\n  * @property {Number} [zoomPerSecond=1.0]\n  *     The number of seconds to animate a single zoom event over.\n  *\n  * @property {Boolean} [showNavigator=false]\n  *     Set to true to make the navigator minimap appear.\n  *\n  * @property {String} [navigatorId=navigator-GENERATED DATE]\n  *     The ID of a div to hold the navigator minimap.\n  *     If an ID is specified, the navigatorPosition, navigatorSizeRatio, navigatorMaintainSizeRatio, navigator[Top|Left|Height|Width] and navigatorAutoFade options will be ignored.\n  *     If an ID is not specified, a div element will be generated and placed on top of the main image.\n  *\n  * @property {String} [navigatorPosition=\'TOP_RIGHT\']\n  *     Valid values are \'TOP_LEFT\', \'TOP_RIGHT\', \'BOTTOM_LEFT\', \'BOTTOM_RIGHT\', or \'ABSOLUTE\'.<br>\n  *     If \'ABSOLUTE\' is specified, then navigator[Top|Left|Height|Width] determines the size and position of the navigator minimap in the viewer, and navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.<br>\n  *     For \'TOP_LEFT\', \'TOP_RIGHT\', \'BOTTOM_LEFT\', and \'BOTTOM_RIGHT\', the navigatorSizeRatio or navigator[Height|Width] values determine the size of the navigator minimap.\n  *\n  * @property {Number} [navigatorSizeRatio=0.2]\n  *     Ratio of navigator size to viewer size. Ignored if navigator[Height|Width] are specified.\n  *\n  * @property {Boolean} [navigatorMaintainSizeRatio=false]\n  *     If true, the navigator minimap is resized (using navigatorSizeRatio) when the viewer size changes.\n  *\n  * @property {Number|String} [navigatorTop=null]\n  *     Specifies the location of the navigator minimap (see navigatorPosition).\n  *\n  * @property {Number|String} [navigatorLeft=null]\n  *     Specifies the location of the navigator minimap (see navigatorPosition).\n  *\n  * @property {Number|String} [navigatorHeight=null]\n  *     Specifies the size of the navigator minimap (see navigatorPosition).\n  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.\n  *\n  * @property {Number|String} [navigatorWidth=null]\n  *     Specifies the size of the navigator minimap (see navigatorPosition).\n  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.\n  *\n  * @property {Boolean} [navigatorAutoResize=true]\n  *     Set to false to prevent polling for navigator size changes. Useful for providing custom resize behavior.\n  *     Setting to false can also improve performance when the navigator is configured to a fixed size.\n  *\n  * @property {Boolean} [navigatorAutoFade=true]\n  *     If the user stops interacting with the viewport, fade the navigator minimap.\n  *     Setting to false will make the navigator minimap always visible.\n  *\n  * @property {Boolean} [navigatorRotate=true]\n  *     If true, the navigator will be rotated together with the viewer.\n  *\n  * @property {Number} [controlsFadeDelay=2000]\n  *     The number of milliseconds to wait once the user has stopped interacting\n  *     with the interface before begining to fade the controls. Assumes\n  *     showNavigationControl and autoHideControls are both true.\n  *\n  * @property {Number} [controlsFadeLength=1500]\n  *     The number of milliseconds to animate the controls fading out.\n  *\n  * @property {Number} [maxImageCacheCount=200]\n  *     The max number of images we should keep in memory (per drawer).\n  *\n  * @property {Number} [timeout=30000]\n  *\n  * @property {Boolean} [useCanvas=true]\n  *     Set to false to not use an HTML canvas element for image rendering even if canvas is supported.\n  *\n  * @property {Number} [minPixelRatio=0.5]\n  *     The higher the minPixelRatio, the lower the quality of the image that\n  *     is considered sufficient to stop rendering a given zoom level.  For\n  *     example, if you are targeting mobile devices with less bandwith you may\n  *     try setting this to 1.5 or higher.\n  *\n  * @property {Boolean} [mouseNavEnabled=true]\n  *     Is the user able to interact with the image via mouse or touch. Default\n  *     interactions include draging the image in a plane, and zooming in toward\n  *     and away from the image.\n  *\n  * @property {Boolean} [showNavigationControl=true]\n  *     Set to false to prevent the appearance of the default navigation controls.<br>\n  *     Note that if set to false, the customs buttons set by the options\n  *     zoomInButton, zoomOutButton etc, are rendered inactive.\n  *\n  * @property {OpenSeadragon.ControlAnchor} [navigationControlAnchor=TOP_LEFT]\n  *     Placement of the default navigation controls.\n  *     To set the placement of the sequence controls, see the\n  *     sequenceControlAnchor option.\n  *\n  * @property {Boolean} [showZoomControl=true]\n  *     If true then + and - buttons to zoom in and out are displayed.<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showHomeControl=true]\n  *     If true then the \'Go home\' button is displayed to go back to the original\n  *     zoom and pan.<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showFullPageControl=true]\n  *     If true then the \'Toggle full page\' button is displayed to switch\n  *     between full page and normal mode.<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showRotationControl=false]\n  *     If true then the rotate left/right controls will be displayed as part of the\n  *     standard controls. This is also subject to the browser support for rotate\n  *     (e.g. viewer.drawer.canRotate()).<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showSequenceControl=true]\n  *     If sequenceMode is true, then provide buttons for navigating forward and\n  *     backward through the images.\n  *\n  * @property {OpenSeadragon.ControlAnchor} [sequenceControlAnchor=TOP_LEFT]\n  *     Placement of the default sequence controls.\n  *\n  * @property {Boolean} [navPrevNextWrap=false]\n  *     If true then the \'previous\' button will wrap to the last image when\n  *     viewing the first image and the \'next\' button will wrap to the first\n  *     image when viewing the last image.\n  *\n  * @property {String} zoomInButton\n  *     Set the id of the custom \'Zoom in\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} zoomOutButton\n  *     Set the id of the custom \'Zoom out\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} homeButton\n  *     Set the id of the custom \'Go home\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} fullPageButton\n  *     Set the id of the custom \'Toggle full page\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} rotateLeftButton\n  *     Set the id of the custom \'Rotate left\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} rotateRightButton\n  *     Set the id of the custom \'Rotate right\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} previousButton\n  *     Set the id of the custom \'Previous page\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} nextButton\n  *     Set the id of the custom \'Next page\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {Boolean} [sequenceMode=false]\n  *     Set to true to have the viewer treat your tilesources as a sequence of images to\n  *     be opened one at a time rather than all at once.\n  *\n  * @property {Number} [initialPage=0]\n  *     If sequenceMode is true, display this page initially.\n  *\n  * @property {Boolean} [preserveViewport=false]\n  *     If sequenceMode is true, then normally navigating through each image resets the\n  *     viewport to \'home\' position.  If preserveViewport is set to true, then the viewport\n  *     position is preserved when navigating between images in the sequence.\n  *\n  * @property {Boolean} [preserveOverlays=false]\n  *     If sequenceMode is true, then normally navigating through each image\n  *     resets the overlays.\n  *     If preserveOverlays is set to true, then the overlays added with {@link OpenSeadragon.Viewer#addOverlay}\n  *     are preserved when navigating between images in the sequence.\n  *     Note: setting preserveOverlays overrides any overlays specified in the global\n  *     "overlays" option for the Viewer. It\'s also not compatible with specifying\n  *     per-tileSource overlays via the options, as those overlays will persist\n  *     even after the tileSource is closed.\n  *\n  * @property {Boolean} [showReferenceStrip=false]\n  *     If sequenceMode is true, then display a scrolling strip of image thumbnails for\n  *     navigating through the images.\n  *\n  * @property {String} [referenceStripScroll=\'horizontal\']\n  *\n  * @property {Element} [referenceStripElement=null]\n  *\n  * @property {Number} [referenceStripHeight=null]\n  *\n  * @property {Number} [referenceStripWidth=null]\n  *\n  * @property {String} [referenceStripPosition=\'BOTTOM_LEFT\']\n  *\n  * @property {Number} [referenceStripSizeRatio=0.2]\n  *\n  * @property {Boolean} [collectionMode=false]\n  *     Set to true to have the viewer arrange your TiledImages in a grid or line.\n  *\n  * @property {Number} [collectionRows=3]\n  *     If collectionMode is true, specifies how many rows the grid should have. Use 1 to make a line.\n  *     If collectionLayout is \'vertical\', specifies how many columns instead.\n  *\n  * @property {Number} [collectionColumns=0]\n  *     If collectionMode is true, specifies how many columns the grid should have. Use 1 to make a line.\n  *     If collectionLayout is \'vertical\', specifies how many rows instead. Ignored if collectionRows is not set to a falsy value.\n  *\n  * @property {String} [collectionLayout=\'horizontal\']\n  *     If collectionMode is true, specifies whether to arrange vertically or horizontally.\n  *\n  * @property {Number} [collectionTileSize=800]\n  *     If collectionMode is true, specifies the size, in viewport coordinates, for each TiledImage to fit into.\n  *     The TiledImage will be centered within a square of the specified size.\n  *\n  * @property {Number} [collectionTileMargin=80]\n  *     If collectionMode is true, specifies the margin, in viewport coordinates, between each TiledImage.\n  *\n  * @property {String|Boolean} [crossOriginPolicy=false]\n  *     Valid values are \'Anonymous\', \'use-credentials\', and false. If false, canvas requests will\n  *     not use CORS, and the canvas will be tainted.\n  *\n  * @property {Boolean} [ajaxWithCredentials=false]\n  *     Whether to set the withCredentials XHR flag for AJAX requests (when loading tile sources).\n  *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.\n  *\n  */\n\n /**\n  * Settings for gestures generated by a pointer device.\n  *\n  * @typedef {Object} GestureSettings\n  * @memberof OpenSeadragon\n  *\n  * @property {Boolean} scrollToZoom\n  *     Set to false to disable zooming on scroll gestures.\n  *\n  * @property {Boolean} clickToZoom\n  *     Set to false to disable zooming on click gestures.\n  *\n  * @property {Boolean} dblClickToZoom\n  *     Set to false to disable zooming on double-click gestures. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  *\n  * @property {Boolean} pinchToZoom\n  *     Set to false to disable zooming on pinch gestures.\n  *\n  * @property {Boolean} flickEnabled\n  *     Set to false to disable the kinetic panning effect (flick) at the end of a drag gesture.\n  *\n  * @property {Number} flickMinSpeed\n  *     If flickEnabled is true, the minimum speed (in pixels-per-second) required to cause the kinetic panning effect (flick) at the end of a drag gesture.\n  *\n  * @property {Number} flickMomentum\n  *     If flickEnabled is true, a constant multiplied by the velocity to determine the distance of the kinetic panning effect (flick) at the end of a drag gesture.\n  *     A larger value will make the flick feel "lighter", while a smaller value will make the flick feel "heavier".\n  *     Note: springStiffness and animationTime also affect the "spring" used to stop the flick animation.\n  *\n  */\n\n/**\n  * The names for the image resources used for the image navigation buttons.\n  *\n  * @typedef {Object} NavImages\n  * @memberof OpenSeadragon\n  *\n  * @property {Object} zoomIn - Images for the zoom-in button.\n  * @property {String} zoomIn.REST\n  * @property {String} zoomIn.GROUP\n  * @property {String} zoomIn.HOVER\n  * @property {String} zoomIn.DOWN\n  *\n  * @property {Object} zoomOut - Images for the zoom-out button.\n  * @property {String} zoomOut.REST\n  * @property {String} zoomOut.GROUP\n  * @property {String} zoomOut.HOVER\n  * @property {String} zoomOut.DOWN\n  *\n  * @property {Object} home - Images for the home button.\n  * @property {String} home.REST\n  * @property {String} home.GROUP\n  * @property {String} home.HOVER\n  * @property {String} home.DOWN\n  *\n  * @property {Object} fullpage - Images for the full-page button.\n  * @property {String} fullpage.REST\n  * @property {String} fullpage.GROUP\n  * @property {String} fullpage.HOVER\n  * @property {String} fullpage.DOWN\n  *\n  * @property {Object} rotateleft - Images for the rotate left button.\n  * @property {String} rotateleft.REST\n  * @property {String} rotateleft.GROUP\n  * @property {String} rotateleft.HOVER\n  * @property {String} rotateleft.DOWN\n  *\n  * @property {Object} rotateright - Images for the rotate right button.\n  * @property {String} rotateright.REST\n  * @property {String} rotateright.GROUP\n  * @property {String} rotateright.HOVER\n  * @property {String} rotateright.DOWN\n  *\n  * @property {Object} previous - Images for the previous button.\n  * @property {String} previous.REST\n  * @property {String} previous.GROUP\n  * @property {String} previous.HOVER\n  * @property {String} previous.DOWN\n  *\n  * @property {Object} next - Images for the next button.\n  * @property {String} next.REST\n  * @property {String} next.GROUP\n  * @property {String} next.HOVER\n  * @property {String} next.DOWN\n  *\n  */\n\n\n /**\n  * This function serves as a single point of instantiation for an {@link OpenSeadragon.Viewer}, including all\n  * combinations of out-of-the-box configurable features.\n  *\n  * @param {OpenSeadragon.Options} options - Viewer options.\n  * @returns {OpenSeadragon.Viewer}\n  */\nwindow.OpenSeadragon = window.OpenSeadragon || function( options ){\n\n    return new OpenSeadragon.Viewer( options );\n\n};\n\nif (true) {\n   !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n       return (window.OpenSeadragon);\n   }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n(function( $ ){\n\n\n    /**\n     * The OpenSeadragon version.\n     *\n     * @member {Object} OpenSeadragon.version\n     * @property {String} versionStr - The version number as a string (\'major.minor.revision\').\n     * @property {Number} major - The major version number.\n     * @property {Number} minor - The minor version number.\n     * @property {Number} revision - The revision number.\n     * @since 1.0.0\n     */\n    $.version = {\n        versionStr: \'2.2.1\',\n        major: parseInt(\'2\', 10),\n        minor: parseInt(\'2\', 10),\n        revision: parseInt(\'1\', 10)\n    };\n\n\n    /**\n     * Taken from jquery 1.6.1\n     * [[Class]] -> type pairs\n     * @private\n     */\n    var class2type = {\n            \'[object Boolean]\':     \'boolean\',\n            \'[object Number]\':      \'number\',\n            \'[object String]\':      \'string\',\n            \'[object Function]\':    \'function\',\n            \'[object Array]\':       \'array\',\n            \'[object Date]\':        \'date\',\n            \'[object RegExp]\':      \'regexp\',\n            \'[object Object]\':      \'object\'\n        },\n        // Save a reference to some core methods\n        toString    = Object.prototype.toString,\n        hasOwn      = Object.prototype.hasOwnProperty;\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isFunction\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isFunction = function( obj ) {\n        return $.type(obj) === "function";\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isArray\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isArray = Array.isArray || function( obj ) {\n        return $.type(obj) === "array";\n    };\n\n\n    /**\n     * A crude way of determining if an object is a window.\n     * Taken from jQuery 1.6.1\n     * @function isWindow\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isWindow = function( obj ) {\n        return obj && typeof obj === "object" && "setInterval" in obj;\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function type\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.type = function( obj ) {\n        return ( obj === null ) || ( obj === undefined ) ?\n            String( obj ) :\n            class2type[ toString.call(obj) ] || "object";\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isPlainObject\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isPlainObject = function( obj ) {\n        // Must be an Object.\n        // Because of IE, we also have to check the presence of the constructor property.\n        // Make sure that DOM nodes and window objects don\'t pass through, as well\n        if ( !obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow( obj ) ) {\n            return false;\n        }\n\n        // Not own constructor property must be Object\n        if ( obj.constructor &&\n            !hasOwn.call(obj, "constructor") &&\n            !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {\n            return false;\n        }\n\n        // Own properties are enumerated firstly, so to speed up,\n        // if last one is own, then all properties are own.\n\n        var lastKey;\n        for (var key in obj ) {\n            lastKey = key;\n        }\n\n        return lastKey === undefined || hasOwn.call( obj, lastKey );\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isEmptyObject\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isEmptyObject = function( obj ) {\n        for ( var name in obj ) {\n            return false;\n        }\n        return true;\n    };\n\n    /**\n     * Shim around Object.freeze. Does nothing if Object.freeze is not supported.\n     * @param {Object} obj The object to freeze.\n     * @return {Object} obj The frozen object.\n     */\n    $.freezeObject = function(obj) {\n        if (Object.freeze) {\n            $.freezeObject = Object.freeze;\n        } else {\n            $.freezeObject = function(obj) {\n                return obj;\n            };\n        }\n        return $.freezeObject(obj);\n    };\n\n    /**\n     * True if the browser supports the HTML5 canvas element\n     * @member {Boolean} supportsCanvas\n     * @memberof OpenSeadragon\n     */\n    $.supportsCanvas = (function () {\n        var canvasElement = document.createElement( \'canvas\' );\n        return !!( $.isFunction( canvasElement.getContext ) &&\n                    canvasElement.getContext( \'2d\' ) );\n    }());\n\n    /**\n     * Test whether the submitted canvas is tainted or not.\n     * @argument {Canvas} canvas The canvas to test.\n     * @returns {Boolean} True if the canvas is tainted.\n     */\n    $.isCanvasTainted = function(canvas) {\n        var isTainted = false;\n        try {\n            // We test if the canvas is tainted by retrieving data from it.\n            // An exception will be raised if the canvas is tainted.\n            var data = canvas.getContext(\'2d\').getImageData(0, 0, 1, 1);\n        } catch (e) {\n            isTainted = true;\n        }\n        return isTainted;\n    };\n\n    /**\n     * A ratio comparing the device screen\'s pixel density to the canvas\'s backing store pixel density. Defaults to 1 if canvas isn\'t supported by the browser.\n     * @member {Number} pixelDensityRatio\n     * @memberof OpenSeadragon\n     */\n    $.pixelDensityRatio = (function () {\n        if ( $.supportsCanvas ) {\n            var context = document.createElement(\'canvas\').getContext(\'2d\');\n            var devicePixelRatio = window.devicePixelRatio || 1;\n            var backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                                    context.mozBackingStorePixelRatio ||\n                                    context.msBackingStorePixelRatio ||\n                                    context.oBackingStorePixelRatio ||\n                                    context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        } else {\n            return 1;\n        }\n    }());\n\n}( OpenSeadragon ));\n\n/**\n *  This closure defines all static methods available to the OpenSeadragon\n *  namespace.  Many, if not most, are taked directly from jQuery for use\n *  to simplify and reduce common programming patterns.  More static methods\n *  from jQuery may eventually make their way into this though we are\n *  attempting to avoid an explicit dependency on jQuery only because\n *  OpenSeadragon is a broadly useful code base and would be made less broad\n *  by requiring jQuery fully.\n *\n *  Some static methods have also been refactored from the original OpenSeadragon\n *  project.\n */\n(function( $ ){\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function extend\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.extend = function() {\n        var options,\n            name,\n            src,\n            copy,\n            copyIsArray,\n            clone,\n            target  = arguments[ 0 ] || {},\n            length  = arguments.length,\n            deep    = false,\n            i       = 1;\n\n        // Handle a deep copy situation\n        if ( typeof target === "boolean" ) {\n            deep    = target;\n            target  = arguments[ 1 ] || {};\n            // skip the boolean and the target\n            i = 2;\n        }\n\n        // Handle case when target is a string or something (possible in deep copy)\n        if ( typeof target !== "object" && !OpenSeadragon.isFunction( target ) ) {\n            target = {};\n        }\n\n        // extend jQuery itself if only one argument is passed\n        if ( length === i ) {\n            target = this;\n            --i;\n        }\n\n        for ( ; i < length; i++ ) {\n            // Only deal with non-null/undefined values\n            options = arguments[ i ];\n            if ( options !== null || options !== undefined ) {\n                // Extend the base object\n                for ( name in options ) {\n                    src = target[ name ];\n                    copy = options[ name ];\n\n                    // Prevent never-ending loop\n                    if ( target === copy ) {\n                        continue;\n                    }\n\n                    // Recurse if we\'re merging plain objects or arrays\n                    if ( deep && copy && ( OpenSeadragon.isPlainObject( copy ) || ( copyIsArray = OpenSeadragon.isArray( copy ) ) ) ) {\n                        if ( copyIsArray ) {\n                            copyIsArray = false;\n                            clone = src && OpenSeadragon.isArray( src ) ? src : [];\n\n                        } else {\n                            clone = src && OpenSeadragon.isPlainObject( src ) ? src : {};\n                        }\n\n                        // Never move original objects, clone them\n                        target[ name ] = OpenSeadragon.extend( deep, clone, copy );\n\n                    // Don\'t bring in undefined values\n                    } else if ( copy !== undefined ) {\n                        target[ name ] = copy;\n                    }\n                }\n            }\n        }\n\n        // Return the modified object\n        return target;\n    };\n\n    var isIOSDevice = function () {\n        if (typeof navigator !== \'object\') {\n            return false;\n        }\n        var userAgent = navigator.userAgent;\n        if (typeof userAgent !== \'string\') {\n            return false;\n        }\n        return userAgent.indexOf(\'iPhone\') !== -1 ||\n               userAgent.indexOf(\'iPad\') !== -1 ||\n               userAgent.indexOf(\'iPod\') !== -1;\n    };\n\n    $.extend( $, /** @lends OpenSeadragon */{\n        /**\n         * The default values for the optional settings documented at {@link OpenSeadragon.Options}.\n         * @static\n         * @type {Object}\n         */\n        DEFAULT_SETTINGS: {\n            //DATA SOURCE DETAILS\n            xmlPath:                null,\n            tileSources:            null,\n            tileHost:               null,\n            initialPage:            0,\n            crossOriginPolicy:      false,\n            ajaxWithCredentials:    false,\n\n            //PAN AND ZOOM SETTINGS AND CONSTRAINTS\n            panHorizontal:          true,\n            panVertical:            true,\n            constrainDuringPan:     false,\n            wrapHorizontal:         false,\n            wrapVertical:           false,\n            visibilityRatio:        0.5, //-> how much of the viewer can be negative space\n            minPixelRatio:          0.5, //->closer to 0 draws tiles meant for a higher zoom at this zoom\n            defaultZoomLevel:       0,\n            minZoomLevel:           null,\n            maxZoomLevel:           null,\n            homeFillsViewer:        false,\n\n            //UI RESPONSIVENESS AND FEEL\n            clickTimeThreshold:     300,\n            clickDistThreshold:     5,\n            dblClickTimeThreshold:  300,\n            dblClickDistThreshold:  20,\n            springStiffness:        6.5,\n            animationTime:          1.2,\n            gestureSettingsMouse:   { scrollToZoom: true,  clickToZoom: true,  dblClickToZoom: false, pinchToZoom: false, flickEnabled: false, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            gestureSettingsTouch:   { scrollToZoom: false, clickToZoom: false, dblClickToZoom: true,  pinchToZoom: true,  flickEnabled: true,  flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            gestureSettingsPen:     { scrollToZoom: false, clickToZoom: true,  dblClickToZoom: false, pinchToZoom: false, flickEnabled: false, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            gestureSettingsUnknown: { scrollToZoom: false, clickToZoom: false, dblClickToZoom: true,  pinchToZoom: true,  flickEnabled: true,  flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            zoomPerClick:           2,\n            zoomPerScroll:          1.2,\n            zoomPerSecond:          1.0,\n            blendTime:              0,\n            alwaysBlend:            false,\n            autoHideControls:       true,\n            immediateRender:        false,\n            minZoomImageRatio:      0.9, //-> closer to 0 allows zoom out to infinity\n            maxZoomPixelRatio:      1.1, //-> higher allows \'over zoom\' into pixels\n            smoothTileEdgesMinZoom: 1.1, //-> higher than maxZoomPixelRatio disables it\n            iOSDevice:              isIOSDevice(),\n            pixelsPerWheelLine:     40,\n            autoResize:             true,\n            preserveImageSizeOnResize: false, // requires autoResize=true\n            minScrollDeltaTime:     50,\n\n            //DEFAULT CONTROL SETTINGS\n            showSequenceControl:     true,  //SEQUENCE\n            sequenceControlAnchor:   null,  //SEQUENCE\n            preserveViewport:        false, //SEQUENCE\n            preserveOverlays:        false, //SEQUENCE\n            navPrevNextWrap:         false, //SEQUENCE\n            showNavigationControl:   true,  //ZOOM/HOME/FULL/ROTATION\n            navigationControlAnchor: null,  //ZOOM/HOME/FULL/ROTATION\n            showZoomControl:         true,  //ZOOM\n            showHomeControl:         true,  //HOME\n            showFullPageControl:     true,  //FULL\n            showRotationControl:     false, //ROTATION\n            controlsFadeDelay:       2000,  //ZOOM/HOME/FULL/SEQUENCE\n            controlsFadeLength:      1500,  //ZOOM/HOME/FULL/SEQUENCE\n            mouseNavEnabled:         true,  //GENERAL MOUSE INTERACTIVITY\n\n            //VIEWPORT NAVIGATOR SETTINGS\n            showNavigator:              false,\n            navigatorId:                null,\n            navigatorPosition:          null,\n            navigatorSizeRatio:         0.2,\n            navigatorMaintainSizeRatio: false,\n            navigatorTop:               null,\n            navigatorLeft:              null,\n            navigatorHeight:            null,\n            navigatorWidth:             null,\n            navigatorAutoResize:        true,\n            navigatorAutoFade:          true,\n            navigatorRotate:            true,\n\n            // INITIAL ROTATION\n            degrees:                    0,\n\n            // APPEARANCE\n            opacity:                    1,\n            compositeOperation:         null,\n            placeholderFillStyle:       null,\n\n            //REFERENCE STRIP SETTINGS\n            showReferenceStrip:          false,\n            referenceStripScroll:       \'horizontal\',\n            referenceStripElement:       null,\n            referenceStripHeight:        null,\n            referenceStripWidth:         null,\n            referenceStripPosition:      \'BOTTOM_LEFT\',\n            referenceStripSizeRatio:     0.2,\n\n            //COLLECTION VISUALIZATION SETTINGS\n            collectionRows:         3, //or columns depending on layout\n            collectionColumns:      0, //columns in horizontal layout, rows in vertical layout\n            collectionLayout:       \'horizontal\', //vertical\n            collectionMode:         false,\n            collectionTileSize:     800,\n            collectionTileMargin:   80,\n\n            //PERFORMANCE SETTINGS\n            imageLoaderLimit:       0,\n            maxImageCacheCount:     200,\n            timeout:                30000,\n            useCanvas:              true,  // Use canvas element for drawing if available\n\n            //INTERFACE RESOURCE SETTINGS\n            prefixUrl:              "/images/",\n            navImages: {\n                zoomIn: {\n                    REST:   \'zoomin_rest.png\',\n                    GROUP:  \'zoomin_grouphover.png\',\n                    HOVER:  \'zoomin_hover.png\',\n                    DOWN:   \'zoomin_pressed.png\'\n                },\n                zoomOut: {\n                    REST:   \'zoomout_rest.png\',\n                    GROUP:  \'zoomout_grouphover.png\',\n                    HOVER:  \'zoomout_hover.png\',\n                    DOWN:   \'zoomout_pressed.png\'\n                },\n                home: {\n                    REST:   \'home_rest.png\',\n                    GROUP:  \'home_grouphover.png\',\n                    HOVER:  \'home_hover.png\',\n                    DOWN:   \'home_pressed.png\'\n                },\n                fullpage: {\n                    REST:   \'fullpage_rest.png\',\n                    GROUP:  \'fullpage_grouphover.png\',\n                    HOVER:  \'fullpage_hover.png\',\n                    DOWN:   \'fullpage_pressed.png\'\n                },\n                rotateleft: {\n                    REST:   \'rotateleft_rest.png\',\n                    GROUP:  \'rotateleft_grouphover.png\',\n                    HOVER:  \'rotateleft_hover.png\',\n                    DOWN:   \'rotateleft_pressed.png\'\n                },\n                rotateright: {\n                    REST:   \'rotateright_rest.png\',\n                    GROUP:  \'rotateright_grouphover.png\',\n                    HOVER:  \'rotateright_hover.png\',\n                    DOWN:   \'rotateright_pressed.png\'\n                },\n                previous: {\n                    REST:   \'previous_rest.png\',\n                    GROUP:  \'previous_grouphover.png\',\n                    HOVER:  \'previous_hover.png\',\n                    DOWN:   \'previous_pressed.png\'\n                },\n                next: {\n                    REST:   \'next_rest.png\',\n                    GROUP:  \'next_grouphover.png\',\n                    HOVER:  \'next_hover.png\',\n                    DOWN:   \'next_pressed.png\'\n                }\n            },\n\n            //DEVELOPER SETTINGS\n            debugMode:              false,\n            debugGridColor:         \'#437AB2\'\n        },\n\n\n        /**\n         * TODO: get rid of this.  I can\'t see how it\'s required at all.  Looks\n         *       like an early legacy code artifact.\n         * @static\n         * @ignore\n         */\n        SIGNAL: "----seadragon----",\n\n\n        /**\n         * Returns a function which invokes the method as if it were a method belonging to the object.\n         * @function\n         * @param {Object} object\n         * @param {Function} method\n         * @returns {Function}\n         */\n        delegate: function( object, method ) {\n            return function(){\n                var args = arguments;\n                if ( args === undefined ){\n                    args = [];\n                }\n                return method.apply( object, args );\n            };\n        },\n\n\n        /**\n         * An enumeration of Browser vendors.\n         * @static\n         * @type {Object}\n         * @property {Number} UNKNOWN\n         * @property {Number} IE\n         * @property {Number} FIREFOX\n         * @property {Number} SAFARI\n         * @property {Number} CHROME\n         * @property {Number} OPERA\n         */\n        BROWSERS: {\n            UNKNOWN:    0,\n            IE:         1,\n            FIREFOX:    2,\n            SAFARI:     3,\n            CHROME:     4,\n            OPERA:      5\n        },\n\n\n        /**\n         * Returns a DOM Element for the given id or element.\n         * @function\n         * @param {String|Element} element Accepts an id or element.\n         * @returns {Element} The element with the given id, null, or the element itself.\n         */\n        getElement: function( element ) {\n            if ( typeof ( element ) == "string" ) {\n                element = document.getElementById( element );\n            }\n            return element;\n        },\n\n\n        /**\n         * Determines the position of the upper-left corner of the element.\n         * @function\n         * @param {Element|String} element - the elemenet we want the position for.\n         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.\n         */\n        getElementPosition: function( element ) {\n            var result = new $.Point(),\n                isFixed,\n                offsetParent;\n\n            element      = $.getElement( element );\n            isFixed      = $.getElementStyle( element ).position == "fixed";\n            offsetParent = getOffsetParent( element, isFixed );\n\n            while ( offsetParent ) {\n\n                result.x += element.offsetLeft;\n                result.y += element.offsetTop;\n\n                if ( isFixed ) {\n                    result = result.plus( $.getPageScroll() );\n                }\n\n                element = offsetParent;\n                isFixed = $.getElementStyle( element ).position == "fixed";\n                offsetParent = getOffsetParent( element, isFixed );\n            }\n\n            return result;\n        },\n\n\n        /**\n         * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.\n         * @function\n         * @param {Element|String} element - the element we want the position for.\n         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.\n         */\n        getElementOffset: function( element ) {\n            element = $.getElement( element );\n\n            var doc = element && element.ownerDocument,\n                docElement,\n                win,\n                boundingRect = { top: 0, left: 0 };\n\n            if ( !doc ) {\n                return new $.Point();\n            }\n\n            docElement = doc.documentElement;\n\n            if ( typeof element.getBoundingClientRect !== typeof undefined ) {\n                boundingRect = element.getBoundingClientRect();\n            }\n\n            win = ( doc == doc.window ) ?\n                doc :\n                ( doc.nodeType === 9 ) ?\n                    doc.defaultView || doc.parentWindow :\n                    false;\n\n            return new $.Point(\n                boundingRect.left + ( win.pageXOffset || docElement.scrollLeft ) - ( docElement.clientLeft || 0 ),\n                boundingRect.top + ( win.pageYOffset || docElement.scrollTop ) - ( docElement.clientTop || 0 )\n            );\n        },\n\n\n        /**\n         * Determines the height and width of the given element.\n         * @function\n         * @param {Element|String} element\n         * @returns {OpenSeadragon.Point}\n         */\n        getElementSize: function( element ) {\n            element = $.getElement( element );\n\n            return new $.Point(\n                element.clientWidth,\n                element.clientHeight\n            );\n        },\n\n\n        /**\n         * Returns the CSSStyle object for the given element.\n         * @function\n         * @param {Element|String} element\n         * @returns {CSSStyle}\n         */\n        getElementStyle:\n            document.documentElement.currentStyle ?\n            function( element ) {\n                element = $.getElement( element );\n                return element.currentStyle;\n            } :\n            function( element ) {\n                element = $.getElement( element );\n                return window.getComputedStyle( element, "" );\n            },\n\n        /**\n         * Returns the property with the correct vendor prefix appended.\n         * @param {String} property the property name\n         * @returns {String} the property with the correct prefix or null if not\n         * supported.\n         */\n        getCssPropertyWithVendorPrefix: function(property) {\n            var memo = {};\n\n            $.getCssPropertyWithVendorPrefix = function(property) {\n                if (memo[property] !== undefined) {\n                    return memo[property];\n                }\n                var style = document.createElement(\'div\').style;\n                var result = null;\n                if (style[property] !== undefined) {\n                    result = property;\n                } else {\n                    var prefixes = [\'Webkit\', \'Moz\', \'MS\', \'O\',\n                        \'webkit\', \'moz\', \'ms\', \'o\'];\n                    var suffix = $.capitalizeFirstLetter(property);\n                    for (var i = 0; i < prefixes.length; i++) {\n                        var prop = prefixes[i] + suffix;\n                        if (style[prop] !== undefined) {\n                            result = prop;\n                            break;\n                        }\n                    }\n                }\n                memo[property] = result;\n                return result;\n            };\n            return $.getCssPropertyWithVendorPrefix(property);\n        },\n\n        /**\n         * Capitalizes the first letter of a string\n         * @param {String} string\n         * @returns {String} The string with the first letter capitalized\n         */\n        capitalizeFirstLetter: function(string) {\n            return string.charAt(0).toUpperCase() + string.slice(1);\n        },\n\n        /**\n         * Determines if a point is within the bounding rectangle of the given element (hit-test).\n         * @function\n         * @param {Element|String} element\n         * @param {OpenSeadragon.Point} point\n         * @returns {Boolean}\n         */\n        pointInElement: function( element, point ) {\n            element = $.getElement( element );\n            var offset = $.getElementOffset( element ),\n                size = $.getElementSize( element );\n            return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;\n        },\n\n\n        /**\n         * Gets the latest event, really only useful internally since its\n         * specific to IE behavior.\n         * @function\n         * @param {Event} [event]\n         * @returns {Event}\n         * @deprecated For internal use only\n         * @private\n         */\n        getEvent: function( event ) {\n            if( event ){\n                $.getEvent = function( event ) {\n                    return event;\n                };\n            } else {\n                $.getEvent = function() {\n                    return window.event;\n                };\n            }\n            return $.getEvent( event );\n        },\n\n\n        /**\n         * Gets the position of the mouse on the screen for a given event.\n         * @function\n         * @param {Event} [event]\n         * @returns {OpenSeadragon.Point}\n         */\n        getMousePosition: function( event ) {\n\n            if ( typeof( event.pageX ) == "number" ) {\n                $.getMousePosition = function( event ){\n                    var result = new $.Point();\n\n                    event = $.getEvent( event );\n                    result.x = event.pageX;\n                    result.y = event.pageY;\n\n                    return result;\n                };\n            } else if ( typeof( event.clientX ) == "number" ) {\n                $.getMousePosition = function( event ){\n                    var result = new $.Point();\n\n                    event = $.getEvent( event );\n                    result.x =\n                        event.clientX +\n                        document.body.scrollLeft +\n                        document.documentElement.scrollLeft;\n                    result.y =\n                        event.clientY +\n                        document.body.scrollTop +\n                        document.documentElement.scrollTop;\n\n                    return result;\n                };\n            } else {\n                throw new Error(\n                    "Unknown event mouse position, no known technique."\n                );\n            }\n\n            return $.getMousePosition( event );\n        },\n\n\n        /**\n         * Determines the page\'s current scroll position.\n         * @function\n         * @returns {OpenSeadragon.Point}\n         */\n        getPageScroll: function() {\n            var docElement  = document.documentElement || {},\n                body        = document.body || {};\n\n            if ( typeof( window.pageXOffset ) == "number" ) {\n                $.getPageScroll = function(){\n                    return new $.Point(\n                        window.pageXOffset,\n                        window.pageYOffset\n                    );\n                };\n            } else if ( body.scrollLeft || body.scrollTop ) {\n                $.getPageScroll = function(){\n                    return new $.Point(\n                        document.body.scrollLeft,\n                        document.body.scrollTop\n                    );\n                };\n            } else if ( docElement.scrollLeft || docElement.scrollTop ) {\n                $.getPageScroll = function(){\n                    return new $.Point(\n                        document.documentElement.scrollLeft,\n                        document.documentElement.scrollTop\n                    );\n                };\n            } else {\n                // We can\'t reassign the function yet, as there was no scroll.\n                return new $.Point(0,0);\n            }\n\n            return $.getPageScroll();\n        },\n\n        /**\n         * Set the page scroll position.\n         * @function\n         * @returns {OpenSeadragon.Point}\n         */\n        setPageScroll: function( scroll ) {\n            if ( typeof ( window.scrollTo ) !== "undefined" ) {\n                $.setPageScroll = function( scroll ) {\n                    window.scrollTo( scroll.x, scroll.y );\n                };\n            } else {\n                var originalScroll = $.getPageScroll();\n                if ( originalScroll.x === scroll.x &&\n                    originalScroll.y === scroll.y ) {\n                    // We are already correctly positioned and there\n                    // is no way to detect the correct method.\n                    return;\n                }\n\n                document.body.scrollLeft = scroll.x;\n                document.body.scrollTop = scroll.y;\n                var currentScroll = $.getPageScroll();\n                if ( currentScroll.x !== originalScroll.x &&\n                    currentScroll.y !== originalScroll.y ) {\n                    $.setPageScroll = function( scroll ) {\n                        document.body.scrollLeft = scroll.x;\n                        document.body.scrollTop = scroll.y;\n                    };\n                    return;\n                }\n\n                document.documentElement.scrollLeft = scroll.x;\n                document.documentElement.scrollTop = scroll.y;\n                currentScroll = $.getPageScroll();\n                if ( currentScroll.x !== originalScroll.x &&\n                    currentScroll.y !== originalScroll.y ) {\n                    $.setPageScroll = function( scroll ) {\n                        document.documentElement.scrollLeft = scroll.x;\n                        document.documentElement.scrollTop = scroll.y;\n                    };\n                    return;\n                }\n\n                // We can\'t find anything working, so we do nothing.\n                $.setPageScroll = function( scroll ) {\n                };\n            }\n\n            return $.setPageScroll( scroll );\n        },\n\n        /**\n         * Determines the size of the browsers window.\n         * @function\n         * @returns {OpenSeadragon.Point}\n         */\n        getWindowSize: function() {\n            var docElement = document.documentElement || {},\n                body    = document.body || {};\n\n            if ( typeof( window.innerWidth ) == \'number\' ) {\n                $.getWindowSize = function(){\n                    return new $.Point(\n                        window.innerWidth,\n                        window.innerHeight\n                    );\n                };\n            } else if ( docElement.clientWidth || docElement.clientHeight ) {\n                $.getWindowSize = function(){\n                    return new $.Point(\n                        document.documentElement.clientWidth,\n                        document.documentElement.clientHeight\n                    );\n                };\n            } else if ( body.clientWidth || body.clientHeight ) {\n                $.getWindowSize = function(){\n                    return new $.Point(\n                        document.body.clientWidth,\n                        document.body.clientHeight\n                    );\n                };\n            } else {\n                throw new Error("Unknown window size, no known technique.");\n            }\n\n            return $.getWindowSize();\n        },\n\n\n        /**\n         * Wraps the given element in a nest of divs so that the element can\n         * be easily centered using CSS tables\n         * @function\n         * @param {Element|String} element\n         * @returns {Element} outermost wrapper element\n         */\n        makeCenteredNode: function( element ) {\n            // Convert a possible ID to an actual HTMLElement\n            element = $.getElement( element );\n\n            /*\n                CSS tables require you to have a display:table/row/cell hierarchy so we need to create\n                three nested wrapper divs:\n             */\n\n            var wrappers = [\n                $.makeNeutralElement( \'div\' ),\n                $.makeNeutralElement( \'div\' ),\n                $.makeNeutralElement( \'div\' )\n            ];\n\n            // It feels like we should be able to pass style dicts to makeNeutralElement:\n            $.extend(wrappers[0].style, {\n                display: "table",\n                height: "100%",\n                width: "100%"\n            });\n\n            $.extend(wrappers[1].style, {\n                display: "table-row"\n            });\n\n            $.extend(wrappers[2].style, {\n                display: "table-cell",\n                verticalAlign: "middle",\n                textAlign: "center"\n            });\n\n            wrappers[0].appendChild(wrappers[1]);\n            wrappers[1].appendChild(wrappers[2]);\n            wrappers[2].appendChild(element);\n\n            return wrappers[0];\n        },\n\n\n        /**\n         * Creates an easily positionable element of the given type that therefor\n         * serves as an excellent container element.\n         * @function\n         * @param {String} tagName\n         * @returns {Element}\n         */\n        makeNeutralElement: function( tagName ) {\n            var element = document.createElement( tagName ),\n                style   = element.style;\n\n            style.background = "transparent none";\n            style.border     = "none";\n            style.margin     = "0px";\n            style.padding    = "0px";\n            style.position   = "static";\n\n            return element;\n        },\n\n\n        /**\n         * Returns the current milliseconds, using Date.now() if available\n         * @function\n         */\n        now: function( ) {\n          if (Date.now) {\n            $.now = Date.now;\n          } else {\n            $.now = function() { return new Date().getTime(); };\n          }\n\n          return $.now();\n        },\n\n\n        /**\n         * Ensures an image is loaded correctly to support alpha transparency.\n         * Generally only IE has issues doing this correctly for formats like\n         * png.\n         * @function\n         * @param {String} src\n         * @returns {Element}\n         */\n        makeTransparentImage: function( src ) {\n\n            $.makeTransparentImage = function( src ){\n                var img = $.makeNeutralElement( "img" );\n\n                img.src = src;\n\n                return img;\n            };\n\n            if ( $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 7 ) {\n\n                $.makeTransparentImage = function( src ){\n                    var img     = $.makeNeutralElement( "img" ),\n                        element = null;\n\n                    element = $.makeNeutralElement("span");\n                    element.style.display = "inline-block";\n\n                    img.onload = function() {\n                        element.style.width  = element.style.width || img.width + "px";\n                        element.style.height = element.style.height || img.height + "px";\n\n                        img.onload = null;\n                        img = null;     // to prevent memory leaks in IE\n                    };\n\n                    img.src = src;\n                    element.style.filter =\n                        "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'" +\n                        src +\n                        "\', sizingMethod=\'scale\')";\n\n                    return element;\n                };\n\n            }\n\n            return $.makeTransparentImage( src );\n        },\n\n\n        /**\n         * Sets the opacity of the specified element.\n         * @function\n         * @param {Element|String} element\n         * @param {Number} opacity\n         * @param {Boolean} [usesAlpha]\n         */\n        setElementOpacity: function( element, opacity, usesAlpha ) {\n\n            var ieOpacity,\n                ieFilter;\n\n            element = $.getElement( element );\n\n            if ( usesAlpha && !$.Browser.alpha ) {\n                opacity = Math.round( opacity );\n            }\n\n            if ( $.Browser.opacity ) {\n                element.style.opacity = opacity < 1 ? opacity : "";\n            } else {\n                if ( opacity < 1 ) {\n                    ieOpacity = Math.round( 100 * opacity );\n                    ieFilter  = "alpha(opacity=" + ieOpacity + ")";\n                    element.style.filter = ieFilter;\n                } else {\n                    element.style.filter = "";\n                }\n            }\n        },\n\n\n        /**\n         * Sets the specified element\'s touch-action style attribute to \'none\'.\n         * @function\n         * @param {Element|String} element\n         */\n        setElementTouchActionNone: function( element ) {\n            element = $.getElement( element );\n            if ( typeof element.style.touchAction !== \'undefined\' ) {\n                element.style.touchAction = \'none\';\n            } else if ( typeof element.style.msTouchAction !== \'undefined\' ) {\n                element.style.msTouchAction = \'none\';\n            }\n        },\n\n\n        /**\n         * Add the specified CSS class to the element if not present.\n         * @function\n         * @param {Element|String} element\n         * @param {String} className\n         */\n        addClass: function( element, className ) {\n            element = $.getElement( element );\n\n            if ( ! element.className ) {\n                element.className = className;\n            } else if ( ( \' \' + element.className + \' \' ).\n                indexOf( \' \' + className + \' \' ) === -1 ) {\n                element.className += \' \' + className;\n            }\n        },\n\n        /**\n         * Find the first index at which an element is found in an array or -1\n         * if not present.\n         *\n         * Code taken and adapted from\n         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility\n         *\n         * @function\n         * @param {Array} array The array from which to find the element\n         * @param {Object} searchElement The element to find\n         * @param {Number} [fromIndex=0] Index to start research.\n         * @returns {Number} The index of the element in the array.\n         */\n        indexOf: function( array, searchElement, fromIndex ) {\n            if ( Array.prototype.indexOf ) {\n                this.indexOf = function( array, searchElement, fromIndex ) {\n                    return array.indexOf( searchElement, fromIndex );\n                };\n            } else {\n                this.indexOf = function( array, searchElement, fromIndex ) {\n                    var i,\n                        pivot = ( fromIndex ) ? fromIndex : 0,\n                        length;\n                    if ( !array ) {\n                        throw new TypeError( );\n                    }\n\n                    length = array.length;\n                    if ( length === 0 || pivot >= length ) {\n                        return -1;\n                    }\n\n                    if ( pivot < 0 ) {\n                        pivot = length - Math.abs( pivot );\n                    }\n\n                    for ( i = pivot; i < length; i++ ) {\n                        if ( array[i] === searchElement ) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                };\n            }\n            return this.indexOf( array, searchElement, fromIndex );\n        },\n\n        /**\n         * Remove the specified CSS class from the element.\n         * @function\n         * @param {Element|String} element\n         * @param {String} className\n         */\n        removeClass: function( element, className ) {\n            var oldClasses,\n                newClasses = [],\n                i;\n\n            element = $.getElement( element );\n            oldClasses = element.className.split( /\\s+/ );\n            for ( i = 0; i < oldClasses.length; i++ ) {\n                if ( oldClasses[ i ] && oldClasses[ i ] !== className ) {\n                    newClasses.push( oldClasses[ i ] );\n                }\n            }\n            element.className = newClasses.join(\' \');\n        },\n\n\n        /**\n         * Adds an event listener for the given element, eventName and handler.\n         * @function\n         * @param {Element|String} element\n         * @param {String} eventName\n         * @param {Function} handler\n         * @param {Boolean} [useCapture]\n         */\n        addEvent: (function () {\n            if ( window.addEventListener ) {\n                return function ( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.addEventListener( eventName, handler, useCapture );\n                };\n            } else if ( window.attachEvent ) {\n                return function ( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.attachEvent( \'on\' + eventName, handler );\n                };\n            } else {\n                throw new Error( "No known event model." );\n            }\n        }()),\n\n\n        /**\n         * Remove a given event listener for the given element, event type and\n         * handler.\n         * @function\n         * @param {Element|String} element\n         * @param {String} eventName\n         * @param {Function} handler\n         * @param {Boolean} [useCapture]\n         */\n        removeEvent: (function () {\n            if ( window.removeEventListener ) {\n                return function ( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.removeEventListener( eventName, handler, useCapture );\n                };\n            } else if ( window.detachEvent ) {\n                return function( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.detachEvent( \'on\' + eventName, handler );\n                };\n            } else {\n                throw new Error( "No known event model." );\n            }\n        }()),\n\n\n        /**\n         * Cancels the default browser behavior had the event propagated all\n         * the way up the DOM to the window object.\n         * @function\n         * @param {Event} [event]\n         */\n        cancelEvent: function( event ) {\n            event = $.getEvent( event );\n\n            if ( event.preventDefault ) {\n                $.cancelEvent = function( event ){\n                    // W3C for preventing default\n                    event.preventDefault();\n                };\n            } else {\n                $.cancelEvent = function( event ){\n                    event = $.getEvent( event );\n                    // legacy for preventing default\n                    event.cancel = true;\n                    // IE for preventing default\n                    event.returnValue = false;\n                };\n            }\n            $.cancelEvent( event );\n        },\n\n\n        /**\n         * Stops the propagation of the event up the DOM.\n         * @function\n         * @param {Event} [event]\n         */\n        stopEvent: function( event ) {\n            event = $.getEvent( event );\n\n            if ( event.stopPropagation ) {\n                // W3C for stopping propagation\n                $.stopEvent = function( event ){\n                    event.stopPropagation();\n                };\n            } else {\n                // IE for stopping propagation\n                $.stopEvent = function( event ){\n                    event = $.getEvent( event );\n                    event.cancelBubble = true;\n                };\n\n            }\n\n            $.stopEvent( event );\n        },\n\n\n        /**\n         * Similar to OpenSeadragon.delegate, but it does not immediately call\n         * the method on the object, returning a function which can be called\n         * repeatedly to delegate the method. It also allows additonal arguments\n         * to be passed during construction which will be added during each\n         * invocation, and each invocation can add additional arguments as well.\n         *\n         * @function\n         * @param {Object} object\n         * @param {Function} method\n         * @param [args] any additional arguments are passed as arguments to the\n         *  created callback\n         * @returns {Function}\n         */\n        createCallback: function( object, method ) {\n            //TODO: This pattern is painful to use and debug.  It\'s much cleaner\n            //      to use pinning plus anonymous functions.  Get rid of this\n            //      pattern!\n            var initialArgs = [],\n                i;\n            for ( i = 2; i < arguments.length; i++ ) {\n                initialArgs.push( arguments[ i ] );\n            }\n\n            return function() {\n                var args = initialArgs.concat( [] ),\n                    i;\n                for ( i = 0; i < arguments.length; i++ ) {\n                    args.push( arguments[ i ] );\n                }\n\n                return method.apply( object, args );\n            };\n        },\n\n\n        /**\n         * Retreives the value of a url parameter from the window.location string.\n         * @function\n         * @param {String} key\n         * @returns {String} The value of the url parameter or null if no param matches.\n         */\n        getUrlParameter: function( key ) {\n            var value = URLPARAMS[ key ];\n            return value ? value : null;\n        },\n\n        /**\n         * Retrieves the protocol used by the url. The url can either be absolute\n         * or relative.\n         * @function\n         * @private\n         * @param {String} url The url to retrieve the protocol from.\n         * @return {String} The protocol (http:, https:, file:, ftp: ...)\n         */\n        getUrlProtocol: function( url ) {\n            var match = url.match(/^([a-z]+:)\\/\\//i);\n            if ( match === null ) {\n                // Relative URL, retrive the protocol from window.location\n                return window.location.protocol;\n            }\n            return match[1].toLowerCase();\n        },\n\n        /**\n         * Create an XHR object\n         * @private\n         * @param {type} [local] If set to true, the XHR will be file: protocol\n         * compatible if possible (but may raise a warning in the browser).\n         * @returns {XMLHttpRequest}\n         */\n        createAjaxRequest: function( local ) {\n            // IE11 does not support window.ActiveXObject so we just try to\n            // create one to see if it is supported.\n            // See: http://msdn.microsoft.com/en-us/library/ie/dn423948%28v=vs.85%29.aspx\n            var supportActiveX;\n            try {\n                /* global ActiveXObject:true */\n                supportActiveX = !!new ActiveXObject( "Microsoft.XMLHTTP" );\n            } catch( e ) {\n                supportActiveX = false;\n            }\n\n            if ( supportActiveX ) {\n                if ( window.XMLHttpRequest ) {\n                    $.createAjaxRequest = function( local ) {\n                        if ( local ) {\n                            return new ActiveXObject( "Microsoft.XMLHTTP" );\n                        }\n                        return new XMLHttpRequest();\n                    };\n                } else {\n                    $.createAjaxRequest = function() {\n                        return new ActiveXObject( "Microsoft.XMLHTTP" );\n                    };\n                }\n            } else if ( window.XMLHttpRequest ) {\n                $.createAjaxRequest = function() {\n                    return new XMLHttpRequest();\n                };\n            } else {\n                throw new Error( "Browser doesn\'t support XMLHttpRequest." );\n            }\n            return $.createAjaxRequest( local );\n        },\n\n        /**\n         * Makes an AJAX request.\n         * @param {Object} options\n         * @param {String} options.url - the url to request\n         * @param {Function} options.success - a function to call on a successful response\n         * @param {Function} options.error - a function to call on when an error occurs\n         * @param {Boolean} [options.withCredentials=false] - whether to set the XHR\'s withCredentials\n         * @throws {Error}\n         */\n        makeAjaxRequest: function( url, onSuccess, onError ) {\n            var withCredentials;\n\n            // Note that our preferred API is that you pass in a single object; the named\n            // arguments are for legacy support.\n            if( $.isPlainObject( url ) ){\n                onSuccess = url.success;\n                onError = url.error;\n                withCredentials = url.withCredentials;\n                url = url.url;\n            }\n\n            var protocol = $.getUrlProtocol( url );\n            var request = $.createAjaxRequest( protocol === "file:" );\n\n            if ( !$.isFunction( onSuccess ) ) {\n                throw new Error( "makeAjaxRequest requires a success callback" );\n            }\n\n            request.onreadystatechange = function() {\n                // 4 = DONE (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Properties)\n                if ( request.readyState == 4 ) {\n                    request.onreadystatechange = function(){};\n\n                    // With protocols other than http/https, the status is 200\n                    // on Firefox and 0 on other browsers\n                    if ( request.status === 200 ||\n                        ( request.status === 0 &&\n                          protocol !== "http:" &&\n                          protocol !== "https:" )) {\n                        onSuccess( request );\n                    } else {\n                        $.console.log( "AJAX request returned %d: %s", request.status, url );\n\n                        if ( $.isFunction( onError ) ) {\n                            onError( request );\n                        }\n                    }\n                }\n            };\n\n            if (withCredentials) {\n                request.withCredentials = true;\n            }\n\n            try {\n                request.open( "GET", url, true );\n                request.send( null );\n            } catch (e) {\n                var msg = e.message;\n\n                /*\n                    IE < 10 does not support CORS and an XHR request to a different origin will fail as soon\n                    as send() is called. This is particularly easy to miss during development and appear in\n                    production if you use a CDN or domain sharding and the security policy is likely to break\n                    exception handlers since any attempt to access a property of the request object will\n                    raise an access denied TypeError inside the catch block.\n\n                    To be friendlier, we\'ll check for this specific error and add a documentation pointer\n                    to point developers in the right direction. We test the exception number because IE\'s\n                    error messages are localized.\n                */\n                var oldIE = $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 10;\n                if ( oldIE && typeof( e.number ) != "undefined" && e.number == -2147024891 ) {\n                    msg += "\\nSee http://msdn.microsoft.com/en-us/library/ms537505(v=vs.85).aspx#xdomain";\n                }\n\n                $.console.log( "%s while making AJAX request: %s", e.name, msg );\n\n                request.onreadystatechange = function(){};\n\n                if (window.XDomainRequest) { // IE9 or IE8 might as well try to use XDomainRequest\n                    var xdr = new XDomainRequest();\n                    if (xdr) {\n                        xdr.onload = function (e) {\n                            if ( $.isFunction( onSuccess ) ) {\n                                onSuccess({ // Faking an xhr object\n                                    responseText: xdr.responseText,\n                                    status: 200, // XDomainRequest doesn\'t support status codes, so we just fake one! :/\n                                    statusText: \'OK\'\n                                });\n                            }\n                        };\n                        xdr.onerror = function (e) {\n                            if ( $.isFunction ( onError ) ) {\n                                onError({ // Faking an xhr object\n                                    responseText: xdr.responseText,\n                                    status: 444, // 444 No Response\n                                    statusText: \'An error happened. Due to an XDomainRequest deficiency we can not extract any information about this error. Upgrade your browser.\'\n                                });\n                            }\n                        };\n                        try {\n                            xdr.open(\'GET\', url);\n                            xdr.send();\n                        } catch (e2) {\n                            if ( $.isFunction( onError ) ) {\n                                onError( request, e );\n                            }\n                        }\n                    }\n                } else {\n                    if ( $.isFunction( onError ) ) {\n                        onError( request, e );\n                    }\n                }\n            }\n        },\n\n        /**\n         * Taken from jQuery 1.6.1\n         * @function\n         * @param {Object} options\n         * @param {String} options.url\n         * @param {Function} options.callback\n         * @param {String} [options.param=\'callback\'] The name of the url parameter\n         *      to request the jsonp provider with.\n         * @param {String} [options.callbackName=] The name of the callback to\n         *      request the jsonp provider with.\n         */\n        jsonp: function( options ){\n            var script,\n                url     = options.url,\n                head    = document.head ||\n                    document.getElementsByTagName( "head" )[ 0 ] ||\n                    document.documentElement,\n                jsonpCallback = options.callbackName || \'openseadragon\' + $.now(),\n                previous      = window[ jsonpCallback ],\n                replace       = "$1" + jsonpCallback + "$2",\n                callbackParam = options.param || \'callback\',\n                callback      = options.callback;\n\n            url = url.replace( /(\\=)\\?(&|$)|\\?\\?/i, replace );\n            // Add callback manually\n            url += (/\\?/.test( url ) ? "&" : "?") + callbackParam + "=" + jsonpCallback;\n\n            // Install callback\n            window[ jsonpCallback ] = function( response ) {\n                if ( !previous ){\n                    try{\n                        delete window[ jsonpCallback ];\n                    }catch(e){\n                        //swallow\n                    }\n                } else {\n                    window[ jsonpCallback ] = previous;\n                }\n                if( callback && $.isFunction( callback ) ){\n                    callback( response );\n                }\n            };\n\n            script = document.createElement( "script" );\n\n            //TODO: having an issue with async info requests\n            if( undefined !== options.async || false !== options.async ){\n                script.async = "async";\n            }\n\n            if ( options.scriptCharset ) {\n                script.charset = options.scriptCharset;\n            }\n\n            script.src = url;\n\n            // Attach handlers for all browsers\n            script.onload = script.onreadystatechange = function( _, isAbort ) {\n\n                if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n                    // Handle memory leak in IE\n                    script.onload = script.onreadystatechange = null;\n\n                    // Remove the script\n                    if ( head && script.parentNode ) {\n                        head.removeChild( script );\n                    }\n\n                    // Dereference the script\n                    script = undefined;\n                }\n            };\n            // Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n            // This arises when a base node is used (#2709 and #4378).\n            head.insertBefore( script, head.firstChild );\n\n        },\n\n\n        /**\n         * Fully deprecated. Will throw an error.\n         * @function\n         * @deprecated use {@link OpenSeadragon.Viewer#open}\n         */\n        createFromDZI: function() {\n            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";\n        },\n\n        /**\n         * Parses an XML string into a DOM Document.\n         * @function\n         * @param {String} string\n         * @returns {Document}\n         */\n        parseXml: function( string ) {\n            if ( window.DOMParser ) {\n\n                $.parseXml = function( string ) {\n                    var xmlDoc = null,\n                        parser;\n\n                    parser = new DOMParser();\n                    xmlDoc = parser.parseFromString( string, "text/xml" );\n                    return xmlDoc;\n                };\n\n            } else if ( window.ActiveXObject ) {\n\n                $.parseXml = function( string ) {\n                    var xmlDoc = null;\n\n                    xmlDoc = new ActiveXObject( "Microsoft.XMLDOM" );\n                    xmlDoc.async = false;\n                    xmlDoc.loadXML( string );\n                    return xmlDoc;\n                };\n\n            } else {\n                throw new Error( "Browser doesn\'t support XML DOM." );\n            }\n\n            return $.parseXml( string );\n        },\n\n        /**\n         * Parses a JSON string into a Javascript object.\n         * @function\n         * @param {String} string\n         * @returns {Object}\n         */\n        parseJSON: function(string) {\n            if (window.JSON && window.JSON.parse) {\n                $.parseJSON = window.JSON.parse;\n            } else {\n                // Should only be used by IE8 in non standards mode\n                $.parseJSON = function(string) {\n                    /*jshint evil:true*/\n                    return eval(\'(\' + string + \')\');\n                };\n            }\n            return $.parseJSON(string);\n        },\n\n        /**\n         * Reports whether the image format is supported for tiling in this\n         * version.\n         * @function\n         * @param {String} [extension]\n         * @returns {Boolean}\n         */\n        imageFormatSupported: function( extension ) {\n            extension = extension ? extension : "";\n            return !!FILEFORMATS[ extension.toLowerCase() ];\n        }\n\n    });\n\n\n    /**\n     * The current browser vendor, version, and related information regarding detected features.\n     * @member {Object} Browser\n     * @memberof OpenSeadragon\n     * @static\n     * @type {Object}\n     * @property {OpenSeadragon.BROWSERS} vendor - One of the {@link OpenSeadragon.BROWSERS} enumeration values.\n     * @property {Number} version\n     * @property {Boolean} alpha - Does the browser support image alpha transparency.\n     */\n    $.Browser = {\n        vendor:     $.BROWSERS.UNKNOWN,\n        version:    0,\n        alpha:      true\n    };\n\n\n    var FILEFORMATS = {\n            "bmp":  false,\n            "jpeg": true,\n            "jpg":  true,\n            "png":  true,\n            "tif":  false,\n            "wdp":  false\n        },\n        URLPARAMS = {};\n\n    (function() {\n        //A small auto-executing routine to determine the browser vendor,\n        //version and supporting feature sets.\n        var app = navigator.appName,\n            ver = navigator.appVersion,\n            ua  = navigator.userAgent,\n            regex;\n\n        //console.error( \'appName: \' + navigator.appName );\n        //console.error( \'appVersion: \' + navigator.appVersion );\n        //console.error( \'userAgent: \' + navigator.userAgent );\n\n        switch( navigator.appName ){\n            case "Microsoft Internet Explorer":\n                if( !!window.attachEvent &&\n                    !!window.ActiveXObject ) {\n\n                    $.Browser.vendor = $.BROWSERS.IE;\n                    $.Browser.version = parseFloat(\n                        ua.substring(\n                            ua.indexOf( "MSIE" ) + 5,\n                            ua.indexOf( ";", ua.indexOf( "MSIE" ) ) )\n                        );\n                }\n                break;\n            case "Netscape":\n                if( !!window.addEventListener ){\n                    if ( ua.indexOf( "Firefox" ) >= 0 ) {\n                        $.Browser.vendor = $.BROWSERS.FIREFOX;\n                        $.Browser.version = parseFloat(\n                            ua.substring( ua.indexOf( "Firefox" ) + 8 )\n                        );\n                    } else if ( ua.indexOf( "Safari" ) >= 0 ) {\n                        $.Browser.vendor = ua.indexOf( "Chrome" ) >= 0 ?\n                            $.BROWSERS.CHROME :\n                            $.BROWSERS.SAFARI;\n                        $.Browser.version = parseFloat(\n                            ua.substring(\n                                ua.substring( 0, ua.indexOf( "Safari" ) ).lastIndexOf( "/" ) + 1,\n                                ua.indexOf( "Safari" )\n                            )\n                        );\n                    } else {\n                        regex = new RegExp( "Trident/.*rv:([0-9]{1,}[.0-9]{0,})");\n                        if ( regex.exec( ua ) !== null ) {\n                            $.Browser.vendor = $.BROWSERS.IE;\n                            $.Browser.version = parseFloat( RegExp.$1 );\n                        }\n                    }\n                }\n                break;\n            case "Opera":\n                $.Browser.vendor = $.BROWSERS.OPERA;\n                $.Browser.version = parseFloat( ver );\n                break;\n        }\n\n            // ignore \'?\' portion of query string\n        var query = window.location.search.substring( 1 ),\n            parts = query.split(\'&\'),\n            part,\n            sep,\n            i;\n\n        for ( i = 0; i < parts.length; i++ ) {\n            part = parts[ i ];\n            sep  = part.indexOf( \'=\' );\n\n            if ( sep > 0 ) {\n                URLPARAMS[ part.substring( 0, sep ) ] =\n                    decodeURIComponent( part.substring( sep + 1 ) );\n            }\n        }\n\n        //determine if this browser supports image alpha transparency\n        $.Browser.alpha = !(\n            (\n                $.Browser.vendor == $.BROWSERS.IE &&\n                $.Browser.version < 9\n            ) || (\n                $.Browser.vendor == $.BROWSERS.CHROME &&\n                $.Browser.version < 2\n            )\n        );\n\n        //determine if this browser supports element.style.opacity\n        $.Browser.opacity = !(\n            $.Browser.vendor == $.BROWSERS.IE &&\n            $.Browser.version < 9\n        );\n\n    })();\n\n\n    //TODO: $.console is often used inside a try/catch block which generally\n    //      prevents allowings errors to occur with detection until a debugger\n    //      is attached.  Although I\'ve been guilty of the same anti-pattern\n    //      I eventually was convinced that errors should naturally propogate in\n    //      all but the most special cases.\n    /**\n     * A convenient alias for console when available, and a simple null\n     * function when console is unavailable.\n     * @static\n     * @private\n     */\n    var nullfunction = function( msg ){\n            //document.location.hash = msg;\n        };\n\n    $.console = window.console || {\n        log:    nullfunction,\n        debug:  nullfunction,\n        info:   nullfunction,\n        warn:   nullfunction,\n        error:  nullfunction,\n        assert: nullfunction\n    };\n\n\n    // Adding support for HTML5\'s requestAnimationFrame as suggested by acdha.\n    // Implementation taken from matt synder\'s post here:\n    // http://mattsnider.com/cross-browser-and-legacy-supported-requestframeanimation/\n    (function( w ) {\n\n        // most browsers have an implementation\n        var requestAnimationFrame = w.requestAnimationFrame ||\n            w.mozRequestAnimationFrame ||\n            w.webkitRequestAnimationFrame ||\n            w.msRequestAnimationFrame;\n\n        var cancelAnimationFrame = w.cancelAnimationFrame ||\n            w.mozCancelAnimationFrame ||\n            w.webkitCancelAnimationFrame ||\n            w.msCancelAnimationFrame;\n\n        // polyfill, when necessary\n        if ( requestAnimationFrame && cancelAnimationFrame ) {\n            // We can\'t assign these window methods directly to $ because they\n            // expect their "this" to be "window", so we call them in wrappers.\n            $.requestAnimationFrame = function(){\n                return requestAnimationFrame.apply( w, arguments );\n            };\n            $.cancelAnimationFrame = function(){\n                return cancelAnimationFrame.apply( w, arguments );\n            };\n        } else {\n            var aAnimQueue = [],\n                processing = [],\n                iRequestId = 0,\n                iIntervalId;\n\n            // create a mock requestAnimationFrame function\n            $.requestAnimationFrame = function( callback ) {\n                aAnimQueue.push( [ ++iRequestId, callback ] );\n\n                if ( !iIntervalId ) {\n                    iIntervalId = setInterval( function() {\n                        if ( aAnimQueue.length ) {\n                            var time = $.now();\n                            // Process all of the currently outstanding frame\n                            // requests, but none that get added during the\n                            // processing.\n                            // Swap the arrays so we don\'t have to create a new\n                            // array every frame.\n                            var temp = processing;\n                            processing = aAnimQueue;\n                            aAnimQueue = temp;\n                            while ( processing.length ) {\n                                processing.shift()[ 1 ]( time );\n                            }\n                        } else {\n                            // don\'t continue the interval, if unnecessary\n                            clearInterval( iIntervalId );\n                            iIntervalId = undefined;\n                        }\n                    }, 1000 / 50);  // estimating support for 50 frames per second\n                }\n\n                return iRequestId;\n            };\n\n            // create a mock cancelAnimationFrame function\n            $.cancelAnimationFrame = function( requestId ) {\n                // find the request ID and remove it\n                var i, j;\n                for ( i = 0, j = aAnimQueue.length; i < j; i += 1 ) {\n                    if ( aAnimQueue[ i ][ 0 ] === requestId ) {\n                        aAnimQueue.splice( i, 1 );\n                        return;\n                    }\n                }\n\n                // If it\'s not in the queue, it may be in the set we\'re currently\n                // processing (if cancelAnimationFrame is called from within a\n                // requestAnimationFrame callback).\n                for ( i = 0, j = processing.length; i < j; i += 1 ) {\n                    if ( processing[ i ][ 0 ] === requestId ) {\n                        processing.splice( i, 1 );\n                        return;\n                    }\n                }\n            };\n        }\n    })( window );\n\n    /**\n     * @private\n     * @inner\n     * @function\n     * @param {Element} element\n     * @param {Boolean} [isFixed]\n     * @returns {Element}\n     */\n    function getOffsetParent( element, isFixed ) {\n        if ( isFixed && element != document.body ) {\n            return document.body;\n        } else {\n            return element.offsetParent;\n        }\n    }\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - full-screen support functions\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ) {\n    /**\n     * Determine native full screen support we can get from the browser.\n     * @member fullScreenApi\n     * @memberof OpenSeadragon\n     * @type {object}\n     * @property {Boolean} supportsFullScreen Return true if full screen API is supported.\n     * @property {Function} isFullScreen Return true if currently in full screen mode.\n     * @property {Function} getFullScreenElement Return the element currently in full screen mode.\n     * @property {Function} requestFullScreen Make a request to go in full screen mode.\n     * @property {Function} exitFullScreen Make a request to exit full screen mode.\n     * @property {Function} cancelFullScreen Deprecated, use exitFullScreen instead.\n     * @property {String} fullScreenEventName Event fired when the full screen mode change.\n     * @property {String} fullScreenErrorEventName Event fired when a request to go\n     * in full screen mode failed.\n     */\n    var fullScreenApi = {\n        supportsFullScreen: false,\n        isFullScreen: function() { return false; },\n        getFullScreenElement: function() { return null; },\n        requestFullScreen: function() {},\n        exitFullScreen: function() {},\n        cancelFullScreen: function() {},\n        fullScreenEventName: \'\',\n        fullScreenErrorEventName: \'\'\n    };\n\n    // check for native support\n    if ( document.exitFullscreen ) {\n        // W3C standard\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.fullscreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.requestFullscreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.exitFullscreen();\n        };\n        fullScreenApi.fullScreenEventName = "fullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "fullscreenerror";\n    } else if ( document.msExitFullscreen ) {\n        // IE 11\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.msFullscreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.msRequestFullscreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.msExitFullscreen();\n        };\n        fullScreenApi.fullScreenEventName = "MSFullscreenChange";\n        fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";\n    } else if ( document.webkitExitFullscreen ) {\n        // Recent webkit\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.webkitFullscreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.webkitRequestFullscreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.webkitExitFullscreen();\n        };\n        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";\n    } else if ( document.webkitCancelFullScreen ) {\n        // Old webkit\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.webkitCurrentFullScreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.webkitRequestFullScreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.webkitCancelFullScreen();\n        };\n        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";\n    } else if ( document.mozCancelFullScreen ) {\n        // Firefox\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.mozFullScreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.mozRequestFullScreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.mozCancelFullScreen();\n        };\n        fullScreenApi.fullScreenEventName = "mozfullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";\n    }\n    fullScreenApi.isFullScreen = function() {\n        return fullScreenApi.getFullScreenElement() !== null;\n    };\n    fullScreenApi.cancelFullScreen = function() {\n        $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");\n        fullScreenApi.exitFullScreen();\n    };\n\n    // export api\n    $.extend( $, fullScreenApi );\n\n})( OpenSeadragon );\n\n/*\n * OpenSeadragon - EventSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($){\n\n/**\n * Event handler method signature used by all OpenSeadragon events.\n *\n * @callback EventHandler\n * @memberof OpenSeadragon\n * @param {Object} event - See individual events for event-specific properties.\n */\n\n\n/**\n * @class EventSource\n * @classdesc For use by classes which want to support custom, non-browser events.\n *\n * @memberof OpenSeadragon\n */\n$.EventSource = function() {\n    this.events = {};\n};\n\n/** @lends OpenSeadragon.EventSource.prototype */\n$.EventSource.prototype = {\n\n    /**\n     * Add an event handler to be triggered only once (or a given number of times)\n     * for a given event.\n     * @function\n     * @param {String} eventName - Name of event to register.\n     * @param {OpenSeadragon.EventHandler} handler - Function to call when event\n     * is triggered.\n     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged\n     * to the handler.\n     * @param {Number} [times=1] - The number of times to handle the event\n     * before removing it.\n     */\n    addOnceHandler: function(eventName, handler, userData, times) {\n        var self = this;\n        times = times || 1;\n        var count = 0;\n        var onceHandler = function(event) {\n            count++;\n            if (count === times) {\n                self.removeHandler(eventName, onceHandler);\n            }\n            handler(event);\n        };\n        this.addHandler(eventName, onceHandler, userData);\n    },\n\n    /**\n     * Add an event handler for a given event.\n     * @function\n     * @param {String} eventName - Name of event to register.\n     * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.\n     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.\n     */\n    addHandler: function ( eventName, handler, userData ) {\n        var events = this.events[ eventName ];\n        if ( !events ) {\n            this.events[ eventName ] = events = [];\n        }\n        if ( handler && $.isFunction( handler ) ) {\n            events[ events.length ] = { handler: handler, userData: userData || null };\n        }\n    },\n\n    /**\n     * Remove a specific event handler for a given event.\n     * @function\n     * @param {String} eventName - Name of event for which the handler is to be removed.\n     * @param {OpenSeadragon.EventHandler} handler - Function to be removed.\n     */\n    removeHandler: function ( eventName, handler ) {\n        var events = this.events[ eventName ],\n            handlers = [],\n            i;\n        if ( !events ) {\n            return;\n        }\n        if ( $.isArray( events ) ) {\n            for ( i = 0; i < events.length; i++ ) {\n                if ( events[i].handler !== handler ) {\n                    handlers.push( events[ i ] );\n                }\n            }\n            this.events[ eventName ] = handlers;\n        }\n    },\n\n\n    /**\n     * Remove all event handlers for a given event type. If no type is given all\n     * event handlers for every event type are removed.\n     * @function\n     * @param {String} eventName - Name of event for which all handlers are to be removed.\n     */\n    removeAllHandlers: function( eventName ) {\n        if ( eventName ){\n            this.events[ eventName ] = [];\n        } else{\n            for ( var eventType in this.events ) {\n                this.events[ eventType ] = [];\n            }\n        }\n    },\n\n    /**\n     * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.\n     * @function\n     * @param {String} eventName - Name of event to get handlers for.\n     */\n    getHandler: function ( eventName ) {\n        var events = this.events[ eventName ];\n        if ( !events || !events.length ) {\n            return null;\n        }\n        events = events.length === 1 ?\n            [ events[ 0 ] ] :\n            Array.apply( null, events );\n        return function ( source, args ) {\n            var i,\n                length = events.length;\n            for ( i = 0; i < length; i++ ) {\n                if ( events[ i ] ) {\n                    args.eventSource = source;\n                    args.userData = events[ i ].userData;\n                    events[ i ].handler( args );\n                }\n            }\n        };\n    },\n\n    /**\n     * Trigger an event, optionally passing additional information.\n     * @function\n     * @param {String} eventName - Name of event to register.\n     * @param {Object} eventArgs - Event-specific data.\n     */\n    raiseEvent: function( eventName, eventArgs ) {\n        //uncomment if you want to get a log of all events\n        //$.console.log( eventName );\n        var handler = this.getHandler( eventName );\n\n        if ( handler ) {\n            if ( !eventArgs ) {\n                eventArgs = {};\n            }\n\n            handler( this, eventArgs );\n        }\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - MouseTracker\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function ( $ ) {\n\n    // All MouseTracker instances\n    var MOUSETRACKERS  = [];\n\n    // dictionary from hash to private properties\n    var THIS           = {};\n\n\n    /**\n     * @class MouseTracker\n     * @classdesc Provides simplified handling of common pointer device (mouse, touch, pen, etc.) gestures\n     *            and keyboard events on a specified element.\n     * @memberof OpenSeadragon\n     * @param {Object} options\n     *      Allows configurable properties to be entirely specified by passing\n     *      an options object to the constructor.  The constructor also supports\n     *      the original positional arguments \'element\', \'clickTimeThreshold\',\n     *      and \'clickDistThreshold\' in that order.\n     * @param {Element|String} options.element\n     *      A reference to an element or an element id for which the pointer/key\n     *      events will be monitored.\n     * @param {Boolean} [options.startDisabled=false]\n     *      If true, event tracking on the element will not start until\n     *      {@link OpenSeadragon.MouseTracker.setTracking|setTracking} is called.\n     * @param {Number} options.clickTimeThreshold\n     *      The number of milliseconds within which a pointer down-up event combination\n     *      will be treated as a click gesture.\n     * @param {Number} options.clickDistThreshold\n     *      The maximum distance allowed between a pointer down event and a pointer up event\n     *      to be treated as a click gesture.\n     * @param {Number} options.dblClickTimeThreshold\n     *      The number of milliseconds within which two pointer down-up event combinations\n     *      will be treated as a double-click gesture.\n     * @param {Number} options.dblClickDistThreshold\n     *      The maximum distance allowed between two pointer click events\n     *      to be treated as a click gesture.\n     * @param {Number} [options.stopDelay=50]\n     *      The number of milliseconds without pointer move before the stop\n     *      event is fired.\n     * @param {OpenSeadragon.EventHandler} [options.enterHandler=null]\n     *      An optional handler for pointer enter.\n     * @param {OpenSeadragon.EventHandler} [options.exitHandler=null]\n     *      An optional handler for pointer exit.\n     * @param {OpenSeadragon.EventHandler} [options.pressHandler=null]\n     *      An optional handler for pointer press.\n     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryPressHandler=null]\n     *      An optional handler for pointer non-primary button press.\n     * @param {OpenSeadragon.EventHandler} [options.releaseHandler=null]\n     *      An optional handler for pointer release.\n     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryReleaseHandler=null]\n     *      An optional handler for pointer non-primary button release.\n     * @param {OpenSeadragon.EventHandler} [options.moveHandler=null]\n     *      An optional handler for pointer move.\n     * @param {OpenSeadragon.EventHandler} [options.scrollHandler=null]\n     *      An optional handler for mouse wheel scroll.\n     * @param {OpenSeadragon.EventHandler} [options.clickHandler=null]\n     *      An optional handler for pointer click.\n     * @param {OpenSeadragon.EventHandler} [options.dblClickHandler=null]\n     *      An optional handler for pointer double-click.\n     * @param {OpenSeadragon.EventHandler} [options.dragHandler=null]\n     *      An optional handler for the drag gesture.\n     * @param {OpenSeadragon.EventHandler} [options.dragEndHandler=null]\n     *      An optional handler for after a drag gesture.\n     * @param {OpenSeadragon.EventHandler} [options.pinchHandler=null]\n     *      An optional handler for the pinch gesture.\n     * @param {OpenSeadragon.EventHandler} [options.keyDownHandler=null]\n     *      An optional handler for keydown.\n     * @param {OpenSeadragon.EventHandler} [options.keyUpHandler=null]\n     *      An optional handler for keyup.\n     * @param {OpenSeadragon.EventHandler} [options.keyHandler=null]\n     *      An optional handler for keypress.\n     * @param {OpenSeadragon.EventHandler} [options.focusHandler=null]\n     *      An optional handler for focus.\n     * @param {OpenSeadragon.EventHandler} [options.blurHandler=null]\n     *      An optional handler for blur.\n     * @param {Object} [options.userData=null]\n     *      Arbitrary object to be passed unchanged to any attached handler methods.\n     */\n    $.MouseTracker = function ( options ) {\n\n        MOUSETRACKERS.push( this );\n\n        var args = arguments;\n\n        if ( !$.isPlainObject( options ) ) {\n            options = {\n                element:            args[ 0 ],\n                clickTimeThreshold: args[ 1 ],\n                clickDistThreshold: args[ 2 ]\n            };\n        }\n\n        this.hash               = Math.random(); // An unique hash for this tracker.\n        /**\n         * The element for which pointer events are being monitored.\n         * @member {Element} element\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.element            = $.getElement( options.element );\n        /**\n         * The number of milliseconds within which a pointer down-up event combination\n         * will be treated as a click gesture.\n         * @member {Number} clickTimeThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;\n        /**\n         * The maximum distance allowed between a pointer down event and a pointer up event\n         * to be treated as a click gesture.\n         * @member {Number} clickDistThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;\n        /**\n         * The number of milliseconds within which two pointer down-up event combinations\n         * will be treated as a double-click gesture.\n         * @member {Number} dblClickTimeThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.dblClickTimeThreshold = options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;\n        /**\n         * The maximum distance allowed between two pointer click events\n         * to be treated as a click gesture.\n         * @member {Number} clickDistThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;\n        this.userData              = options.userData          || null;\n        this.stopDelay             = options.stopDelay         || 50;\n\n        this.enterHandler             = options.enterHandler             || null;\n        this.exitHandler              = options.exitHandler              || null;\n        this.pressHandler             = options.pressHandler             || null;\n        this.nonPrimaryPressHandler   = options.nonPrimaryPressHandler   || null;\n        this.releaseHandler           = options.releaseHandler           || null;\n        this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;\n        this.moveHandler              = options.moveHandler              || null;\n        this.scrollHandler            = options.scrollHandler            || null;\n        this.clickHandler             = options.clickHandler             || null;\n        this.dblClickHandler          = options.dblClickHandler          || null;\n        this.dragHandler              = options.dragHandler              || null;\n        this.dragEndHandler           = options.dragEndHandler           || null;\n        this.pinchHandler             = options.pinchHandler             || null;\n        this.stopHandler              = options.stopHandler              || null;\n        this.keyDownHandler           = options.keyDownHandler           || null;\n        this.keyUpHandler             = options.keyUpHandler             || null;\n        this.keyHandler               = options.keyHandler               || null;\n        this.focusHandler             = options.focusHandler             || null;\n        this.blurHandler              = options.blurHandler              || null;\n\n        //Store private properties in a scope sealed hash map\n        var _this = this;\n\n        /**\n         * @private\n         * @property {Boolean} tracking\n         *      Are we currently tracking pointer events for this element.\n         */\n        THIS[ this.hash ] = {\n            click:                 function ( event ) { onClick( _this, event ); },\n            dblclick:              function ( event ) { onDblClick( _this, event ); },\n            keydown:               function ( event ) { onKeyDown( _this, event ); },\n            keyup:                 function ( event ) { onKeyUp( _this, event ); },\n            keypress:              function ( event ) { onKeyPress( _this, event ); },\n            focus:                 function ( event ) { onFocus( _this, event ); },\n            blur:                  function ( event ) { onBlur( _this, event ); },\n\n            wheel:                 function ( event ) { onWheel( _this, event ); },\n            mousewheel:            function ( event ) { onMouseWheel( _this, event ); },\n            DOMMouseScroll:        function ( event ) { onMouseWheel( _this, event ); },\n            MozMousePixelScroll:   function ( event ) { onMouseWheel( _this, event ); },\n\n            mouseenter:            function ( event ) { onMouseEnter( _this, event ); }, // Used on IE8 only\n            mouseleave:            function ( event ) { onMouseLeave( _this, event ); }, // Used on IE8 only\n            mouseover:             function ( event ) { onMouseOver( _this, event ); },\n            mouseout:              function ( event ) { onMouseOut( _this, event ); },\n            mousedown:             function ( event ) { onMouseDown( _this, event ); },\n            mouseup:               function ( event ) { onMouseUp( _this, event ); },\n            mouseupcaptured:       function ( event ) { onMouseUpCaptured( _this, event ); },\n            mousemove:             function ( event ) { onMouseMove( _this, event ); },\n            mousemovecaptured:     function ( event ) { onMouseMoveCaptured( _this, event ); },\n\n            touchstart:            function ( event ) { onTouchStart( _this, event ); },\n            touchend:              function ( event ) { onTouchEnd( _this, event ); },\n            touchendcaptured:      function ( event ) { onTouchEndCaptured( _this, event ); },\n            touchmove:             function ( event ) { onTouchMove( _this, event ); },\n            touchmovecaptured:     function ( event ) { onTouchMoveCaptured( _this, event ); },\n            touchcancel:           function ( event ) { onTouchCancel( _this, event ); },\n\n            gesturestart:          function ( event ) { onGestureStart( _this, event ); },\n            gesturechange:         function ( event ) { onGestureChange( _this, event ); },\n\n            pointerover:           function ( event ) { onPointerOver( _this, event ); },\n            MSPointerOver:         function ( event ) { onPointerOver( _this, event ); },\n            pointerout:            function ( event ) { onPointerOut( _this, event ); },\n            MSPointerOut:          function ( event ) { onPointerOut( _this, event ); },\n            pointerdown:           function ( event ) { onPointerDown( _this, event ); },\n            MSPointerDown:         function ( event ) { onPointerDown( _this, event ); },\n            pointerup:             function ( event ) { onPointerUp( _this, event ); },\n            MSPointerUp:           function ( event ) { onPointerUp( _this, event ); },\n            pointermove:           function ( event ) { onPointerMove( _this, event ); },\n            MSPointerMove:         function ( event ) { onPointerMove( _this, event ); },\n            pointercancel:         function ( event ) { onPointerCancel( _this, event ); },\n            MSPointerCancel:       function ( event ) { onPointerCancel( _this, event ); },\n            pointerupcaptured:     function ( event ) { onPointerUpCaptured( _this, event ); },\n            pointermovecaptured:   function ( event ) { onPointerMoveCaptured( _this, event ); },\n\n            tracking:              false,\n\n            // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.\n            // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).\n            // Active pointers are any pointer being tracked for this element which are in the hit-test area\n            //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.\n            activePointersLists:   [],\n\n            // Tracking for double-click gesture\n            lastClickPos:          null,\n            dblClickTimeOut:       null,\n\n            // Tracking for pinch gesture\n            pinchGPoints:          [],\n            lastPinchDist:         0,\n            currentPinchDist:      0,\n            lastPinchCenter:       null,\n            currentPinchCenter:    null\n        };\n\n        if ( !options.startDisabled ) {\n            this.setTracking( true );\n        }\n    };\n\n    /** @lends OpenSeadragon.MouseTracker.prototype */\n    $.MouseTracker.prototype = {\n\n        /**\n         * Clean up any events or objects created by the tracker.\n         * @function\n         */\n        destroy: function () {\n            var i;\n\n            stopTracking( this );\n            this.element = null;\n\n            for ( i = 0; i < MOUSETRACKERS.length; i++ ) {\n                if ( MOUSETRACKERS[ i ] === this ) {\n                    MOUSETRACKERS.splice( i, 1 );\n                    break;\n                }\n            }\n\n            THIS[ this.hash ] = null;\n            delete THIS[ this.hash ];\n        },\n\n        /**\n         * Are we currently tracking events on this element.\n         * @deprecated Just use this.tracking\n         * @function\n         * @returns {Boolean} Are we currently tracking events on this element.\n         */\n        isTracking: function () {\n            return THIS[ this.hash ].tracking;\n        },\n\n        /**\n         * Enable or disable whether or not we are tracking events on this element.\n         * @function\n         * @param {Boolean} track True to start tracking, false to stop tracking.\n         * @returns {OpenSeadragon.MouseTracker} Chainable.\n         */\n        setTracking: function ( track ) {\n            if ( track ) {\n                startTracking( this );\n            } else {\n                stopTracking( this );\n            }\n            //chain\n            return this;\n        },\n\n        /**\n         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,\n         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn\'t already exist for the type.\n         * @function\n         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.\n         * @returns {OpenSeadragon.MouseTracker.GesturePointList}\n         */\n        getActivePointersListByType: function ( type ) {\n            var delegate = THIS[ this.hash ],\n                i,\n                len = delegate.activePointersLists.length,\n                list;\n\n            for ( i = 0; i < len; i++ ) {\n                if ( delegate.activePointersLists[ i ].type === type ) {\n                    return delegate.activePointersLists[ i ];\n                }\n            }\n\n            list = new $.MouseTracker.GesturePointList( type );\n            delegate.activePointersLists.push( list );\n            return list;\n        },\n\n        /**\n         * Returns the total number of pointers currently active on the tracked element.\n         * @function\n         * @returns {Number}\n         */\n        getActivePointerCount: function () {\n            var delegate = THIS[ this.hash ],\n                i,\n                len = delegate.activePointersLists.length,\n                count = 0;\n\n            for ( i = 0; i < len; i++ ) {\n                count += delegate.activePointersLists[ i ].getLength();\n            }\n\n            return count;\n        },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Number} event.pointers\n         *      Number of pointers (all types) active in the tracked element.\n         * @param {Boolean} event.insideElementPressed\n         *      True if the left mouse button is currently being pressed and was\n         *      initiated inside the tracked element, otherwise false.\n         * @param {Boolean} event.buttonDownAny\n         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        enterHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Number} event.pointers\n         *      Number of pointers (all types) active in the tracked element.\n         * @param {Boolean} event.insideElementPressed\n         *      True if the left mouse button is currently being pressed and was\n         *      initiated inside the tracked element, otherwise false.\n         * @param {Boolean} event.buttonDownAny\n         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        exitHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        pressHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.button\n         *      Button which caused the event.\n         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        nonPrimaryPressHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.insideElementPressed\n         *      True if the left mouse button is currently being pressed and was\n         *      initiated inside the tracked element, otherwise false.\n         * @param {Boolean} event.insideElementReleased\n         *      True if the cursor inside the tracked element when the button was released.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        releaseHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.button\n         *      Button which caused the event.\n         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        nonPrimaryReleaseHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        moveHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.scroll\n         *      The scroll delta for the event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        scrollHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Boolean} event.quick\n         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        clickHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        dblClickHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {OpenSeadragon.Point} event.delta\n         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.\n         * @param {Number} event.speed\n         *     Current computed speed, in pixels per second.\n         * @param {Number} event.direction\n         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        dragHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.speed\n         *     Speed at the end of a drag gesture, in pixels per second.\n         * @param {Number} event.direction\n         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        dragEndHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints\n         *      Gesture points associated with the gesture. Velocity data can be found here.\n         * @param {OpenSeadragon.Point} event.lastCenter\n         *      The previous center point of the two pinch contact points relative to the tracked element.\n         * @param {OpenSeadragon.Point} event.center\n         *      The center point of the two pinch contact points relative to the tracked element.\n         * @param {Number} event.lastDistance\n         *      The previous distance between the two pinch contact points in CSS pixels.\n         * @param {Number} event.distance\n         *      The distance between the two pinch contact points in CSS pixels.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        pinchHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        stopHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Number} event.keyCode\n         *      The key code that was pressed.\n         * @param {Boolean} event.ctrl\n         *      True if the ctrl key was pressed during this event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.alt\n         *      True if the alt key was pressed during this event.\n         * @param {Boolean} event.meta\n         *      True if the meta key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        keyDownHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Number} event.keyCode\n         *      The key code that was pressed.\n         * @param {Boolean} event.ctrl\n         *      True if the ctrl key was pressed during this event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.alt\n         *      True if the alt key was pressed during this event.\n         * @param {Boolean} event.meta\n         *      True if the meta key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        keyUpHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Number} event.keyCode\n         *      The key code that was pressed.\n         * @param {Boolean} event.ctrl\n         *      True if the ctrl key was pressed during this event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.alt\n         *      True if the alt key was pressed during this event.\n         * @param {Boolean} event.meta\n         *      True if the meta key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        keyHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        focusHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        blurHandler: function () { }\n    };\n\n\n    /**\n     * Provides continuous computation of velocity (speed and direction) of active pointers.\n     * This is a singleton, used by all MouseTracker instances, as it is unlikely there will ever be more than\n     * two active gesture pointers at a time.\n     *\n     * @private\n     * @member gesturePointVelocityTracker\n     * @memberof OpenSeadragon.MouseTracker\n     */\n    $.MouseTracker.gesturePointVelocityTracker = (function () {\n        var trackerPoints = [],\n            intervalId = 0,\n            lastTime = 0;\n\n        // Generates a unique identifier for a tracked gesture point\n        var _generateGuid = function ( tracker, gPoint ) {\n            return tracker.hash.toString() + gPoint.type + gPoint.id.toString();\n        };\n\n        // Interval timer callback. Computes velocity for all tracked gesture points.\n        var _doTracking = function () {\n            var i,\n                len = trackerPoints.length,\n                trackPoint,\n                gPoint,\n                now = $.now(),\n                elapsedTime,\n                distance,\n                speed;\n\n            elapsedTime = now - lastTime;\n            lastTime = now;\n\n            for ( i = 0; i < len; i++ ) {\n                trackPoint = trackerPoints[ i ];\n                gPoint = trackPoint.gPoint;\n                // Math.atan2 gives us just what we need for a velocity vector, as we can simply\n                //   use cos()/sin() to extract the x/y velocity components.\n                gPoint.direction = Math.atan2( gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x );\n                // speed = distance / elapsed time\n                distance = trackPoint.lastPos.distanceTo( gPoint.currentPos );\n                trackPoint.lastPos = gPoint.currentPos;\n                speed = 1000 * distance / ( elapsedTime + 1 );\n                // Simple biased average, favors the most recent speed computation. Smooths out erratic gestures a bit.\n                gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;\n            }\n        };\n\n        // Public. Add a gesture point to be tracked\n        var addPoint = function ( tracker, gPoint ) {\n            var guid = _generateGuid( tracker, gPoint );\n\n            trackerPoints.push(\n                {\n                    guid: guid,\n                    gPoint: gPoint,\n                    lastPos: gPoint.currentPos\n                } );\n\n            // Only fire up the interval timer when there\'s gesture pointers to track\n            if ( trackerPoints.length === 1 ) {\n                lastTime = $.now();\n                intervalId = window.setInterval( _doTracking, 50 );\n            }\n        };\n\n        // Public. Stop tracking a gesture point\n        var removePoint = function ( tracker, gPoint ) {\n            var guid = _generateGuid( tracker, gPoint ),\n                i,\n                len = trackerPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( trackerPoints[ i ].guid === guid ) {\n                    trackerPoints.splice( i, 1 );\n                    // Only run the interval timer if theres gesture pointers to track\n                    len--;\n                    if ( len === 0 ) {\n                        window.clearInterval( intervalId );\n                    }\n                    break;\n                }\n            }\n        };\n\n        return {\n            addPoint:    addPoint,\n            removePoint: removePoint\n        };\n    } )();\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Pointer event model and feature detection\n///////////////////////////////////////////////////////////////////////////////\n\n    $.MouseTracker.captureElement = document;\n\n    /**\n     * Detect available mouse wheel event name.\n     */\n    $.MouseTracker.wheelEventName = ( $.Browser.vendor == $.BROWSERS.IE && $.Browser.version > 8 ) ||\n                                                ( \'onwheel\' in document.createElement( \'div\' ) ) ? \'wheel\' : // Modern browsers support \'wheel\'\n                                    document.onmousewheel !== undefined ? \'mousewheel\' :                     // Webkit and IE support at least \'mousewheel\'\n                                    \'DOMMouseScroll\';                                                        // Assume old Firefox\n\n    /**\n     * Detect legacy mouse capture support.\n     */\n    $.MouseTracker.supportsMouseCapture = (function () {\n        var divElement = document.createElement( \'div\' );\n        return $.isFunction( divElement.setCapture ) && $.isFunction( divElement.releaseCapture );\n    }());\n\n    /**\n     * Detect browser pointer device event model(s) and build appropriate list of events to subscribe to.\n     */\n    $.MouseTracker.subscribeEvents = [ "click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", $.MouseTracker.wheelEventName ];\n\n    if( $.MouseTracker.wheelEventName == "DOMMouseScroll" ) {\n        // Older Firefox\n        $.MouseTracker.subscribeEvents.push( "MozMousePixelScroll" );\n    }\n\n    // Note: window.navigator.pointerEnable is deprecated on IE 11 and not part of W3C spec.\n    if ( window.PointerEvent && ( window.navigator.pointerEnabled || $.Browser.vendor !== $.BROWSERS.IE ) ) {\n        // IE11 and other W3C Pointer Event implementations (see http://www.w3.org/TR/pointerevents)\n        $.MouseTracker.havePointerEvents = true;\n        $.MouseTracker.subscribeEvents.push( "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel" );\n        $.MouseTracker.unprefixedPointerEvents = true;\n        if( navigator.maxTouchPoints ) {\n            $.MouseTracker.maxTouchPoints = navigator.maxTouchPoints;\n        } else {\n            $.MouseTracker.maxTouchPoints = 0;\n        }\n        $.MouseTracker.haveMouseEnter = false;\n    } else if ( window.MSPointerEvent && window.navigator.msPointerEnabled ) {\n        // IE10\n        $.MouseTracker.havePointerEvents = true;\n        $.MouseTracker.subscribeEvents.push( "MSPointerOver", "MSPointerOut", "MSPointerDown", "MSPointerUp", "MSPointerMove", "MSPointerCancel" );\n        $.MouseTracker.unprefixedPointerEvents = false;\n        if( navigator.msMaxTouchPoints ) {\n            $.MouseTracker.maxTouchPoints = navigator.msMaxTouchPoints;\n        } else {\n            $.MouseTracker.maxTouchPoints = 0;\n        }\n        $.MouseTracker.haveMouseEnter = false;\n    } else {\n        // Legacy W3C mouse events\n        $.MouseTracker.havePointerEvents = false;\n        if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n            $.MouseTracker.subscribeEvents.push( "mouseenter", "mouseleave" );\n            $.MouseTracker.haveMouseEnter = true;\n        } else {\n            $.MouseTracker.subscribeEvents.push( "mouseover", "mouseout" );\n            $.MouseTracker.haveMouseEnter = false;\n        }\n        $.MouseTracker.subscribeEvents.push( "mousedown", "mouseup", "mousemove" );\n        if ( \'ontouchstart\' in window ) {\n            // iOS, Android, and other W3c Touch Event implementations\n            //    (see http://www.w3.org/TR/touch-events/)\n            //    (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)\n            //    (see https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)\n            $.MouseTracker.subscribeEvents.push( "touchstart", "touchend", "touchmove", "touchcancel" );\n        }\n        if ( \'ongesturestart\' in window ) {\n            // iOS (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)\n            //   Subscribe to these to prevent default gesture handling\n            $.MouseTracker.subscribeEvents.push( "gesturestart", "gesturechange" );\n        }\n        $.MouseTracker.mousePointerId = "legacy-mouse";\n        $.MouseTracker.maxTouchPoints = 10;\n    }\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Classes and typedefs\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Represents a point of contact on the screen made by a mouse cursor, pen, touch, or other pointer device.\n     *\n     * @typedef {Object} GesturePoint\n     * @memberof OpenSeadragon.MouseTracker\n     *\n     * @property {Number} id\n     *     Identifier unique from all other active GesturePoints for a given pointer device.\n     * @property {String} type\n     *     The pointer device type: "mouse", "touch", "pen", etc.\n     * @property {Boolean} captured\n     *     True if events for the gesture point are captured to the tracked element.\n     * @property {Boolean} isPrimary\n     *     True if the gesture point is a master pointer amongst the set of active pointers for each pointer type. True for mouse and primary (first) touch/pen pointers.\n     * @property {Boolean} insideElementPressed\n     *     True if button pressed or contact point initiated inside the screen area of the tracked element.\n     * @property {Boolean} insideElement\n     *     True if pointer or contact point is currently inside the bounds of the tracked element.\n     * @property {Number} speed\n     *     Current computed speed, in pixels per second.\n     * @property {Number} direction\n     *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n     * @property {OpenSeadragon.Point} contactPos\n     *     The initial pointer contact position, relative to the page including any scrolling. Only valid if the pointer has contact (pressed, touch contact, pen contact).\n     * @property {Number} contactTime\n     *     The initial pointer contact time, in milliseconds. Only valid if the pointer has contact (pressed, touch contact, pen contact).\n     * @property {OpenSeadragon.Point} lastPos\n     *     The last pointer position, relative to the page including any scrolling.\n     * @property {Number} lastTime\n     *     The last pointer contact time, in milliseconds.\n     * @property {OpenSeadragon.Point} currentPos\n     *     The current pointer position, relative to the page including any scrolling.\n     * @property {Number} currentTime\n     *     The current pointer contact time, in milliseconds.\n     */\n\n\n    /**\n     * @class GesturePointList\n     * @classdesc Provides an abstraction for a set of active {@link OpenSeadragon.MouseTracker.GesturePoint|GesturePoint} objects for a given pointer device type.\n     *            Active pointers are any pointer being tracked for this element which are in the hit-test area\n     *            of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.\n     * @memberof OpenSeadragon.MouseTracker\n     * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.\n     */\n    $.MouseTracker.GesturePointList = function ( type ) {\n        this._gPoints = [];\n        /**\n         * The pointer device type: "mouse", "touch", "pen", etc.\n         * @member {String} type\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.type = type;\n        /**\n         * Current buttons pressed for the device.\n         * Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @member {Number} buttons\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.buttons = 0;\n        /**\n         * Current number of contact points (touch points, mouse down, etc.) for the device.\n         * @member {Number} contacts\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.contacts = 0;\n        /**\n         * Current number of clicks for the device. Used for multiple click gesture tracking.\n         * @member {Number} clicks\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.clicks = 0;\n        /**\n         * Current number of captured pointers for the device.\n         * @member {Number} captureCount\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.captureCount = 0;\n    };\n\n    /** @lends OpenSeadragon.MouseTracker.GesturePointList.prototype */\n    $.MouseTracker.GesturePointList.prototype = {\n        /**\n         * @function\n         * @returns {Number} Number of gesture points in the list.\n         */\n        getLength: function () {\n            return this._gPoints.length;\n        },\n        /**\n         * @function\n         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).\n         */\n        asArray: function () {\n            return this._gPoints;\n        },\n        /**\n         * @function\n         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.\n         * @returns {Number} Number of gesture points in the list.\n         */\n        add: function ( gp ) {\n            return this._gPoints.push( gp );\n        },\n        /**\n         * @function\n         * @param {Number} id - The id of the gesture point to remove from the list.\n         * @returns {Number} Number of gesture points in the list.\n         */\n        removeById: function ( id ) {\n            var i,\n                len = this._gPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( this._gPoints[ i ].id === id ) {\n                    this._gPoints.splice( i, 1 );\n                    break;\n                }\n            }\n            return this._gPoints.length;\n        },\n        /**\n         * @function\n         * @param {Number} index - The index of the gesture point to retrieve from the list.\n         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.\n         */\n        getByIndex: function ( index ) {\n            if ( index < this._gPoints.length) {\n                return this._gPoints[ index ];\n            }\n\n            return null;\n        },\n        /**\n         * @function\n         * @param {Number} id - The id of the gesture point to retrieve from the list.\n         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.\n         */\n        getById: function ( id ) {\n            var i,\n                len = this._gPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( this._gPoints[ i ].id === id ) {\n                    return this._gPoints[ i ];\n                }\n            }\n            return null;\n        },\n        /**\n         * @function\n         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.\n         */\n        getPrimary: function ( id ) {\n            var i,\n                len = this._gPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( this._gPoints[ i ].isPrimary ) {\n                    return this._gPoints[ i ];\n                }\n            }\n            return null;\n        }\n    };\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Utility functions\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Removes all tracked pointers.\n     * @private\n     * @inner\n     */\n    function clearTrackedPointers( tracker ) {\n        var delegate = THIS[ tracker.hash ],\n            i,\n            pointerListCount = delegate.activePointersLists.length;\n\n        for ( i = 0; i < pointerListCount; i++ ) {\n            if ( delegate.activePointersLists[ i ].captureCount > 0 ) {\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'mousemove\',\n                    delegate.mousemovecaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'mouseup\',\n                    delegate.mouseupcaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    $.MouseTracker.unprefixedPointerEvents ? \'pointermove\' : \'MSPointerMove\',\n                    delegate.pointermovecaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    $.MouseTracker.unprefixedPointerEvents ? \'pointerup\' : \'MSPointerUp\',\n                    delegate.pointerupcaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'touchmove\',\n                    delegate.touchmovecaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'touchend\',\n                    delegate.touchendcaptured,\n                    true\n                );\n\n                delegate.activePointersLists[ i ].captureCount = 0;\n            }\n        }\n\n        for ( i = 0; i < pointerListCount; i++ ) {\n            delegate.activePointersLists.pop();\n        }\n    }\n\n    /**\n     * Starts tracking pointer events on the tracked element.\n     * @private\n     * @inner\n     */\n    function startTracking( tracker ) {\n        var delegate = THIS[ tracker.hash ],\n            event,\n            i;\n\n        if ( !delegate.tracking ) {\n            for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {\n                event = $.MouseTracker.subscribeEvents[ i ];\n                $.addEvent(\n                    tracker.element,\n                    event,\n                    delegate[ event ],\n                    false\n                );\n            }\n\n            clearTrackedPointers( tracker );\n\n            delegate.tracking = true;\n        }\n    }\n\n    /**\n     * Stops tracking pointer events on the tracked element.\n     * @private\n     * @inner\n     */\n    function stopTracking( tracker ) {\n        var delegate = THIS[ tracker.hash ],\n            event,\n            i;\n\n        if ( delegate.tracking ) {\n            for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {\n                event = $.MouseTracker.subscribeEvents[ i ];\n                $.removeEvent(\n                    tracker.element,\n                    event,\n                    delegate[ event ],\n                    false\n                );\n            }\n\n            clearTrackedPointers( tracker );\n\n            delegate.tracking = false;\n        }\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getCaptureEventParams( tracker, pointerType ) {\n        var delegate = THIS[ tracker.hash ];\n\n        if ( pointerType === \'pointerevent\' ) {\n            return {\n                upName: $.MouseTracker.unprefixedPointerEvents ? \'pointerup\' : \'MSPointerUp\',\n                upHandler: delegate.pointerupcaptured,\n                moveName: $.MouseTracker.unprefixedPointerEvents ? \'pointermove\' : \'MSPointerMove\',\n                moveHandler: delegate.pointermovecaptured\n            };\n        } else if ( pointerType === \'mouse\' ) {\n            return {\n                upName: \'mouseup\',\n                upHandler: delegate.mouseupcaptured,\n                moveName: \'mousemove\',\n                moveHandler: delegate.mousemovecaptured\n            };\n        } else if ( pointerType === \'touch\' ) {\n            return {\n                upName: \'touchend\',\n                upHandler: delegate.touchendcaptured,\n                moveName: \'touchmove\',\n                moveHandler: delegate.touchmovecaptured\n            };\n        } else {\n            throw new Error( "MouseTracker.getCaptureEventParams: Unknown pointer type." );\n        }\n    }\n\n    /**\n     * Begin capturing pointer events to the tracked element.\n     * @private\n     * @inner\n     */\n    function capturePointer( tracker, pointerType, pointerCount ) {\n        var pointsList = tracker.getActivePointersListByType( pointerType ),\n            eventParams;\n\n        pointsList.captureCount += (pointerCount || 1);\n\n        if ( pointsList.captureCount === 1 ) {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                tracker.element.setCapture( true );\n            } else {\n                eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? \'pointerevent\' : pointerType );\n                // We emulate mouse capture by hanging listeners on the document object.\n                //    (Note we listen on the capture phase so the captured handlers will get called first)\n                if (isInIframe && canAccessEvents(window.top)) {\n                    $.addEvent(\n                        window.top,\n                        eventParams.upName,\n                        eventParams.upHandler,\n                        true\n                    );\n                }\n                $.addEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.upName,\n                    eventParams.upHandler,\n                    true\n                );\n                $.addEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.moveName,\n                    eventParams.moveHandler,\n                    true\n                );\n            }\n        }\n    }\n\n\n    /**\n     * Stop capturing pointer events to the tracked element.\n     * @private\n     * @inner\n     */\n    function releasePointer( tracker, pointerType, pointerCount ) {\n        var pointsList = tracker.getActivePointersListByType( pointerType ),\n            eventParams;\n\n        pointsList.captureCount -= (pointerCount || 1);\n\n        if ( pointsList.captureCount === 0 ) {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                tracker.element.releaseCapture();\n            } else {\n                eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? \'pointerevent\' : pointerType );\n                // We emulate mouse capture by hanging listeners on the document object.\n                //    (Note we listen on the capture phase so the captured handlers will get called first)\n                if (isInIframe && canAccessEvents(window.top)) {\n                    $.removeEvent(\n                        window.top,\n                        eventParams.upName,\n                        eventParams.upHandler,\n                        true\n                    );\n                }\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.moveName,\n                    eventParams.moveHandler,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.upName,\n                    eventParams.upHandler,\n                    true\n                );\n            }\n        }\n    }\n\n\n    /**\n     * Gets a W3C Pointer Events model compatible pointer type string from a DOM pointer event.\n     * IE10 used a long integer value, but the W3C specification (and IE11+) use a string "mouse", "touch", "pen", etc.\n     * @private\n     * @inner\n     */\n    function getPointerType( event ) {\n        var pointerTypeStr;\n        if ( $.MouseTracker.unprefixedPointerEvents ) {\n            pointerTypeStr = event.pointerType;\n        } else {\n            // IE10\n            //  MSPOINTER_TYPE_TOUCH: 0x00000002\n            //  MSPOINTER_TYPE_PEN:   0x00000003\n            //  MSPOINTER_TYPE_MOUSE: 0x00000004\n            switch( event.pointerType )\n            {\n                case 0x00000002:\n                    pointerTypeStr = \'touch\';\n                    break;\n                case 0x00000003:\n                    pointerTypeStr = \'pen\';\n                    break;\n                case 0x00000004:\n                    pointerTypeStr = \'mouse\';\n                    break;\n                default:\n                    pointerTypeStr = \'\';\n            }\n        }\n        return pointerTypeStr;\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function getMouseAbsolute( event ) {\n        return $.getMousePosition( event );\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getMouseRelative( event, element ) {\n        return getPointRelativeToAbsolute( getMouseAbsolute( event ), element );\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getPointRelativeToAbsolute( point, element ) {\n        var offset = $.getElementOffset( element );\n        return point.minus( offset );\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getCenterPoint( point1, point2 ) {\n        return new $.Point( ( point1.x + point2.x ) / 2, ( point1.y + point2.y ) / 2 );\n    }\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Device-specific DOM event handlers\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @private\n     * @inner\n     */\n    function onClick( tracker, event ) {\n        if ( tracker.clickHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onDblClick( tracker, event ) {\n        if ( tracker.dblClickHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onKeyDown( tracker, event ) {\n        //$.console.log( "keydown %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );\n        var propagate;\n        if ( tracker.keyDownHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.keyDownHandler(\n                {\n                    eventSource:          tracker,\n                    keyCode:              event.keyCode ? event.keyCode : event.charCode,\n                    ctrl:                 event.ctrlKey,\n                    shift:                event.shiftKey,\n                    alt:                  event.altKey,\n                    meta:                 event.metaKey,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( !propagate ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onKeyUp( tracker, event ) {\n        //$.console.log( "keyup %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );\n        var propagate;\n        if ( tracker.keyUpHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.keyUpHandler(\n                {\n                    eventSource:          tracker,\n                    keyCode:              event.keyCode ? event.keyCode : event.charCode,\n                    ctrl:                 event.ctrlKey,\n                    shift:                event.shiftKey,\n                    alt:                  event.altKey,\n                    meta:                 event.metaKey,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( !propagate ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onKeyPress( tracker, event ) {\n        //$.console.log( "keypress %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );\n        var propagate;\n        if ( tracker.keyHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.keyHandler(\n                {\n                    eventSource:          tracker,\n                    keyCode:              event.keyCode ? event.keyCode : event.charCode,\n                    ctrl:                 event.ctrlKey,\n                    shift:                event.shiftKey,\n                    alt:                  event.altKey,\n                    meta:                 event.metaKey,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( !propagate ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onFocus( tracker, event ) {\n        //console.log( "focus %s", event );\n        var propagate;\n        if ( tracker.focusHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.focusHandler(\n                {\n                    eventSource:          tracker,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( propagate === false ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onBlur( tracker, event ) {\n        //console.log( "blur %s", event );\n        var propagate;\n        if ( tracker.blurHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.blurHandler(\n                {\n                    eventSource:          tracker,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( propagate === false ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * Handler for \'wheel\' events\n     *\n     * @private\n     * @inner\n     */\n    function onWheel( tracker, event ) {\n        handleWheelEvent( tracker, event, event );\n    }\n\n\n    /**\n     * Handler for \'mousewheel\', \'DOMMouseScroll\', and \'MozMousePixelScroll\' events\n     *\n     * @private\n     * @inner\n     */\n    function onMouseWheel( tracker, event ) {\n        event = $.getEvent( event );\n\n        // Simulate a \'wheel\' event\n        var simulatedEvent = {\n            target:     event.target || event.srcElement,\n            type:       "wheel",\n            shiftKey:   event.shiftKey || false,\n            clientX:    event.clientX,\n            clientY:    event.clientY,\n            pageX:      event.pageX ? event.pageX : event.clientX,\n            pageY:      event.pageY ? event.pageY : event.clientY,\n            deltaMode:  event.type == "MozMousePixelScroll" ? 0 : 1, // 0=pixel, 1=line, 2=page\n            deltaX:     0,\n            deltaZ:     0\n        };\n\n        // Calculate deltaY\n        if ( $.MouseTracker.wheelEventName == "mousewheel" ) {\n            simulatedEvent.deltaY = - 1 / $.DEFAULT_SETTINGS.pixelsPerWheelLine * event.wheelDelta;\n        } else {\n            simulatedEvent.deltaY = event.detail;\n        }\n\n        handleWheelEvent( tracker, simulatedEvent, event );\n    }\n\n\n    /**\n     * Handles \'wheel\' events.\n     * The event may be simulated by the legacy mouse wheel event handler (onMouseWheel()).\n     *\n     * @private\n     * @inner\n     */\n    function handleWheelEvent( tracker, event, originalEvent ) {\n        var nDelta = 0,\n            propagate;\n\n        // The nDelta variable is gated to provide smooth z-index scrolling\n        //   since the mouse wheel allows for substantial deltas meant for rapid\n        //   y-index scrolling.\n        // event.deltaMode: 0=pixel, 1=line, 2=page\n        // TODO: Deltas in pixel mode should be accumulated then a scroll value computed after $.DEFAULT_SETTINGS.pixelsPerWheelLine threshold reached\n        nDelta = event.deltaY < 0 ? 1 : -1;\n\n        if ( tracker.scrollHandler ) {\n            propagate = tracker.scrollHandler(\n                {\n                    eventSource:          tracker,\n                    pointerType:          \'mouse\',\n                    position:             getMouseRelative( event, tracker.element ),\n                    scroll:               nDelta,\n                    shift:                event.shiftKey,\n                    isTouchEvent:         false,\n                    originalEvent:        originalEvent,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( propagate === false ) {\n                $.cancelEvent( originalEvent );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function isParentChild( parent, child )\n    {\n       if ( parent === child ) {\n           return false;\n       }\n       while ( child && child !== parent ) {\n           child = child.parentNode;\n       }\n       return child === parent;\n    }\n\n\n    /**\n     * Only used on IE 8\n     *\n     * @private\n     * @inner\n     */\n    function onMouseEnter( tracker, event ) {\n        event = $.getEvent( event );\n\n        handleMouseEnter( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseOver( tracker, event ) {\n        event = $.getEvent( event );\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        handleMouseEnter( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseEnter( tracker, event ) {\n        var gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersEnter( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * Only used on IE 8\n     *\n     * @private\n     * @inner\n     */\n    function onMouseLeave( tracker, event ) {\n        event = $.getEvent( event );\n\n        handleMouseExit( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseOut( tracker, event ) {\n        event = $.getEvent( event );\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        handleMouseExit( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseExit( tracker, event ) {\n        var gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersExit( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * Returns a W3C DOM level 3 standard button value given an event.button property:\n     *   -1 == none, 0 == primary/left, 1 == middle, 2 == secondary/right, 3 == X1/back, 4 == X2/forward, 5 == eraser (pen)\n     * @private\n     * @inner\n     */\n    function getStandardizedButton( button ) {\n        if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n            // On IE 8, 0 == none, 1 == left, 2 == right, 3 == left and right, 4 == middle, 5 == left and middle, 6 == right and middle, 7 == all three\n            // TODO: Support chorded (multiple) button presses on IE 8?\n            if ( button === 1 ) {\n                return 0;\n            } else if ( button === 2 ) {\n                return 2;\n            } else if ( button === 4 ) {\n                return 1;\n            } else {\n                return -1;\n            }\n        } else {\n            return button;\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseDown( tracker, event ) {\n        var gPoint;\n\n        event = $.getEvent( event );\n\n        gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersDown( tracker, event, [ gPoint ], getStandardizedButton( event.button ) ) ) {\n            $.stopEvent( event );\n            capturePointer( tracker, \'mouse\' );\n        }\n\n        if ( tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseUp( tracker, event ) {\n        handleMouseUp( tracker, event );\n    }\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onMouseUp is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onMouseUpCaptured( tracker, event ) {\n        handleMouseUp( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseUp( tracker, event ) {\n        var gPoint;\n\n        event = $.getEvent( event );\n\n        gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersUp( tracker, event, [ gPoint ], getStandardizedButton( event.button ) ) ) {\n            releasePointer( tracker, \'mouse\' );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseMove( tracker, event ) {\n        handleMouseMove( tracker, event );\n   }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onMouseMove is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onMouseMoveCaptured( tracker, event ) {\n        handleMouseMove( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseMove( tracker, event ) {\n        var gPoint;\n\n        event = $.getEvent( event );\n\n        gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersMove( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function abortTouchContacts( tracker, event, pointsList ) {\n        var i,\n            gPointCount = pointsList.getLength(),\n            abortGPoints = [];\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            abortGPoints.push( pointsList.getByIndex( i ) );\n        }\n\n        if ( abortGPoints.length > 0 ) {\n            // simulate touchend\n            updatePointersUp( tracker, event, abortGPoints, 0 ); // 0 means primary button press/release or touch contact\n            // release pointer capture\n            pointsList.captureCount = 1;\n            releasePointer( tracker, \'touch\' );\n            // simulate touchleave\n            updatePointersExit( tracker, event, abortGPoints );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchStart( tracker, event ) {\n        var time,\n            i,\n            j,\n            touchCount = event.changedTouches.length,\n            gPoints = [],\n            parentGPoints,\n            pointsList = tracker.getActivePointersListByType( \'touch\' );\n\n        time = $.now();\n\n        if ( pointsList.getLength() > event.touches.length - touchCount ) {\n            $.console.warn(\'Tracked touch contact count doesn\\\'t match event.touches.length. Removing all tracked touch pointers.\');\n            abortTouchContacts( tracker, event, pointsList );\n        }\n\n        for ( i = 0; i < touchCount; i++ ) {\n            gPoints.push( {\n                id: event.changedTouches[ i ].identifier,\n                type: \'touch\',\n                // isPrimary not set - let the updatePointers functions determine it\n                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),\n                currentTime: time\n            } );\n        }\n\n        // simulate touchenter on our tracked element\n        updatePointersEnter( tracker, event, gPoints );\n\n        // simulate touchenter on our tracked element\'s tracked ancestor elements\n        for ( i = 0; i < MOUSETRACKERS.length; i++ ) {\n            if ( MOUSETRACKERS[ i ] !== tracker && MOUSETRACKERS[ i ].isTracking() && isParentChild( MOUSETRACKERS[ i ].element, tracker.element ) ) {\n                parentGPoints = [];\n                for ( j = 0; j < touchCount; j++ ) {\n                    parentGPoints.push( {\n                        id: event.changedTouches[ j ].identifier,\n                        type: \'touch\',\n                        // isPrimary not set - let the updatePointers functions determine it\n                        currentPos: getMouseAbsolute( event.changedTouches[ j ] ),\n                        currentTime: time\n                    } );\n                }\n                updatePointersEnter( MOUSETRACKERS[ i ], event, parentGPoints );\n            }\n        }\n\n        if ( updatePointersDown( tracker, event, gPoints, 0 ) ) { // 0 means primary button press/release or touch contact\n            $.stopEvent( event );\n            capturePointer( tracker, \'touch\', touchCount );\n        }\n\n        $.cancelEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchEnd( tracker, event ) {\n        handleTouchEnd( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate pointer capture.\n     * onTouchEnd is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onTouchEndCaptured( tracker, event ) {\n        handleTouchEnd( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleTouchEnd( tracker, event ) {\n        var time,\n            i,\n            j,\n            touchCount = event.changedTouches.length,\n            gPoints = [],\n            parentGPoints;\n\n        time = $.now();\n\n        for ( i = 0; i < touchCount; i++ ) {\n            gPoints.push( {\n                id: event.changedTouches[ i ].identifier,\n                type: \'touch\',\n                // isPrimary not set - let the updatePointers functions determine it\n                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),\n                currentTime: time\n            } );\n        }\n\n        if ( updatePointersUp( tracker, event, gPoints, 0 ) ) {\n            releasePointer( tracker, \'touch\', touchCount );\n        }\n\n        // simulate touchleave on our tracked element\n        updatePointersExit( tracker, event, gPoints );\n\n        // simulate touchleave on our tracked element\'s tracked ancestor elements\n        for ( i = 0; i < MOUSETRACKERS.length; i++ ) {\n            if ( MOUSETRACKERS[ i ] !== tracker && MOUSETRACKERS[ i ].isTracking() && isParentChild( MOUSETRACKERS[ i ].element, tracker.element ) ) {\n                parentGPoints = [];\n                for ( j = 0; j < touchCount; j++ ) {\n                    parentGPoints.push( {\n                        id: event.changedTouches[ j ].identifier,\n                        type: \'touch\',\n                        // isPrimary not set - let the updatePointers functions determine it\n                        currentPos: getMouseAbsolute( event.changedTouches[ j ] ),\n                        currentTime: time\n                    } );\n                }\n                updatePointersExit( MOUSETRACKERS[ i ], event, parentGPoints );\n            }\n        }\n\n        $.cancelEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchMove( tracker, event ) {\n        handleTouchMove( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate pointer capture.\n     * onTouchMove is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onTouchMoveCaptured( tracker, event ) {\n        handleTouchMove( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleTouchMove( tracker, event ) {\n        var i,\n            touchCount = event.changedTouches.length,\n            gPoints = [];\n\n        for ( i = 0; i < touchCount; i++ ) {\n            gPoints.push( {\n                id: event.changedTouches[ i ].identifier,\n                type: \'touch\',\n                // isPrimary not set - let the updatePointers functions determine it\n                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),\n                currentTime: $.now()\n            } );\n        }\n\n        updatePointersMove( tracker, event, gPoints );\n\n        $.cancelEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchCancel( tracker, event ) {\n        var i,\n            touchCount = event.changedTouches.length,\n            gPoints = [],\n            pointsList = tracker.getActivePointersListByType( \'touch\' );\n        \n        abortTouchContacts( tracker, event, pointsList );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onGestureStart( tracker, event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        return false;\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onGestureChange( tracker, event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        return false;\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerOver( tracker, event ) {\n        var gPoint;\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersEnter( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerOut( tracker, event ) {\n        var gPoint;\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersExit( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerDown( tracker, event ) {\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersDown( tracker, event, [ gPoint ], event.button ) ) {\n            $.stopEvent( event );\n            capturePointer( tracker, gPoint.type );\n        }\n\n        if ( tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerUp( tracker, event ) {\n        handlePointerUp( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onPointerUp is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onPointerUpCaptured( tracker, event ) {\n        var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );\n        if ( pointsList.getById( event.pointerId ) ) {\n            handlePointerUp( tracker, event );\n        }\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handlePointerUp( tracker, event ) {\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersUp( tracker, event, [ gPoint ], event.button ) ) {\n            releasePointer( tracker, gPoint.type );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerMove( tracker, event ) {\n        handlePointerMove( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onPointerMove is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onPointerMoveCaptured( tracker, event ) {\n        var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );\n        if ( pointsList.getById( event.pointerId ) ) {\n            handlePointerMove( tracker, event );\n        }\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handlePointerMove( tracker, event ) {\n        // Pointer changed coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersMove( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerCancel( tracker, event ) {\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event )\n        };\n\n        updatePointersCancel( tracker, event, [ gPoint ] );\n    }\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Device-agnostic DOM event handlers\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList\n     *     The GesturePointList to track the pointer in.\n     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint\n     *      Gesture point to track.\n     * @returns {Number} Number of gesture points in pointsList.\n     */\n    function startTrackingPointer( pointsList, gPoint ) {\n\n        // If isPrimary is not known for the pointer then set it according to our rules:\n        //    true if the first pointer in the gesture, otherwise false\n        if ( !gPoint.hasOwnProperty( \'isPrimary\' ) ) {\n            if ( pointsList.getLength() === 0 ) {\n                gPoint.isPrimary = true;\n            } else {\n                gPoint.isPrimary = false;\n            }\n        }\n        gPoint.speed = 0;\n        gPoint.direction = 0;\n        gPoint.contactPos = gPoint.currentPos;\n        gPoint.contactTime = gPoint.currentTime;\n        gPoint.lastPos = gPoint.currentPos;\n        gPoint.lastTime = gPoint.currentTime;\n\n        return pointsList.add( gPoint );\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList\n     *     The GesturePointList to stop tracking the pointer on.\n     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint\n     *      Gesture point to stop tracking.\n     * @returns {Number} Number of gesture points in pointsList.\n     */\n    function stopTrackingPointer( pointsList, gPoint ) {\n        var listLength,\n            primaryPoint;\n\n        if ( pointsList.getById( gPoint.id ) ) {\n            listLength = pointsList.removeById( gPoint.id );\n\n            // If isPrimary is not known for the pointer and we just removed the primary pointer from the list then we need to set another pointer as primary\n            if ( !gPoint.hasOwnProperty( \'isPrimary\' ) ) {\n                primaryPoint = pointsList.getPrimary();\n                if ( !primaryPoint ) {\n                    primaryPoint = pointsList.getByIndex( 0 );\n                    if ( primaryPoint ) {\n                        primaryPoint.isPrimary = true;\n                    }\n                }\n            }\n        } else {\n            listLength = pointsList.getLength();\n        }\n\n        return listLength;\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersEnter( tracker, event, gPoints ) {\n        var pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            propagate;\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer...update it\n                updateGPoint.insideElement = true;\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n\n                curGPoint = updateGPoint;\n            } else {\n                // Initialize for tracking and add to the tracking list\n                curGPoint.captured = false;\n                curGPoint.insideElementPressed = false;\n                curGPoint.insideElement = true;\n                startTrackingPointer( pointsList, curGPoint );\n            }\n\n            // Enter\n            if ( tracker.enterHandler ) {\n                propagate = tracker.enterHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          curGPoint.type,\n                        position:             getPointRelativeToAbsolute( curGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        pointers:             tracker.getActivePointerCount(),\n                        insideElementPressed: curGPoint.insideElementPressed,\n                        buttonDownAny:        pointsList.buttons !== 0,\n                        isTouchEvent:         curGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        }\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersExit( tracker, event, gPoints ) {\n        var delegate = THIS[ tracker.hash ],\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            propagate;\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer. If captured then update it, else stop tracking it\n                if ( updateGPoint.captured ) {\n                    updateGPoint.insideElement = false;\n                    updateGPoint.lastPos = updateGPoint.currentPos;\n                    updateGPoint.lastTime = updateGPoint.currentTime;\n                    updateGPoint.currentPos = curGPoint.currentPos;\n                    updateGPoint.currentTime = curGPoint.currentTime;\n                } else {\n                    stopTrackingPointer( pointsList, updateGPoint );\n                }\n\n                curGPoint = updateGPoint;\n            }\n\n            // Exit\n            if ( tracker.exitHandler ) {\n                propagate = tracker.exitHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          curGPoint.type,\n                        position:             getPointRelativeToAbsolute( curGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        pointers:             tracker.getActivePointerCount(),\n                        insideElementPressed: updateGPoint ? updateGPoint.insideElementPressed : false,\n                        buttonDownAny:        pointsList.buttons !== 0,\n                        isTouchEvent:         curGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        }\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     * @param {Number} buttonChanged\n     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,\n     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.\n     *\n     * @returns {Boolean} True if pointers should be captured to the tracked element, otherwise false.\n     */\n    function updatePointersDown( tracker, event, gPoints, buttonChanged ) {\n        var delegate = THIS[ tracker.hash ],\n            propagate,\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint;\n\n        if ( typeof event.buttons !== \'undefined\' ) {\n            pointsList.buttons = event.buttons;\n        } else {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons += 1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons += 4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons += 2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons += 8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons += 16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons += 32;\n                }\n            } else {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons |= 1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons |= 4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons |= 2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons |= 8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons |= 16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons |= 32;\n                }\n            }\n        }\n\n        // Only capture and track primary button, pen, and touch contacts\n        if ( buttonChanged !== 0 ) {\n            // Aux Press\n            if ( tracker.nonPrimaryPressHandler ) {\n                propagate = tracker.nonPrimaryPressHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          gPoints[ 0 ].type,\n                        position:             getPointRelativeToAbsolute( gPoints[ 0 ].currentPos, tracker.element ),\n                        button:               buttonChanged,\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         gPoints[ 0 ].type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            return false;\n        }\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer...update it\n                updateGPoint.captured = true;\n                updateGPoint.insideElementPressed = true;\n                updateGPoint.insideElement = true;\n                updateGPoint.contactPos = curGPoint.currentPos;\n                updateGPoint.contactTime = curGPoint.currentTime;\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n\n                curGPoint = updateGPoint;\n            } else {\n                // Initialize for tracking and add to the tracking list (no pointerover or pointermove event occurred before this)\n                curGPoint.captured = true;\n                curGPoint.insideElementPressed = true;\n                curGPoint.insideElement = true;\n                startTrackingPointer( pointsList, curGPoint );\n            }\n\n            pointsList.contacts++;\n            //$.console.log(\'contacts++ \', pointsList.contacts);\n\n            if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {\n                $.MouseTracker.gesturePointVelocityTracker.addPoint( tracker, curGPoint );\n            }\n\n            if ( pointsList.contacts === 1 ) {\n                // Press\n                if ( tracker.pressHandler ) {\n                    propagate = tracker.pressHandler(\n                        {\n                            eventSource:          tracker,\n                            pointerType:          curGPoint.type,\n                            position:             getPointRelativeToAbsolute( curGPoint.contactPos, tracker.element ),\n                            buttons:              pointsList.buttons,\n                            isTouchEvent:         curGPoint.type === \'touch\',\n                            originalEvent:        event,\n                            preventDefaultAction: false,\n                            userData:             tracker.userData\n                        }\n                    );\n                    if ( propagate === false ) {\n                        $.cancelEvent( event );\n                    }\n                }\n            } else if ( pointsList.contacts === 2 ) {\n                if ( tracker.pinchHandler && curGPoint.type === \'touch\' ) {\n                    // Initialize for pinch\n                    delegate.pinchGPoints = pointsList.asArray();\n                    delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );\n                    delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );\n                }\n            }\n        }\n\n        return true;\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     * @param {Number} buttonChanged\n     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,\n     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.\n     *\n     * @returns {Boolean} True if pointer capture should be released from the tracked element, otherwise false.\n     */\n    function updatePointersUp( tracker, event, gPoints, buttonChanged ) {\n        var delegate = THIS[ tracker.hash ],\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            propagate,\n            insideElementReleased,\n            releasePoint,\n            releaseTime,\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            releaseCapture = false,\n            wasCaptured = false,\n            quick;\n\n        if ( typeof event.buttons !== \'undefined\' ) {\n            pointsList.buttons = event.buttons;\n        } else {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons -= 1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons -= 4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons -= 2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons -= 8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons -= 16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons -= 32;\n                }\n            } else {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons ^= ~1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons ^= ~4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons ^= ~2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons ^= ~8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons ^= ~16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons ^= ~32;\n                }\n            }\n        }\n\n        // Only capture and track primary button, pen, and touch contacts\n        if ( buttonChanged !== 0 ) {\n            // Aux Release\n            if ( tracker.nonPrimaryReleaseHandler ) {\n                propagate = tracker.nonPrimaryReleaseHandler(\n                    {\n                        eventSource:           tracker,\n                        pointerType:           gPoints[ 0 ].type,\n                        position:              getPointRelativeToAbsolute(  gPoints[ 0 ].currentPos, tracker.element ),\n                        button:                buttonChanged,\n                        buttons:               pointsList.buttons,\n                        isTouchEvent:          gPoints[ 0 ].type === \'touch\',\n                        originalEvent:         event,\n                        preventDefaultAction:  false,\n                        userData:              tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            return false;\n        }\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Update the pointer, stop tracking it if not still in this element\n                if ( updateGPoint.captured ) {\n                    updateGPoint.captured = false;\n                    releaseCapture = true;\n                    wasCaptured = true;\n                }\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n                if ( !updateGPoint.insideElement ) {\n                    stopTrackingPointer( pointsList, updateGPoint );\n                }\n\n                releasePoint = updateGPoint.currentPos;\n                releaseTime = updateGPoint.currentTime;\n\n                if ( wasCaptured ) {\n                    // Pointer was activated in our element but could have been removed in any element since events are captured to our element\n\n                    pointsList.contacts--;\n                    //$.console.log(\'contacts-- \', pointsList.contacts);\n\n                    if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {\n                        $.MouseTracker.gesturePointVelocityTracker.removePoint( tracker, updateGPoint );\n                    }\n\n                    if ( pointsList.contacts === 0 ) {\n\n                        // Release (pressed in our element)\n                        if ( tracker.releaseHandler ) {\n                            propagate = tracker.releaseHandler(\n                                {\n                                    eventSource:           tracker,\n                                    pointerType:           updateGPoint.type,\n                                    position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),\n                                    buttons:               pointsList.buttons,\n                                    insideElementPressed:  updateGPoint.insideElementPressed,\n                                    insideElementReleased: updateGPoint.insideElement,\n                                    isTouchEvent:          updateGPoint.type === \'touch\',\n                                    originalEvent:         event,\n                                    preventDefaultAction:  false,\n                                    userData:              tracker.userData\n                                }\n                            );\n                            if ( propagate === false ) {\n                                $.cancelEvent( event );\n                            }\n                        }\n\n                        // Drag End\n                        if ( tracker.dragEndHandler && !updateGPoint.currentPos.equals( updateGPoint.contactPos ) ) {\n                            propagate = tracker.dragEndHandler(\n                                {\n                                    eventSource:          tracker,\n                                    pointerType:          updateGPoint.type,\n                                    position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                                    speed:                updateGPoint.speed,\n                                    direction:            updateGPoint.direction,\n                                    shift:                event.shiftKey,\n                                    isTouchEvent:         updateGPoint.type === \'touch\',\n                                    originalEvent:        event,\n                                    preventDefaultAction: false,\n                                    userData:             tracker.userData\n                                }\n                            );\n                            if ( propagate === false ) {\n                                $.cancelEvent( event );\n                            }\n                        }\n\n                        // Click / Double-Click\n                        if ( ( tracker.clickHandler || tracker.dblClickHandler ) && updateGPoint.insideElement ) {\n                            quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold &&\n                                            updateGPoint.contactPos.distanceTo( releasePoint ) <= tracker.clickDistThreshold;\n\n                            // Click\n                            if ( tracker.clickHandler ) {\n                                propagate = tracker.clickHandler(\n                                    {\n                                        eventSource:          tracker,\n                                        pointerType:          updateGPoint.type,\n                                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                                        quick:                quick,\n                                        shift:                event.shiftKey,\n                                        isTouchEvent:         updateGPoint.type === \'touch\',\n                                        originalEvent:        event,\n                                        preventDefaultAction: false,\n                                        userData:             tracker.userData\n                                    }\n                                );\n                                if ( propagate === false ) {\n                                    $.cancelEvent( event );\n                                }\n                            }\n\n                            // Double-Click\n                            if ( tracker.dblClickHandler && quick ) {\n                                pointsList.clicks++;\n                                if ( pointsList.clicks === 1 ) {\n                                    delegate.lastClickPos = releasePoint;\n                                    /*jshint loopfunc:true*/\n                                    delegate.dblClickTimeOut = setTimeout( function() {\n                                        pointsList.clicks = 0;\n                                    }, tracker.dblClickTimeThreshold );\n                                    /*jshint loopfunc:false*/\n                                } else if ( pointsList.clicks === 2 ) {\n                                    clearTimeout( delegate.dblClickTimeOut );\n                                    pointsList.clicks = 0;\n                                    if ( delegate.lastClickPos.distanceTo( releasePoint ) <= tracker.dblClickDistThreshold ) {\n                                        propagate = tracker.dblClickHandler(\n                                            {\n                                                eventSource:          tracker,\n                                                pointerType:          updateGPoint.type,\n                                                position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                                                shift:                event.shiftKey,\n                                                isTouchEvent:         updateGPoint.type === \'touch\',\n                                                originalEvent:        event,\n                                                preventDefaultAction: false,\n                                                userData:             tracker.userData\n                                            }\n                                        );\n                                        if ( propagate === false ) {\n                                            $.cancelEvent( event );\n                                        }\n                                    }\n                                    delegate.lastClickPos = null;\n                                }\n                            }\n                        }\n                    } else if ( pointsList.contacts === 2 ) {\n                        if ( tracker.pinchHandler && updateGPoint.type === \'touch\' ) {\n                            // Reset for pinch\n                            delegate.pinchGPoints = pointsList.asArray();\n                            delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );\n                            delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );\n                        }\n                    }\n                } else {\n                    // Pointer was activated in another element but removed in our element\n\n                    // Release (pressed in another element)\n                    if ( tracker.releaseHandler ) {\n                        propagate = tracker.releaseHandler(\n                            {\n                                eventSource:           tracker,\n                                pointerType:           updateGPoint.type,\n                                position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),\n                                buttons:               pointsList.buttons,\n                                insideElementPressed:  updateGPoint.insideElementPressed,\n                                insideElementReleased: updateGPoint.insideElement,\n                                isTouchEvent:          updateGPoint.type === \'touch\',\n                                originalEvent:         event,\n                                preventDefaultAction:  false,\n                                userData:              tracker.userData\n                            }\n                        );\n                        if ( propagate === false ) {\n                            $.cancelEvent( event );\n                        }\n                    }\n                }\n            }\n        }\n\n        return releaseCapture;\n    }\n\n\n    /**\n     * Call when pointer(s) change coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)\n     *\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersMove( tracker, event, gPoints ) {\n        var delegate = THIS[ tracker.hash ],\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            gPointArray,\n            delta,\n            propagate;\n\n        if ( typeof event.buttons !== \'undefined\' ) {\n            pointsList.buttons = event.buttons;\n        }\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer...update it\n                if ( curGPoint.hasOwnProperty( \'isPrimary\' ) ) {\n                    updateGPoint.isPrimary = curGPoint.isPrimary;\n                }\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n            } else {\n                // Initialize for tracking and add to the tracking list (no pointerover or pointerdown event occurred before this)\n                curGPoint.captured = false;\n                curGPoint.insideElementPressed = false;\n                curGPoint.insideElement = true;\n                startTrackingPointer( pointsList, curGPoint );\n            }\n        }\n\n        // Stop (mouse only)\n        if ( tracker.stopHandler && gPoints[ 0 ].type === \'mouse\' ) {\n            clearTimeout( tracker.stopTimeOut );\n            tracker.stopTimeOut = setTimeout( function() {\n                handlePointerStop( tracker, event, gPoints[ 0 ].type );\n            }, tracker.stopDelay );\n        }\n\n        if ( pointsList.contacts === 0 ) {\n            // Move (no contacts: hovering mouse or other hover-capable device)\n            if ( tracker.moveHandler ) {\n                propagate = tracker.moveHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          gPoints[ 0 ].type,\n                        position:             getPointRelativeToAbsolute( gPoints[ 0 ].currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         gPoints[ 0 ].type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        } else if ( pointsList.contacts === 1 ) {\n            // Move (1 contact)\n            if ( tracker.moveHandler ) {\n                updateGPoint = pointsList.asArray()[ 0 ];\n                propagate = tracker.moveHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          updateGPoint.type,\n                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         updateGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            // Drag\n            if ( tracker.dragHandler ) {\n                updateGPoint = pointsList.asArray()[ 0 ];\n                delta = updateGPoint.currentPos.minus( updateGPoint.lastPos );\n                propagate = tracker.dragHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          updateGPoint.type,\n                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        delta:                delta,\n                        speed:                updateGPoint.speed,\n                        direction:            updateGPoint.direction,\n                        shift:                event.shiftKey,\n                        isTouchEvent:         updateGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        } else if ( pointsList.contacts === 2 ) {\n            // Move (2 contacts, use center)\n            if ( tracker.moveHandler ) {\n                gPointArray = pointsList.asArray();\n                propagate = tracker.moveHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          gPointArray[ 0 ].type,\n                        position:             getPointRelativeToAbsolute( getCenterPoint( gPointArray[ 0 ].currentPos, gPointArray[ 1 ].currentPos ), tracker.element ),\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         gPointArray[ 0 ].type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            // Pinch\n            if ( tracker.pinchHandler && gPoints[ 0 ].type === \'touch\' ) {\n                delta = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );\n                if ( delta != delegate.currentPinchDist ) {\n                    delegate.lastPinchDist = delegate.currentPinchDist;\n                    delegate.currentPinchDist = delta;\n                    delegate.lastPinchCenter = delegate.currentPinchCenter;\n                    delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );\n                    propagate = tracker.pinchHandler(\n                        {\n                            eventSource:          tracker,\n                            pointerType:          \'touch\',\n                            gesturePoints:        delegate.pinchGPoints,\n                            lastCenter:           getPointRelativeToAbsolute( delegate.lastPinchCenter, tracker.element ),\n                            center:               getPointRelativeToAbsolute( delegate.currentPinchCenter, tracker.element ),\n                            lastDistance:         delegate.lastPinchDist,\n                            distance:             delegate.currentPinchDist,\n                            shift:                event.shiftKey,\n                            originalEvent:        event,\n                            preventDefaultAction: false,\n                            userData:             tracker.userData\n                        }\n                    );\n                    if ( propagate === false ) {\n                        $.cancelEvent( event );\n                    }\n                }\n            }\n        }\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersCancel( tracker, event, gPoints ) {\n        updatePointersUp( tracker, event, gPoints, 0 );\n        updatePointersExit( tracker, event, gPoints );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handlePointerStop( tracker, originalMoveEvent, pointerType ) {\n        if ( tracker.stopHandler ) {\n            tracker.stopHandler( {\n                eventSource:          tracker,\n                pointerType:          pointerType,\n                position:             getMouseRelative( originalMoveEvent, tracker.element ),\n                buttons:              tracker.getActivePointersListByType( pointerType ).buttons,\n                isTouchEvent:         pointerType === \'touch\',\n                originalEvent:        originalMoveEvent,\n                preventDefaultAction: false,\n                userData:             tracker.userData\n            } );\n        }\n    }\n    \n    // True if inside an iframe, otherwise false.\n    // @member {Boolean} isInIframe\n    // @private\n    // @inner\n    var isInIframe = (function() {\n        try {\n            return window.self !== window.top;\n        } catch (e) {\n            return true;\n        }\n    })();\n \n    // @function\n    // @private\n    // @inner\n    // @returns {Boolean} True if the target has access rights to events, otherwise false.\n    function canAccessEvents (target) {\n        try {\n            return target.addEventListener && target.removeEventListener;\n        } catch (e) {\n            return false;\n        }\n    }\n\n} ( OpenSeadragon ) );\n\n/*\n * OpenSeadragon - Control\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * An enumeration of supported locations where controls can be anchored.\n * The anchoring is always relative to the container.\n * @member ControlAnchor\n * @memberof OpenSeadragon\n * @static\n * @type {Object}\n * @property {Number} NONE\n * @property {Number} TOP_LEFT\n * @property {Number} TOP_RIGHT\n * @property {Number} BOTTOM_LEFT\n * @property {Number} BOTTOM_RIGHT\n * @property {Number} ABSOLUTE\n */\n$.ControlAnchor = {\n    NONE: 0,\n    TOP_LEFT: 1,\n    TOP_RIGHT: 2,\n    BOTTOM_RIGHT: 3,\n    BOTTOM_LEFT: 4,\n    ABSOLUTE: 5\n};\n\n/**\n * @class Control\n * @classdesc A Control represents any interface element which is meant to allow the user\n * to interact with the zoomable interface. Any control can be anchored to any\n * element.\n *\n * @memberof OpenSeadragon\n * @param {Element} element - the control element to be anchored in the container.\n * @param {Object } options - All required and optional settings for configuring a control element.\n * @param {OpenSeadragon.ControlAnchor} [options.anchor=OpenSeadragon.ControlAnchor.NONE] - the position of the control\n *  relative to the container.\n * @param {Boolean} [options.attachToViewer=true] - Whether the control should be added directly to the viewer, or\n *  directly to the container\n * @param {Boolean} [options.autoFade=true] - Whether the control should have the autofade behavior\n * @param {Element} container - the element to control will be anchored too.\n */\n$.Control = function ( element, options, container ) {\n    var parent = element.parentNode;\n    if (typeof options === \'number\')\n    {\n        $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; " +\n                        "please use an options object instead.  " +\n                        "Support for this deprecated variant is scheduled for removal in December 2013");\n         options = {anchor: options};\n    }\n    options.attachToViewer = (typeof options.attachToViewer === \'undefined\') ? true : options.attachToViewer;\n    /**\n     * True if the control should have autofade behavior.\n     * @member {Boolean} autoFade\n     * @memberof OpenSeadragon.Control#\n     */\n    this.autoFade = (typeof options.autoFade === \'undefined\') ? true : options.autoFade;\n    /**\n     * The element providing the user interface with some type of control (e.g. a zoom-in button).\n     * @member {Element} element\n     * @memberof OpenSeadragon.Control#\n     */\n    this.element    = element;\n    /**\n     * The position of the Control relative to its container.\n     * @member {OpenSeadragon.ControlAnchor} anchor\n     * @memberof OpenSeadragon.Control#\n     */\n    this.anchor     = options.anchor;\n    /**\n     * The Control\'s containing element.\n     * @member {Element} container\n     * @memberof OpenSeadragon.Control#\n     */\n    this.container  = container;\n    /**\n     * A neutral element surrounding the control element.\n     * @member {Element} wrapper\n     * @memberof OpenSeadragon.Control#\n     */\n    if ( this.anchor == $.ControlAnchor.ABSOLUTE ) {\n        this.wrapper    = $.makeNeutralElement( "div" );\n        this.wrapper.style.position = "absolute";\n        this.wrapper.style.top = typeof ( options.top )  == "number" ? ( options.top + \'px\' ) : options.top;\n        this.wrapper.style.left  = typeof ( options.left )  == "number" ?  (options.left + \'px\' ) : options.left;\n        this.wrapper.style.height = typeof ( options.height )  == "number" ? ( options.height + \'px\' ) : options.height;\n        this.wrapper.style.width  = typeof ( options.width )  == "number" ? ( options.width + \'px\' ) : options.width;\n        this.wrapper.style.margin = "0px";\n        this.wrapper.style.padding = "0px";\n\n        this.element.style.position = "relative";\n        this.element.style.top = "0px";\n        this.element.style.left = "0px";\n        this.element.style.height = "100%";\n        this.element.style.width = "100%";\n    } else {\n        this.wrapper    = $.makeNeutralElement( "div" );\n        this.wrapper.style.display = "inline-block";\n        if ( this.anchor == $.ControlAnchor.NONE ) {\n            // IE6 fix\n            this.wrapper.style.width = this.wrapper.style.height = "100%";\n        }\n    }\n    this.wrapper.appendChild( this.element );\n\n    if (options.attachToViewer ) {\n        if ( this.anchor == $.ControlAnchor.TOP_RIGHT ||\n             this.anchor == $.ControlAnchor.BOTTOM_RIGHT ) {\n            this.container.insertBefore(\n                this.wrapper,\n                this.container.firstChild\n            );\n        } else {\n            this.container.appendChild( this.wrapper );\n        }\n    } else {\n        parent.appendChild( this.wrapper );\n    }\n};\n\n/** @lends OpenSeadragon.Control.prototype */\n$.Control.prototype = {\n\n    /**\n     * Removes the control from the container.\n     * @function\n     */\n    destroy: function() {\n        this.wrapper.removeChild( this.element );\n        this.container.removeChild( this.wrapper );\n    },\n\n    /**\n     * Determines if the control is currently visible.\n     * @function\n     * @return {Boolean} true if currenly visible, false otherwise.\n     */\n    isVisible: function() {\n        return this.wrapper.style.display != "none";\n    },\n\n    /**\n     * Toggles the visibility of the control.\n     * @function\n     * @param {Boolean} visible - true to make visible, false to hide.\n     */\n    setVisible: function( visible ) {\n        this.wrapper.style.display = visible ?\n            ( this.anchor == $.ControlAnchor.ABSOLUTE ? \'block\' : \'inline-block\' ) :\n            "none";\n    },\n\n    /**\n     * Sets the opacity level for the control.\n     * @function\n     * @param {Number} opactiy - a value between 1 and 0 inclusively.\n     */\n    setOpacity: function( opacity ) {\n        if ( this.element[ $.SIGNAL ] && $.Browser.vendor == $.BROWSERS.IE ) {\n            $.setElementOpacity( this.element, opacity, true );\n        } else {\n            $.setElementOpacity( this.wrapper, opacity, true );\n        }\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ControlDock\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n    /**\n     * @class ControlDock\n     * @classdesc Provides a container element (a &lt;form&gt; element) with support for the layout of control elements.\n     *\n     * @memberof OpenSeadragon\n     */\n    $.ControlDock = function( options ){\n        var layouts = [ \'topleft\', \'topright\', \'bottomright\', \'bottomleft\'],\n            layout,\n            i;\n\n        $.extend( true, this, {\n            id: \'controldock-\'+$.now()+\'-\'+Math.floor(Math.random()*1000000),\n            container: $.makeNeutralElement( \'div\' ),\n            controls: []\n        }, options );\n\n        // Disable the form\'s submit; otherwise button clicks and return keys\n        // can trigger it.\n        this.container.onsubmit = function() {\n            return false;\n        };\n\n        if( this.element ){\n            this.element = $.getElement( this.element );\n            this.element.appendChild( this.container );\n            this.element.style.position = \'relative\';\n            this.container.style.width = \'100%\';\n            this.container.style.height = \'100%\';\n        }\n\n        for( i = 0; i < layouts.length; i++ ){\n            layout = layouts[ i ];\n            this.controls[ layout ] = $.makeNeutralElement( "div" );\n            this.controls[ layout ].style.position = \'absolute\';\n            if ( layout.match( \'left\' ) ){\n                this.controls[ layout ].style.left = \'0px\';\n            }\n            if ( layout.match( \'right\' ) ){\n                this.controls[ layout ].style.right = \'0px\';\n            }\n            if ( layout.match( \'top\' ) ){\n                this.controls[ layout ].style.top = \'0px\';\n            }\n            if ( layout.match( \'bottom\' ) ){\n                this.controls[ layout ].style.bottom = \'0px\';\n            }\n        }\n\n        this.container.appendChild( this.controls.topleft );\n        this.container.appendChild( this.controls.topright );\n        this.container.appendChild( this.controls.bottomright );\n        this.container.appendChild( this.controls.bottomleft );\n    };\n\n    /** @lends OpenSeadragon.ControlDock.prototype */\n    $.ControlDock.prototype = {\n\n        /**\n         * @function\n         */\n        addControl: function ( element, controlOptions ) {\n            element = $.getElement( element );\n            var div = null;\n\n            if ( getControlIndex( this, element ) >= 0 ) {\n                return;     // they\'re trying to add a duplicate control\n            }\n\n            switch ( controlOptions.anchor ) {\n                case $.ControlAnchor.TOP_RIGHT:\n                    div = this.controls.topright;\n                    element.style.position = "relative";\n                    element.style.paddingRight = "0px";\n                    element.style.paddingTop = "0px";\n                    break;\n                case $.ControlAnchor.BOTTOM_RIGHT:\n                    div = this.controls.bottomright;\n                    element.style.position = "relative";\n                    element.style.paddingRight = "0px";\n                    element.style.paddingBottom = "0px";\n                    break;\n                case $.ControlAnchor.BOTTOM_LEFT:\n                    div = this.controls.bottomleft;\n                    element.style.position = "relative";\n                    element.style.paddingLeft = "0px";\n                    element.style.paddingBottom = "0px";\n                    break;\n                case $.ControlAnchor.TOP_LEFT:\n                    div = this.controls.topleft;\n                    element.style.position = "relative";\n                    element.style.paddingLeft = "0px";\n                    element.style.paddingTop = "0px";\n                    break;\n                case $.ControlAnchor.ABSOLUTE:\n                    div = this.container;\n                    element.style.margin = "0px";\n                    element.style.padding = "0px";\n                    break;\n                default:\n                case $.ControlAnchor.NONE:\n                    div = this.container;\n                    element.style.margin = "0px";\n                    element.style.padding = "0px";\n                    break;\n            }\n\n            this.controls.push(\n                new $.Control( element, controlOptions, div )\n            );\n            element.style.display = "inline-block";\n        },\n\n\n        /**\n         * @function\n         * @return {OpenSeadragon.ControlDock} Chainable.\n         */\n        removeControl: function ( element ) {\n            element = $.getElement( element );\n            var i = getControlIndex( this, element );\n\n            if ( i >= 0 ) {\n                this.controls[ i ].destroy();\n                this.controls.splice( i, 1 );\n            }\n\n            return this;\n        },\n\n        /**\n         * @function\n         * @return {OpenSeadragon.ControlDock} Chainable.\n         */\n        clearControls: function () {\n            while ( this.controls.length > 0 ) {\n                this.controls.pop().destroy();\n            }\n\n            return this;\n        },\n\n\n        /**\n         * @function\n         * @return {Boolean}\n         */\n        areControlsEnabled: function () {\n            var i;\n\n            for ( i = this.controls.length - 1; i >= 0; i-- ) {\n                if ( this.controls[ i ].isVisible() ) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n\n        /**\n         * @function\n         * @return {OpenSeadragon.ControlDock} Chainable.\n         */\n        setControlsEnabled: function( enabled ) {\n            var i;\n\n            for ( i = this.controls.length - 1; i >= 0; i-- ) {\n                this.controls[ i ].setVisible( enabled );\n            }\n\n            return this;\n        }\n\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Utility methods\n    ///////////////////////////////////////////////////////////////////////////////\n    function getControlIndex( dock, element ) {\n        var controls = dock.controls,\n            i;\n\n        for ( i = controls.length - 1; i >= 0; i-- ) {\n            if ( controls[ i ].element == element ) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Placement\n *\n * Copyright (C) 2010-2016 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($) {\n\n    /**\n     * An enumeration of positions to anchor an element.\n     * @member Placement\n     * @memberOf OpenSeadragon\n     * @static\n     * @readonly\n     * @property {OpenSeadragon.Placement} CENTER\n     * @property {OpenSeadragon.Placement} TOP_LEFT\n     * @property {OpenSeadragon.Placement} TOP\n     * @property {OpenSeadragon.Placement} TOP_RIGHT\n     * @property {OpenSeadragon.Placement} RIGHT\n     * @property {OpenSeadragon.Placement} BOTTOM_RIGHT\n     * @property {OpenSeadragon.Placement} BOTTOM\n     * @property {OpenSeadragon.Placement} BOTTOM_LEFT\n     * @property {OpenSeadragon.Placement} LEFT\n     */\n    $.Placement = $.freezeObject({\n        CENTER:       0,\n        TOP_LEFT:     1,\n        TOP:          2,\n        TOP_RIGHT:    3,\n        RIGHT:        4,\n        BOTTOM_RIGHT: 5,\n        BOTTOM:       6,\n        BOTTOM_LEFT:  7,\n        LEFT:         8,\n        properties: {\n            0: {\n                isLeft: false,\n                isHorizontallyCentered: true,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: true,\n                isBottom: false\n            },\n            1: {\n                isLeft: true,\n                isHorizontallyCentered: false,\n                isRight: false,\n                isTop: true,\n                isVerticallyCentered: false,\n                isBottom: false\n            },\n            2: {\n                isLeft: false,\n                isHorizontallyCentered: true,\n                isRight: false,\n                isTop: true,\n                isVerticallyCentered: false,\n                isBottom: false\n            },\n            3: {\n                isLeft: false,\n                isHorizontallyCentered: false,\n                isRight: true,\n                isTop: true,\n                isVerticallyCentered: false,\n                isBottom: false\n            },\n            4: {\n                isLeft: false,\n                isHorizontallyCentered: false,\n                isRight: true,\n                isTop: false,\n                isVerticallyCentered: true,\n                isBottom: false\n            },\n            5: {\n                isLeft: false,\n                isHorizontallyCentered: false,\n                isRight: true,\n                isTop: false,\n                isVerticallyCentered: false,\n                isBottom: true\n            },\n            6: {\n                isLeft: false,\n                isHorizontallyCentered: true,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: false,\n                isBottom: true\n            },\n            7: {\n                isLeft: true,\n                isHorizontallyCentered: false,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: false,\n                isBottom: true\n            },\n            8: {\n                isLeft: true,\n                isHorizontallyCentered: false,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: true,\n                isBottom: false\n            }\n        }\n    });\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - Viewer\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// dictionary from hash to private properties\nvar THIS = {};\nvar nextHash = 1;\n\n/**\n *\n * The main point of entry into creating a zoomable image on the page.<br>\n * <br>\n * We have provided an idiomatic javascript constructor which takes\n * a single object, but still support the legacy positional arguments.<br>\n * <br>\n * The options below are given in order that they appeared in the constructor\n * as arguments and we translate a positional call into an idiomatic call.<br>\n * <br>\n * To create a viewer, you can use either of this methods:<br>\n * <ul>\n * <li><code>var viewer = new OpenSeadragon.Viewer(options);</code></li>\n * <li><code>var viewer = OpenSeadragon(options);</code></li>\n * </ul>\n * @class Viewer\n * @classdesc The main OpenSeadragon viewer class.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @extends OpenSeadragon.ControlDock\n * @param {OpenSeadragon.Options} options - Viewer options.\n *\n **/\n$.Viewer = function( options ) {\n\n    var args  = arguments,\n        _this = this,\n        i;\n\n\n    //backward compatibility for positional args while prefering more\n    //idiomatic javascript options object as the only argument\n    if( !$.isPlainObject( options ) ){\n        options = {\n            id:                 args[ 0 ],\n            xmlPath:            args.length > 1 ? args[ 1 ] : undefined,\n            prefixUrl:          args.length > 2 ? args[ 2 ] : undefined,\n            controls:           args.length > 3 ? args[ 3 ] : undefined,\n            overlays:           args.length > 4 ? args[ 4 ] : undefined\n        };\n    }\n\n    //options.config and the general config argument are deprecated\n    //in favor of the more direct specification of optional settings\n    //being pass directly on the options object\n    if ( options.config ){\n        $.extend( true, options, options.config );\n        delete options.config;\n    }\n\n    //Public properties\n    //Allow the options object to override global defaults\n    $.extend( true, this, {\n\n        //internal state and dom identifiers\n        id:             options.id,\n        hash:           options.hash || nextHash++,\n\n        //dom nodes\n        /**\n         * The parent element of this Viewer instance, passed in when the Viewer was created.\n         * @member {Element} element\n         * @memberof OpenSeadragon.Viewer#\n         */\n        element:        null,\n        /**\n         * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>\n         * Child element of {@link OpenSeadragon.Viewer#element}.\n         * @member {Element} container\n         * @memberof OpenSeadragon.Viewer#\n         */\n        container:      null,\n        /**\n         * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>\n         * Child element of {@link OpenSeadragon.Viewer#container},\n         * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>\n         * The parent of {@link OpenSeadragon.Drawer#canvas} instances.\n         * @member {Element} canvas\n         * @memberof OpenSeadragon.Viewer#\n         */\n        canvas:         null,\n\n        // Overlays list. An overlay allows to add html on top of the viewer.\n        overlays:           [],\n        // Container inside the canvas where overlays are drawn.\n        overlaysContainer:  null,\n\n        //private state properties\n        previousBody:   [],\n\n        //This was originally initialized in the constructor and so could never\n        //have anything in it.  now it can because we allow it to be specified\n        //in the options and is only empty by default if not specified. Also\n        //this array was returned from get_controls which I find confusing\n        //since this object has a controls property which is treated in other\n        //functions like clearControls.  I\'m removing the accessors.\n        customControls: [],\n\n        //These are originally not part options but declared as members\n        //in initialize.  It\'s still considered idiomatic to put them here\n        source:         null,\n        /**\n         * Handles rendering of tiles in the viewer. Created for each TileSource opened.\n         * @member {OpenSeadragon.Drawer} drawer\n         * @memberof OpenSeadragon.Viewer#\n         */\n        drawer:             null,\n        world:              null,\n        /**\n         * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.\n         * @member {OpenSeadragon.Viewport} viewport\n         * @memberof OpenSeadragon.Viewer#\n         */\n        viewport:       null,\n        /**\n         * @member {OpenSeadragon.Navigator} navigator\n         * @memberof OpenSeadragon.Viewer#\n         */\n        navigator:      null,\n\n        //A collection viewport is a separate viewport used to provide\n        //simultaneous rendering of sets of tiles\n        collectionViewport:     null,\n        collectionDrawer:       null,\n\n        //UI image resources\n        //TODO: rename navImages to uiImages\n        navImages:      null,\n\n        //interface button controls\n        buttons:        null,\n\n        //TODO: this is defunct so safely remove it\n        profiler:       null\n\n    }, $.DEFAULT_SETTINGS, options );\n\n    if ( typeof( this.hash) === "undefined" ) {\n        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");\n    }\n    if ( typeof( THIS[ this.hash ] ) !== "undefined" ) {\n        // We don\'t want to throw an error here, as the user might have discarded\n        // the previous viewer with the same hash and now want to recreate it.\n        $.console.warn("Hash " + this.hash + " has already been used.");\n    }\n\n    //Private state properties\n    THIS[ this.hash ] = {\n        "fsBoundsDelta":     new $.Point( 1, 1 ),\n        "prevContainerSize": null,\n        "animating":         false,\n        "forceRedraw":       false,\n        "mouseInside":       false,\n        "group":             null,\n        // whether we should be continuously zooming\n        "zooming":           false,\n        // how much we should be continuously zooming by\n        "zoomFactor":        null,\n        "lastZoomTime":      null,\n        "fullPage":          false,\n        "onfullscreenchange": null\n    };\n\n    this._sequenceIndex = 0;\n    this._firstOpen = true;\n    this._updateRequestId = null;\n    this._loadQueue = [];\n    this.currentOverlays = [];\n\n    this._lastScrollTime = $.now(); // variable used to help normalize the scroll event speed of different devices\n\n    //Inherit some behaviors and properties\n    $.EventSource.call( this );\n\n    this.addHandler( \'open-failed\', function ( event ) {\n        var msg = $.getString( "Errors.OpenFailed", event.eventSource, event.message);\n        _this._showMessage( msg );\n    });\n\n    $.ControlDock.call( this, options );\n\n    //Deal with tile sources\n    if ( this.xmlPath  ){\n        //Deprecated option.  Now it is preferred to use the tileSources option\n        this.tileSources = [ this.xmlPath ];\n    }\n\n    this.element              = this.element || document.getElementById( this.id );\n    this.canvas               = $.makeNeutralElement( "div" );\n\n    this.canvas.className = "openseadragon-canvas";\n    (function( style ){\n        style.width    = "100%";\n        style.height   = "100%";\n        style.overflow = "hidden";\n        style.position = "absolute";\n        style.top      = "0px";\n        style.left     = "0px";\n    }(this.canvas.style));\n    $.setElementTouchActionNone( this.canvas );\n    if (options.tabIndex !== "") {\n        this.canvas.tabIndex = (options.tabIndex === undefined ? 0 : options.tabIndex);\n    }\n\n    //the container is created through applying the ControlDock constructor above\n    this.container.className = "openseadragon-container";\n    (function( style ){\n        style.width     = "100%";\n        style.height    = "100%";\n        style.position  = "relative";\n        style.overflow  = "hidden";\n        style.left      = "0px";\n        style.top       = "0px";\n        style.textAlign = "left";  // needed to protect against\n    }( this.container.style ));\n\n    this.container.insertBefore( this.canvas, this.container.firstChild );\n    this.element.appendChild( this.container );\n\n    //Used for toggling between fullscreen and default container size\n    //TODO: these can be closure private and shared across Viewer\n    //      instances.\n    this.bodyWidth      = document.body.style.width;\n    this.bodyHeight     = document.body.style.height;\n    this.bodyOverflow   = document.body.style.overflow;\n    this.docOverflow    = document.documentElement.style.overflow;\n\n    this.innerTracker = new $.MouseTracker({\n        element:                  this.canvas,\n        startDisabled:            this.mouseNavEnabled ? false : true,\n        clickTimeThreshold:       this.clickTimeThreshold,\n        clickDistThreshold:       this.clickDistThreshold,\n        dblClickTimeThreshold:    this.dblClickTimeThreshold,\n        dblClickDistThreshold:    this.dblClickDistThreshold,\n        keyDownHandler:           $.delegate( this, onCanvasKeyDown ),\n        keyHandler:               $.delegate( this, onCanvasKeyPress ),\n        clickHandler:             $.delegate( this, onCanvasClick ),\n        dblClickHandler:          $.delegate( this, onCanvasDblClick ),\n        dragHandler:              $.delegate( this, onCanvasDrag ),\n        dragEndHandler:           $.delegate( this, onCanvasDragEnd ),\n        enterHandler:             $.delegate( this, onCanvasEnter ),\n        exitHandler:              $.delegate( this, onCanvasExit ),\n        pressHandler:             $.delegate( this, onCanvasPress ),\n        releaseHandler:           $.delegate( this, onCanvasRelease ),\n        nonPrimaryPressHandler:   $.delegate( this, onCanvasNonPrimaryPress ),\n        nonPrimaryReleaseHandler: $.delegate( this, onCanvasNonPrimaryRelease ),\n        scrollHandler:            $.delegate( this, onCanvasScroll ),\n        pinchHandler:             $.delegate( this, onCanvasPinch )\n    });\n\n    this.outerTracker = new $.MouseTracker({\n        element:               this.container,\n        startDisabled:         this.mouseNavEnabled ? false : true,\n        clickTimeThreshold:    this.clickTimeThreshold,\n        clickDistThreshold:    this.clickDistThreshold,\n        dblClickTimeThreshold: this.dblClickTimeThreshold,\n        dblClickDistThreshold: this.dblClickDistThreshold,\n        enterHandler:          $.delegate( this, onContainerEnter ),\n        exitHandler:           $.delegate( this, onContainerExit )\n    });\n\n    if( this.toolbar ){\n        this.toolbar = new $.ControlDock({ element: this.toolbar });\n    }\n\n    this.bindStandardControls();\n\n    THIS[ this.hash ].prevContainerSize = _getSafeElemSize( this.container );\n\n    // Create the world\n    this.world = new $.World({\n        viewer: this\n    });\n\n    this.world.addHandler(\'add-item\', function(event) {\n        // For backwards compatibility, we maintain the source property\n        _this.source = _this.world.getItemAt(0).source;\n\n        THIS[ _this.hash ].forceRedraw = true;\n\n        if (!_this._updateRequestId) {\n            _this._updateRequestId = scheduleUpdate( _this, updateMulti );\n        }\n    });\n\n    this.world.addHandler(\'remove-item\', function(event) {\n        // For backwards compatibility, we maintain the source property\n        if (_this.world.getItemCount()) {\n            _this.source = _this.world.getItemAt(0).source;\n        } else {\n            _this.source = null;\n        }\n\n        THIS[ _this.hash ].forceRedraw = true;\n    });\n\n    this.world.addHandler(\'metrics-change\', function(event) {\n        if (_this.viewport) {\n            _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());\n        }\n    });\n\n    this.world.addHandler(\'item-index-change\', function(event) {\n        // For backwards compatibility, we maintain the source property\n        _this.source = _this.world.getItemAt(0).source;\n    });\n\n    // Create the viewport\n    this.viewport = new $.Viewport({\n        containerSize:      THIS[ this.hash ].prevContainerSize,\n        springStiffness:    this.springStiffness,\n        animationTime:      this.animationTime,\n        minZoomImageRatio:  this.minZoomImageRatio,\n        maxZoomPixelRatio:  this.maxZoomPixelRatio,\n        visibilityRatio:    this.visibilityRatio,\n        wrapHorizontal:     this.wrapHorizontal,\n        wrapVertical:       this.wrapVertical,\n        defaultZoomLevel:   this.defaultZoomLevel,\n        minZoomLevel:       this.minZoomLevel,\n        maxZoomLevel:       this.maxZoomLevel,\n        viewer:             this,\n        degrees:            this.degrees,\n        navigatorRotate:    this.navigatorRotate,\n        homeFillsViewer:    this.homeFillsViewer,\n        margins:            this.viewportMargins\n    });\n\n    this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());\n\n    // Create the image loader\n    this.imageLoader = new $.ImageLoader({\n        jobLimit: this.imageLoaderLimit\n    });\n\n    // Create the tile cache\n    this.tileCache = new $.TileCache({\n        maxImageCacheCount: this.maxImageCacheCount\n    });\n\n    // Create the drawer\n    this.drawer = new $.Drawer({\n        viewer:             this,\n        viewport:           this.viewport,\n        element:            this.canvas,\n        debugGridColor:     this.debugGridColor\n    });\n\n    // Overlay container\n    this.overlaysContainer    = $.makeNeutralElement( "div" );\n    this.canvas.appendChild( this.overlaysContainer );\n\n    // Now that we have a drawer, see if it supports rotate. If not we need to remove the rotate buttons\n    if (!this.drawer.canRotate()) {\n        // Disable/remove the rotate left/right buttons since they aren\'t supported\n        if (this.rotateLeft) {\n            i = this.buttons.buttons.indexOf(this.rotateLeft);\n            this.buttons.buttons.splice(i, 1);\n            this.buttons.element.removeChild(this.rotateLeft.element);\n        }\n        if (this.rotateRight) {\n            i = this.buttons.buttons.indexOf(this.rotateRight);\n            this.buttons.buttons.splice(i, 1);\n            this.buttons.element.removeChild(this.rotateRight.element);\n        }\n    }\n\n    //Instantiate a navigator if configured\n    if ( this.showNavigator){\n        this.navigator = new $.Navigator({\n            id:                this.navigatorId,\n            position:          this.navigatorPosition,\n            sizeRatio:         this.navigatorSizeRatio,\n            maintainSizeRatio: this.navigatorMaintainSizeRatio,\n            top:               this.navigatorTop,\n            left:              this.navigatorLeft,\n            width:             this.navigatorWidth,\n            height:            this.navigatorHeight,\n            autoResize:        this.navigatorAutoResize,\n            autoFade:          this.navigatorAutoFade,\n            prefixUrl:         this.prefixUrl,\n            viewer:            this,\n            navigatorRotate:   this.navigatorRotate,\n            crossOriginPolicy: this.crossOriginPolicy\n        });\n    }\n\n    // Sequence mode\n    if (this.sequenceMode) {\n        this.bindSequenceControls();\n    }\n\n    // Open initial tilesources\n    if (this.tileSources) {\n        this.open( this.tileSources );\n    }\n\n    // Add custom controls\n    for ( i = 0; i < this.customControls.length; i++ ) {\n        this.addControl(\n            this.customControls[ i ].id,\n            {anchor: this.customControls[ i ].anchor}\n        );\n    }\n\n    // Initial fade out\n    $.requestAnimationFrame( function(){\n        beginControlsAutoHide( _this );\n    } );\n};\n\n$.extend( $.Viewer.prototype, $.EventSource.prototype, $.ControlDock.prototype, /** @lends OpenSeadragon.Viewer.prototype */{\n\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isOpen: function () {\n        return !!this.world.getItemCount();\n    },\n\n    // deprecated\n    openDzi: function ( dzi ) {\n        $.console.error( "[Viewer.openDzi] this function is deprecated; use Viewer.open() instead." );\n        return this.open( dzi );\n    },\n\n    // deprecated\n    openTileSource: function ( tileSource ) {\n        $.console.error( "[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead." );\n        return this.open( tileSource );\n    },\n\n    /**\n     * Open tiled images into the viewer, closing any others.\n     * @function\n     * @param {Array|String|Object|Function} tileSources - This can be a TiledImage\n     * specifier, a TileSource specifier, or an array of either. A TiledImage specifier\n     * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},\n     * except for the index property; images are added in sequence.\n     * A TileSource specifier is anything you could pass as the tileSource property\n     * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:open\n     * @fires OpenSeadragon.Viewer.event:open-failed\n     */\n    open: function (tileSources) {\n        var _this = this;\n\n        this.close();\n\n        if (!tileSources) {\n            return;\n        }\n\n        if (this.sequenceMode && $.isArray(tileSources)) {\n            if (this.referenceStrip) {\n                this.referenceStrip.destroy();\n                this.referenceStrip = null;\n            }\n\n            this.tileSources = tileSources;\n            this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));\n            if (this.tileSources.length) {\n                this.open(this.tileSources[this._sequenceIndex]);\n\n                if ( this.showReferenceStrip ){\n                    this.referenceStrip = new $.ReferenceStrip({\n                        id:          this.referenceStripElement,\n                        position:    this.referenceStripPosition,\n                        sizeRatio:   this.referenceStripSizeRatio,\n                        scroll:      this.referenceStripScroll,\n                        height:      this.referenceStripHeight,\n                        width:       this.referenceStripWidth,\n                        tileSources: this.tileSources,\n                        prefixUrl:   this.prefixUrl,\n                        viewer:      this\n                    });\n                }\n            }\n\n            this._updateSequenceButtons( this._sequenceIndex );\n            return;\n        }\n\n        if (!$.isArray(tileSources)) {\n            tileSources = [tileSources];\n        }\n\n        if (!tileSources.length) {\n            return;\n        }\n\n        this._opening = true;\n\n        var expected = tileSources.length;\n        var successes = 0;\n        var failures = 0;\n        var failEvent;\n\n        var checkCompletion = function() {\n            if (successes + failures === expected) {\n                if (successes) {\n                    if (_this._firstOpen || !_this.preserveViewport) {\n                        _this.viewport.goHome( true );\n                        _this.viewport.update();\n                    }\n\n                    _this._firstOpen = false;\n\n                    var source = tileSources[0];\n                    if (source.tileSource) {\n                        source = source.tileSource;\n                    }\n\n                    // Global overlays\n                    if( _this.overlays && !_this.preserveOverlays ){\n                        for ( var i = 0; i < _this.overlays.length; i++ ) {\n                            _this.currentOverlays[ i ] = getOverlayObject( _this, _this.overlays[ i ] );\n                        }\n                    }\n\n                    _this._drawOverlays();\n                    _this._opening = false;\n\n                    /**\n                     * Raised when the viewer has opened and loaded one or more TileSources.\n                     *\n                     * @event open\n                     * @memberof OpenSeadragon.Viewer\n                     * @type {object}\n                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n                     * @property {OpenSeadragon.TileSource} source - The tile source that was opened.\n                     * @property {?Object} userData - Arbitrary subscriber-defined object.\n                     */\n                    // TODO: what if there are multiple sources?\n                    _this.raiseEvent( \'open\', { source: source } );\n                } else {\n                    _this._opening = false;\n\n                    /**\n                     * Raised when an error occurs loading a TileSource.\n                     *\n                     * @event open-failed\n                     * @memberof OpenSeadragon.Viewer\n                     * @type {object}\n                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n                     * @property {String} message - Information about what failed.\n                     * @property {String} source - The tile source that failed.\n                     * @property {?Object} userData - Arbitrary subscriber-defined object.\n                     */\n                    _this.raiseEvent( \'open-failed\', failEvent );\n                }\n            }\n        };\n\n        var doOne = function(options) {\n            if (!$.isPlainObject(options) || !options.tileSource) {\n                options = {\n                    tileSource: options\n                };\n            }\n\n            if (options.index !== undefined) {\n                $.console.error(\'[Viewer.open] setting indexes here is not supported; use addTiledImage instead\');\n                delete options.index;\n            }\n\n            if (options.collectionImmediately === undefined) {\n                options.collectionImmediately = true;\n            }\n\n            var originalSuccess = options.success;\n            options.success = function(event) {\n                successes++;\n\n                // TODO: now that options has other things besides tileSource, the overlays\n                // should probably be at the options level, not the tileSource level.\n                if (options.tileSource.overlays) {\n                    for (var i = 0; i < options.tileSource.overlays.length; i++) {\n                        _this.addOverlay(options.tileSource.overlays[i]);\n                    }\n                }\n\n                if (originalSuccess) {\n                    originalSuccess(event);\n                }\n\n                checkCompletion();\n            };\n\n            var originalError = options.error;\n            options.error = function(event) {\n                failures++;\n\n                if (!failEvent) {\n                    failEvent = event;\n                }\n\n                if (originalError) {\n                    originalError(event);\n                }\n\n                checkCompletion();\n            };\n\n            _this.addTiledImage(options);\n        };\n\n        // TileSources\n        for (var i = 0; i < tileSources.length; i++) {\n            doOne(tileSources[i]);\n        }\n\n        return this;\n    },\n\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:close\n     */\n    close: function ( ) {\n        if ( !THIS[ this.hash ] ) {\n            //this viewer has already been destroyed: returning immediately\n            return this;\n        }\n\n        this._opening = false;\n\n        if ( this.navigator ) {\n            this.navigator.close();\n        }\n\n        if( ! this.preserveOverlays) {\n            this.clearOverlays();\n            this.overlaysContainer.innerHTML = "";\n        }\n\n        THIS[ this.hash ].animating = false;\n        this.world.removeAll();\n        this.imageLoader.clear();\n\n        /**\n         * Raised when the viewer is closed (see {@link OpenSeadragon.Viewer#close}).\n         *\n         * @event close\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'close\' );\n\n        return this;\n    },\n\n\n    /**\n     * Function to destroy the viewer and clean up everything created by OpenSeadragon.\n     *\n     * Example:\n     * var viewer = OpenSeadragon({\n     *   [...]\n     * });\n     *\n     * //when you are done with the viewer:\n     * viewer.destroy();\n     * viewer = null; //important\n     *\n     * @function\n     */\n    destroy: function( ) {\n        if ( !THIS[ this.hash ] ) {\n            //this viewer has already been destroyed: returning immediately\n            return;\n        }\n\n        this.close();\n\n        this.clearOverlays();\n        this.overlaysContainer.innerHTML = "";\n\n        //TODO: implement this...\n        //this.unbindSequenceControls()\n        //this.unbindStandardControls()\n\n        if (this.referenceStrip) {\n            this.referenceStrip.destroy();\n            this.referenceStrip = null;\n        }\n\n        if ( this._updateRequestId !== null ) {\n            $.cancelAnimationFrame( this._updateRequestId );\n            this._updateRequestId = null;\n        }\n\n        if ( this.drawer ) {\n            this.drawer.destroy();\n        }\n\n        this.removeAllHandlers();\n\n        // Go through top element (passed to us) and remove all children\n        // Use removeChild to make sure it handles SVG or any non-html\n        // also it performs better - http://jsperf.com/innerhtml-vs-removechild/15\n        if (this.element){\n            while (this.element.firstChild) {\n                this.element.removeChild(this.element.firstChild);\n            }\n        }\n\n        // destroy the mouse trackers\n        if (this.innerTracker){\n            this.innerTracker.destroy();\n        }\n        if (this.outerTracker){\n            this.outerTracker.destroy();\n        }\n\n        THIS[ this.hash ] = null;\n        delete THIS[ this.hash ];\n\n        // clear all our references to dom objects\n        this.canvas = null;\n        this.container = null;\n\n        // clear our reference to the main element - they will need to pass it in again, creating a new viewer\n        this.element = null;\n    },\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isMouseNavEnabled: function () {\n        return this.innerTracker.isTracking();\n    },\n\n    /**\n     * @function\n     * @param {Boolean} enabled - true to enable, false to disable\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:mouse-enabled\n     */\n    setMouseNavEnabled: function( enabled ){\n        this.innerTracker.setTracking( enabled );\n        this.outerTracker.setTracking( enabled );\n        /**\n         * Raised when mouse/touch navigation is enabled or disabled (see {@link OpenSeadragon.Viewer#setMouseNavEnabled}).\n         *\n         * @event mouse-enabled\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} enabled\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'mouse-enabled\', { enabled: enabled } );\n        return this;\n    },\n\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    areControlsEnabled: function () {\n        var enabled = this.controls.length,\n            i;\n        for( i = 0; i < this.controls.length; i++ ){\n            enabled = enabled && this.controls[ i ].isVisibile();\n        }\n        return enabled;\n    },\n\n\n    /**\n     * Shows or hides the controls (e.g. the default navigation buttons).\n     *\n     * @function\n     * @param {Boolean} true to show, false to hide.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:controls-enabled\n     */\n    setControlsEnabled: function( enabled ) {\n        if( enabled ){\n            abortControlsAutoHide( this );\n        } else {\n            beginControlsAutoHide( this );\n        }\n        /**\n         * Raised when the navigation controls are shown or hidden (see {@link OpenSeadragon.Viewer#setControlsEnabled}).\n         *\n         * @event controls-enabled\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} enabled\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'controls-enabled\', { enabled: enabled } );\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isFullPage: function () {\n        return THIS[ this.hash ].fullPage;\n    },\n\n\n    /**\n     * Toggle full page mode.\n     * @function\n     * @param {Boolean} fullPage\n     *      If true, enter full page mode.  If false, exit full page mode.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pre-full-page\n     * @fires OpenSeadragon.Viewer.event:full-page\n     */\n    setFullPage: function( fullPage ) {\n\n        var body = document.body,\n            bodyStyle = body.style,\n            docStyle = document.documentElement.style,\n            _this = this,\n            hash,\n            nodes,\n            i;\n\n        //dont bother modifying the DOM if we are already in full page mode.\n        if ( fullPage == this.isFullPage() ) {\n            return this;\n        }\n\n        var fullPageEventArgs = {\n            fullPage: fullPage,\n            preventDefaultAction: false\n        };\n        /**\n         * Raised when the viewer is about to change to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).\n         *\n         * @event pre-full-page\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} fullPage - True if entering full-page mode, false if exiting full-page mode.\n         * @property {Boolean} preventDefaultAction - Set to true to prevent full-page mode change. Default: false.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'pre-full-page\', fullPageEventArgs );\n        if ( fullPageEventArgs.preventDefaultAction ) {\n            return this;\n        }\n\n        if ( fullPage ) {\n\n            this.elementSize = $.getElementSize( this.element );\n            this.pageScroll = $.getPageScroll();\n\n            this.elementMargin = this.element.style.margin;\n            this.element.style.margin = "0";\n            this.elementPadding = this.element.style.padding;\n            this.element.style.padding = "0";\n\n            this.bodyMargin = bodyStyle.margin;\n            this.docMargin = docStyle.margin;\n            bodyStyle.margin = "0";\n            docStyle.margin = "0";\n\n            this.bodyPadding = bodyStyle.padding;\n            this.docPadding = docStyle.padding;\n            bodyStyle.padding = "0";\n            docStyle.padding = "0";\n\n            this.bodyWidth = bodyStyle.width;\n            this.docWidth = docStyle.width;\n            bodyStyle.width = "100%";\n            docStyle.width = "100%";\n\n            this.bodyHeight = bodyStyle.height;\n            this.docHeight = docStyle.height;\n            bodyStyle.height = "100%";\n            docStyle.height = "100%";\n\n            //when entering full screen on the ipad it wasnt sufficient to leave\n            //the body intact as only only the top half of the screen would\n            //respond to touch events on the canvas, while the bottom half treated\n            //them as touch events on the document body.  Thus we remove and store\n            //the bodies elements and replace them when we leave full screen.\n            this.previousBody = [];\n            THIS[ this.hash ].prevElementParent = this.element.parentNode;\n            THIS[ this.hash ].prevNextSibling = this.element.nextSibling;\n            THIS[ this.hash ].prevElementWidth = this.element.style.width;\n            THIS[ this.hash ].prevElementHeight = this.element.style.height;\n            nodes = body.childNodes.length;\n            for ( i = 0; i < nodes; i++ ) {\n                this.previousBody.push( body.childNodes[ 0 ] );\n                body.removeChild( body.childNodes[ 0 ] );\n            }\n\n            //If we\'ve got a toolbar, we need to enable the user to use css to\n            //preserve it in fullpage mode\n            if ( this.toolbar && this.toolbar.element ) {\n                //save a reference to the parent so we can put it back\n                //in the long run we need a better strategy\n                this.toolbar.parentNode = this.toolbar.element.parentNode;\n                this.toolbar.nextSibling = this.toolbar.element.nextSibling;\n                body.appendChild( this.toolbar.element );\n\n                //Make sure the user has some ability to style the toolbar based\n                //on the mode\n                $.addClass( this.toolbar.element, \'fullpage\' );\n            }\n\n            $.addClass( this.element, \'fullpage\' );\n            body.appendChild( this.element );\n\n            this.element.style.height = $.getWindowSize().y + \'px\';\n            this.element.style.width = $.getWindowSize().x + \'px\';\n\n            if ( this.toolbar && this.toolbar.element ) {\n                this.element.style.height = (\n                    $.getElementSize( this.element ).y - $.getElementSize( this.toolbar.element ).y\n                ) + \'px\';\n            }\n\n            THIS[ this.hash ].fullPage = true;\n\n            // mouse will be inside container now\n            $.delegate( this, onContainerEnter )( {} );\n\n        } else {\n\n            this.element.style.margin = this.elementMargin;\n            this.element.style.padding = this.elementPadding;\n\n            bodyStyle.margin = this.bodyMargin;\n            docStyle.margin = this.docMargin;\n\n            bodyStyle.padding = this.bodyPadding;\n            docStyle.padding = this.docPadding;\n\n            bodyStyle.width = this.bodyWidth;\n            docStyle.width = this.docWidth;\n\n            bodyStyle.height = this.bodyHeight;\n            docStyle.height = this.docHeight;\n\n            body.removeChild( this.element );\n            nodes = this.previousBody.length;\n            for ( i = 0; i < nodes; i++ ) {\n                body.appendChild( this.previousBody.shift() );\n            }\n\n            $.removeClass( this.element, \'fullpage\' );\n            THIS[ this.hash ].prevElementParent.insertBefore(\n                this.element,\n                THIS[ this.hash ].prevNextSibling\n            );\n\n            //If we\'ve got a toolbar, we need to enable the user to use css to\n            //reset it to its original state\n            if ( this.toolbar && this.toolbar.element ) {\n                body.removeChild( this.toolbar.element );\n\n                //Make sure the user has some ability to style the toolbar based\n                //on the mode\n                $.removeClass( this.toolbar.element, \'fullpage\' );\n\n                this.toolbar.parentNode.insertBefore(\n                    this.toolbar.element,\n                    this.toolbar.nextSibling\n                );\n                delete this.toolbar.parentNode;\n                delete this.toolbar.nextSibling;\n            }\n\n            this.element.style.width = THIS[ this.hash ].prevElementWidth;\n            this.element.style.height = THIS[ this.hash ].prevElementHeight;\n\n            // After exiting fullPage or fullScreen, it can take some time\n            // before the browser can actually set the scroll.\n            var restoreScrollCounter = 0;\n            var restoreScroll = function() {\n                $.setPageScroll( _this.pageScroll );\n                var pageScroll = $.getPageScroll();\n                restoreScrollCounter++;\n                if ( restoreScrollCounter < 10 &&\n                    pageScroll.x !== _this.pageScroll.x ||\n                    pageScroll.y !== _this.pageScroll.y ) {\n                    $.requestAnimationFrame( restoreScroll );\n                }\n            };\n            $.requestAnimationFrame( restoreScroll );\n\n            THIS[ this.hash ].fullPage = false;\n\n            // mouse will likely be outside now\n            $.delegate( this, onContainerExit )( { } );\n\n        }\n\n        if ( this.navigator && this.viewport ) {\n            this.navigator.update( this.viewport );\n        }\n\n        /**\n         * Raised when the viewer has changed to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).\n         *\n         * @event full-page\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} fullPage - True if changed to full-page mode, false if exited full-page mode.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'full-page\', { fullPage: fullPage } );\n\n        return this;\n    },\n\n    /**\n     * Toggle full screen mode if supported. Toggle full page mode otherwise.\n     * @function\n     * @param {Boolean} fullScreen\n     *      If true, enter full screen mode.  If false, exit full screen mode.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pre-full-screen\n     * @fires OpenSeadragon.Viewer.event:full-screen\n     */\n    setFullScreen: function( fullScreen ) {\n        var _this = this;\n\n        if ( !$.supportsFullScreen ) {\n            return this.setFullPage( fullScreen );\n        }\n\n        if ( $.isFullScreen() === fullScreen ) {\n            return this;\n        }\n\n        var fullScreeEventArgs = {\n            fullScreen: fullScreen,\n            preventDefaultAction: false\n        };\n        /**\n         * Raised when the viewer is about to change to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).\n         * Note: the pre-full-screen event is not raised when the user is exiting\n         * full-screen mode by pressing the Esc key. In that case, consider using\n         * the full-screen, pre-full-page or full-page events.\n         *\n         * @event pre-full-screen\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} fullScreen - True if entering full-screen mode, false if exiting full-screen mode.\n         * @property {Boolean} preventDefaultAction - Set to true to prevent full-screen mode change. Default: false.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'pre-full-screen\', fullScreeEventArgs );\n        if ( fullScreeEventArgs.preventDefaultAction ) {\n            return this;\n        }\n\n        if ( fullScreen ) {\n\n            this.setFullPage( true );\n            // If the full page mode is not actually entered, we need to prevent\n            // the full screen mode.\n            if ( !this.isFullPage() ) {\n                return this;\n            }\n\n            this.fullPageStyleWidth = this.element.style.width;\n            this.fullPageStyleHeight = this.element.style.height;\n            this.element.style.width = \'100%\';\n            this.element.style.height = \'100%\';\n\n            var onFullScreenChange = function() {\n                var isFullScreen = $.isFullScreen();\n                if ( !isFullScreen ) {\n                    $.removeEvent( document, $.fullScreenEventName, onFullScreenChange );\n                    $.removeEvent( document, $.fullScreenErrorEventName, onFullScreenChange );\n\n                    _this.setFullPage( false );\n                    if ( _this.isFullPage() ) {\n                        _this.element.style.width = _this.fullPageStyleWidth;\n                        _this.element.style.height = _this.fullPageStyleHeight;\n                    }\n                }\n                if ( _this.navigator && _this.viewport ) {\n                    _this.navigator.update( _this.viewport );\n                }\n                /**\n                 * Raised when the viewer has changed to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).\n                 *\n                 * @event full-screen\n                 * @memberof OpenSeadragon.Viewer\n                 * @type {object}\n                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n                 * @property {Boolean} fullScreen - True if changed to full-screen mode, false if exited full-screen mode.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( \'full-screen\', { fullScreen: isFullScreen } );\n            };\n            $.addEvent( document, $.fullScreenEventName, onFullScreenChange );\n            $.addEvent( document, $.fullScreenErrorEventName, onFullScreenChange );\n\n            $.requestFullScreen( document.body );\n\n        } else {\n            $.exitFullScreen();\n        }\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isVisible: function () {\n        return this.container.style.visibility != "hidden";\n    },\n\n\n    /**\n     * @function\n     * @param {Boolean} visible\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:visible\n     */\n    setVisible: function( visible ){\n        this.container.style.visibility = visible ? "" : "hidden";\n        /**\n         * Raised when the viewer is shown or hidden (see {@link OpenSeadragon.Viewer#setVisible}).\n         *\n         * @event visible\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} visible\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'visible\', { visible: visible } );\n        return this;\n    },\n\n    /**\n     * Add a tiled image to the viewer.\n     * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}\n     *  supports except arrays of images.\n     * Note that you can specify options.width or options.height, but not both.\n     * The other dimension will be calculated according to the item\'s aspect ratio.\n     * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is\n     * automatically arranged with the others.\n     * @function\n     * @param {Object} options\n     * @param {String|Object|Function} options.tileSource - The TileSource specifier.\n     * A String implies a url used to determine the tileSource implementation\n     *      based on the file extension of url. JSONP is implied by *.js,\n     *      otherwise the url is retrieved as text and the resulting text is\n     *      introspected to determine if its json, xml, or text and parsed.\n     * An Object implies an inline configuration which has a single\n     *      property sufficient for being able to determine tileSource\n     *      implementation. If the object has a property which is a function\n     *      named \'getTileUrl\', it is treated as a custom TileSource.\n     * @param {Number} [options.index] The index of the item. Added on top of\n     * all other items if not specified.\n     * @param {Boolean} [options.replace=false] If true, the item at options.index will be\n     * removed and the new item is added in its place. options.tileSource will be\n     * interpreted and fetched if necessary before the old item is removed to avoid leaving\n     * a gap in the world.\n     * @param {Number} [options.x=0] The X position for the image in viewport coordinates.\n     * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.\n     * @param {Number} [options.width=1] The width for the image in viewport coordinates.\n     * @param {Number} [options.height] The height for the image in viewport coordinates.\n     * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates\n     * to fit the image into. If specified, x, y, width and height get ignored.\n     * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]\n     * How to anchor the image in the bounds if options.fitBounds is set.\n     * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to\n     * (portions of the image outside of this area will not be visible). Only works on\n     * browsers that support the HTML5 canvas.\n     * @param {Number} [options.opacity] Opacity the tiled image should be drawn at by default.\n     * @param {String} [options.compositeOperation] How the image is composited onto other images.\n     * @param {Function} [options.success] A function that gets called when the image is\n     * successfully added. It\'s passed the event object which contains a single property:\n     * "item", the resulting TiledImage.\n     * @param {Function} [options.error] A function that gets called if the image is\n     * unable to be added. It\'s passed the error event object, which contains "message"\n     * and "source" properties.\n     * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,\n     * specifies whether to snap to the new arrangement immediately or to animate to it.\n     * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.\n     * @fires OpenSeadragon.World.event:add-item\n     * @fires OpenSeadragon.Viewer.event:add-item-failed\n     */\n    addTiledImage: function( options ) {\n        $.console.assert(options, "[Viewer.addTiledImage] options is required");\n        $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");\n        $.console.assert(!options.replace || (options.index > -1 && options.index < this.world.getItemCount()),\n            "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world");\n\n        var _this = this;\n\n        if (options.replace) {\n            options.replaceItem = _this.world.getItemAt(options.index);\n        }\n\n        this._hideMessage();\n\n        if (options.placeholderFillStyle === undefined) {\n            options.placeholderFillStyle = this.placeholderFillStyle;\n        }\n        if (options.opacity === undefined) {\n            options.opacity = this.opacity;\n        }\n        if (options.compositeOperation === undefined) {\n            options.compositeOperation = this.compositeOperation;\n        }\n\n        var myQueueItem = {\n            options: options\n        };\n\n        function raiseAddItemFailed( event ) {\n            for (var i = 0; i < _this._loadQueue.length; i++) {\n                if (_this._loadQueue[i] === myQueueItem) {\n                    _this._loadQueue.splice(i, 1);\n                    break;\n                }\n            }\n\n            if (_this._loadQueue.length === 0) {\n                refreshWorld(myQueueItem);\n            }\n\n             /**\n             * Raised when an error occurs while adding a item.\n             * @event add-item-failed\n             * @memberOf OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n             * @property {String} message\n             * @property {String} source\n             * @property {Object} options The options passed to the addTiledImage method.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( \'add-item-failed\', event );\n\n            if (options.error) {\n                options.error(event);\n            }\n        }\n\n        function refreshWorld(theItem) {\n            if (_this.collectionMode) {\n                _this.world.arrange({\n                    immediately: theItem.options.collectionImmediately,\n                    rows: _this.collectionRows,\n                    columns: _this.collectionColumns,\n                    layout: _this.collectionLayout,\n                    tileSize: _this.collectionTileSize,\n                    tileMargin: _this.collectionTileMargin\n                });\n                _this.world.setAutoRefigureSizes(true);\n            }\n        }\n\n        if ($.isArray(options.tileSource)) {\n            setTimeout(function() {\n                raiseAddItemFailed({\n                    message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",\n                    source: options.tileSource,\n                    options: options\n                });\n            });\n            return;\n        }\n\n        this._loadQueue.push(myQueueItem);\n\n        getTileSourceImplementation( this, options.tileSource, function( tileSource ) {\n\n            myQueueItem.tileSource = tileSource;\n\n            // add everybody at the front of the queue that\'s ready to go\n            var queueItem, tiledImage, optionsClone;\n            while (_this._loadQueue.length) {\n                queueItem = _this._loadQueue[0];\n                if (!queueItem.tileSource) {\n                    break;\n                }\n\n                _this._loadQueue.splice(0, 1);\n\n                if (queueItem.options.replace) {\n                    var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);\n                    if (newIndex != -1) {\n                        queueItem.options.index = newIndex;\n                    }\n                    _this.world.removeItem(queueItem.options.replaceItem);\n                }\n\n                tiledImage = new $.TiledImage({\n                    viewer: _this,\n                    source: queueItem.tileSource,\n                    viewport: _this.viewport,\n                    drawer: _this.drawer,\n                    tileCache: _this.tileCache,\n                    imageLoader: _this.imageLoader,\n                    x: queueItem.options.x,\n                    y: queueItem.options.y,\n                    width: queueItem.options.width,\n                    height: queueItem.options.height,\n                    fitBounds: queueItem.options.fitBounds,\n                    fitBoundsPlacement: queueItem.options.fitBoundsPlacement,\n                    clip: queueItem.options.clip,\n                    placeholderFillStyle: queueItem.options.placeholderFillStyle,\n                    opacity: queueItem.options.opacity,\n                    compositeOperation: queueItem.options.compositeOperation,\n                    springStiffness: _this.springStiffness,\n                    animationTime: _this.animationTime,\n                    minZoomImageRatio: _this.minZoomImageRatio,\n                    wrapHorizontal: _this.wrapHorizontal,\n                    wrapVertical: _this.wrapVertical,\n                    immediateRender: _this.immediateRender,\n                    blendTime: _this.blendTime,\n                    alwaysBlend: _this.alwaysBlend,\n                    minPixelRatio: _this.minPixelRatio,\n                    smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,\n                    iOSDevice: _this.iOSDevice,\n                    crossOriginPolicy: _this.crossOriginPolicy,\n                    debugMode: _this.debugMode\n                });\n\n                if (_this.collectionMode) {\n                    _this.world.setAutoRefigureSizes(false);\n                }\n                _this.world.addItem( tiledImage, {\n                    index: queueItem.options.index\n                });\n\n                if (_this._loadQueue.length === 0) {\n                    //this restores the autoRefigureSizes flag to true.\n                    refreshWorld(queueItem);\n                }\n\n                if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {\n                    _this.viewport.goHome(true);\n                }\n\n                if (_this.navigator) {\n                    optionsClone = $.extend({}, queueItem.options, {\n                        replace: false, // navigator already removed the layer, nothing to replace\n                        originalTiledImage: tiledImage,\n                        tileSource: queueItem.tileSource\n                    });\n\n                    _this.navigator.addTiledImage(optionsClone);\n                }\n\n                if (queueItem.options.success) {\n                    queueItem.options.success({\n                        item: tiledImage\n                    });\n                }\n            }\n        }, function( event ) {\n            event.options = options;\n            raiseAddItemFailed(event);\n        } );\n    },\n\n    /**\n     * Add a simple image to the viewer.\n     * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}\n     * except for options.tileSource which is replaced by options.url.\n     * @function\n     * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}\n     * for all the options\n     * @param {String} options.url - The URL of the image to add.\n     * @fires OpenSeadragon.World.event:add-item\n     * @fires OpenSeadragon.Viewer.event:add-item-failed\n     */\n    addSimpleImage: function(options) {\n        $.console.assert(options, "[Viewer.addSimpleImage] options is required");\n        $.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");\n\n        var opts = $.extend({}, options, {\n            tileSource: {\n                type: \'image\',\n                url:  options.url\n            }\n        });\n        delete opts.url;\n        this.addTiledImage(opts);\n    },\n\n    // deprecated\n    addLayer: function( options ) {\n        var _this = this;\n\n        $.console.error( "[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead." );\n\n        var optionsClone = $.extend({}, options, {\n            success: function(event) {\n                _this.raiseEvent("add-layer", {\n                    options: options,\n                    drawer: event.item\n                });\n            },\n            error: function(event) {\n                _this.raiseEvent("add-layer-failed", event);\n            }\n        });\n\n        this.addTiledImage(optionsClone);\n        return this;\n    },\n\n    // deprecated\n    getLayerAtLevel: function( level ) {\n        $.console.error( "[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead." );\n        return this.world.getItemAt(level);\n    },\n\n    // deprecated\n    getLevelOfLayer: function( drawer ) {\n        $.console.error( "[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead." );\n        return this.world.getIndexOfItem(drawer);\n    },\n\n    // deprecated\n    getLayersCount: function() {\n        $.console.error( "[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead." );\n        return this.world.getItemCount();\n    },\n\n    // deprecated\n    setLayerLevel: function( drawer, level ) {\n        $.console.error( "[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead." );\n        return this.world.setItemIndex(drawer, level);\n    },\n\n    // deprecated\n    removeLayer: function( drawer ) {\n        $.console.error( "[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead." );\n        return this.world.removeItem(drawer);\n    },\n\n    /**\n     * Force the viewer to redraw its contents.\n     * @returns {OpenSeadragon.Viewer} Chainable.\n     */\n    forceRedraw: function() {\n        THIS[ this.hash ].forceRedraw = true;\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     */\n    bindSequenceControls: function(){\n\n        //////////////////////////////////////////////////////////////////////////\n        // Image Sequence Controls\n        //////////////////////////////////////////////////////////////////////////\n        var onFocusHandler          = $.delegate( this, onFocus ),\n            onBlurHandler           = $.delegate( this, onBlur ),\n            onNextHandler           = $.delegate( this, onNext ),\n            onPreviousHandler       = $.delegate( this, onPrevious ),\n            navImages               = this.navImages,\n            useGroup                = true ;\n\n        if( this.showSequenceControl ){\n\n            if( this.previousButton || this.nextButton ){\n                //if we are binding to custom buttons then layout and\n                //grouping is the responsibility of the page author\n                useGroup = false;\n            }\n\n            this.previousButton = new $.Button({\n                element:    this.previousButton ? $.getElement( this.previousButton ) : null,\n                clickTimeThreshold: this.clickTimeThreshold,\n                clickDistThreshold: this.clickDistThreshold,\n                tooltip:    $.getString( "Tooltips.PreviousPage" ),\n                srcRest:    resolveUrl( this.prefixUrl, navImages.previous.REST ),\n                srcGroup:   resolveUrl( this.prefixUrl, navImages.previous.GROUP ),\n                srcHover:   resolveUrl( this.prefixUrl, navImages.previous.HOVER ),\n                srcDown:    resolveUrl( this.prefixUrl, navImages.previous.DOWN ),\n                onRelease:  onPreviousHandler,\n                onFocus:    onFocusHandler,\n                onBlur:     onBlurHandler\n            });\n\n            this.nextButton = new $.Button({\n                element:    this.nextButton ? $.getElement( this.nextButton ) : null,\n                clickTimeThreshold: this.clickTimeThreshold,\n                clickDistThreshold: this.clickDistThreshold,\n                tooltip:    $.getString( "Tooltips.NextPage" ),\n                srcRest:    resolveUrl( this.prefixUrl, navImages.next.REST ),\n                srcGroup:   resolveUrl( this.prefixUrl, navImages.next.GROUP ),\n                srcHover:   resolveUrl( this.prefixUrl, navImages.next.HOVER ),\n                srcDown:    resolveUrl( this.prefixUrl, navImages.next.DOWN ),\n                onRelease:  onNextHandler,\n                onFocus:    onFocusHandler,\n                onBlur:     onBlurHandler\n            });\n\n            if( !this.navPrevNextWrap ){\n                this.previousButton.disable();\n            }\n\n            if (!this.tileSources || !this.tileSources.length) {\n                this.nextButton.disable();\n            }\n\n            if( useGroup ){\n                this.paging = new $.ButtonGroup({\n                    buttons: [\n                        this.previousButton,\n                        this.nextButton\n                    ],\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold\n                });\n\n                this.pagingControl = this.paging.element;\n\n                if( this.toolbar ){\n                    this.toolbar.addControl(\n                        this.pagingControl,\n                        {anchor: $.ControlAnchor.BOTTOM_RIGHT}\n                    );\n                }else{\n                    this.addControl(\n                        this.pagingControl,\n                        {anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT}\n                    );\n                }\n            }\n        }\n        return this;\n    },\n\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     */\n    bindStandardControls: function(){\n        //////////////////////////////////////////////////////////////////////////\n        // Navigation Controls\n        //////////////////////////////////////////////////////////////////////////\n        var beginZoomingInHandler   = $.delegate( this, beginZoomingIn ),\n            endZoomingHandler       = $.delegate( this, endZooming ),\n            doSingleZoomInHandler   = $.delegate( this, doSingleZoomIn ),\n            beginZoomingOutHandler  = $.delegate( this, beginZoomingOut ),\n            doSingleZoomOutHandler  = $.delegate( this, doSingleZoomOut ),\n            onHomeHandler           = $.delegate( this, onHome ),\n            onFullScreenHandler     = $.delegate( this, onFullScreen ),\n            onRotateLeftHandler     = $.delegate( this, onRotateLeft ),\n            onRotateRightHandler    = $.delegate( this, onRotateRight ),\n            onFocusHandler          = $.delegate( this, onFocus ),\n            onBlurHandler           = $.delegate( this, onBlur ),\n            navImages               = this.navImages,\n            buttons                 = [],\n            useGroup                = true ;\n\n\n        if ( this.showNavigationControl ) {\n\n            if( this.zoomInButton || this.zoomOutButton ||\n                this.homeButton || this.fullPageButton ||\n                this.rotateLeftButton || this.rotateRightButton ) {\n                //if we are binding to custom buttons then layout and\n                //grouping is the responsibility of the page author\n                useGroup = false;\n            }\n\n            if ( this.showZoomControl ) {\n                buttons.push( this.zoomInButton = new $.Button({\n                    element:    this.zoomInButton ? $.getElement( this.zoomInButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.ZoomIn" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomIn.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomIn.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomIn.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomIn.DOWN ),\n                    onPress:    beginZoomingInHandler,\n                    onRelease:  endZoomingHandler,\n                    onClick:    doSingleZoomInHandler,\n                    onEnter:    beginZoomingInHandler,\n                    onExit:     endZoomingHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n\n                buttons.push( this.zoomOutButton = new $.Button({\n                    element:    this.zoomOutButton ? $.getElement( this.zoomOutButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.ZoomOut" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomOut.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomOut.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomOut.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomOut.DOWN ),\n                    onPress:    beginZoomingOutHandler,\n                    onRelease:  endZoomingHandler,\n                    onClick:    doSingleZoomOutHandler,\n                    onEnter:    beginZoomingOutHandler,\n                    onExit:     endZoomingHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n            }\n\n            if ( this.showHomeControl ) {\n                buttons.push( this.homeButton = new $.Button({\n                    element:    this.homeButton ? $.getElement( this.homeButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.Home" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.home.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.home.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.home.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.home.DOWN ),\n                    onRelease:  onHomeHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n            }\n\n            if ( this.showFullPageControl ) {\n                buttons.push( this.fullPageButton = new $.Button({\n                    element:    this.fullPageButton ? $.getElement( this.fullPageButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.FullPage" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.fullpage.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.fullpage.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.fullpage.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.fullpage.DOWN ),\n                    onRelease:  onFullScreenHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n            }\n\n            if ( this.showRotationControl ) {\n                buttons.push( this.rotateLeftButton = new $.Button({\n                    element:    this.rotateLeftButton ? $.getElement( this.rotateLeftButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.RotateLeft" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateleft.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateleft.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateleft.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateleft.DOWN ),\n                    onRelease:  onRotateLeftHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n\n                buttons.push( this.rotateRightButton = new $.Button({\n                    element:    this.rotateRightButton ? $.getElement( this.rotateRightButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.RotateRight" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateright.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateright.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateright.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateright.DOWN ),\n                    onRelease:  onRotateRightHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n\n            }\n\n            if ( useGroup ) {\n                this.buttons = new $.ButtonGroup({\n                    buttons:            buttons,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold\n                });\n\n                this.navControl  = this.buttons.element;\n                this.addHandler( \'open\', $.delegate( this, lightUp ) );\n\n                if( this.toolbar ){\n                    this.toolbar.addControl(\n                        this.navControl,\n                        {anchor: $.ControlAnchor.TOP_LEFT}\n                    );\n                } else {\n                    this.addControl(\n                        this.navControl,\n                        {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}\n                    );\n                }\n            }\n\n        }\n        return this;\n    },\n\n    /**\n     * Gets the active page of a sequence\n     * @function\n     * @return {Number}\n     */\n    currentPage: function() {\n        return this._sequenceIndex;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:page\n     */\n    goToPage: function( page ){\n        if( this.tileSources && page >= 0 && page < this.tileSources.length ){\n            /**\n             * Raised when the page is changed on a viewer configured with multiple image sources (see {@link OpenSeadragon.Viewer#goToPage}).\n             *\n             * @event page\n             * @memberof OpenSeadragon.Viewer\n             * @type {Object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n             * @property {Number} page - The page index.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent( \'page\', { page: page } );\n\n            this._sequenceIndex = page;\n\n            this._updateSequenceButtons( page );\n\n            this.open( this.tileSources[ page ] );\n\n            if( this.referenceStrip ){\n                this.referenceStrip.setFocus( page );\n            }\n        }\n\n        return this;\n    },\n\n   /**\n     * Adds an html element as an overlay to the current viewport.  Useful for\n     * highlighting words or areas of interest on an image or other zoomable\n     * interface. The overlays added via this method are removed when the viewport\n     * is closed which include when changing page.\n     * @method\n     * @param {Element|String|Object} element - A reference to an element or an id for\n     *      the element which will be overlayed. Or an Object specifying the configuration for the overlay.\n     *      If using an object, see {@link OpenSeadragon.Overlay} for a list of\n     *      all available options.\n     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or\n     *      rectangle which will be overlayed. This is a viewport relative location.\n     * @param {OpenSeadragon.Placement} placement - The position of the\n     *      viewport which the location coordinates will be treated as relative\n     *      to.\n     * @param {function} onDraw - If supplied the callback is called when the overlay\n     *      needs to be drawn. It it the responsibility of the callback to do any drawing/positioning.\n     *      It is passed position, size and element.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:add-overlay\n     */\n    addOverlay: function( element, location, placement, onDraw ) {\n        var options;\n        if( $.isPlainObject( element ) ){\n            options = element;\n        } else {\n            options = {\n                element: element,\n                location: location,\n                placement: placement,\n                onDraw: onDraw\n            };\n        }\n\n        element = $.getElement( options.element );\n\n        if ( getOverlayIndex( this.currentOverlays, element ) >= 0 ) {\n            // they\'re trying to add a duplicate overlay\n            return this;\n        }\n\n        var overlay = getOverlayObject( this, options);\n        this.currentOverlays.push(overlay);\n        overlay.drawHTML( this.overlaysContainer, this.viewport );\n\n        /**\n         * Raised when an overlay is added to the viewer (see {@link OpenSeadragon.Viewer#addOverlay}).\n         *\n         * @event add-overlay\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Element} element - The overlay element.\n         * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location\n         * @property {OpenSeadragon.Placement} placement\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'add-overlay\', {\n            element: element,\n            location: options.location,\n            placement: options.placement\n        });\n        return this;\n    },\n\n    /**\n     * Updates the overlay represented by the reference to the element or\n     * element id moving it to the new location, relative to the new placement.\n     * @method\n     * @param {Element|String} element - A reference to an element or an id for\n     *      the element which is overlayed.\n     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or\n     *      rectangle which will be overlayed. This is a viewport relative location.\n     * @param {OpenSeadragon.Placement} placement - The position of the\n     *      viewport which the location coordinates will be treated as relative\n     *      to.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:update-overlay\n     */\n    updateOverlay: function( element, location, placement ) {\n        var i;\n\n        element = $.getElement( element );\n        i = getOverlayIndex( this.currentOverlays, element );\n\n        if ( i >= 0 ) {\n            this.currentOverlays[ i ].update( location, placement );\n            THIS[ this.hash ].forceRedraw = true;\n            /**\n             * Raised when an overlay\'s location or placement changes\n             * (see {@link OpenSeadragon.Viewer#updateOverlay}).\n             *\n             * @event update-overlay\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the\n             * Viewer which raised the event.\n             * @property {Element} element\n             * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location\n             * @property {OpenSeadragon.Placement} placement\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent( \'update-overlay\', {\n                element: element,\n                location: location,\n                placement: placement\n            });\n        }\n        return this;\n    },\n\n    /**\n     * Removes an overlay identified by the reference element or element id\n     * and schedules an update.\n     * @method\n     * @param {Element|String} element - A reference to the element or an\n     *      element id which represent the ovelay content to be removed.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:remove-overlay\n     */\n    removeOverlay: function( element ) {\n        var i;\n\n        element = $.getElement( element );\n        i = getOverlayIndex( this.currentOverlays, element );\n\n        if ( i >= 0 ) {\n            this.currentOverlays[ i ].destroy();\n            this.currentOverlays.splice( i, 1 );\n            THIS[ this.hash ].forceRedraw = true;\n            /**\n             * Raised when an overlay is removed from the viewer\n             * (see {@link OpenSeadragon.Viewer#removeOverlay}).\n             *\n             * @event remove-overlay\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the\n             * Viewer which raised the event.\n             * @property {Element} element - The overlay element.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent( \'remove-overlay\', {\n                element: element\n            });\n        }\n        return this;\n    },\n\n    /**\n     * Removes all currently configured Overlays from this Viewer and schedules\n     * an update.\n     * @method\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:clear-overlay\n     */\n    clearOverlays: function() {\n        while ( this.currentOverlays.length > 0 ) {\n            this.currentOverlays.pop().destroy();\n        }\n        THIS[ this.hash ].forceRedraw = true;\n        /**\n         * Raised when all overlays are removed from the viewer (see {@link OpenSeadragon.Drawer#clearOverlays}).\n         *\n         * @event clear-overlay\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'clear-overlay\', {} );\n        return this;\n    },\n\n     /**\n     * Finds an overlay identified by the reference element or element id\n     * and returns it as an object, return null if not found.\n     * @method\n     * @param {Element|String} element - A reference to the element or an\n     *      element id which represents the overlay content.\n     * @return {OpenSeadragon.Overlay} the matching overlay or null if none found.\n     */\n    getOverlayById: function( element ) {\n        var i;\n\n        element = $.getElement( element );\n        i = getOverlayIndex( this.currentOverlays, element );\n\n        if (i>=0) {\n            return this.currentOverlays[i];\n        } else {\n            return null;\n        }\n    },\n\n    /**\n     * Updates the sequence buttons.\n     * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons\n     * @private\n     * @param {Number} Sequence Value\n     */\n    _updateSequenceButtons: function( page ) {\n\n            if ( this.nextButton ) {\n                if(!this.tileSources || this.tileSources.length - 1 === page) {\n                    //Disable next button\n                    if ( !this.navPrevNextWrap ) {\n                        this.nextButton.disable();\n                    }\n                } else {\n                    this.nextButton.enable();\n                }\n            }\n            if ( this.previousButton ) {\n                if ( page > 0 ) {\n                    //Enable previous button\n                    this.previousButton.enable();\n                } else {\n                    if ( !this.navPrevNextWrap ) {\n                        this.previousButton.disable();\n                    }\n                }\n            }\n      },\n\n    /**\n     * Display a message in the viewport\n     * @function OpenSeadragon.Viewer.prototype._showMessage\n     * @private\n     * @param {String} text message\n     */\n    _showMessage: function ( message ) {\n        this._hideMessage();\n\n        var div = $.makeNeutralElement( "div" );\n        div.appendChild( document.createTextNode( message ) );\n\n        this.messageDiv = $.makeCenteredNode( div );\n\n        $.addClass(this.messageDiv, "openseadragon-message");\n\n        this.container.appendChild( this.messageDiv );\n    },\n\n    /**\n     * Hide any currently displayed viewport message\n     * @function OpenSeadragon.Viewer.prototype._hideMessage\n     * @private\n     */\n    _hideMessage: function () {\n        var div = this.messageDiv;\n        if (div) {\n            div.parentNode.removeChild(div);\n            delete this.messageDiv;\n        }\n    },\n\n    /**\n     * Gets this viewer\'s gesture settings for the given pointer device type.\n     * @method\n     * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).\n     * @return {OpenSeadragon.GestureSettings}\n     */\n    gestureSettingsByDeviceType: function ( type ) {\n        switch ( type ) {\n            case \'mouse\':\n                return this.gestureSettingsMouse;\n            case \'touch\':\n                return this.gestureSettingsTouch;\n            case \'pen\':\n                return this.gestureSettingsPen;\n            default:\n                return this.gestureSettingsUnknown;\n        }\n    },\n\n    // private\n    _drawOverlays: function() {\n        var i,\n            length = this.currentOverlays.length;\n        for ( i = 0; i < length; i++ ) {\n            this.currentOverlays[ i ].drawHTML( this.overlaysContainer, this.viewport );\n        }\n    },\n\n    /**\n     * Cancel the "in flight" images.\n     */\n    _cancelPendingImages: function() {\n        this._loadQueue = [];\n    }\n});\n\n\n/**\n * _getSafeElemSize is like getElementSize(), but refuses to return 0 for x or y,\n * which was causing some calling operations to return NaN.\n * @returns {Point}\n * @private\n */\nfunction _getSafeElemSize (oElement) {\n    oElement = $.getElement( oElement );\n\n    return new $.Point(\n        (oElement.clientWidth === 0 ? 1 : oElement.clientWidth),\n        (oElement.clientHeight === 0 ? 1 : oElement.clientHeight)\n    );\n}\n\n/**\n * @function\n * @private\n */\nfunction getTileSourceImplementation( viewer, tileSource, successCallback,\n    failCallback ) {\n    var _this = viewer;\n\n    //allow plain xml strings or json strings to be parsed here\n    if ( $.type( tileSource ) == \'string\' ) {\n        if ( tileSource.match( /\\s*<.*/ ) ) {\n            tileSource = $.parseXml( tileSource );\n        } else if ( tileSource.match( /\\s*[\\{\\[].*/ ) ) {\n            tileSource = $.parseJSON(tileSource);\n        }\n    }\n\n    function waitUntilReady(tileSource, originalTileSource) {\n        if (tileSource.ready) {\n            successCallback(tileSource);\n        } else {\n            tileSource.addHandler(\'ready\', function () {\n                successCallback(tileSource);\n            });\n            tileSource.addHandler(\'open-failed\', function (event) {\n                failCallback({\n                    message: event.message,\n                    source: originalTileSource\n                });\n            });\n        }\n    }\n\n    setTimeout( function() {\n        if ( $.type( tileSource ) == \'string\' ) {\n            //If its still a string it means it must be a url at this point\n            tileSource = new $.TileSource({\n                url: tileSource,\n                crossOriginPolicy: viewer.crossOriginPolicy,\n                ajaxWithCredentials: viewer.ajaxWithCredentials,\n                useCanvas: viewer.useCanvas,\n                success: function( event ) {\n                    successCallback( event.tileSource );\n                }\n            });\n            tileSource.addHandler( \'open-failed\', function( event ) {\n                failCallback( event );\n            } );\n\n        } else if ($.isPlainObject(tileSource) || tileSource.nodeType) {\n            if (!tileSource.crossOriginPolicy && viewer.crossOriginPolicy) {\n                tileSource.crossOriginPolicy = viewer.crossOriginPolicy;\n            }\n            if (tileSource.ajaxWithCredentials === undefined) {\n                tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;\n            }\n            if (tileSource.useCanvas === undefined) {\n                tileSource.useCanvas = viewer.useCanvas;\n            }\n\n            if ( $.isFunction( tileSource.getTileUrl ) ) {\n                //Custom tile source\n                var customTileSource = new $.TileSource( tileSource );\n                customTileSource.getTileUrl = tileSource.getTileUrl;\n                successCallback( customTileSource );\n            } else {\n                //inline configuration\n                var $TileSource = $.TileSource.determineType( _this, tileSource );\n                if ( !$TileSource ) {\n                    failCallback( {\n                        message: "Unable to load TileSource",\n                        source: tileSource\n                    });\n                    return;\n                }\n                var options = $TileSource.prototype.configure.apply( _this, [ tileSource ] );\n                waitUntilReady(new $TileSource(options), tileSource);\n            }\n        } else {\n            //can assume it\'s already a tile source implementation\n            waitUntilReady(tileSource, tileSource);\n        }\n    });\n}\n\nfunction getOverlayObject( viewer, overlay ) {\n    if ( overlay instanceof $.Overlay ) {\n        return overlay;\n    }\n\n    var element = null;\n    if ( overlay.element ) {\n        element = $.getElement( overlay.element );\n    } else {\n        var id = overlay.id ?\n            overlay.id :\n            "openseadragon-overlay-" + Math.floor( Math.random() * 10000000 );\n\n        element = $.getElement( overlay.id );\n        if ( !element ) {\n            element         = document.createElement( "a" );\n            element.href    = "#/overlay/" + id;\n        }\n        element.id = id;\n        $.addClass( element, overlay.className ?\n            overlay.className :\n            "openseadragon-overlay"\n        );\n    }\n\n    var location = overlay.location;\n    var width = overlay.width;\n    var height = overlay.height;\n    if (!location) {\n        var x = overlay.x;\n        var y = overlay.y;\n        if (overlay.px !== undefined) {\n            var rect = viewer.viewport.imageToViewportRectangle(new $.Rect(\n                overlay.px,\n                overlay.py,\n                width || 0,\n                height || 0));\n            x = rect.x;\n            y = rect.y;\n            width = width !== undefined ? rect.width : undefined;\n            height = height !== undefined ? rect.height : undefined;\n        }\n        location = new $.Point(x, y);\n    }\n\n    var placement = overlay.placement;\n    if (placement && $.type(placement) === "string") {\n        placement = $.Placement[overlay.placement.toUpperCase()];\n    }\n\n    return new $.Overlay({\n        element: element,\n        location: location,\n        placement: placement,\n        onDraw: overlay.onDraw,\n        checkResize: overlay.checkResize,\n        width: width,\n        height: height,\n        rotationMode: overlay.rotationMode\n    });\n}\n\n/**\n * @private\n * @inner\n * Determines the index of the given overlay in the given overlays array.\n */\nfunction getOverlayIndex( overlays, element ) {\n    var i;\n    for ( i = overlays.length - 1; i >= 0; i-- ) {\n        if ( overlays[ i ].element === element ) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Schedulers provide the general engine for animation\n///////////////////////////////////////////////////////////////////////////////\nfunction scheduleUpdate( viewer, updateFunc ){\n    return $.requestAnimationFrame( function(){\n        updateFunc( viewer );\n    } );\n}\n\n\n//provides a sequence in the fade animation\nfunction scheduleControlsFade( viewer ) {\n    $.requestAnimationFrame( function(){\n        updateControlsFade( viewer );\n    });\n}\n\n\n//initiates an animation to hide the controls\nfunction beginControlsAutoHide( viewer ) {\n    if ( !viewer.autoHideControls ) {\n        return;\n    }\n    viewer.controlsShouldFade = true;\n    viewer.controlsFadeBeginTime =\n        $.now() +\n        viewer.controlsFadeDelay;\n\n    window.setTimeout( function(){\n        scheduleControlsFade( viewer );\n    }, viewer.controlsFadeDelay );\n}\n\n\n//determines if fade animation is done or continues the animation\nfunction updateControlsFade( viewer ) {\n    var currentTime,\n        deltaTime,\n        opacity,\n        i;\n    if ( viewer.controlsShouldFade ) {\n        currentTime = $.now();\n        deltaTime = currentTime - viewer.controlsFadeBeginTime;\n        opacity = 1.0 - deltaTime / viewer.controlsFadeLength;\n\n        opacity = Math.min( 1.0, opacity );\n        opacity = Math.max( 0.0, opacity );\n\n        for ( i = viewer.controls.length - 1; i >= 0; i--) {\n            if (viewer.controls[ i ].autoFade) {\n                viewer.controls[ i ].setOpacity( opacity );\n            }\n        }\n\n        if ( opacity > 0 ) {\n            // fade again\n            scheduleControlsFade( viewer );\n        }\n    }\n}\n\n\n//stop the fade animation on the controls and show them\nfunction abortControlsAutoHide( viewer ) {\n    var i;\n    viewer.controlsShouldFade = false;\n    for ( i = viewer.controls.length - 1; i >= 0; i-- ) {\n        viewer.controls[ i ].setOpacity( 1.0 );\n    }\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Default view event handlers.\n///////////////////////////////////////////////////////////////////////////////\nfunction onFocus(){\n    abortControlsAutoHide( this );\n}\n\nfunction onBlur(){\n    beginControlsAutoHide( this );\n\n}\n\nfunction onCanvasKeyDown( event ) {\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch( event.keyCode ){\n            case 38://up arrow\n                if ( event.shift ) {\n                    this.viewport.zoomBy(1.1);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 40://down arrow\n                if ( event.shift ) {\n                    this.viewport.zoomBy(0.9);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 37://left arrow\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            case 39://right arrow\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\nfunction onCanvasKeyPress( event ) {\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch( event.keyCode ){\n            case 43://=|+\n            case 61://=|+\n                this.viewport.zoomBy(1.1);\n                this.viewport.applyConstraints();\n                return false;\n            case 45://-|_\n                this.viewport.zoomBy(0.9);\n                this.viewport.applyConstraints();\n                return false;\n            case 48://0|)\n                this.viewport.goHome();\n                this.viewport.applyConstraints();\n                return false;\n            case 119://w\n            case 87://W\n                if ( event.shift ) {\n                    this.viewport.zoomBy(1.1);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 115://s\n            case 83://S\n                if ( event.shift ) {\n                    this.viewport.zoomBy(0.9);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 97://a\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            case 100://d\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\nfunction onCanvasClick( event ) {\n    var gestureSettings;\n\n    var haveKeyboardFocus = document.activeElement == this.canvas;\n\n    // If we don\'t have keyboard focus, request it.\n    if ( !haveKeyboardFocus ) {\n        this.canvas.focus();\n    }\n\n    if ( !event.preventDefaultAction && this.viewport && event.quick ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if ( gestureSettings.clickToZoom ) {\n            this.viewport.zoomBy(\n                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,\n                this.viewport.pointFromPixel( event.position, true )\n            );\n            this.viewport.applyConstraints();\n        }\n    }\n    /**\n     * Raised when a mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-click\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-click\', {\n        tracker: event.eventSource,\n        position: event.position,\n        quick: event.quick,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasDblClick( event ) {\n    var gestureSettings;\n\n    if ( !event.preventDefaultAction && this.viewport ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if ( gestureSettings.dblClickToZoom ) {\n            this.viewport.zoomBy(\n                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,\n                this.viewport.pointFromPixel( event.position, true )\n            );\n            this.viewport.applyConstraints();\n        }\n    }\n    /**\n     * Raised when a double mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-double-click\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-double-click\', {\n        tracker: event.eventSource,\n        position: event.position,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasDrag( event ) {\n    var gestureSettings;\n\n    if ( !event.preventDefaultAction && this.viewport ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if( !this.panHorizontal ){\n            event.delta.x = 0;\n        }\n        if( !this.panVertical ){\n            event.delta.y = 0;\n        }\n        this.viewport.panBy( this.viewport.deltaPointsFromPixels( event.delta.negate() ), gestureSettings.flickEnabled );\n        if( this.constrainDuringPan ){\n            this.viewport.applyConstraints();\n        }\n    }\n    /**\n     * Raised when a mouse or touch drag operation occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-drag\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.\n     * @property {Number} speed - Current computed speed, in pixels per second.\n     * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-drag\', {\n        tracker: event.eventSource,\n        position: event.position,\n        delta: event.delta,\n        speed: event.speed,\n        direction: event.direction,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasDragEnd( event ) {\n    if (!event.preventDefaultAction && this.viewport) {\n        var gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);\n        if (gestureSettings.flickEnabled &&\n            event.speed >= gestureSettings.flickMinSpeed) {\n            var amplitudeX = 0;\n            if (this.panHorizontal) {\n                amplitudeX = gestureSettings.flickMomentum * event.speed *\n                    Math.cos(event.direction);\n            }\n            var amplitudeY = 0;\n            if (this.panVertical) {\n                amplitudeY = gestureSettings.flickMomentum * event.speed *\n                    Math.sin(event.direction);\n            }\n            var center = this.viewport.pixelFromPoint(\n                this.viewport.getCenter(true));\n            var target = this.viewport.pointFromPixel(\n                new $.Point(center.x - amplitudeX, center.y - amplitudeY));\n            this.viewport.panTo(target, false);\n        }\n        this.viewport.applyConstraints();\n    }\n    /**\n     * Raised when a mouse or touch drag operation ends on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-drag-end\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} speed - Speed at the end of a drag gesture, in pixels per second.\n     * @property {Number} direction - Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent(\'canvas-drag-end\', {\n        tracker: event.eventSource,\n        position: event.position,\n        speed: event.speed,\n        direction: event.direction,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasEnter( event ) {\n    /**\n     * Raised when a pointer enters the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-enter\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-enter\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasExit( event ) {\n    /**\n     * Raised when a pointer leaves the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-exit\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-exit\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasPress( event ) {\n    /**\n     * Raised when the primary mouse button is pressed or touch starts on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-press\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-press\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        insideElementPressed: event.insideElementPressed,\n        insideElementReleased: event.insideElementReleased,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasRelease( event ) {\n    /**\n     * Raised when the primary mouse button is released or touch ends on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-release\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-release\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        insideElementPressed: event.insideElementPressed,\n        insideElementReleased: event.insideElementReleased,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasNonPrimaryPress( event ) {\n    /**\n     * Raised when any non-primary pointer button is pressed on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-nonprimary-press\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {Number} button - Button which caused the event.\n     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     * @property {Number} buttons - Current buttons pressed.\n     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-nonprimary-press\', {\n        tracker: event.eventSource,\n        position: event.position,\n        pointerType: event.pointerType,\n        button: event.button,\n        buttons: event.buttons,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasNonPrimaryRelease( event ) {\n    /**\n     * Raised when any non-primary pointer button is released on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-nonprimary-release\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {Number} button - Button which caused the event.\n     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     * @property {Number} buttons - Current buttons pressed.\n     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-nonprimary-release\', {\n        tracker: event.eventSource,\n        position: event.position,\n        pointerType: event.pointerType,\n        button: event.button,\n        buttons: event.buttons,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasPinch( event ) {\n    var gestureSettings,\n        centerPt,\n        lastCenterPt,\n        panByPt;\n\n    if ( !event.preventDefaultAction && this.viewport ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if ( gestureSettings.pinchToZoom ) {\n            centerPt = this.viewport.pointFromPixel( event.center, true );\n            lastCenterPt = this.viewport.pointFromPixel( event.lastCenter, true );\n            panByPt = lastCenterPt.minus( centerPt );\n            if( !this.panHorizontal ) {\n                panByPt.x = 0;\n            }\n            if( !this.panVertical ) {\n                panByPt.y = 0;\n            }\n            this.viewport.zoomBy( event.distance / event.lastDistance, centerPt, true );\n            this.viewport.panBy( panByPt, true );\n            this.viewport.applyConstraints();\n        }\n        if ( gestureSettings.pinchRotate ) {\n            // Pinch rotate\n            var angle1 = Math.atan2(event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,\n                event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x);\n            var angle2 = Math.atan2(event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,\n                event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x);\n            this.viewport.setRotation(this.viewport.getRotation() + ((angle1 - angle2) * (180 / Math.PI)));\n        }\n    }\n    /**\n     * Raised when a pinch event occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-pinch\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gesturePoints - Gesture points associated with the gesture. Velocity data can be found here.\n     * @property {OpenSeadragon.Point} lastCenter - The previous center point of the two pinch contact points relative to the tracked element.\n     * @property {OpenSeadragon.Point} center - The center point of the two pinch contact points relative to the tracked element.\n     * @property {Number} lastDistance - The previous distance between the two pinch contact points in CSS pixels.\n     * @property {Number} distance - The distance between the two pinch contact points in CSS pixels.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent(\'canvas-pinch\', {\n        tracker: event.eventSource,\n        gesturePoints: event.gesturePoints,\n        lastCenter: event.lastCenter,\n        center: event.center,\n        lastDistance: event.lastDistance,\n        distance: event.distance,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n    //cancels event\n    return false;\n}\n\nfunction onCanvasScroll( event ) {\n    var gestureSettings,\n        factor,\n        thisScrollTime,\n        deltaScrollTime;\n\n    /* Certain scroll devices fire the scroll event way too fast so we are injecting a simple adjustment to keep things\n     * partially normalized. If we have already fired an event within the last \'minScrollDelta\' milliseconds we skip\n     * this one and wait for the next event. */\n    thisScrollTime = $.now();\n    deltaScrollTime = thisScrollTime - this._lastScrollTime;\n    if (deltaScrollTime > this.minScrollDeltaTime) {\n        this._lastScrollTime = thisScrollTime;\n\n        if ( !event.preventDefaultAction && this.viewport ) {\n            gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n            if ( gestureSettings.scrollToZoom ) {\n                factor = Math.pow( this.zoomPerScroll, event.scroll );\n                this.viewport.zoomBy(\n                    factor,\n                    this.viewport.pointFromPixel( event.position, true )\n                );\n                this.viewport.applyConstraints();\n            }\n        }\n        /**\n         * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#canvas} element (mouse wheel).\n         *\n         * @event canvas-scroll\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n         * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n         * @property {Number} scroll - The scroll delta for the event.\n         * @property {Boolean} shift - True if the shift key was pressed during this event.\n         * @property {Object} originalEvent - The original DOM event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'canvas-scroll\', {\n            tracker: event.eventSource,\n            position: event.position,\n            scroll: event.scroll,\n            shift: event.shift,\n            originalEvent: event.originalEvent\n        });\n        if (gestureSettings && gestureSettings.scrollToZoom) {\n            //cancels event\n            return false;\n        }\n    }\n    else {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if (gestureSettings && gestureSettings.scrollToZoom) {\n            return false;   // We are swallowing this event\n        }\n    }\n}\n\nfunction onContainerEnter( event ) {\n    THIS[ this.hash ].mouseInside = true;\n    abortControlsAutoHide( this );\n    /**\n     * Raised when the cursor enters the {@link OpenSeadragon.Viewer#container} element.\n     *\n     * @event container-enter\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'container-enter\', {\n        tracker: event.eventSource,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onContainerExit( event ) {\n    if ( event.pointers < 1 ) {\n        THIS[ this.hash ].mouseInside = false;\n        if ( !THIS[ this.hash ].animating ) {\n            beginControlsAutoHide( this );\n        }\n    }\n    /**\n     * Raised when the cursor leaves the {@link OpenSeadragon.Viewer#container} element.\n     *\n     * @event container-exit\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'container-exit\', {\n        tracker: event.eventSource,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Page update routines ( aka Views - for future reference )\n///////////////////////////////////////////////////////////////////////////////\n\nfunction updateMulti( viewer ) {\n    updateOnce( viewer );\n\n    // Request the next frame, unless we\'ve been closed\n    if ( viewer.isOpen() ) {\n        viewer._updateRequestId = scheduleUpdate( viewer, updateMulti );\n    } else {\n        viewer._updateRequestId = false;\n    }\n}\n\nfunction updateOnce( viewer ) {\n\n    //viewer.profiler.beginUpdate();\n\n    if (viewer._opening) {\n        return;\n    }\n\n    if (viewer.autoResize) {\n        var containerSize = _getSafeElemSize(viewer.container);\n        var prevContainerSize = THIS[viewer.hash].prevContainerSize;\n        if (!containerSize.equals(prevContainerSize)) {\n            var viewport = viewer.viewport;\n            if (viewer.preserveImageSizeOnResize) {\n                var resizeRatio = prevContainerSize.x / containerSize.x;\n                var zoom = viewport.getZoom() * resizeRatio;\n                var center = viewport.getCenter();\n                viewport.resize(containerSize, false);\n                viewport.zoomTo(zoom, null, true);\n                viewport.panTo(center, true);\n            } else {\n                // maintain image position\n                var oldBounds = viewport.getBounds();\n                viewport.resize(containerSize, true);\n                viewport.fitBoundsWithConstraints(oldBounds, true);\n            }\n            THIS[viewer.hash].prevContainerSize = containerSize;\n            THIS[viewer.hash].forceRedraw = true;\n        }\n    }\n\n    var viewportChange = viewer.viewport.update();\n    var animated = viewer.world.update() || viewportChange;\n\n    if (viewportChange) {\n        /**\n         * Raised when any spring animation update occurs (zoom, pan, etc.),\n         * before the viewer has drawn the new location.\n         *\n         * @event viewport-change\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        viewer.raiseEvent(\'viewport-change\');\n    }\n\n    if( viewer.referenceStrip ){\n        animated = viewer.referenceStrip.update( viewer.viewport ) || animated;\n    }\n\n    if ( !THIS[ viewer.hash ].animating && animated ) {\n        /**\n         * Raised when any spring animation starts (zoom, pan, etc.).\n         *\n         * @event animation-start\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        viewer.raiseEvent( "animation-start" );\n        abortControlsAutoHide( viewer );\n    }\n\n    if ( animated || THIS[ viewer.hash ].forceRedraw || viewer.world.needsDraw() ) {\n        drawWorld( viewer );\n        viewer._drawOverlays();\n        if( viewer.navigator ){\n            viewer.navigator.update( viewer.viewport );\n        }\n\n        THIS[ viewer.hash ].forceRedraw = false;\n\n        if (animated) {\n            /**\n             * Raised when any spring animation update occurs (zoom, pan, etc.),\n             * after the viewer has drawn the new location.\n             *\n             * @event animation\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            viewer.raiseEvent( "animation" );\n        }\n    }\n\n    if ( THIS[ viewer.hash ].animating && !animated ) {\n        /**\n         * Raised when any spring animation ends (zoom, pan, etc.).\n         *\n         * @event animation-finish\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        viewer.raiseEvent( "animation-finish" );\n\n        if ( !THIS[ viewer.hash ].mouseInside ) {\n            beginControlsAutoHide( viewer );\n        }\n    }\n\n    THIS[ viewer.hash ].animating = animated;\n\n    //viewer.profiler.endUpdate();\n}\n\nfunction drawWorld( viewer ) {\n    viewer.imageLoader.clear();\n    viewer.drawer.clear();\n    viewer.world.draw();\n\n    /**\n     * <em>- Needs documentation -</em>\n     *\n     * @event update-viewport\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    viewer.raiseEvent( \'update-viewport\', {} );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Navigation Controls\n///////////////////////////////////////////////////////////////////////////////\nfunction resolveUrl( prefix, url ) {\n    return prefix ? prefix + url : url;\n}\n\n\n\nfunction beginZoomingIn() {\n    THIS[ this.hash ].lastZoomTime = $.now();\n    THIS[ this.hash ].zoomFactor = this.zoomPerSecond;\n    THIS[ this.hash ].zooming = true;\n    scheduleZoom( this );\n}\n\n\nfunction beginZoomingOut() {\n    THIS[ this.hash ].lastZoomTime = $.now();\n    THIS[ this.hash ].zoomFactor = 1.0 / this.zoomPerSecond;\n    THIS[ this.hash ].zooming = true;\n    scheduleZoom( this );\n}\n\n\nfunction endZooming() {\n    THIS[ this.hash ].zooming = false;\n}\n\n\nfunction scheduleZoom( viewer ) {\n    $.requestAnimationFrame( $.delegate( viewer, doZoom ) );\n}\n\n\nfunction doZoom() {\n    var currentTime,\n        deltaTime,\n        adjustedFactor;\n\n    if ( THIS[ this.hash ].zooming && this.viewport) {\n        currentTime     = $.now();\n        deltaTime       = currentTime - THIS[ this.hash ].lastZoomTime;\n        adjustedFactor  = Math.pow( THIS[ this.hash ].zoomFactor, deltaTime / 1000 );\n\n        this.viewport.zoomBy( adjustedFactor );\n        this.viewport.applyConstraints();\n        THIS[ this.hash ].lastZoomTime = currentTime;\n        scheduleZoom( this );\n    }\n}\n\n\nfunction doSingleZoomIn() {\n    if ( this.viewport ) {\n        THIS[ this.hash ].zooming = false;\n        this.viewport.zoomBy(\n            this.zoomPerClick / 1.0\n        );\n        this.viewport.applyConstraints();\n    }\n}\n\n\nfunction doSingleZoomOut() {\n    if ( this.viewport ) {\n        THIS[ this.hash ].zooming = false;\n        this.viewport.zoomBy(\n            1.0 / this.zoomPerClick\n        );\n        this.viewport.applyConstraints();\n    }\n}\n\n\nfunction lightUp() {\n    this.buttons.emulateEnter();\n    this.buttons.emulateExit();\n}\n\n\nfunction onHome() {\n    if ( this.viewport ) {\n        this.viewport.goHome();\n    }\n}\n\n\nfunction onFullScreen() {\n    if ( this.isFullPage() && !$.isFullScreen() ) {\n        // Is fullPage but not fullScreen\n        this.setFullPage( false );\n    } else {\n        this.setFullScreen( !this.isFullPage() );\n    }\n    // correct for no mouseout event on change\n    if ( this.buttons ) {\n        this.buttons.emulateExit();\n    }\n    this.fullPageButton.element.focus();\n    if ( this.viewport ) {\n        this.viewport.applyConstraints();\n    }\n}\n\n/**\n * Note: The current rotation feature is limited to 90 degree turns.\n */\nfunction onRotateLeft() {\n    if ( this.viewport ) {\n        var currRotation = this.viewport.getRotation();\n        if (currRotation === 0) {\n            currRotation = 270;\n        }\n        else {\n            currRotation -= 90;\n        }\n        this.viewport.setRotation(currRotation);\n    }\n}\n\n/**\n * Note: The current rotation feature is limited to 90 degree turns.\n */\nfunction onRotateRight() {\n    if ( this.viewport ) {\n        var currRotation = this.viewport.getRotation();\n        if (currRotation === 270) {\n            currRotation = 0;\n        }\n        else {\n            currRotation += 90;\n        }\n        this.viewport.setRotation(currRotation);\n    }\n}\n\n\nfunction onPrevious(){\n    var previous = this._sequenceIndex - 1;\n    if(this.navPrevNextWrap && previous < 0){\n        previous += this.tileSources.length;\n    }\n    this.goToPage( previous );\n}\n\n\nfunction onNext(){\n    var next = this._sequenceIndex + 1;\n    if(this.navPrevNextWrap && next >= this.tileSources.length){\n        next = 0;\n    }\n    this.goToPage( next );\n}\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Navigator\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Navigator\n * @classdesc The Navigator provides a small view of the current image as fixed\n * while representing the viewport as a moving box serving as a frame\n * of reference in the larger viewport as to which portion of the image\n * is currently being examined.  The navigator\'s viewport can be interacted\n * with using the keyboard or the mouse.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.Viewer\n * @extends OpenSeadragon.EventSource\n * @param {Object} options\n */\n$.Navigator = function( options ){\n\n    var viewer      = options.viewer,\n        _this = this,\n        viewerSize,\n        navigatorSize;\n\n    //We may need to create a new element and id if they did not\n    //provide the id for the existing element\n    if( !options.id ){\n        options.id              = \'navigator-\' + $.now();\n        this.element            = $.makeNeutralElement( "div" );\n        options.controlOptions  = {\n            anchor:           $.ControlAnchor.TOP_RIGHT,\n            attachToViewer:   true,\n            autoFade:         options.autoFade\n        };\n\n        if( options.position ){\n            if( \'BOTTOM_RIGHT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;\n            } else if( \'BOTTOM_LEFT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;\n            } else if( \'TOP_RIGHT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;\n            } else if( \'TOP_LEFT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;\n            } else if( \'ABSOLUTE\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;\n               options.controlOptions.top = options.top;\n               options.controlOptions.left = options.left;\n               options.controlOptions.height = options.height;\n               options.controlOptions.width = options.width;\n            }\n        }\n\n    } else {\n        this.element            = document.getElementById( options.id );\n        options.controlOptions  = {\n            anchor:           $.ControlAnchor.NONE,\n            attachToViewer:   false,\n            autoFade:         false\n        };\n    }\n    this.element.id         = options.id;\n    this.element.className  += \' navigator\';\n\n    options = $.extend( true, {\n        sizeRatio:     $.DEFAULT_SETTINGS.navigatorSizeRatio\n    }, options, {\n        element:                this.element,\n        tabIndex:               -1, // No keyboard navigation, omit from tab order\n        //These need to be overridden to prevent recursion since\n        //the navigator is a viewer and a viewer has a navigator\n        showNavigator:          false,\n        mouseNavEnabled:        false,\n        showNavigationControl:  false,\n        showSequenceControl:    false,\n        immediateRender:        true,\n        blendTime:              0,\n        animationTime:          0,\n        autoResize:             options.autoResize,\n        // prevent resizing the navigator from adding unwanted space around the image\n        minZoomImageRatio:      1.0\n    });\n\n    options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;\n\n    $.setElementTouchActionNone( this.element );\n\n    this.borderWidth = 2;\n    //At some browser magnification levels the display regions lines up correctly, but at some there appears to\n    //be a one pixel gap.\n    this.fudge = new $.Point(1, 1);\n    this.totalBorderWidths = new $.Point(this.borderWidth*2, this.borderWidth*2).minus(this.fudge);\n\n\n    if ( options.controlOptions.anchor != $.ControlAnchor.NONE ) {\n        (function( style, borderWidth ){\n            style.margin        = \'0px\';\n            style.border        = borderWidth + \'px solid #555\';\n            style.padding       = \'0px\';\n            style.background    = \'#000\';\n            style.opacity       = 0.8;\n            style.overflow      = \'hidden\';\n        }( this.element.style, this.borderWidth));\n    }\n\n    this.displayRegion           = $.makeNeutralElement( "div" );\n    this.displayRegion.id        = this.element.id + \'-displayregion\';\n    this.displayRegion.className = \'displayregion\';\n\n    (function( style, borderWidth ){\n        style.position      = \'relative\';\n        style.top           = \'0px\';\n        style.left          = \'0px\';\n        style.fontSize      = \'0px\';\n        style.overflow      = \'hidden\';\n        style.border        = borderWidth + \'px solid #900\';\n        style.margin        = \'0px\';\n        style.padding       = \'0px\';\n        //TODO: IE doesnt like this property being set\n        //try{ style.outline  = \'2px auto #909\'; }catch(e){/*ignore*/}\n\n        style.background    = \'transparent\';\n\n        // We use square bracket notation on the statement below, because float is a keyword.\n        // This is important for the Google Closure compiler, if nothing else.\n        /*jshint sub:true */\n        style[\'float\']      = \'left\'; //Webkit\n\n        style.cssFloat      = \'left\'; //Firefox\n        style.styleFloat    = \'left\'; //IE\n        style.zIndex        = 999999999;\n        style.cursor        = \'default\';\n    }( this.displayRegion.style, this.borderWidth ));\n\n    this.displayRegionContainer = $.makeNeutralElement("div");\n    this.displayRegionContainer.id = this.element.id + \'-displayregioncontainer\';\n    this.displayRegionContainer.className = "displayregioncontainer";\n    this.displayRegionContainer.style.width = "100%";\n    this.displayRegionContainer.style.height = "100%";\n\n    viewer.addControl(\n        this.element,\n        options.controlOptions\n    );\n\n    this._resizeWithViewer = options.controlOptions.anchor != $.ControlAnchor.ABSOLUTE &&\n        options.controlOptions.anchor != $.ControlAnchor.NONE;\n\n    if ( this._resizeWithViewer ) {\n        if ( options.width && options.height ) {\n            this.element.style.height = typeof ( options.height )  == "number" ? ( options.height + \'px\' ) : options.height;\n            this.element.style.width  = typeof ( options.width )  == "number" ? ( options.width + \'px\' ) : options.width;\n        } else {\n            viewerSize = $.getElementSize( viewer.element );\n            this.element.style.height = Math.round( viewerSize.y * options.sizeRatio ) + \'px\';\n            this.element.style.width  = Math.round( viewerSize.x * options.sizeRatio ) + \'px\';\n            this.oldViewerSize = viewerSize;\n        }\n        navigatorSize = $.getElementSize( this.element );\n        this.elementArea = navigatorSize.x * navigatorSize.y;\n    }\n\n    this.oldContainerSize = new $.Point( 0, 0 );\n\n    $.Viewer.apply( this, [ options ] );\n\n    this.displayRegionContainer.appendChild(this.displayRegion);\n    this.element.getElementsByTagName(\'div\')[0].appendChild(this.displayRegionContainer);\n\n    function rotate(degrees) {\n        _setTransformRotate(_this.displayRegionContainer, degrees);\n        _setTransformRotate(_this.displayRegion, -degrees);\n        _this.viewport.setRotation(degrees);\n    }\n    if (options.navigatorRotate) {\n        var degrees = options.viewer.viewport ?\n            options.viewer.viewport.getRotation() :\n            options.viewer.degrees || 0;\n        rotate(degrees);\n        options.viewer.addHandler("rotate", function (args) {\n            rotate(args.degrees);\n        });\n    }\n\n    // Remove the base class\' (Viewer\'s) innerTracker and replace it with our own\n    this.innerTracker.destroy();\n    this.innerTracker = new $.MouseTracker({\n        element:         this.element,\n        dragHandler:     $.delegate( this, onCanvasDrag ),\n        clickHandler:    $.delegate( this, onCanvasClick ),\n        releaseHandler:  $.delegate( this, onCanvasRelease ),\n        scrollHandler:   $.delegate( this, onCanvasScroll )\n    });\n\n    this.addHandler("reset-size", function() {\n        if (_this.viewport) {\n            _this.viewport.goHome(true);\n        }\n    });\n\n    viewer.world.addHandler("item-index-change", function(event) {\n        var item = _this.world.getItemAt(event.previousIndex);\n        _this.world.setItemIndex(item, event.newIndex);\n    });\n\n    viewer.world.addHandler("remove-item", function(event) {\n        var theirItem = event.item;\n        var myItem = _this._getMatchingItem(theirItem);\n        if (myItem) {\n            _this.world.removeItem(myItem);\n        }\n    });\n\n    this.update(viewer.viewport);\n};\n\n$.extend( $.Navigator.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.Navigator.prototype */{\n\n    /**\n     * Used to notify the navigator when its size has changed.\n     * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.\n     * @function\n     */\n    updateSize: function () {\n        if ( this.viewport ) {\n            var containerSize = new $.Point(\n                    (this.container.clientWidth === 0 ? 1 : this.container.clientWidth),\n                    (this.container.clientHeight === 0 ? 1 : this.container.clientHeight)\n                );\n\n            if ( !containerSize.equals( this.oldContainerSize ) ) {\n                this.viewport.resize( containerSize, true );\n                this.viewport.goHome(true);\n                this.oldContainerSize = containerSize;\n                this.drawer.clear();\n                this.world.draw();\n            }\n        }\n    },\n\n    /**\n     * Used to update the navigator minimap\'s viewport rectangle when a change in the viewer\'s viewport occurs.\n     * @function\n     * @param {OpenSeadragon.Viewport} The viewport this navigator is tracking.\n     */\n    update: function( viewport ) {\n\n        var viewerSize,\n            newWidth,\n            newHeight,\n            bounds,\n            topleft,\n            bottomright;\n\n        viewerSize = $.getElementSize( this.viewer.element );\n        if ( this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals( this.oldViewerSize ) ) {\n            this.oldViewerSize = viewerSize;\n\n            if ( this.maintainSizeRatio || !this.elementArea) {\n                newWidth  = viewerSize.x * this.sizeRatio;\n                newHeight = viewerSize.y * this.sizeRatio;\n            } else {\n                newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));\n                newHeight = this.elementArea / newWidth;\n            }\n\n            this.element.style.width  = Math.round( newWidth ) + \'px\';\n            this.element.style.height = Math.round( newHeight ) + \'px\';\n\n            if (!this.elementArea) {\n                this.elementArea = newWidth * newHeight;\n            }\n\n            this.updateSize();\n        }\n\n        if (viewport && this.viewport) {\n            bounds      = viewport.getBoundsNoRotate(true);\n            topleft     = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);\n            bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false)\n                .minus( this.totalBorderWidths );\n\n            //update style for navigator-box\n            var style = this.displayRegion.style;\n            style.display = this.world.getItemCount() ? \'block\' : \'none\';\n\n            style.top    = Math.round( topleft.y ) + \'px\';\n            style.left   = Math.round( topleft.x ) + \'px\';\n\n            var width = Math.abs( topleft.x - bottomright.x );\n            var height = Math.abs( topleft.y - bottomright.y );\n            // make sure width and height are non-negative so IE doesn\'t throw\n            style.width  = Math.round( Math.max( width, 0 ) ) + \'px\';\n            style.height = Math.round( Math.max( height, 0 ) ) + \'px\';\n        }\n\n    },\n\n    // overrides Viewer.addTiledImage\n    addTiledImage: function(options) {\n        var _this = this;\n\n        var original = options.originalTiledImage;\n        delete options.original;\n\n        var optionsClone = $.extend({}, options, {\n            success: function(event) {\n                var myItem = event.item;\n                myItem._originalForNavigator = original;\n                _this._matchBounds(myItem, original, true);\n\n                original.addHandler(\'bounds-change\', function() {\n                    _this._matchBounds(myItem, original);\n                });\n            }\n        });\n\n        return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);\n    },\n\n    // private\n    _getMatchingItem: function(theirItem) {\n        var count = this.world.getItemCount();\n        var item;\n        for (var i = 0; i < count; i++) {\n            item = this.world.getItemAt(i);\n            if (item._originalForNavigator === theirItem) {\n                return item;\n            }\n        }\n\n        return null;\n    },\n\n    // private\n    _matchBounds: function(myItem, theirItem, immediately) {\n        var bounds = theirItem.getBounds();\n        myItem.setPosition(bounds.getTopLeft(), immediately);\n        myItem.setWidth(bounds.width, immediately);\n    }\n});\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasClick( event ) {\n    if ( event.quick && this.viewer.viewport ) {\n        this.viewer.viewport.panTo(this.viewport.pointFromPixel(event.position));\n        this.viewer.viewport.applyConstraints();\n    }\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasDrag( event ) {\n    if ( this.viewer.viewport ) {\n        if( !this.panHorizontal ){\n            event.delta.x = 0;\n        }\n        if( !this.panVertical ){\n            event.delta.y = 0;\n        }\n        this.viewer.viewport.panBy(\n            this.viewport.deltaPointsFromPixels(\n                event.delta\n            )\n        );\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasRelease( event ) {\n    if ( event.insideElementPressed && this.viewer.viewport ) {\n        this.viewer.viewport.applyConstraints();\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasScroll( event ) {\n    /**\n     * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#navigator} element (mouse wheel, touch pinch, etc.).\n     *\n     * @event navigator-scroll\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} scroll - The scroll delta for the event.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.viewer.raiseEvent( \'navigator-scroll\', {\n        tracker: event.eventSource,\n        position: event.position,\n        scroll: event.scroll,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n\n    //dont scroll the page up and down if the user is scrolling\n    //in the navigator\n    return false;\n}\n\n/**\n    * @function\n    * @private\n    * @param {Object} element\n    * @param {Number} degrees\n    */\nfunction _setTransformRotate (element, degrees) {\n    element.style.webkitTransform = "rotate(" + degrees + "deg)";\n    element.style.mozTransform = "rotate(" + degrees + "deg)";\n    element.style.msTransform = "rotate(" + degrees + "deg)";\n    element.style.oTransform = "rotate(" + degrees + "deg)";\n    element.style.transform = "rotate(" + degrees + "deg)";\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - getString/setString\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n//TODO: I guess this is where the i18n needs to be reimplemented.  I\'ll look\n//      into existing patterns for i18n in javascript but i think that mimicking\n//      pythons gettext might be a reasonable approach.\nvar I18N = {\n    Errors: {\n        Dzc:            "Sorry, we don\'t support Deep Zoom Collections!",\n        Dzi:            "Hmm, this doesn\'t appear to be a valid Deep Zoom Image.",\n        Xml:            "Hmm, this doesn\'t appear to be a valid Deep Zoom Image.",\n        ImageFormat:    "Sorry, we don\'t support {0}-based Deep Zoom Images.",\n        Security:       "It looks like a security restriction stopped us from " +\n                        "loading this Deep Zoom Image.",\n        Status:         "This space unintentionally left blank ({0} {1}).",\n        OpenFailed:     "Unable to open {0}: {1}"\n    },\n\n    Tooltips: {\n        FullPage:       "Toggle full page",\n        Home:           "Go home",\n        ZoomIn:         "Zoom in",\n        ZoomOut:        "Zoom out",\n        NextPage:       "Next page",\n        PreviousPage:   "Previous page",\n        RotateLeft:     "Rotate left",\n        RotateRight:    "Rotate right"\n    }\n};\n\n$.extend( $, /** @lends OpenSeadragon */{\n\n    /**\n     * @function\n     * @param {String} property\n     */\n    getString: function( prop ) {\n\n        var props   = prop.split(\'.\'),\n            string  = null,\n            args    = arguments,\n            container = I18N,\n            i;\n\n        for ( i = 0; i < props.length-1; i++ ) {\n            // in case not a subproperty\n            container = container[ props[ i ] ] || {};\n        }\n        string = container[ props[ i ] ];\n\n        if ( typeof( string ) != "string" ) {\n            $.console.debug( "Untranslated source string:", prop );\n            string = ""; // FIXME: this breaks gettext()-style convention, which would return source\n        }\n\n        return string.replace(/\\{\\d+\\}/g, function(capture) {\n            var i = parseInt( capture.match( /\\d+/ ), 10 ) + 1;\n            return i < args.length ?\n                args[ i ] :\n                "";\n        });\n    },\n\n    /**\n     * @function\n     * @param {String} property\n     * @param {*} value\n     */\n    setString: function( prop, value ) {\n\n        var props     = prop.split(\'.\'),\n            container = I18N,\n            i;\n\n        for ( i = 0; i < props.length - 1; i++ ) {\n            if ( !container[ props[ i ] ] ) {\n                container[ props[ i ] ] = {};\n            }\n            container = container[ props[ i ] ];\n        }\n\n        container[ props[ i ] ] = value;\n    }\n\n});\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Point\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Point\n * @classdesc A Point is really used as a 2-dimensional vector, equally useful for\n * representing a point on a plane, or the height and width of a plane\n * not requiring any other frame of reference.\n *\n * @memberof OpenSeadragon\n * @param {Number} [x] The vector component \'x\'. Defaults to the origin at 0.\n * @param {Number} [y] The vector component \'y\'. Defaults to the origin at 0.\n */\n$.Point = function( x, y ) {\n    /**\n     * The vector component \'x\'.\n     * @member {Number} x\n     * @memberof OpenSeadragon.Point#\n     */\n    this.x = typeof ( x ) == "number" ? x : 0;\n    /**\n     * The vector component \'y\'.\n     * @member {Number} y\n     * @memberof OpenSeadragon.Point#\n     */\n    this.y = typeof ( y ) == "number" ? y : 0;\n};\n\n/** @lends OpenSeadragon.Point.prototype */\n$.Point.prototype = {\n    /**\n     * @function\n     * @returns {OpenSeadragon.Point} a duplicate of this Point\n     */\n    clone: function() {\n        return new $.Point(this.x, this.y);\n    },\n\n    /**\n     * Add another Point to this point and return a new Point.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to add vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the sum of the\n     *  vector components\n     */\n    plus: function( point ) {\n        return new $.Point(\n            this.x + point.x,\n            this.y + point.y\n        );\n    },\n\n    /**\n     * Substract another Point to this point and return a new Point.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to substract vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the substraction of the\n     *  vector components\n     */\n    minus: function( point ) {\n        return new $.Point(\n            this.x - point.x,\n            this.y - point.y\n        );\n    },\n\n    /**\n     * Multiply this point by a factor and return a new Point.\n     * @function\n     * @param {Number} factor The factor to multiply vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the multiplication\n     *  of the vector components by the factor\n     */\n    times: function( factor ) {\n        return new $.Point(\n            this.x * factor,\n            this.y * factor\n        );\n    },\n\n    /**\n     * Divide this point by a factor and return a new Point.\n     * @function\n     * @param {Number} factor The factor to divide vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the division of the\n     *  vector components by the factor\n     */\n    divide: function( factor ) {\n        return new $.Point(\n            this.x / factor,\n            this.y / factor\n        );\n    },\n\n    /**\n     * Compute the opposite of this point and return a new Point.\n     * @function\n     * @returns {OpenSeadragon.Point} A new point representing the opposite of the\n     *  vector components\n     */\n    negate: function() {\n        return new $.Point( -this.x, -this.y );\n    },\n\n    /**\n     * Compute the distance between this point and another point.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to compute the distance with.\n     * @returns {Number} The distance between the 2 points\n     */\n    distanceTo: function( point ) {\n        return Math.sqrt(\n            Math.pow( this.x - point.x, 2 ) +\n            Math.pow( this.y - point.y, 2 )\n        );\n    },\n\n    /**\n     * Apply a function to each coordinate of this point and return a new point.\n     * @function\n     * @param {function} func The function to apply to each coordinate.\n     * @returns {OpenSeadragon.Point} A new point with the coordinates computed\n     * by the specified function\n     */\n    apply: function( func ) {\n        return new $.Point( func( this.x ), func( this.y ) );\n    },\n\n    /**\n     * Check if this point is equal to another one.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to compare this point with.\n     * @returns {Boolean} true if they are equal, false otherwise.\n     */\n    equals: function( point ) {\n        return (\n            point instanceof $.Point\n        ) && (\n            this.x === point.x\n        ) && (\n            this.y === point.y\n        );\n    },\n\n    /**\n     * Rotates the point around the specified pivot\n     * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point\n     * @function\n     * @param {Number} degress to rotate around the pivot.\n     * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.\n     * Defaults to the origin.\n     * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot\n     */\n    rotate: function (degrees, pivot) {\n        pivot = pivot || new $.Point(0, 0);\n        var cos;\n        var sin;\n        // Avoid float computations when possible\n        if (degrees % 90 === 0) {\n            var d = degrees % 360;\n            if (d < 0) {\n                d += 360;\n            }\n            switch (d) {\n                case 0:\n                    cos = 1;\n                    sin = 0;\n                    break;\n                case 90:\n                    cos = 0;\n                    sin = 1;\n                    break;\n                case 180:\n                    cos = -1;\n                    sin = 0;\n                    break;\n                case 270:\n                    cos = 0;\n                    sin = -1;\n                    break;\n            }\n        } else {\n            var angle = degrees * Math.PI / 180.0;\n            cos = Math.cos(angle);\n            sin = Math.sin(angle);\n        }\n        var x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;\n        var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;\n        return new $.Point(x, y);\n    },\n\n    /**\n     * Convert this point to a string in the format (x,y) where x and y are\n     * rounded to the nearest integer.\n     * @function\n     * @returns {String} A string representation of this point.\n     */\n    toString: function() {\n        return "(" + (Math.round(this.x * 100) / 100) + "," + (Math.round(this.y * 100) / 100) + ")";\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n\n/**\n * @class TileSource\n * @classdesc The TileSource contains the most basic implementation required to create a\n * smooth transition between layers in an image pyramid. It has only a single key\n * interface that must be implemented to complete its key functionality:\n * \'getTileUrl\'.  It also has several optional interfaces that can be\n * implemented if a new TileSource wishes to support configuration via a simple\n * object or array (\'configure\') and if the tile source supports or requires\n * configuration via retrieval of a document on the network ala AJAX or JSONP,\n * (\'getImageInfo\').\n * <br/>\n * By default the image pyramid is split into N layers where the image\'s longest\n * side in M (in pixels), where N is the smallest integer which satisfies\n *      <strong>2^(N+1) >= M</strong>.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @param {Object} options\n *      You can either specify a URL, or literally define the TileSource (by specifying\n *      width, height, tileSize, tileOverlap, minLevel, and maxLevel). For the former,\n *      the extending class is expected to implement \'getImageInfo\' and \'configure\'.\n *      For the latter, the construction is assumed to occur through\n *      the extending classes implementation of \'configure\'.\n * @param {String} [options.url]\n *      The URL for the data necessary for this TileSource.\n * @param {Function} [options.success]\n *      A function to be called upon successful creation.\n * @param {Boolean} [options.ajaxWithCredentials]\n *      If this TileSource needs to make an AJAX call, this specifies whether to set\n *      the XHR\'s withCredentials (for accessing secure data).\n * @param {Number} [options.width]\n *      Width of the source image at max resolution in pixels.\n * @param {Number} [options.height]\n *      Height of the source image at max resolution in pixels.\n * @param {Number} [options.tileSize]\n *      The size of the tiles to assumed to make up each pyramid layer in pixels.\n *      Tile size determines the point at which the image pyramid must be\n *      divided into a matrix of smaller images.\n *      Use options.tileWidth and options.tileHeight to support non-square tiles.\n * @param {Number} [options.tileWidth]\n *      The width of the tiles to assumed to make up each pyramid layer in pixels.\n * @param {Number} [options.tileHeight]\n *      The height of the tiles to assumed to make up each pyramid layer in pixels.\n * @param {Number} [options.tileOverlap]\n *      The number of pixels each tile is expected to overlap touching tiles.\n * @param {Number} [options.minLevel]\n *      The minimum level to attempt to load.\n * @param {Number} [options.maxLevel]\n *      The maximum level to attempt to load.\n */\n$.TileSource = function( width, height, tileSize, tileOverlap, minLevel, maxLevel ) {\n    var _this = this;\n\n    var args = arguments,\n        options,\n        i;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: args[0],\n            height: args[1],\n            tileSize: args[2],\n            tileOverlap: args[3],\n            minLevel: args[4],\n            maxLevel: args[5]\n        };\n    }\n\n    //Tile sources supply some events, namely \'ready\' when they must be configured\n    //by asynchronously fetching their configuration data.\n    $.EventSource.call( this );\n\n    //we allow options to override anything we dont treat as\n    //required via idiomatic options or which is functionally\n    //set depending on the state of the readiness of this tile\n    //source\n    $.extend( true, this, options );\n\n    if (!this.success) {\n        //Any functions that are passed as arguments are bound to the ready callback\n        for ( i = 0; i < arguments.length; i++ ) {\n            if ( $.isFunction( arguments[ i ] ) ) {\n                this.success = arguments[ i ];\n                //only one callback per constructor\n                break;\n            }\n        }\n    }\n\n    if (this.success) {\n        this.addHandler( \'ready\', function ( event ) {\n            _this.success( event );\n        } );\n    }\n\n    /**\n     * Ratio of width to height\n     * @member {Number} aspectRatio\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * Vector storing x and y dimensions ( width and height respectively ).\n     * @member {OpenSeadragon.Point} dimensions\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * The overlap in pixels each tile shares with its adjacent neighbors.\n     * @member {Number} tileOverlap\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * The minimum pyramid level this tile source supports or should attempt to load.\n     * @member {Number} minLevel\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * The maximum pyramid level this tile source supports or should attempt to load.\n     * @member {Number} maxLevel\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     *\n     * @member {Boolean} ready\n     * @memberof OpenSeadragon.TileSource#\n     */\n\n    if( \'string\' == $.type( arguments[ 0 ] ) ){\n        this.url = arguments[0];\n    }\n\n    if (this.url) {\n        //in case the getImageInfo method is overriden and/or implies an\n        //async mechanism set some safe defaults first\n        this.aspectRatio = 1;\n        this.dimensions  = new $.Point( 10, 10 );\n        this._tileWidth  = 0;\n        this._tileHeight = 0;\n        this.tileOverlap = 0;\n        this.minLevel    = 0;\n        this.maxLevel    = 0;\n        this.ready       = false;\n        //configuration via url implies the extending class\n        //implements and \'configure\'\n        this.getImageInfo( this.url );\n\n    } else {\n\n        //explicit configuration via positional args in constructor\n        //or the more idiomatic \'options\' object\n        this.ready       = true;\n        this.aspectRatio = ( options.width && options.height ) ?\n            (  options.width / options.height ) : 1;\n        this.dimensions  = new $.Point( options.width, options.height );\n\n        if ( this.tileSize ){\n            this._tileWidth = this._tileHeight = this.tileSize;\n            delete this.tileSize;\n        } else {\n            if( this.tileWidth ){\n                // We were passed tileWidth in options, but we want to rename it\n                // with a leading underscore to make clear that it is not safe to directly modify it\n                this._tileWidth = this.tileWidth;\n                delete this.tileWidth;\n            } else {\n                this._tileWidth = 0;\n            }\n\n            if( this.tileHeight ){\n                // See note above about renaming this.tileWidth\n                this._tileHeight = this.tileHeight;\n                delete this.tileHeight;\n            } else {\n                this._tileHeight = 0;\n            }\n        }\n\n        this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;\n        this.minLevel    = options.minLevel ? options.minLevel : 0;\n        this.maxLevel    = ( undefined !== options.maxLevel && null !== options.maxLevel ) ?\n            options.maxLevel : (\n                ( options.width && options.height ) ? Math.ceil(\n                    Math.log( Math.max( options.width, options.height ) ) /\n                    Math.log( 2 )\n                ) : 0\n            );\n        if( this.success && $.isFunction( this.success ) ){\n            this.success( this );\n        }\n    }\n\n\n};\n\n/** @lends OpenSeadragon.TileSource.prototype */\n$.TileSource.prototype = {\n\n    getTileSize: function( level ) {\n        $.console.error(\n            "[TileSource.getTileSize] is deprecated." +\n            "Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"\n        );\n        return this._tileWidth;\n    },\n\n    /**\n     * Return the tileWidth for a given level.\n     * Subclasses should override this if tileWidth can be different at different levels\n     *   such as in IIIFTileSource.  Code should use this function rather than reading\n     *   from ._tileWidth directly.\n     * @function\n     * @param {Number} level\n     */\n    getTileWidth: function( level ) {\n        if (!this._tileWidth) {\n            return this.getTileSize(level);\n        }\n        return this._tileWidth;\n    },\n\n    /**\n     * Return the tileHeight for a given level.\n     * Subclasses should override this if tileHeight can be different at different levels\n     *   such as in IIIFTileSource.  Code should use this function rather than reading\n     *   from ._tileHeight directly.\n     * @function\n     * @param {Number} level\n     */\n    getTileHeight: function( level ) {\n        if (!this._tileHeight) {\n            return this.getTileSize(level);\n        }\n        return this._tileHeight;\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getLevelScale: function( level ) {\n\n        // see https://github.com/openseadragon/openseadragon/issues/22\n        // we use the tilesources implementation of getLevelScale to generate\n        // a memoized re-implementation\n        var levelScaleCache = {},\n            i;\n        for( i = 0; i <= this.maxLevel; i++ ){\n            levelScaleCache[ i ] = 1 / Math.pow(2, this.maxLevel - i);\n        }\n        this.getLevelScale = function( _level ){\n            return levelScaleCache[ _level ];\n        };\n        return this.getLevelScale( level );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getNumTiles: function( level ) {\n        var scale = this.getLevelScale( level ),\n            x = Math.ceil( scale * this.dimensions.x / this.getTileWidth(level) ),\n            y = Math.ceil( scale * this.dimensions.y / this.getTileHeight(level) );\n\n        return new $.Point( x, y );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getPixelRatio: function( level ) {\n        var imageSizeScaled = this.dimensions.times( this.getLevelScale( level ) ),\n            rx = 1.0 / imageSizeScaled.x,\n            ry = 1.0 / imageSizeScaled.y;\n\n        return new $.Point(rx, ry);\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getClosestLevel: function( rect ) {\n        var i,\n            tilesPerSide,\n            tiles;\n\n        for( i = this.minLevel; i < this.maxLevel; i++ ){\n            tiles = this.getNumTiles( i );\n            tilesPerSide = new $.Point(\n              Math.floor( rect.x / this.getTileWidth(i) ),\n              Math.floor( rect.y / this.getTileHeight(i) )\n            );\n\n            if( tiles.x + 1 >= tilesPerSide.x && tiles.y + 1 >= tilesPerSide.y ){\n                break;\n            }\n        }\n        return Math.max( 0, i - 1 );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {OpenSeadragon.Point} point\n     */\n    getTileAtPoint: function( level, point ) {\n        var pixel = point.times( this.dimensions.x ).times( this.getLevelScale(level) ),\n            tx = Math.floor( pixel.x / this.getTileWidth(level) ),\n            ty = Math.floor( pixel.y / this.getTileHeight(level) );\n\n        return new $.Point( tx, ty );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileBounds: function( level, x, y ) {\n        var dimensionsScaled = this.dimensions.times( this.getLevelScale( level ) ),\n            tileWidth = this.getTileWidth(level),\n            tileHeight = this.getTileHeight(level),\n            px = ( x === 0 ) ? 0 : tileWidth * x - this.tileOverlap,\n            py = ( y === 0 ) ? 0 : tileHeight * y - this.tileOverlap,\n            sx = tileWidth + ( x === 0 ? 1 : 2 ) * this.tileOverlap,\n            sy = tileHeight + ( y === 0 ? 1 : 2 ) * this.tileOverlap,\n            scale = 1.0 / dimensionsScaled.x;\n\n        sx = Math.min( sx, dimensionsScaled.x - px );\n        sy = Math.min( sy, dimensionsScaled.y - py );\n\n        return new $.Rect( px * scale, py * scale, sx * scale, sy * scale );\n    },\n\n\n    /**\n     * Responsible for retrieving, and caching the\n     * image metadata pertinent to this TileSources implementation.\n     * @function\n     * @param {String} url\n     * @throws {Error}\n     */\n    getImageInfo: function( url ) {\n        var _this = this,\n            callbackName,\n            callback,\n            readySource,\n            options,\n            urlParts,\n            filename,\n            lastDot;\n\n\n        if( url ) {\n            urlParts = url.split( \'/\' );\n            filename = urlParts[ urlParts.length - 1 ];\n            lastDot  = filename.lastIndexOf( \'.\' );\n            if ( lastDot > -1 ) {\n                urlParts[ urlParts.length - 1 ] = filename.slice( 0, lastDot );\n            }\n        }\n\n        callback = function( data ){\n            if( typeof(data) === "string" ) {\n                data = $.parseXml( data );\n            }\n            var $TileSource = $.TileSource.determineType( _this, data, url );\n            if ( !$TileSource ) {\n                /**\n                 * Raised when an error occurs loading a TileSource.\n                 *\n                 * @event open-failed\n                 * @memberof OpenSeadragon.TileSource\n                 * @type {object}\n                 * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.\n                 * @property {String} message\n                 * @property {String} source\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( \'open-failed\', { message: "Unable to load TileSource", source: url } );\n                return;\n            }\n\n            options = $TileSource.prototype.configure.apply( _this, [ data, url ]);\n            if (options.ajaxWithCredentials === undefined) {\n                options.ajaxWithCredentials = _this.ajaxWithCredentials;\n            }\n\n            readySource = new $TileSource( options );\n            _this.ready = true;\n            /**\n             * Raised when a TileSource is opened and initialized.\n             *\n             * @event ready\n             * @memberof OpenSeadragon.TileSource\n             * @type {object}\n             * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.\n             * @property {Object} tileSource\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( \'ready\', { tileSource: readySource } );\n        };\n\n        if( url.match(/\\.js$/) ){\n            //TODO: Its not very flexible to require tile sources to end jsonp\n            //      request for info  with a url that ends with \'.js\' but for\n            //      now it\'s the only way I see to distinguish uniformly.\n            callbackName = url.split( \'/\' ).pop().replace(\'.js\',\'\');\n            $.jsonp({\n                url: url,\n                async: false,\n                callbackName: callbackName,\n                callback: callback\n            });\n        } else {\n            // request info via xhr asynchronously.\n            $.makeAjaxRequest( {\n                url: url,\n                withCredentials: this.ajaxWithCredentials,\n                success: function( xhr ) {\n                    var data = processResponse( xhr );\n                    callback( data );\n                },\n                error: function ( xhr, exc ) {\n                    var msg;\n\n                    /*\n                        IE < 10 will block XHR requests to different origins. Any property access on the request\n                        object will raise an exception which we\'ll attempt to handle by formatting the original\n                        exception rather than the second one raised when we try to access xhr.status\n                     */\n                    try {\n                        msg = "HTTP " + xhr.status + " attempting to load TileSource";\n                    } catch ( e ) {\n                        var formattedExc;\n                        if ( typeof( exc ) == "undefined" || !exc.toString ) {\n                            formattedExc = "Unknown error";\n                        } else {\n                            formattedExc = exc.toString();\n                        }\n\n                        msg = formattedExc + " attempting to load TileSource";\n                    }\n\n                    /***\n                     * Raised when an error occurs loading a TileSource.\n                     *\n                     * @event open-failed\n                     * @memberof OpenSeadragon.TileSource\n                     * @type {object}\n                     * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.\n                     * @property {String} message\n                     * @property {String} source\n                     * @property {?Object} userData - Arbitrary subscriber-defined object.\n                     */\n                    _this.raiseEvent( \'open-failed\', {\n                        message: msg,\n                        source: url\n                    });\n                }\n            });\n        }\n\n    },\n\n    /**\n     * Responsible determining if a the particular TileSource supports the\n     * data format ( and allowed to apply logic against the url the data was\n     * loaded from, if any ). Overriding implementations are expected to do\n     * something smart with data and / or url to determine support.  Also\n     * understand that iteration order of TileSources is not guarunteed so\n     * please make sure your data or url is expressive enough to ensure a simple\n     * and sufficient mechanisim for clear determination.\n     * @function\n     * @param {String|Object|Array|Document} data\n     * @param {String} url - the url the data was loaded\n     *      from if any.\n     * @return {Boolean}\n     */\n    supports: function( data, url ) {\n        return false;\n    },\n\n    /**\n     * Responsible for parsing and configuring the\n     * image metadata pertinent to this TileSources implementation.\n     * This method is not implemented by this class other than to throw an Error\n     * announcing you have to implement it.  Because of the variety of tile\n     * server technologies, and various specifications for building image\n     * pyramids, this method is here to allow easy integration.\n     * @function\n     * @param {String|Object|Array|Document} data\n     * @param {String} url - the url the data was loaded\n     *      from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     * @throws {Error}\n     */\n    configure: function( data, url ) {\n        throw new Error( "Method not implemented." );\n    },\n\n    /**\n     * Responsible for retriving the url which will return an image for the\n     * region specified by the given x, y, and level components.\n     * This method is not implemented by this class other than to throw an Error\n     * announcing you have to implement it.  Because of the variety of tile\n     * server technologies, and various specifications for building image\n     * pyramids, this method is here to allow easy integration.\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     * @throws {Error}\n     */\n    getTileUrl: function( level, x, y ) {\n        throw new Error( "Method not implemented." );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    tileExists: function( level, x, y ) {\n        var numTiles = this.getNumTiles( level );\n        return  level >= this.minLevel &&\n                level <= this.maxLevel &&\n                x >= 0 &&\n                y >= 0 &&\n                x < numTiles.x &&\n                y < numTiles.y;\n    }\n};\n\n\n$.extend( true, $.TileSource.prototype, $.EventSource.prototype );\n\n\n/**\n * Decides whether to try to process the response as xml, json, or hand back\n * the text\n * @private\n * @inner\n * @function\n * @param {XMLHttpRequest} xhr - the completed network request\n */\nfunction processResponse( xhr ){\n    var responseText = xhr.responseText,\n        status       = xhr.status,\n        statusText,\n        data;\n\n    if ( !xhr ) {\n        throw new Error( $.getString( "Errors.Security" ) );\n    } else if ( xhr.status !== 200 && xhr.status !== 0 ) {\n        status     = xhr.status;\n        statusText = ( status == 404 ) ?\n            "Not Found" :\n            xhr.statusText;\n        throw new Error( $.getString( "Errors.Status", status, statusText ) );\n    }\n\n    if( responseText.match(/\\s*<.*/) ){\n        try{\n        data = ( xhr.responseXML && xhr.responseXML.documentElement ) ?\n            xhr.responseXML :\n            $.parseXml( responseText );\n        } catch (e){\n            data = xhr.responseText;\n        }\n    }else if( responseText.match(/\\s*[\\{\\[].*/) ){\n        data = $.parseJSON(responseText);\n    }else{\n        data = responseText;\n    }\n    return data;\n}\n\n\n/**\n * Determines the TileSource Implementation by introspection of OpenSeadragon\n * namespace, calling each TileSource implementation of \'isType\'\n * @private\n * @inner\n * @function\n * @param {Object|Array|Document} data - the tile source configuration object\n * @param {String} url - the url where the tile source configuration object was\n *      loaded from, if any.\n */\n$.TileSource.determineType = function( tileSource, data, url ){\n    var property;\n    for( property in OpenSeadragon ){\n        if( property.match(/.+TileSource$/) &&\n            $.isFunction( OpenSeadragon[ property ] ) &&\n            $.isFunction( OpenSeadragon[ property ].prototype.supports ) &&\n            OpenSeadragon[ property ].prototype.supports.call( tileSource, data, url )\n        ){\n            return OpenSeadragon[ property ];\n        }\n    }\n\n    $.console.error( "No TileSource was able to open %s %s", url, data );\n};\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - DziTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class DziTileSource\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Number|Object} width - the pixel width of the image or the idiomatic\n *      options object which is used instead of positional arguments.\n * @param {Number} height\n * @param {Number} tileSize\n * @param {Number} tileOverlap\n * @param {String} tilesUrl\n * @param {String} fileFormat\n * @param {OpenSeadragon.DisplayRect[]} displayRects\n * @property {String} tilesUrl\n * @property {String} fileFormat\n * @property {OpenSeadragon.DisplayRect[]} displayRects\n */\n$.DziTileSource = function( width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel ) {\n    var i,\n        rect,\n        level,\n        options;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: arguments[ 0 ],\n            height: arguments[ 1 ],\n            tileSize: arguments[ 2 ],\n            tileOverlap: arguments[ 3 ],\n            tilesUrl: arguments[ 4 ],\n            fileFormat: arguments[ 5 ],\n            displayRects: arguments[ 6 ],\n            minLevel: arguments[ 7 ],\n            maxLevel: arguments[ 8 ]\n        };\n    }\n\n    this._levelRects  = {};\n    this.tilesUrl     = options.tilesUrl;\n    this.fileFormat   = options.fileFormat;\n    this.displayRects = options.displayRects;\n\n    if ( this.displayRects ) {\n        for ( i = this.displayRects.length - 1; i >= 0; i-- ) {\n            rect = this.displayRects[ i ];\n            for ( level = rect.minLevel; level <= rect.maxLevel; level++ ) {\n                if ( !this._levelRects[ level ] ) {\n                    this._levelRects[ level ] = [];\n                }\n                this._levelRects[ level ].push( rect );\n            }\n        }\n    }\n\n    $.TileSource.apply( this, [ options ] );\n\n};\n\n$.extend( $.DziTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.DziTileSource.prototype */{\n\n\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        var ns;\n        if ( data.Image ) {\n            ns = data.Image.xmlns;\n        } else if ( data.documentElement) {\n            if ("Image" == data.documentElement.localName || "Image" == data.documentElement.tagName) {\n                ns = data.documentElement.namespaceURI;\n            }\n        }\n\n        return ( "http://schemas.microsoft.com/deepzoom/2008" == ns ||\n            "http://schemas.microsoft.com/deepzoom/2009" == ns );\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object|XMLDocument} data - the raw configuration\n     * @param {String} url - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( data, url ){\n\n        var options;\n\n        if( !$.isPlainObject(data) ){\n\n            options = configureFromXML( this, data );\n\n        }else{\n\n            options = configureFromObject( this, data );\n        }\n\n        if (url && !options.tilesUrl) {\n            options.tilesUrl = url.replace(\n                    /([^\\/]+?)(\\.(dzi|xml|js))?\\/?(\\?.*)?$/, \'$1_files/\');\n\n            if (url.search(/\\.(dzi|xml|js)\\?/) != -1) {\n                options.queryParams = url.match(/\\?.*/);\n            }else{\n                options.queryParams = \'\';\n            }\n        }\n\n        return options;\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileUrl: function( level, x, y ) {\n        return [ this.tilesUrl, level, \'/\', x, \'_\', y, \'.\', this.fileFormat, this.queryParams ].join( \'\' );\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    tileExists: function( level, x, y ) {\n        var rects = this._levelRects[ level ],\n            rect,\n            scale,\n            xMin,\n            yMin,\n            xMax,\n            yMax,\n            i;\n\n        if ( !rects || !rects.length ) {\n            return true;\n        }\n\n        for ( i = rects.length - 1; i >= 0; i-- ) {\n            rect = rects[ i ];\n\n            if ( level < rect.minLevel || level > rect.maxLevel ) {\n                continue;\n            }\n\n            scale = this.getLevelScale( level );\n            xMin = rect.x * scale;\n            yMin = rect.y * scale;\n            xMax = xMin + rect.width * scale;\n            yMax = yMin + rect.height * scale;\n\n            xMin = Math.floor( xMin / this.tileSize );\n            yMin = Math.floor( yMin / this.tileSize );\n            xMax = Math.ceil( xMax / this.tileSize );\n            yMax = Math.ceil( yMax / this.tileSize );\n\n            if ( xMin <= x && x < xMax && yMin <= y && y < yMax ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n});\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromXML( tileSource, xmlDoc ){\n\n    if ( !xmlDoc || !xmlDoc.documentElement ) {\n        throw new Error( $.getString( "Errors.Xml" ) );\n    }\n\n    var root           = xmlDoc.documentElement,\n        rootName       = root.localName || root.tagName,\n        ns             = xmlDoc.documentElement.namespaceURI,\n        configuration  = null,\n        displayRects   = [],\n        dispRectNodes,\n        dispRectNode,\n        rectNode,\n        sizeNode,\n        i;\n\n    if ( rootName == "Image" ) {\n\n        try {\n            sizeNode = root.getElementsByTagName("Size" )[ 0 ];\n            if (sizeNode === undefined) {\n                sizeNode = root.getElementsByTagNameNS(ns, "Size" )[ 0 ];\n            }\n\n            configuration = {\n                Image: {\n                    xmlns:       "http://schemas.microsoft.com/deepzoom/2008",\n                    Url:         root.getAttribute( "Url" ),\n                    Format:      root.getAttribute( "Format" ),\n                    DisplayRect: null,\n                    Overlap:     parseInt( root.getAttribute( "Overlap" ), 10 ),\n                    TileSize:    parseInt( root.getAttribute( "TileSize" ), 10 ),\n                    Size: {\n                        Height: parseInt( sizeNode.getAttribute( "Height" ), 10 ),\n                        Width:  parseInt( sizeNode.getAttribute( "Width" ), 10 )\n                    }\n                }\n            };\n\n            if ( !$.imageFormatSupported( configuration.Image.Format ) ) {\n                throw new Error(\n                    $.getString( "Errors.ImageFormat", configuration.Image.Format.toUpperCase() )\n                );\n            }\n\n            dispRectNodes = root.getElementsByTagName("DisplayRect" );\n            if (dispRectNodes === undefined) {\n                dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect" )[ 0 ];\n            }\n\n            for ( i = 0; i < dispRectNodes.length; i++ ) {\n                dispRectNode = dispRectNodes[ i ];\n                rectNode     = dispRectNode.getElementsByTagName("Rect" )[ 0 ];\n                if (rectNode === undefined) {\n                    rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect" )[ 0 ];\n                }\n\n                displayRects.push({\n                    Rect: {\n                        X: parseInt( rectNode.getAttribute( "X" ), 10 ),\n                        Y: parseInt( rectNode.getAttribute( "Y" ), 10 ),\n                        Width: parseInt( rectNode.getAttribute( "Width" ), 10 ),\n                        Height: parseInt( rectNode.getAttribute( "Height" ), 10 ),\n                        MinLevel: parseInt( dispRectNode.getAttribute( "MinLevel" ), 10 ),\n                        MaxLevel: parseInt( dispRectNode.getAttribute( "MaxLevel" ), 10 )\n                    }\n                });\n            }\n\n            if( displayRects.length ){\n                configuration.Image.DisplayRect = displayRects;\n            }\n\n            return configureFromObject( tileSource, configuration );\n\n        } catch ( e ) {\n            throw (e instanceof Error) ?\n                e :\n                new Error( $.getString("Errors.Dzi") );\n        }\n    } else if ( rootName == "Collection" ) {\n        throw new Error( $.getString( "Errors.Dzc" ) );\n    } else if ( rootName == "Error" ) {\n        var messageNode = root.getElementsByTagName("Message")[0];\n        var message = messageNode.firstChild.nodeValue;\n        throw new Error(message);\n    }\n\n    throw new Error( $.getString( "Errors.Dzi" ) );\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromObject( tileSource, configuration ){\n    var imageData     = configuration.Image,\n        tilesUrl      = imageData.Url,\n        fileFormat    = imageData.Format,\n        sizeData      = imageData.Size,\n        dispRectData  = imageData.DisplayRect || [],\n        width         = parseInt( sizeData.Width, 10 ),\n        height        = parseInt( sizeData.Height, 10 ),\n        tileSize      = parseInt( imageData.TileSize, 10 ),\n        tileOverlap   = parseInt( imageData.Overlap, 10 ),\n        displayRects  = [],\n        rectData,\n        i;\n\n    //TODO: need to figure out out to better handle image format compatibility\n    //      which actually includes additional file formats like xml and pdf\n    //      and plain text for various tilesource implementations to avoid low\n    //      level errors.\n    //\n    //      For now, just don\'t perform the check.\n    //\n    /*if ( !imageFormatSupported( fileFormat ) ) {\n        throw new Error(\n            $.getString( "Errors.ImageFormat", fileFormat.toUpperCase() )\n        );\n    }*/\n\n    for ( i = 0; i < dispRectData.length; i++ ) {\n        rectData = dispRectData[ i ].Rect;\n\n        displayRects.push( new $.DisplayRect(\n            parseInt( rectData.X, 10 ),\n            parseInt( rectData.Y, 10 ),\n            parseInt( rectData.Width, 10 ),\n            parseInt( rectData.Height, 10 ),\n            parseInt( rectData.MinLevel, 10 ),\n            parseInt( rectData.MaxLevel, 10 )\n        ));\n    }\n\n    return $.extend(true, {\n        width: width, /* width *required */\n        height: height, /* height *required */\n        tileSize: tileSize, /* tileSize *required */\n        tileOverlap: tileOverlap, /* tileOverlap *required */\n        minLevel: null, /* minLevel */\n        maxLevel: null, /* maxLevel */\n        tilesUrl: tilesUrl, /* tilesUrl */\n        fileFormat: fileFormat, /* fileFormat */\n        displayRects: displayRects /* displayRects */\n    }, configuration );\n\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - IIIFTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class IIIFTileSource\n * @classdesc A client implementation of the International Image Interoperability Framework\n * Format: Image API 1.0 - 2.1\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @see http://iiif.io/api/image/\n */\n$.IIIFTileSource = function( options ){\n\n\n    $.extend( true, this, options );\n\n    if ( !( this.height && this.width && this[\'@id\'] ) ) {\n        throw new Error( \'IIIF required parameters not provided.\' );\n    }\n\n    options.tileSizePerScaleFactor = {};\n\n    // N.B. 2.0 renamed scale_factors to scaleFactors\n    if ( this.tile_width && this.tile_height ) {\n        options.tileWidth = this.tile_width;\n        options.tileHeight = this.tile_height;\n    } else if ( this.tile_width ) {\n        options.tileSize = this.tile_width;\n    } else if ( this.tile_height ) {\n        options.tileSize = this.tile_height;\n    } else if ( this.tiles ) {\n        // Version 2.0 forwards\n        if ( this.tiles.length == 1 ) {\n            options.tileWidth  = this.tiles[0].width;\n            // Use height if provided, otherwise assume square tiles and use width.\n            options.tileHeight = this.tiles[0].height || this.tiles[0].width;\n            this.scale_factors = this.tiles[0].scaleFactors;\n        } else {\n            // Multiple tile sizes at different levels\n            this.scale_factors = [];\n            for (var t = 0; t < this.tiles.length; t++ ) {\n                for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {\n                    var scaleFactor = this.tiles[t].scaleFactors[sf];\n                    this.scale_factors.push(scaleFactor);\n                    options.tileSizePerScaleFactor[scaleFactor] = {\n                        width: this.tiles[t].width,\n                        height: this.tiles[t].height || this.tiles[t].width\n                    };\n                }\n            }\n        }\n    } else if ( canBeTiled(options.profile) ) {\n        // use the largest of tileOptions that is smaller than the short dimension\n        var shortDim = Math.min( this.height, this.width ),\n            tileOptions = [256,512,1024],\n            smallerTiles = [];\n\n        for ( var c = 0; c < tileOptions.length; c++ ) {\n            if ( tileOptions[c] <= shortDim ) {\n                smallerTiles.push( tileOptions[c] );\n            }\n        }\n\n        if ( smallerTiles.length > 0 ) {\n            options.tileSize = Math.max.apply( null, smallerTiles );\n        } else {\n            // If we\'re smaller than 256, just use the short side.\n            options.tileSize = shortDim;\n        }\n    } else if (this.sizes && this.sizes.length > 0) {\n        // This info.json can\'t be tiled, but we can still construct a legacy pyramid from the sizes array. \n        // In this mode, IIIFTileSource will call functions from the abstract baseTileSource or the \n        // LegacyTileSource instead of performing IIIF tiling.      \n        this.emulateLegacyImagePyramid = true;\n        \n        options.levels = constructLevels( this );\n        // use the largest available size to define tiles\n        $.extend( true, options, {\n            width: options.levels[ options.levels.length - 1 ].width,\n            height: options.levels[ options.levels.length - 1 ].height,\n            tileSize: Math.max( options.height, options.width ),\n            tileOverlap: 0,\n            minLevel: 0,\n            maxLevel: options.levels.length - 1\n        });\n        this.levels = options.levels;\n    } else {\n        $.console.error("Nothing in the info.json to construct image pyramids from");\n    }\n\n    if (!options.maxLevel && !this.emulateLegacyImagePyramid) {\n        if (!this.scale_factors) {\n            options.maxLevel = Number(Math.ceil(Math.log(Math.max(this.width, this.height), 2)));\n        } else {\n            options.maxLevel = Math.floor(Math.pow(Math.max.apply(null, this.scale_factors), 0.5));\n        }\n    }\n\n    $.TileSource.apply( this, [ options ] );\n};\n\n$.extend( $.IIIFTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.IIIFTileSource.prototype */{\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n     \n    supports: function( data, url ) {\n        // Version 2.0 and forwards\n        if (data.protocol && data.protocol == \'http://iiif.io/api/image\') {\n            return true;\n        // Version 1.1\n        } else if ( data[\'@context\'] && (\n            data[\'@context\'] == "http://library.stanford.edu/iiif/image-api/1.1/context.json" ||\n            data[\'@context\'] == "http://iiif.io/api/image/1/context.json") ) {\n            // N.B. the iiif.io context is wrong, but where the representation lives so likely to be used\n            return true;\n\n        // Version 1.0\n        } else if ( data.profile &&\n            data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {\n            return true;\n        } else if ( data.identifier && data.width && data.height ) {\n            return true;\n        } else if ( data.documentElement &&\n            "info" == data.documentElement.tagName &&\n            "http://library.stanford.edu/iiif/image-api/ns/" ==\n                data.documentElement.namespaceURI) {\n            return true;\n\n        // Not IIIF\n        } else {\n            return false;\n        }\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object} data - the raw configuration\n     * @example <caption>IIIF 1.1 Info Looks like this</caption>\n     * {\n     *   "@context" : "http://library.stanford.edu/iiif/image-api/1.1/context.json",\n     *   "@id" : "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",\n     *   "width" : 6000,\n     *   "height" : 4000,\n     *   "scale_factors" : [ 1, 2, 4 ],\n     *   "tile_width" : 1024,\n     *   "tile_height" : 1024,\n     *   "formats" : [ "jpg", "png" ],\n     *   "qualities" : [ "native", "grey" ],\n     *   "profile" : "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0"\n     * }\n     */\n    configure: function( data, url ){\n        // Try to deduce our version and fake it upwards if needed\n        if ( !$.isPlainObject(data) ) {\n            var options = configureFromXml10( data );\n            options[\'@context\'] = "http://iiif.io/api/image/1.0/context.json";\n            options[\'@id\'] = url.replace(\'/info.xml\', \'\');\n            return options;\n        } else if ( !data[\'@context\'] ) {\n            data[\'@context\'] = \'http://iiif.io/api/image/1.0/context.json\';\n            data[\'@id\'] = url.replace(\'/info.json\', \'\');\n            return data;\n        } else {\n            return data;\n        }\n    },\n\n    /**\n     * Return the tileWidth for the given level.\n     * @function\n     * @param {Number} level\n     */\n    getTileWidth: function( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            return $.TileSource.prototype.getTileWidth.call(this, level);\n        }\n\n        var scaleFactor = Math.pow(2, this.maxLevel - level);\n\n        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {\n            return this.tileSizePerScaleFactor[scaleFactor].width;\n        }\n        return this._tileWidth;\n    },\n\n    /**\n     * Return the tileHeight for the given level.\n     * @function\n     * @param {Number} level\n     */\n    getTileHeight: function( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            return $.TileSource.prototype.getTileHeight.call(this, level);\n        }\n\n        var scaleFactor = Math.pow(2, this.maxLevel - level);\n\n        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {\n            return this.tileSizePerScaleFactor[scaleFactor].height;\n        }\n        return this._tileHeight;\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getLevelScale: function ( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            var levelScale = NaN;\n            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {\n                levelScale =\n                    this.levels[level].width /\n                    this.levels[this.maxLevel].width;\n            }\n            return levelScale;\n        }\n\n        return $.TileSource.prototype.getLevelScale.call(this, level);\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getNumTiles: function( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            var scale = this.getLevelScale(level);\n            if (scale) {\n                return new $.Point(1, 1);\n            } else {\n                return new $.Point(0, 0);\n            }\n        }\n\n        return $.TileSource.prototype.getNumTiles.call(this, level);\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {OpenSeadragon.Point} point\n     */\n    getTileAtPoint: function( level, point ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            return new $.Point(0, 0);\n        }\n\n        return $.TileSource.prototype.getTileAtPoint.call(this, level, point);\n    },\n\n\n    /**\n     * Responsible for retrieving the url which will return an image for the\n     * region specified by the given x, y, and level components.\n     * @function\n     * @param {Number} level - z index\n     * @param {Number} x\n     * @param {Number} y\n     * @throws {Error}\n     */\n    getTileUrl: function( level, x, y ){\n\n        if(this.emulateLegacyImagePyramid) {\n            var url = null;\n            if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {\n                url = this.levels[ level ].url;\n            }\n            return url;\n        }\n\n        //# constants\n        var IIIF_ROTATION = \'0\',\n            //## get the scale (level as a decimal)\n            scale = Math.pow( 0.5, this.maxLevel - level ),\n\n            //# image dimensions at this level\n            levelWidth = Math.ceil( this.width * scale ),\n            levelHeight = Math.ceil( this.height * scale ),\n\n            //## iiif region\n            tileWidth,\n            tileHeight,\n            iiifTileSizeWidth,\n            iiifTileSizeHeight,\n            iiifRegion,\n            iiifTileX,\n            iiifTileY,\n            iiifTileW,\n            iiifTileH,\n            iiifSize,\n            iiifQuality,\n            uri;\n\n        tileWidth = this.getTileWidth(level);\n        tileHeight = this.getTileHeight(level);\n        iiifTileSizeWidth = Math.ceil( tileWidth / scale );\n        iiifTileSizeHeight = Math.ceil( tileHeight / scale );\n\n        if ( this[\'@context\'].indexOf(\'/1.0/context.json\') > -1 ||\n             this[\'@context\'].indexOf(\'/1.1/context.json\') > -1 ||\n             this[\'@context\'].indexOf(\'/1/context.json\') > -1 ) {\n            iiifQuality = "native.jpg";\n        } else {\n            iiifQuality = "default.jpg";\n        }\n\n        if ( levelWidth < tileWidth && levelHeight < tileHeight ){\n            iiifSize = levelWidth + ",";\n            iiifRegion = \'full\';\n        } else {\n            iiifTileX = x * iiifTileSizeWidth;\n            iiifTileY = y * iiifTileSizeHeight;\n            iiifTileW = Math.min( iiifTileSizeWidth, this.width - iiifTileX );\n            iiifTileH = Math.min( iiifTileSizeHeight, this.height - iiifTileY );\n            iiifSize = Math.ceil( iiifTileW * scale ) + ",";\n            iiifRegion = [ iiifTileX, iiifTileY, iiifTileW, iiifTileH ].join( \',\' );\n        }\n        uri = [ this[\'@id\'], iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality ].join( \'/\' );\n\n        return uri;\n    }\n\n  });\n\n    /**\n     * Determine whether arbitrary tile requests can be made against a service with the given profile\n     * @function\n     * @param {object} profile - IIIF profile object\n     * @throws {Error}\n     */\n    function canBeTiled (profile ) {\n        var level0Profiles = [\n            "http://library.stanford.edu/iiif/image-api/compliance.html#level0",\n            "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",\n            "http://iiif.io/api/image/2/level0.json"\n        ];\n        var isLevel0 = (level0Profiles.indexOf(profile[0]) != -1);\n        return !isLevel0 || (profile.indexOf("sizeByW") != -1);\n    }\n\n    /**\n     * Build the legacy pyramid URLs (one tile per level)\n     * @function\n     * @param {object} options - infoJson\n     * @throws {Error}\n     */\n    function constructLevels(options) {\n        var levels = [];\n        for(var i=0; i<options.sizes.length; i++) {\n            levels.push({\n                url: options[\'@id\'] + \'/full/\' + options.sizes[i].width + \',/0/default.jpg\',\n                width: options.sizes[i].width,\n                height: options.sizes[i].height\n            });\n        }\n        return levels.sort(function(a,b){return a.width - b.width;});\n    }\n\n\n    function configureFromXml10(xmlDoc) {\n        //parse the xml\n        if ( !xmlDoc || !xmlDoc.documentElement ) {\n            throw new Error( $.getString( "Errors.Xml" ) );\n        }\n\n        var root            = xmlDoc.documentElement,\n            rootName        = root.tagName,\n            configuration   = null;\n\n        if ( rootName == "info" ) {\n            try {\n                configuration = {};\n                parseXML10( root, configuration );\n                return configuration;\n\n            } catch ( e ) {\n                throw (e instanceof Error) ?\n                    e :\n                    new Error( $.getString("Errors.IIIF") );\n            }\n        }\n        throw new Error( $.getString( "Errors.IIIF" ) );\n    }\n\n    function parseXML10( node, configuration, property ) {\n        var i,\n            value;\n        if ( node.nodeType == 3 && property ) {//text node\n            value = node.nodeValue.trim();\n            if( value.match(/^\\d*$/)){\n                value = Number( value );\n            }\n            if( !configuration[ property ] ){\n                configuration[ property ] = value;\n            }else{\n                if( !$.isArray( configuration[ property ] ) ){\n                    configuration[ property ] = [ configuration[ property ] ];\n                }\n                configuration[ property ].push( value );\n            }\n        } else if( node.nodeType == 1 ){\n            for( i = 0; i < node.childNodes.length; i++ ){\n                parseXML10( node.childNodes[ i ], configuration, node.nodeName );\n            }\n        }\n    }\n\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - OsmTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Derived from the OSM tile source in Rainer Simon\'s seajax-utils project\n * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed\n * the included code to the OpenSeadragon project under the New BSD license;\n * see <https://github.com/openseadragon/openseadragon/issues/58>.\n */\n\n\n(function( $ ){\n\n/**\n * @class OsmTileSource\n * @classdesc A tilesource implementation for OpenStreetMap.<br><br>\n *\n * Note 1. Zoomlevels. Deep Zoom and OSM define zoom levels differently. In  Deep\n * Zoom, level 0 equals an image of 1x1 pixels. In OSM, level 0 equals an image of\n * 256x256 levels (see http://gasi.ch/blog/inside-deep-zoom-2). I.e. there is a\n * difference of log2(256)=8 levels.<br><br>\n *\n * Note 2. Image dimension. According to the OSM Wiki\n * (http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Zoom_levels)\n * the highest Mapnik zoom level has 256.144x256.144 tiles, with a 256x256\n * pixel size. I.e. the Deep Zoom image dimension is 65.572.864x65.572.864\n * pixels.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Number|Object} width - the pixel width of the image or the idiomatic\n *      options object which is used instead of positional arguments.\n * @param {Number} height\n * @param {Number} tileSize\n * @param {Number} tileOverlap\n * @param {String} tilesUrl\n */\n$.OsmTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {\n    var options;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: arguments[0],\n            height: arguments[1],\n            tileSize: arguments[2],\n            tileOverlap: arguments[3],\n            tilesUrl: arguments[4]\n        };\n    }\n    //apply default setting for standard public OpenStreatMaps service\n    //but allow them to be specified so fliks can host there own instance\n    //or apply against other services supportting the same standard\n    if( !options.width || !options.height ){\n        options.width = 65572864;\n        options.height = 65572864;\n    }\n    if( !options.tileSize ){\n        options.tileSize = 256;\n        options.tileOverlap = 0;\n    }\n    if( !options.tilesUrl ){\n        options.tilesUrl = "http://tile.openstreetmap.org/";\n    }\n    options.minLevel = 8;\n\n    $.TileSource.apply( this, [ options ] );\n\n};\n\n$.extend( $.OsmTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.OsmTileSource.prototype */{\n\n\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        return (\n            data.type &&\n            "openstreetmaps" == data.type\n        );\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object} data - the raw configuration\n     * @param {String} url - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( data, url ){\n        return data;\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileUrl: function( level, x, y ) {\n        return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";\n    }\n});\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TmsTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Derived from the TMS tile source in Rainer Simon\'s seajax-utils project\n * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed\n * the included code to the OpenSeadragon project under the New BSD license;\n * see <https://github.com/openseadragon/openseadragon/issues/58>.\n */\n\n\n(function( $ ){\n\n/**\n * @class TmsTileSource\n * @classdesc A tilesource implementation for Tiled Map Services (TMS).\n * TMS tile scheme ( [ as supported by OpenLayers ] is described here\n * ( http://openlayers.org/dev/examples/tms.html ).\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Number|Object} width - the pixel width of the image or the idiomatic\n *      options object which is used instead of positional arguments.\n * @param {Number} height\n * @param {Number} tileSize\n * @param {Number} tileOverlap\n * @param {String} tilesUrl\n */\n$.TmsTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {\n    var options;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: arguments[0],\n            height: arguments[1],\n            tileSize: arguments[2],\n            tileOverlap: arguments[3],\n            tilesUrl: arguments[4]\n        };\n    }\n    // TMS has integer multiples of 256 for width/height and adds buffer\n    // if necessary -> account for this!\n    var bufferedWidth = Math.ceil(options.width / 256) * 256,\n        bufferedHeight = Math.ceil(options.height / 256) * 256,\n        max;\n\n    // Compute number of zoomlevels in this tileset\n    if (bufferedWidth > bufferedHeight) {\n        max = bufferedWidth / 256;\n    } else {\n        max = bufferedHeight / 256;\n    }\n    options.maxLevel = Math.ceil(Math.log(max)/Math.log(2)) - 1;\n    options.tileSize = 256;\n    options.width = bufferedWidth;\n    options.height = bufferedHeight;\n\n    $.TileSource.apply( this, [ options ] );\n\n};\n\n$.extend( $.TmsTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.TmsTileSource.prototype */{\n\n\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        return ( data.type && "tiledmapservice" == data.type );\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object} data - the raw configuration\n     * @param {String} url - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( data, url ){\n        return data;\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileUrl: function( level, x, y ) {\n        // Convert from Deep Zoom definition to TMS zoom definition\n        var yTiles = this.getNumTiles( level ).y - 1;\n\n        return this.tilesUrl + level + "/" + x + "/" +  (yTiles - y) + ".png";\n    }\n});\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - LegacyTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class LegacyTileSource\n * @classdesc The LegacyTileSource allows simple, traditional image pyramids to be loaded\n * into an OpenSeadragon Viewer.  Basically, this translates to the historically\n * common practice of starting with a \'master\' image, maybe a tiff for example,\n * and generating a set of \'service\' images like one or more thumbnails, a medium\n * resolution image and a high resolution image in standard web formats like\n * png or jpg.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Array} levels An array of file descriptions, each is an object with\n *      a \'url\', a \'width\', and a \'height\'.  Overriding classes can expect more\n *      properties but these properties are sufficient for this implementation.\n *      Additionally, the levels are required to be listed in order from\n *      smallest to largest.\n * @property {Number} aspectRatio\n * @property {Number} dimensions\n * @property {Number} tileSize\n * @property {Number} tileOverlap\n * @property {Number} minLevel\n * @property {Number} maxLevel\n * @property {Array}  levels\n */\n$.LegacyTileSource = function( levels ) {\n\n    var options,\n        width,\n        height;\n\n    if( $.isArray( levels ) ){\n        options = {\n            type: \'legacy-image-pyramid\',\n            levels: levels\n        };\n    }\n\n    //clean up the levels to make sure we support all formats\n    options.levels = filterFiles( options.levels );\n\n    if ( options.levels.length > 0 ) {\n        width = options.levels[ options.levels.length - 1 ].width;\n        height = options.levels[ options.levels.length - 1 ].height;\n    }\n    else {\n        width = 0;\n        height = 0;\n        $.console.error( "No supported image formats found" );\n    }\n\n    $.extend( true, options, {\n        width: width,\n        height: height,\n        tileSize: Math.max( height, width ),\n        tileOverlap: 0,\n        minLevel: 0,\n        maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0\n    } );\n\n    $.TileSource.apply( this, [ options ] );\n\n    this.levels = options.levels;\n};\n\n$.extend( $.LegacyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.LegacyTileSource.prototype */{\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        return (\n            data.type &&\n            "legacy-image-pyramid" == data.type\n        ) || (\n            data.documentElement &&\n            "legacy-image-pyramid" == data.documentElement.getAttribute(\'type\')\n        );\n    },\n\n\n    /**\n     *\n     * @function\n     * @param {Object|XMLDocument} configuration - the raw configuration\n     * @param {String} dataUrl - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( configuration, dataUrl ){\n\n        var options;\n\n        if( !$.isPlainObject(configuration) ){\n\n            options = configureFromXML( this, configuration );\n\n        }else{\n\n            options = configureFromObject( this, configuration );\n        }\n\n        return options;\n\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getLevelScale: function ( level ) {\n        var levelScale = NaN;\n        if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {\n            levelScale =\n                this.levels[ level ].width /\n                this.levels[ this.maxLevel ].width;\n        }\n        return levelScale;\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getNumTiles: function( level ) {\n        var scale = this.getLevelScale( level );\n        if ( scale ){\n            return new $.Point( 1, 1 );\n        } else {\n            return new $.Point( 0, 0 );\n        }\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {OpenSeadragon.Point} point\n     */\n    getTileAtPoint: function( level, point ) {\n        return new $.Point( 0, 0 );\n    },\n\n\n    /**\n     * This method is not implemented by this class other than to throw an Error\n     * announcing you have to implement it.  Because of the variety of tile\n     * server technologies, and various specifications for building image\n     * pyramids, this method is here to allow easy integration.\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     * @throws {Error}\n     */\n    getTileUrl: function ( level, x, y ) {\n        var url = null;\n        if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {\n            url = this.levels[ level ].url;\n        }\n        return url;\n    }\n} );\n\n/**\n * This method removes any files from the Array which dont conform to our\n * basic requirements for a \'level\' in the LegacyTileSource.\n * @private\n * @inner\n * @function\n */\nfunction filterFiles( files ){\n    var filtered = [],\n        file,\n        i;\n    for( i = 0; i < files.length; i++ ){\n        file = files[ i ];\n        if( file.height &&\n            file.width &&\n            file.url && (\n                file.url.toLowerCase().match(/^.*\\.(png|jpg|jpeg|gif)(?:\\?.*)?$/) || (\n                    file.mimetype &&\n                    file.mimetype.toLowerCase().match(/^.*\\/(png|jpg|jpeg|gif)$/)\n                )\n            ) ){\n            //This is sufficient to serve as a level\n            filtered.push({\n                url: file.url,\n                width: Number( file.width ),\n                height: Number( file.height )\n            });\n        }\n        else {\n            $.console.error( \'Unsupported image format: %s\', file.url ? file.url : \'<no URL>\' );\n        }\n    }\n\n    return filtered.sort(function(a,b){\n        return a.height - b.height;\n    });\n\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromXML( tileSource, xmlDoc ){\n\n    if ( !xmlDoc || !xmlDoc.documentElement ) {\n        throw new Error( $.getString( "Errors.Xml" ) );\n    }\n\n    var root         = xmlDoc.documentElement,\n        rootName     = root.tagName,\n        conf         = null,\n        levels       = [],\n        level,\n        i;\n\n    if ( rootName == "image" ) {\n\n        try {\n            conf = {\n                type:        root.getAttribute( "type" ),\n                levels:      []\n            };\n\n            levels = root.getElementsByTagName( "level" );\n            for ( i = 0; i < levels.length; i++ ) {\n                level = levels[ i ];\n\n                conf.levels .push({\n                    url:    level.getAttribute( "url" ),\n                    width:  parseInt( level.getAttribute( "width" ), 10 ),\n                    height: parseInt( level.getAttribute( "height" ), 10 )\n                });\n            }\n\n            return configureFromObject( tileSource, conf );\n\n        } catch ( e ) {\n            throw (e instanceof Error) ?\n                e :\n                new Error( \'Unknown error parsing Legacy Image Pyramid XML.\' );\n        }\n    } else if ( rootName == "collection" ) {\n        throw new Error( \'Legacy Image Pyramid Collections not yet supported.\' );\n    } else if ( rootName == "error" ) {\n        throw new Error( \'Error: \' + xmlDoc );\n    }\n\n    throw new Error( \'Unknown element \' + rootName );\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromObject( tileSource, configuration ){\n\n    return configuration.levels;\n\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ImageTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function ($) {\n\n    /**\n     * @class ImageTileSource\n     * @classdesc The ImageTileSource allows a simple image to be loaded\n     * into an OpenSeadragon Viewer.\n     * There are 2 ways to open an ImageTileSource:\n     * 1. viewer.open({type: \'image\', url: fooUrl});\n     * 2. viewer.open(new OpenSeadragon.ImageTileSource({url: fooUrl}));\n     *\n     * With the first syntax, the crossOriginPolicy, ajaxWithCredentials and\n     * useCanvas options are inherited from the viewer if they are not\n     * specified directly in the options object.\n     *\n     * @memberof OpenSeadragon\n     * @extends OpenSeadragon.TileSource\n     * @param {Object} options Options object.\n     * @param {String} options.url URL of the image\n     * @param {Boolean} [options.buildPyramid=true] If set to true (default), a\n     * pyramid will be built internally to provide a better downsampling.\n     * @param {String|Boolean} [options.crossOriginPolicy=false] Valid values are\n     * \'Anonymous\', \'use-credentials\', and false. If false, image requests will\n     * not use CORS preventing internal pyramid building for images from other\n     * domains.\n     * @param {String|Boolean} [options.ajaxWithCredentials=false] Whether to set\n     * the withCredentials XHR flag for AJAX requests (when loading tile sources).\n     * @param {Boolean} [options.useCanvas=true] Set to false to prevent any use\n     * of the canvas API.\n     */\n    $.ImageTileSource = function (options) {\n\n        options = $.extend({\n            buildPyramid: true,\n            crossOriginPolicy: false,\n            ajaxWithCredentials: false,\n            useCanvas: true\n        }, options);\n        $.TileSource.apply(this, [options]);\n\n    };\n\n    $.extend($.ImageTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.ImageTileSource.prototype */{\n        /**\n         * Determine if the data and/or url imply the image service is supported by\n         * this tile source.\n         * @function\n         * @param {Object|Array} data\n         * @param {String} optional - url\n         */\n        supports: function (data, url) {\n            return data.type && data.type === "image";\n        },\n        /**\n         *\n         * @function\n         * @param {Object} options - the options\n         * @param {String} dataUrl - the url the image was retreived from, if any.\n         * @return {Object} options - A dictionary of keyword arguments sufficient\n         *      to configure this tile sources constructor.\n         */\n        configure: function (options, dataUrl) {\n            return options;\n        },\n        /**\n         * Responsible for retrieving, and caching the\n         * image metadata pertinent to this TileSources implementation.\n         * @function\n         * @param {String} url\n         * @throws {Error}\n         */\n        getImageInfo: function (url) {\n            var image = this._image = new Image();\n            var _this = this;\n\n            if (this.crossOriginPolicy) {\n                image.crossOrigin = this.crossOriginPolicy;\n            }\n            if (this.ajaxWithCredentials) {\n                image.useCredentials = this.ajaxWithCredentials;\n            }\n\n            $.addEvent(image, \'load\', function () {\n                _this.width = image.naturalWidth;\n                _this.height = image.naturalHeight;\n                _this.aspectRatio = _this.width / _this.height;\n                _this.dimensions = new $.Point(_this.width, _this.height);\n                _this._tileWidth = _this.width;\n                _this._tileHeight = _this.height;\n                _this.tileOverlap = 0;\n                _this.minLevel = 0;\n                _this.levels = _this._buildLevels();\n                _this.maxLevel = _this.levels.length - 1;\n\n                _this.ready = true;\n\n                // Note: this event is documented elsewhere, in TileSource\n                _this.raiseEvent(\'ready\', {tileSource: _this});\n            });\n\n            $.addEvent(image, \'error\', function () {\n                // Note: this event is documented elsewhere, in TileSource\n                _this.raiseEvent(\'open-failed\', {\n                    message: "Error loading image at " + url,\n                    source: url\n                });\n            });\n\n            image.src = url;\n        },\n        /**\n         * @function\n         * @param {Number} level\n         */\n        getLevelScale: function (level) {\n            var levelScale = NaN;\n            if (level >= this.minLevel && level <= this.maxLevel) {\n                levelScale =\n                        this.levels[level].width /\n                        this.levels[this.maxLevel].width;\n            }\n            return levelScale;\n        },\n        /**\n         * @function\n         * @param {Number} level\n         */\n        getNumTiles: function (level) {\n            var scale = this.getLevelScale(level);\n            if (scale) {\n                return new $.Point(1, 1);\n            } else {\n                return new $.Point(0, 0);\n            }\n        },\n        /**\n         * @function\n         * @param {Number} level\n         * @param {OpenSeadragon.Point} point\n         */\n        getTileAtPoint: function (level, point) {\n            return new $.Point(0, 0);\n        },\n        /**\n         * Retrieves a tile url\n         * @function\n         * @param {Number} level Level of the tile\n         * @param {Number} x x coordinate of the tile\n         * @param {Number} y y coordinate of the tile\n         */\n        getTileUrl: function (level, x, y) {\n            var url = null;\n            if (level >= this.minLevel && level <= this.maxLevel) {\n                url = this.levels[level].url;\n            }\n            return url;\n        },\n        /**\n         * Retrieves a tile context 2D\n         * @function\n         * @param {Number} level Level of the tile\n         * @param {Number} x x coordinate of the tile\n         * @param {Number} y y coordinate of the tile\n         */\n        getContext2D: function (level, x, y) {\n            var context = null;\n            if (level >= this.minLevel && level <= this.maxLevel) {\n                context = this.levels[level].context2D;\n            }\n            return context;\n        },\n\n        // private\n        //\n        // Builds the differents levels of the pyramid if possible\n        // (i.e. if canvas API enabled and no canvas tainting issue).\n        _buildLevels: function () {\n            var levels = [{\n                    url: this._image.src,\n                    width: this._image.naturalWidth,\n                    height: this._image.naturalHeight\n                }];\n\n            if (!this.buildPyramid || !$.supportsCanvas || !this.useCanvas) {\n                // We don\'t need the image anymore. Allows it to be GC.\n                delete this._image;\n                return levels;\n            }\n\n            var currentWidth = this._image.naturalWidth;\n            var currentHeight = this._image.naturalHeight;\n\n            var bigCanvas = document.createElement("canvas");\n            var bigContext = bigCanvas.getContext("2d");\n\n            bigCanvas.width = currentWidth;\n            bigCanvas.height = currentHeight;\n            bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);\n            // We cache the context of the highest level because the browser\n            // is a lot faster at downsampling something it already has\n            // downsampled before.\n            levels[0].context2D = bigContext;\n            // We don\'t need the image anymore. Allows it to be GC.\n            delete this._image;\n\n            if ($.isCanvasTainted(bigCanvas)) {\n                // If the canvas is tainted, we can\'t compute the pyramid.\n                return levels;\n            }\n\n            // We build smaller levels until either width or height becomes\n            // 1 pixel wide.\n            while (currentWidth >= 2 && currentHeight >= 2) {\n                currentWidth = Math.floor(currentWidth / 2);\n                currentHeight = Math.floor(currentHeight / 2);\n                var smallCanvas = document.createElement("canvas");\n                var smallContext = smallCanvas.getContext("2d");\n                smallCanvas.width = currentWidth;\n                smallCanvas.height = currentHeight;\n                smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);\n\n                levels.splice(0, 0, {\n                    context2D: smallContext,\n                    width: currentWidth,\n                    height: currentHeight\n                });\n\n                bigCanvas = smallCanvas;\n                bigContext = smallContext;\n            }\n            return levels;\n        }\n    });\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - TileSourceCollection\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// deprecated\n$.TileSourceCollection = function( tileSize, tileSources, rows, layout  ) {\n    $.console.error(\'TileSourceCollection is deprecated; use World instead\');\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Button\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * An enumeration of button states\n * @member ButtonState\n * @memberof OpenSeadragon\n * @static\n * @type {Object}\n * @property {Number} REST\n * @property {Number} GROUP\n * @property {Number} HOVER\n * @property {Number} DOWN\n */\n$.ButtonState = {\n    REST:   0,\n    GROUP:  1,\n    HOVER:  2,\n    DOWN:   3\n};\n\n/**\n * @class Button\n * @classdesc Manages events, hover states for individual buttons, tool-tips, as well\n * as fading the buttons out when the user has not interacted with them\n * for a specified period.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @param {Object} options\n * @param {Element} [options.element=null] Element to use as the button. If not specified, an HTML &lt;button&gt; element is created.\n * @param {String} [options.tooltip=null] Provides context help for the button when the\n *  user hovers over it.\n * @param {String} [options.srcRest=null] URL of image to use in \'rest\' state.\n * @param {String} [options.srcGroup=null] URL of image to use in \'up\' state.\n * @param {String} [options.srcHover=null] URL of image to use in \'hover\' state.\n * @param {String} [options.srcDown=null] URL of image to use in \'down\' state.\n * @param {Number} [options.fadeDelay=0] How long to wait before fading.\n * @param {Number} [options.fadeLength=2000] How long should it take to fade the button.\n * @param {OpenSeadragon.EventHandler} [options.onPress=null] Event handler callback for {@link OpenSeadragon.Button.event:press}.\n * @param {OpenSeadragon.EventHandler} [options.onRelease=null] Event handler callback for {@link OpenSeadragon.Button.event:release}.\n * @param {OpenSeadragon.EventHandler} [options.onClick=null] Event handler callback for {@link OpenSeadragon.Button.event:click}.\n * @param {OpenSeadragon.EventHandler} [options.onEnter=null] Event handler callback for {@link OpenSeadragon.Button.event:enter}.\n * @param {OpenSeadragon.EventHandler} [options.onExit=null] Event handler callback for {@link OpenSeadragon.Button.event:exit}.\n * @param {OpenSeadragon.EventHandler} [options.onFocus=null] Event handler callback for {@link OpenSeadragon.Button.event:focus}.\n * @param {OpenSeadragon.EventHandler} [options.onBlur=null] Event handler callback for {@link OpenSeadragon.Button.event:blur}.\n */\n$.Button = function( options ) {\n\n    var _this = this;\n\n    $.EventSource.call( this );\n\n    $.extend( true, this, {\n\n        tooltip:            null,\n        srcRest:            null,\n        srcGroup:           null,\n        srcHover:           null,\n        srcDown:            null,\n        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,\n        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,\n        /**\n         * How long to wait before fading.\n         * @member {Number} fadeDelay\n         * @memberof OpenSeadragon.Button#\n         */\n        fadeDelay:          0,\n        /**\n         * How long should it take to fade the button.\n         * @member {Number} fadeLength\n         * @memberof OpenSeadragon.Button#\n         */\n        fadeLength:         2000,\n        onPress:            null,\n        onRelease:          null,\n        onClick:            null,\n        onEnter:            null,\n        onExit:             null,\n        onFocus:            null,\n        onBlur:             null\n\n    }, options );\n\n    /**\n     * The button element.\n     * @member {Element} element\n     * @memberof OpenSeadragon.Button#\n     */\n    this.element        = options.element   || $.makeNeutralElement( "div" );\n\n    //if the user has specified the element to bind the control to explicitly\n    //then do not add the default control images\n    if ( !options.element ) {\n        this.imgRest      = $.makeTransparentImage( this.srcRest );\n        this.imgGroup     = $.makeTransparentImage( this.srcGroup );\n        this.imgHover     = $.makeTransparentImage( this.srcHover );\n        this.imgDown      = $.makeTransparentImage( this.srcDown );\n\n        this.imgRest.alt  =\n        this.imgGroup.alt =\n        this.imgHover.alt =\n        this.imgDown.alt  =\n            this.tooltip;\n\n        this.element.style.position = "relative";\n        $.setElementTouchActionNone( this.element );\n\n        this.imgGroup.style.position =\n        this.imgHover.style.position =\n        this.imgDown.style.position  =\n            "absolute";\n\n        this.imgGroup.style.top =\n        this.imgHover.style.top =\n        this.imgDown.style.top  =\n            "0px";\n\n        this.imgGroup.style.left =\n        this.imgHover.style.left =\n        this.imgDown.style.left  =\n            "0px";\n\n        this.imgHover.style.visibility =\n        this.imgDown.style.visibility  =\n            "hidden";\n\n        if ( $.Browser.vendor == $.BROWSERS.FIREFOX  && $.Browser.version < 3 ){\n            this.imgGroup.style.top =\n            this.imgHover.style.top =\n            this.imgDown.style.top  =\n                "";\n        }\n\n        this.element.appendChild( this.imgRest );\n        this.element.appendChild( this.imgGroup );\n        this.element.appendChild( this.imgHover );\n        this.element.appendChild( this.imgDown );\n    }\n\n\n    this.addHandler( "press",     this.onPress );\n    this.addHandler( "release",   this.onRelease );\n    this.addHandler( "click",     this.onClick );\n    this.addHandler( "enter",     this.onEnter );\n    this.addHandler( "exit",      this.onExit );\n    this.addHandler( "focus",     this.onFocus );\n    this.addHandler( "blur",      this.onBlur );\n\n    /**\n     * The button\'s current state.\n     * @member {OpenSeadragon.ButtonState} currentState\n     * @memberof OpenSeadragon.Button#\n     */\n    this.currentState = $.ButtonState.GROUP;\n\n    // When the button last began to fade.\n    this.fadeBeginTime  = null;\n    // Whether this button should fade after user stops interacting with the viewport.\n    this.shouldFade     = false;\n\n    this.element.style.display  = "inline-block";\n    this.element.style.position = "relative";\n    this.element.title          = this.tooltip;\n\n    /**\n     * Tracks mouse/touch/key events on the button.\n     * @member {OpenSeadragon.MouseTracker} tracker\n     * @memberof OpenSeadragon.Button#\n     */\n    this.tracker = new $.MouseTracker({\n\n        element:            this.element,\n        clickTimeThreshold: this.clickTimeThreshold,\n        clickDistThreshold: this.clickDistThreshold,\n\n        enterHandler: function( event ) {\n            if ( event.insideElementPressed ) {\n                inTo( _this, $.ButtonState.DOWN );\n                /**\n                 * Raised when the cursor enters the Button element.\n                 *\n                 * @event enter\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "enter", { originalEvent: event.originalEvent } );\n            } else if ( !event.buttonDownAny ) {\n                inTo( _this, $.ButtonState.HOVER );\n            }\n        },\n\n        focusHandler: function ( event ) {\n            this.enterHandler( event );\n            /**\n             * Raised when the Button element receives focus.\n             *\n             * @event focus\n             * @memberof OpenSeadragon.Button\n             * @type {object}\n             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n             * @property {Object} originalEvent - The original DOM event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( "focus", { originalEvent: event.originalEvent } );\n        },\n\n        exitHandler: function( event ) {\n            outTo( _this, $.ButtonState.GROUP );\n            if ( event.insideElementPressed ) {\n                /**\n                 * Raised when the cursor leaves the Button element.\n                 *\n                 * @event exit\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "exit", { originalEvent: event.originalEvent } );\n            }\n        },\n\n        blurHandler: function ( event ) {\n            this.exitHandler( event );\n            /**\n             * Raised when the Button element loses focus.\n             *\n             * @event blur\n             * @memberof OpenSeadragon.Button\n             * @type {object}\n             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n             * @property {Object} originalEvent - The original DOM event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( "blur", { originalEvent: event.originalEvent } );\n        },\n\n        pressHandler: function ( event ) {\n            inTo( _this, $.ButtonState.DOWN );\n            /**\n             * Raised when a mouse button is pressed or touch occurs in the Button element.\n             *\n             * @event press\n             * @memberof OpenSeadragon.Button\n             * @type {object}\n             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n             * @property {Object} originalEvent - The original DOM event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( "press", { originalEvent: event.originalEvent } );\n        },\n\n        releaseHandler: function( event ) {\n            if ( event.insideElementPressed && event.insideElementReleased ) {\n                outTo( _this, $.ButtonState.HOVER );\n                /**\n                 * Raised when the mouse button is released or touch ends in the Button element.\n                 *\n                 * @event release\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );\n            } else if ( event.insideElementPressed ) {\n                outTo( _this, $.ButtonState.GROUP );\n            } else {\n                inTo( _this, $.ButtonState.HOVER );\n            }\n        },\n\n        clickHandler: function( event ) {\n            if ( event.quick ) {\n                /**\n                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.\n                 *\n                 * @event click\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent("click", { originalEvent: event.originalEvent });\n            }\n        },\n\n        keyHandler: function( event ){\n            //console.log( "%s : handling key %s!", _this.tooltip, event.keyCode);\n            if( 13 === event.keyCode ){\n                /***\n                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.\n                 *\n                 * @event click\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "click", { originalEvent: event.originalEvent } );\n                /***\n                 * Raised when the mouse button is released or touch ends in the Button element.\n                 *\n                 * @event release\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );\n                return false;\n            }\n            return true;\n        }\n\n    });\n\n    outTo( this, $.ButtonState.REST );\n};\n\n$.extend( $.Button.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.Button.prototype */{\n\n    /**\n     * TODO: Determine what this function is intended to do and if it\'s actually\n     * useful as an API point.\n     * @function\n     */\n    notifyGroupEnter: function() {\n        inTo( this, $.ButtonState.GROUP );\n    },\n\n    /**\n     * TODO: Determine what this function is intended to do and if it\'s actually\n     * useful as an API point.\n     * @function\n     */\n    notifyGroupExit: function() {\n        outTo( this, $.ButtonState.REST );\n    },\n\n    /**\n     * @function\n     */\n    disable: function(){\n        this.notifyGroupExit();\n        this.element.disabled = true;\n        $.setElementOpacity( this.element, 0.2, true );\n    },\n\n    /**\n     * @function\n     */\n    enable: function(){\n        this.element.disabled = false;\n        $.setElementOpacity( this.element, 1.0, true );\n        this.notifyGroupEnter();\n    }\n\n});\n\n\nfunction scheduleFade( button ) {\n    $.requestAnimationFrame(function(){\n        updateFade( button );\n    });\n}\n\nfunction updateFade( button ) {\n    var currentTime,\n        deltaTime,\n        opacity;\n\n    if ( button.shouldFade ) {\n        currentTime = $.now();\n        deltaTime   = currentTime - button.fadeBeginTime;\n        opacity     = 1.0 - deltaTime / button.fadeLength;\n        opacity     = Math.min( 1.0, opacity );\n        opacity     = Math.max( 0.0, opacity );\n\n        if( button.imgGroup ){\n            $.setElementOpacity( button.imgGroup, opacity, true );\n        }\n        if ( opacity > 0 ) {\n            // fade again\n            scheduleFade( button );\n        }\n    }\n}\n\nfunction beginFading( button ) {\n    button.shouldFade = true;\n    button.fadeBeginTime = $.now() + button.fadeDelay;\n    window.setTimeout( function(){\n        scheduleFade( button );\n    }, button.fadeDelay );\n}\n\nfunction stopFading( button ) {\n    button.shouldFade = false;\n    if( button.imgGroup ){\n        $.setElementOpacity( button.imgGroup, 1.0, true );\n    }\n}\n\nfunction inTo( button, newState ) {\n\n    if( button.element.disabled ){\n        return;\n    }\n\n    if ( newState >= $.ButtonState.GROUP &&\n         button.currentState == $.ButtonState.REST ) {\n        stopFading( button );\n        button.currentState = $.ButtonState.GROUP;\n    }\n\n    if ( newState >= $.ButtonState.HOVER &&\n         button.currentState == $.ButtonState.GROUP ) {\n        if( button.imgHover ){\n            button.imgHover.style.visibility = "";\n        }\n        button.currentState = $.ButtonState.HOVER;\n    }\n\n    if ( newState >= $.ButtonState.DOWN &&\n         button.currentState == $.ButtonState.HOVER ) {\n        if( button.imgDown ){\n            button.imgDown.style.visibility = "";\n        }\n        button.currentState = $.ButtonState.DOWN;\n    }\n}\n\n\nfunction outTo( button, newState ) {\n\n    if( button.element.disabled ){\n        return;\n    }\n\n    if ( newState <= $.ButtonState.HOVER &&\n         button.currentState == $.ButtonState.DOWN ) {\n        if( button.imgDown ){\n            button.imgDown.style.visibility = "hidden";\n        }\n        button.currentState = $.ButtonState.HOVER;\n    }\n\n    if ( newState <= $.ButtonState.GROUP &&\n         button.currentState == $.ButtonState.HOVER ) {\n        if( button.imgHover ){\n            button.imgHover.style.visibility = "hidden";\n        }\n        button.currentState = $.ButtonState.GROUP;\n    }\n\n    if ( newState <= $.ButtonState.REST &&\n         button.currentState == $.ButtonState.GROUP ) {\n        beginFading( button );\n        button.currentState = $.ButtonState.REST;\n    }\n}\n\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ButtonGroup\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n/**\n * @class ButtonGroup\n * @classdesc Manages events on groups of buttons.\n *\n * @memberof OpenSeadragon\n * @param {Object} options - A dictionary of settings applied against the entire group of buttons.\n * @param {Array} options.buttons Array of buttons\n * @param {Element} [options.element] Element to use as the container\n **/\n$.ButtonGroup = function( options ) {\n\n    $.extend( true, this, {\n        /**\n         * An array containing the buttons themselves.\n         * @member {Array} buttons\n         * @memberof OpenSeadragon.ButtonGroup#\n         */\n        buttons:            [],\n        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,\n        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,\n        labelText:          ""\n    }, options );\n\n    // copy the button elements  TODO: Why?\n    var buttons = this.buttons.concat([]),\n        _this = this,\n        i;\n\n    /**\n     * The shared container for the buttons.\n     * @member {Element} element\n     * @memberof OpenSeadragon.ButtonGroup#\n     */\n    this.element = options.element || $.makeNeutralElement( "div" );\n\n    // TODO What if there IS an options.group specified?\n    if( !options.group ){\n        this.label   = $.makeNeutralElement( "label" );\n        //TODO: support labels for ButtonGroups\n        //this.label.innerHTML = this.labelText;\n        this.element.style.display = "inline-block";\n        this.element.appendChild( this.label );\n        for ( i = 0; i < buttons.length; i++ ) {\n            this.element.appendChild( buttons[ i ].element );\n        }\n    }\n\n    $.setElementTouchActionNone( this.element );\n\n    /**\n     * Tracks mouse/touch/key events accross the group of buttons.\n     * @member {OpenSeadragon.MouseTracker} tracker\n     * @memberof OpenSeadragon.ButtonGroup#\n     */\n    this.tracker = new $.MouseTracker({\n        element:            this.element,\n        clickTimeThreshold: this.clickTimeThreshold,\n        clickDistThreshold: this.clickDistThreshold,\n        enterHandler: function ( event ) {\n            var i;\n            for ( i = 0; i < _this.buttons.length; i++ ) {\n                _this.buttons[ i ].notifyGroupEnter();\n            }\n        },\n        exitHandler: function ( event ) {\n            var i;\n            if ( !event.insideElementPressed ) {\n                for ( i = 0; i < _this.buttons.length; i++ ) {\n                    _this.buttons[ i ].notifyGroupExit();\n                }\n            }\n        },\n    });\n};\n\n/** @lends OpenSeadragon.ButtonGroup.prototype */\n$.ButtonGroup.prototype = {\n\n    /**\n     * TODO: Figure out why this is used on the public API and if a more useful\n     * api can be created.\n     * @function\n     * @private\n     */\n    emulateEnter: function() {\n        this.tracker.enterHandler( { eventSource: this.tracker } );\n    },\n\n    /**\n     * TODO: Figure out why this is used on the public API and if a more useful\n     * api can be created.\n     * @function\n     * @private\n     */\n    emulateExit: function() {\n        this.tracker.exitHandler( { eventSource: this.tracker } );\n    }\n};\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Rect\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($) {\n\n/**\n * @class Rect\n * @classdesc A Rectangle is described by it top left coordinates (x, y), width,\n * height and degrees of rotation around (x, y).\n * Note that the coordinate system used is the one commonly used with images:\n * x increases when going to the right\n * y increases when going to the bottom\n * degrees increases clockwise with 0 being the horizontal\n *\n * The constructor normalizes the rectangle to always have 0 <= degrees < 90\n *\n * @memberof OpenSeadragon\n * @param {Number} [x=0] The vector component \'x\'.\n * @param {Number} [y=0] The vector component \'y\'.\n * @param {Number} [width=0] The vector component \'width\'.\n * @param {Number} [height=0] The vector component \'height\'.\n * @param {Number} [degrees=0] Rotation of the rectangle around (x,y) in degrees.\n */\n$.Rect = function(x, y, width, height, degrees) {\n    /**\n     * The vector component \'x\'.\n     * @member {Number} x\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.x = typeof(x) === "number" ? x : 0;\n    /**\n     * The vector component \'y\'.\n     * @member {Number} y\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.y = typeof(y) === "number" ? y : 0;\n    /**\n     * The vector component \'width\'.\n     * @member {Number} width\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.width  = typeof(width) === "number" ? width : 0;\n    /**\n     * The vector component \'height\'.\n     * @member {Number} height\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.height = typeof(height) === "number" ? height : 0;\n\n    this.degrees = typeof(degrees) === "number" ? degrees : 0;\n\n    // Normalizes the rectangle.\n    this.degrees = this.degrees % 360;\n    if (this.degrees < 0) {\n        this.degrees += 360;\n    }\n    var newTopLeft, newWidth;\n    if (this.degrees >= 270) {\n        newTopLeft = this.getTopRight();\n        this.x = newTopLeft.x;\n        this.y = newTopLeft.y;\n        newWidth = this.height;\n        this.height = this.width;\n        this.width = newWidth;\n        this.degrees -= 270;\n    } else if (this.degrees >= 180) {\n        newTopLeft = this.getBottomRight();\n        this.x = newTopLeft.x;\n        this.y = newTopLeft.y;\n        this.degrees -= 180;\n    } else if (this.degrees >= 90) {\n        newTopLeft = this.getBottomLeft();\n        this.x = newTopLeft.x;\n        this.y = newTopLeft.y;\n        newWidth = this.height;\n        this.height = this.width;\n        this.width = newWidth;\n        this.degrees -= 90;\n    }\n};\n\n/**\n * Builds a rectangle having the 3 specified points as summits.\n * @static\n * @memberof OpenSeadragon.Rect\n * @param {OpenSeadragon.Point} topLeft\n * @param {OpenSeadragon.Point} topRight\n * @param {OpenSeadragon.Point} bottomLeft\n * @returns {OpenSeadragon.Rect}\n */\n$.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {\n    var width = topLeft.distanceTo(topRight);\n    var height = topLeft.distanceTo(bottomLeft);\n    var diff = topRight.minus(topLeft);\n    var radians = Math.atan(diff.y / diff.x);\n    if (diff.x < 0) {\n        radians += Math.PI;\n    } else if (diff.y < 0) {\n        radians += 2 * Math.PI;\n    }\n    return new $.Rect(\n        topLeft.x,\n        topLeft.y,\n        width,\n        height,\n        radians / Math.PI * 180);\n};\n\n/** @lends OpenSeadragon.Rect.prototype */\n$.Rect.prototype = {\n    /**\n     * @function\n     * @returns {OpenSeadragon.Rect} a duplicate of this Rect\n     */\n    clone: function() {\n        return new $.Rect(\n            this.x,\n            this.y,\n            this.width,\n            this.height,\n            this.degrees);\n    },\n\n    /**\n     * The aspect ratio is simply the ratio of width to height.\n     * @function\n     * @returns {Number} The ratio of width to height.\n     */\n    getAspectRatio: function() {\n        return this.width / this.height;\n    },\n\n    /**\n     * Provides the coordinates of the upper-left corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of\n     *  the rectangle.\n     */\n    getTopLeft: function() {\n        return new $.Point(\n            this.x,\n            this.y\n        );\n    },\n\n    /**\n     * Provides the coordinates of the bottom-right corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of\n     *  the rectangle.\n     */\n    getBottomRight: function() {\n        return new $.Point(this.x + this.width, this.y + this.height)\n            .rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Provides the coordinates of the top-right corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of\n     *  the rectangle.\n     */\n    getTopRight: function() {\n        return new $.Point(this.x + this.width, this.y)\n            .rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Provides the coordinates of the bottom-left corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of\n     *  the rectangle.\n     */\n    getBottomLeft: function() {\n        return new $.Point(this.x, this.y + this.height)\n            .rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Computes the center of the rectangle.\n     * @function\n     * @returns {OpenSeadragon.Point} The center of the rectangle as represented\n     *  as represented by a 2-dimensional vector (x,y)\n     */\n    getCenter: function() {\n        return new $.Point(\n            this.x + this.width / 2.0,\n            this.y + this.height / 2.0\n        ).rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Returns the width and height component as a vector OpenSeadragon.Point\n     * @function\n     * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the\n     *  the width and height of the rectangle.\n     */\n    getSize: function() {\n        return new $.Point(this.width, this.height);\n    },\n\n    /**\n     * Determines if two Rectangles have equivalent components.\n     * @function\n     * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.\n     * @return {Boolean} \'true\' if all components are equal, otherwise \'false\'.\n     */\n    equals: function(other) {\n        return (other instanceof $.Rect) &&\n            this.x === other.x &&\n            this.y === other.y &&\n            this.width === other.width &&\n            this.height === other.height &&\n            this.degrees === other.degrees;\n    },\n\n    /**\n    * Multiply all dimensions (except degrees) in this Rect by a factor and\n    * return a new Rect.\n    * @function\n    * @param {Number} factor The factor to multiply vector components.\n    * @returns {OpenSeadragon.Rect} A new rect representing the multiplication\n    *  of the vector components by the factor\n    */\n    times: function(factor) {\n        return new $.Rect(\n            this.x * factor,\n            this.y * factor,\n            this.width * factor,\n            this.height * factor,\n            this.degrees);\n    },\n\n    /**\n    * Translate/move this Rect by a vector and return new Rect.\n    * @function\n    * @param {OpenSeadragon.Point} delta The translation vector.\n    * @returns {OpenSeadragon.Rect} A new rect with altered position\n    */\n    translate: function(delta) {\n        return new $.Rect(\n            this.x + delta.x,\n            this.y + delta.y,\n            this.width,\n            this.height,\n            this.degrees);\n    },\n\n    /**\n     * Returns the smallest rectangle that will contain this and the given\n     * rectangle bounding boxes.\n     * @param {OpenSeadragon.Rect} rect\n     * @return {OpenSeadragon.Rect} The new rectangle.\n     */\n    union: function(rect) {\n        var thisBoundingBox = this.getBoundingBox();\n        var otherBoundingBox = rect.getBoundingBox();\n\n        var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);\n        var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);\n        var right = Math.max(\n            thisBoundingBox.x + thisBoundingBox.width,\n            otherBoundingBox.x + otherBoundingBox.width);\n        var bottom = Math.max(\n            thisBoundingBox.y + thisBoundingBox.height,\n            otherBoundingBox.y + otherBoundingBox.height);\n\n        return new $.Rect(\n            left,\n            top,\n            right - left,\n            bottom - top);\n    },\n\n    /**\n     * Returns the bounding box of the intersection of this rectangle with the\n     * given rectangle.\n     * @param {OpenSeadragon.Rect} rect\n     * @return {OpenSeadragon.Rect} the bounding box of the intersection\n     * or null if the rectangles don\'t intersect.\n     */\n    intersection: function(rect) {\n        // Simplified version of Weiler Atherton clipping algorithm\n        // https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm\n        // Because we just want the bounding box of the intersection,\n        // we can just compute the bounding box of:\n        // 1. all the summits of this which are inside rect\n        // 2. all the summits of rect which are inside this\n        // 3. all the intersections of rect and this\n        var EPSILON = 0.0000000001;\n\n        var intersectionPoints = [];\n\n        var thisTopLeft = this.getTopLeft();\n        if (rect.containsPoint(thisTopLeft, EPSILON)) {\n            intersectionPoints.push(thisTopLeft);\n        }\n        var thisTopRight = this.getTopRight();\n        if (rect.containsPoint(thisTopRight, EPSILON)) {\n            intersectionPoints.push(thisTopRight);\n        }\n        var thisBottomLeft = this.getBottomLeft();\n        if (rect.containsPoint(thisBottomLeft, EPSILON)) {\n            intersectionPoints.push(thisBottomLeft);\n        }\n        var thisBottomRight = this.getBottomRight();\n        if (rect.containsPoint(thisBottomRight, EPSILON)) {\n            intersectionPoints.push(thisBottomRight);\n        }\n\n        var rectTopLeft = rect.getTopLeft();\n        if (this.containsPoint(rectTopLeft, EPSILON)) {\n            intersectionPoints.push(rectTopLeft);\n        }\n        var rectTopRight = rect.getTopRight();\n        if (this.containsPoint(rectTopRight, EPSILON)) {\n            intersectionPoints.push(rectTopRight);\n        }\n        var rectBottomLeft = rect.getBottomLeft();\n        if (this.containsPoint(rectBottomLeft, EPSILON)) {\n            intersectionPoints.push(rectBottomLeft);\n        }\n        var rectBottomRight = rect.getBottomRight();\n        if (this.containsPoint(rectBottomRight, EPSILON)) {\n            intersectionPoints.push(rectBottomRight);\n        }\n\n        var thisSegments = this._getSegments();\n        var rectSegments = rect._getSegments();\n        for (var i = 0; i < thisSegments.length; i++) {\n            var thisSegment = thisSegments[i];\n            for (var j = 0; j < rectSegments.length; j++) {\n                var rectSegment = rectSegments[j];\n                var intersect = getIntersection(thisSegment[0], thisSegment[1],\n                    rectSegment[0], rectSegment[1]);\n                if (intersect) {\n                    intersectionPoints.push(intersect);\n                }\n            }\n        }\n\n        // Get intersection point of segments [a,b] and [c,d]\n        function getIntersection(a, b, c, d) {\n            // http://stackoverflow.com/a/1968345/1440403\n            var abVector = b.minus(a);\n            var cdVector = d.minus(c);\n\n            var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;\n            if (denom === 0) {\n                return null;\n            }\n\n            var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;\n            var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;\n\n            if (-EPSILON <= s && s <= 1 - EPSILON &&\n                -EPSILON <= t && t <= 1 - EPSILON) {\n                return new $.Point(a.x + t * abVector.x, a.y + t * abVector.y);\n            }\n            return null;\n        }\n\n        if (intersectionPoints.length === 0) {\n            return null;\n        }\n\n        var minX = intersectionPoints[0].x;\n        var maxX = intersectionPoints[0].x;\n        var minY = intersectionPoints[0].y;\n        var maxY = intersectionPoints[0].y;\n        for (var k = 1; k < intersectionPoints.length; k++) {\n            var point = intersectionPoints[k];\n            if (point.x < minX) {\n                minX = point.x;\n            }\n            if (point.x > maxX) {\n                maxX = point.x;\n            }\n            if (point.y < minY) {\n                minY = point.y;\n            }\n            if (point.y > maxY) {\n                maxY = point.y;\n            }\n        }\n        return new $.Rect(minX, minY, maxX - minX, maxY - minY);\n    },\n\n    // private\n    _getSegments: function() {\n        var topLeft = this.getTopLeft();\n        var topRight = this.getTopRight();\n        var bottomLeft = this.getBottomLeft();\n        var bottomRight = this.getBottomRight();\n        return [[topLeft, topRight],\n            [topRight, bottomRight],\n            [bottomRight, bottomLeft],\n            [bottomLeft, topLeft]];\n    },\n\n    /**\n     * Rotates a rectangle around a point.\n     * @function\n     * @param {Number} degrees The angle in degrees to rotate.\n     * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.\n     * Defaults to the center of the rectangle.\n     * @return {OpenSeadragon.Rect}\n     */\n    rotate: function(degrees, pivot) {\n        degrees = degrees % 360;\n        if (degrees === 0) {\n            return this.clone();\n        }\n        if (degrees < 0) {\n            degrees += 360;\n        }\n\n        pivot = pivot || this.getCenter();\n        var newTopLeft = this.getTopLeft().rotate(degrees, pivot);\n        var newTopRight = this.getTopRight().rotate(degrees, pivot);\n\n        var diff = newTopRight.minus(newTopLeft);\n        var radians = Math.atan(diff.y / diff.x);\n        if (diff.x < 0) {\n            radians += Math.PI;\n        } else if (diff.y < 0) {\n            radians += 2 * Math.PI;\n        }\n        return new $.Rect(\n            newTopLeft.x,\n            newTopLeft.y,\n            this.width,\n            this.height,\n            radians / Math.PI * 180);\n    },\n\n    /**\n     * Retrieves the smallest horizontal (degrees=0) rectangle which contains\n     * this rectangle.\n     * @returns {OpenSeadragon.Rect}\n     */\n    getBoundingBox: function() {\n        if (this.degrees === 0) {\n            return this.clone();\n        }\n        var topLeft = this.getTopLeft();\n        var topRight = this.getTopRight();\n        var bottomLeft = this.getBottomLeft();\n        var bottomRight = this.getBottomRight();\n        var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);\n        var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);\n        var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);\n        var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);\n        return new $.Rect(\n            minX,\n            minY,\n            maxX - minX,\n            maxY - minY);\n    },\n\n    /**\n     * Retrieves the smallest horizontal (degrees=0) rectangle which contains\n     * this rectangle and has integers x, y, width and height\n     * @returns {OpenSeadragon.Rect}\n     */\n    getIntegerBoundingBox: function() {\n        var boundingBox = this.getBoundingBox();\n        var x = Math.floor(boundingBox.x);\n        var y = Math.floor(boundingBox.y);\n        var width = Math.ceil(boundingBox.width + boundingBox.x - x);\n        var height = Math.ceil(boundingBox.height + boundingBox.y - y);\n        return new $.Rect(x, y, width, height);\n    },\n\n    /**\n     * Determines whether a point is inside this rectangle (edge included).\n     * @function\n     * @param {OpenSeadragon.Point} point\n     * @param {Number} [epsilon=0] the margin of error allowed\n     * @returns {Boolean} true if the point is inside this rectangle, false\n     * otherwise.\n     */\n    containsPoint: function(point, epsilon) {\n        epsilon = epsilon || 0;\n\n        // See http://stackoverflow.com/a/2752754/1440403 for explanation\n        var topLeft = this.getTopLeft();\n        var topRight = this.getTopRight();\n        var bottomLeft = this.getBottomLeft();\n        var topDiff = topRight.minus(topLeft);\n        var leftDiff = bottomLeft.minus(topLeft);\n\n        return ((point.x - topLeft.x) * topDiff.x +\n            (point.y - topLeft.y) * topDiff.y >= -epsilon) &&\n\n            ((point.x - topRight.x) * topDiff.x +\n            (point.y - topRight.y) * topDiff.y <= epsilon) &&\n\n            ((point.x - topLeft.x) * leftDiff.x +\n            (point.y - topLeft.y) * leftDiff.y >= -epsilon) &&\n\n            ((point.x - bottomLeft.x) * leftDiff.x +\n            (point.y - bottomLeft.y) * leftDiff.y <= epsilon);\n    },\n\n    /**\n     * Provides a string representation of the rectangle which is useful for\n     * debugging.\n     * @function\n     * @returns {String} A string representation of the rectangle.\n     */\n    toString: function() {\n        return "[" +\n            (Math.round(this.x * 100) / 100) + ", " +\n            (Math.round(this.y * 100) / 100) + ", " +\n            (Math.round(this.width * 100) / 100) + "x" +\n            (Math.round(this.height * 100) / 100) + ", " +\n            (Math.round(this.degrees * 100) / 100) + "deg" +\n            "]";\n    }\n};\n\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - ReferenceStrip\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function ( $ ) {\n\n// dictionary from id to private properties\nvar THIS = {};\n\n/**\n *  The CollectionDrawer is a reimplementation if the Drawer API that\n *  focuses on allowing a viewport to be redefined as a collection\n *  of smaller viewports, defined by a clear number of rows and / or\n *  columns of which each item in the matrix of viewports has its own\n *  source.\n *\n *  This idea is a reexpression of the idea of dzi collections\n *  which allows a clearer algorithm to reuse the tile sources already\n *  supported by OpenSeadragon, in heterogenious or homogenious\n *  sequences just like mixed groups already supported by the viewer\n *  for the purpose of image sequnces.\n *\n *  TODO:   The difficult part of this feature is figuring out how to express\n *          this functionality as a combination of the functionality already\n *          provided by Drawer, Viewport, TileSource, and Navigator.  It may\n *          require better abstraction at those points in order to effeciently\n *          reuse those paradigms.\n */\n/**\n * @class ReferenceStrip\n * @memberof OpenSeadragon\n * @param {Object} options\n */\n$.ReferenceStrip = function ( options ) {\n\n    var _this       = this,\n        viewer      = options.viewer,\n        viewerSize  = $.getElementSize( viewer.element ),\n        element,\n        style,\n        i;\n\n    //We may need to create a new element and id if they did not\n    //provide the id for the existing element\n    if ( !options.id ) {\n        options.id              = \'referencestrip-\' + $.now();\n        this.element            = $.makeNeutralElement( "div" );\n        this.element.id         = options.id;\n        this.element.className  = \'referencestrip\';\n    }\n\n    options = $.extend( true, {\n        sizeRatio:  $.DEFAULT_SETTINGS.referenceStripSizeRatio,\n        position:   $.DEFAULT_SETTINGS.referenceStripPosition,\n        scroll:     $.DEFAULT_SETTINGS.referenceStripScroll,\n        clickTimeThreshold:  $.DEFAULT_SETTINGS.clickTimeThreshold\n    }, options, {\n        //required overrides\n        element:                this.element,\n        //These need to be overridden to prevent recursion since\n        //the navigator is a viewer and a viewer has a navigator\n        showNavigator:          false,\n        mouseNavEnabled:        false,\n        showNavigationControl:  false,\n        showSequenceControl:    false\n    } );\n\n    $.extend( this, options );\n    //Private state properties\n    THIS[this.id] = {\n        "animating":           false\n    };\n\n    this.minPixelRatio = this.viewer.minPixelRatio;\n\n    style = this.element.style;\n    style.marginTop     = \'0px\';\n    style.marginRight   = \'0px\';\n    style.marginBottom  = \'0px\';\n    style.marginLeft    = \'0px\';\n    style.left          = \'0px\';\n    style.bottom        = \'0px\';\n    style.border        = \'0px\';\n    style.background    = \'#000\';\n    style.position      = \'relative\';\n\n    $.setElementTouchActionNone( this.element );\n\n    $.setElementOpacity( this.element, 0.8 );\n\n    this.viewer = viewer;\n    this.innerTracker = new $.MouseTracker( {\n        element:        this.element,\n        dragHandler:    $.delegate( this, onStripDrag ),\n        scrollHandler:  $.delegate( this, onStripScroll ),\n        enterHandler:   $.delegate( this, onStripEnter ),\n        exitHandler:    $.delegate( this, onStripExit ),\n        keyDownHandler: $.delegate( this, onKeyDown ),\n        keyHandler:     $.delegate( this, onKeyPress )\n    } );\n\n    //Controls the position and orientation of the reference strip and sets the\n    //appropriate width and height\n    if ( options.width && options.height ) {\n        this.element.style.width  = options.width + \'px\';\n        this.element.style.height = options.height + \'px\';\n        viewer.addControl(\n            this.element,\n            { anchor: $.ControlAnchor.BOTTOM_LEFT }\n        );\n    } else {\n        if ( "horizontal" == options.scroll ) {\n            this.element.style.width = (\n                viewerSize.x *\n                options.sizeRatio *\n                viewer.tileSources.length\n            ) + ( 12 * viewer.tileSources.length ) + \'px\';\n\n            this.element.style.height = (\n                viewerSize.y *\n                options.sizeRatio\n            ) + \'px\';\n\n            viewer.addControl(\n                this.element,\n                { anchor: $.ControlAnchor.BOTTOM_LEFT }\n            );\n        } else {\n            this.element.style.height = (\n                viewerSize.y *\n                options.sizeRatio *\n                viewer.tileSources.length\n            ) + ( 12 * viewer.tileSources.length ) + \'px\';\n\n            this.element.style.width = (\n                viewerSize.x *\n                options.sizeRatio\n            ) + \'px\';\n\n            viewer.addControl(\n                this.element,\n                { anchor: $.ControlAnchor.TOP_LEFT }\n            );\n\n        }\n    }\n\n    this.panelWidth = ( viewerSize.x * this.sizeRatio ) + 8;\n    this.panelHeight = ( viewerSize.y * this.sizeRatio ) + 8;\n    this.panels = [];\n\n    /*jshint loopfunc:true*/\n    for ( i = 0; i < viewer.tileSources.length; i++ ) {\n\n        element = $.makeNeutralElement( \'div\' );\n        element.id = this.element.id + "-" + i;\n\n        element.style.width         = _this.panelWidth + \'px\';\n        element.style.height        = _this.panelHeight + \'px\';\n        element.style.display       = \'inline\';\n        element.style.float         = \'left\'; //Webkit\n        element.style.cssFloat      = \'left\'; //Firefox\n        element.style.styleFloat    = \'left\'; //IE\n        element.style.padding       = \'2px\';\n        $.setElementTouchActionNone( element );\n\n        element.innerTracker = new $.MouseTracker( {\n            element:            element,\n            clickTimeThreshold: this.clickTimeThreshold,\n            clickDistThreshold: this.clickDistThreshold,\n            pressHandler: function ( event ) {\n                event.eventSource.dragging = $.now();\n            },\n            releaseHandler: function ( event ) {\n                var tracker = event.eventSource,\n                    id      = tracker.element.id,\n                    page    = Number( id.split( \'-\' )[2] ),\n                    now     = $.now();\n\n                if ( event.insideElementPressed &&\n                     event.insideElementReleased &&\n                     tracker.dragging &&\n                     ( now - tracker.dragging ) < tracker.clickTimeThreshold ) {\n                    tracker.dragging = null;\n                    viewer.goToPage( page );\n                }\n            }\n        } );\n\n        this.element.appendChild( element );\n\n        element.activePanel = false;\n\n        this.panels.push( element );\n\n    }\n    loadPanels( this, this.scroll == \'vertical\' ? viewerSize.y : viewerSize.x, 0 );\n    this.setFocus( 0 );\n\n};\n\n$.extend( $.ReferenceStrip.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.ReferenceStrip.prototype */{\n\n    /**\n     * @function\n     */\n    setFocus: function ( page ) {\n        var element      = $.getElement( this.element.id + \'-\' + page ),\n            viewerSize   = $.getElementSize( this.viewer.canvas ),\n            scrollWidth  = Number( this.element.style.width.replace( \'px\', \'\' ) ),\n            scrollHeight = Number( this.element.style.height.replace( \'px\', \'\' ) ),\n            offsetLeft   = -Number( this.element.style.marginLeft.replace( \'px\', \'\' ) ),\n            offsetTop    = -Number( this.element.style.marginTop.replace( \'px\', \'\' ) ),\n            offset;\n\n        if ( this.currentSelected !== element ) {\n            if ( this.currentSelected ) {\n                this.currentSelected.style.background = \'#000\';\n            }\n            this.currentSelected = element;\n            this.currentSelected.style.background = \'#999\';\n\n            if ( \'horizontal\' == this.scroll ) {\n                //right left\n                offset = ( Number( page ) ) * ( this.panelWidth + 3 );\n                if ( offset > offsetLeft + viewerSize.x - this.panelWidth ) {\n                    offset = Math.min( offset, ( scrollWidth - viewerSize.x ) );\n                    this.element.style.marginLeft = -offset + \'px\';\n                    loadPanels( this, viewerSize.x, -offset );\n                } else if ( offset < offsetLeft ) {\n                    offset = Math.max( 0, offset - viewerSize.x / 2 );\n                    this.element.style.marginLeft = -offset + \'px\';\n                    loadPanels( this, viewerSize.x, -offset );\n                }\n            } else {\n                offset = ( Number( page ) ) * ( this.panelHeight + 3 );\n                if ( offset > offsetTop + viewerSize.y - this.panelHeight ) {\n                    offset = Math.min( offset, ( scrollHeight - viewerSize.y ) );\n                    this.element.style.marginTop = -offset + \'px\';\n                    loadPanels( this, viewerSize.y, -offset );\n                } else if ( offset < offsetTop ) {\n                    offset = Math.max( 0, offset - viewerSize.y / 2 );\n                    this.element.style.marginTop = -offset + \'px\';\n                    loadPanels( this, viewerSize.y, -offset );\n                }\n            }\n\n            this.currentPage = page;\n            onStripEnter.call( this, { eventSource: this.innerTracker } );\n        }\n    },\n\n    /**\n     * @function\n     */\n    update: function () {\n        if ( THIS[this.id].animating ) {\n            $.console.log( \'image reference strip update\' );\n            return true;\n        }\n        return false;\n    },\n\n    // Overrides Viewer.destroy\n    destroy: function() {\n        if (this.element) {\n            this.element.parentNode.removeChild(this.element);\n        }\n    }\n\n} );\n\n\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripDrag( event ) {\n\n    var offsetLeft   = Number( this.element.style.marginLeft.replace( \'px\', \'\' ) ),\n        offsetTop    = Number( this.element.style.marginTop.replace( \'px\', \'\' ) ),\n        scrollWidth  = Number( this.element.style.width.replace( \'px\', \'\' ) ),\n        scrollHeight = Number( this.element.style.height.replace( \'px\', \'\' ) ),\n        viewerSize   = $.getElementSize( this.viewer.canvas );\n    this.dragging = true;\n    if ( this.element ) {\n        if ( \'horizontal\' == this.scroll ) {\n            if ( -event.delta.x > 0 ) {\n                //forward\n                if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {\n                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );\n                }\n            } else if ( -event.delta.x < 0 ) {\n                //reverse\n                if ( offsetLeft < 0 ) {\n                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );\n                }\n            }\n        } else {\n            if ( -event.delta.y > 0 ) {\n                //forward\n                if ( offsetTop > -( scrollHeight - viewerSize.y ) ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );\n                }\n            } else if ( -event.delta.y < 0 ) {\n                //reverse\n                if ( offsetTop < 0 ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );\n                }\n            }\n        }\n    }\n    return false;\n\n}\n\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripScroll( event ) {\n    var offsetLeft   = Number( this.element.style.marginLeft.replace( \'px\', \'\' ) ),\n        offsetTop    = Number( this.element.style.marginTop.replace( \'px\', \'\' ) ),\n        scrollWidth  = Number( this.element.style.width.replace( \'px\', \'\' ) ),\n        scrollHeight = Number( this.element.style.height.replace( \'px\', \'\' ) ),\n        viewerSize   = $.getElementSize( this.viewer.canvas );\n    if ( this.element ) {\n        if ( \'horizontal\' == this.scroll ) {\n            if ( event.scroll > 0 ) {\n                //forward\n                if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {\n                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );\n                }\n            } else if ( event.scroll < 0 ) {\n                //reverse\n                if ( offsetLeft < 0 ) {\n                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );\n                }\n            }\n        } else {\n            if ( event.scroll < 0 ) {\n                //scroll up\n                if ( offsetTop > viewerSize.y - scrollHeight ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );\n                }\n            } else if ( event.scroll > 0 ) {\n                //scroll dowm\n                if ( offsetTop < 0 ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );\n                }\n            }\n        }\n    }\n    //cancels event\n    return false;\n}\n\n\nfunction loadPanels( strip, viewerSize, scroll ) {\n    var panelSize,\n        activePanelsStart,\n        activePanelsEnd,\n        miniViewer,\n        style,\n        i,\n        element;\n    if ( \'horizontal\' == strip.scroll ) {\n        panelSize = strip.panelWidth;\n    } else {\n        panelSize = strip.panelHeight;\n    }\n    activePanelsStart = Math.ceil( viewerSize / panelSize ) + 5;\n    activePanelsEnd = Math.ceil( ( Math.abs( scroll ) + viewerSize ) / panelSize ) + 1;\n    activePanelsStart = activePanelsEnd - activePanelsStart;\n    activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;\n\n    for ( i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++ ) {\n        element = strip.panels[i];\n        if ( !element.activePanel ) {\n            miniViewer = new $.Viewer( {\n                id:                     element.id,\n                tileSources:            [strip.viewer.tileSources[i]],\n                element:                element,\n                navigatorSizeRatio:     strip.sizeRatio,\n                showNavigator:          false,\n                mouseNavEnabled:        false,\n                showNavigationControl:  false,\n                showSequenceControl:    false,\n                immediateRender:        true,\n                blendTime:              0,\n                animationTime:          0\n            } );\n\n            miniViewer.displayRegion           = $.makeNeutralElement( "div" );\n            miniViewer.displayRegion.id        = element.id + \'-displayregion\';\n            miniViewer.displayRegion.className = \'displayregion\';\n\n            style               = miniViewer.displayRegion.style;\n            style.position      = \'relative\';\n            style.top           = \'0px\';\n            style.left          = \'0px\';\n            style.fontSize      = \'0px\';\n            style.overflow      = \'hidden\';\n            style.float         = \'left\'; //Webkit\n            style.cssFloat      = \'left\'; //Firefox\n            style.styleFloat    = \'left\'; //IE\n            style.zIndex        = 999999999;\n            style.cursor        = \'default\';\n            style.width         = ( strip.panelWidth - 4 ) + \'px\';\n            style.height        = ( strip.panelHeight - 4 ) + \'px\';\n\n            // TODO: What is this for? Future keyboard navigation support?\n            miniViewer.displayRegion.innerTracker = new $.MouseTracker( {\n                element: miniViewer.displayRegion,\n                startDisabled: true\n            } );\n\n            element.getElementsByTagName( \'div\' )[0].appendChild(\n                miniViewer.displayRegion\n            );\n\n            element.activePanel = true;\n        }\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripEnter( event ) {\n    var element = event.eventSource.element;\n\n    //$.setElementOpacity(element, 0.8);\n\n    //element.style.border = \'1px solid #555\';\n    //element.style.background = \'#000\';\n\n    if ( \'horizontal\' == this.scroll ) {\n\n        //element.style.paddingTop = "0px";\n        element.style.marginBottom = "0px";\n\n    } else {\n\n        //element.style.paddingRight = "0px";\n        element.style.marginLeft = "0px";\n\n    }\n    return false;\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripExit( event ) {\n    var element = event.eventSource.element;\n\n    if ( \'horizontal\' == this.scroll ) {\n\n        //element.style.paddingTop = "10px";\n        element.style.marginBottom = "-" + ( $.getElementSize( element ).y / 2 ) + "px";\n\n    } else {\n\n        //element.style.paddingRight = "10px";\n        element.style.marginLeft = "-" + ( $.getElementSize( element ).x / 2 ) + "px";\n\n    }\n    return false;\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onKeyDown( event ) {\n    //console.log( event.keyCode );\n\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch ( event.keyCode ) {\n            case 38: //up arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            case 40: //down arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 37: //left arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 39: //right arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onKeyPress( event ) {\n    //console.log( event.keyCode );\n\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch ( event.keyCode ) {\n            case 61: //=|+\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            case 45: //-|_\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 48: //0|)\n            case 119: //w\n            case 87: //W\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            case 115: //s\n            case 83: //S\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 97: //a\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 100: //d\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\n\n\n} ( OpenSeadragon ) );\n\n/*\n * OpenSeadragon - DisplayRect\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class DisplayRect\n * @classdesc A display rectangle is very similar to {@link OpenSeadragon.Rect} but adds two\n * fields, \'minLevel\' and \'maxLevel\' which denote the supported zoom levels\n * for this rectangle.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.Rect\n * @param {Number} x The vector component \'x\'.\n * @param {Number} y The vector component \'y\'.\n * @param {Number} width The vector component \'height\'.\n * @param {Number} height The vector component \'width\'.\n * @param {Number} minLevel The lowest zoom level supported.\n * @param {Number} maxLevel The highest zoom level supported.\n */\n$.DisplayRect = function( x, y, width, height, minLevel, maxLevel ) {\n    $.Rect.apply( this, [ x, y, width, height ] );\n\n    /**\n     * The lowest zoom level supported.\n     * @member {Number} minLevel\n     * @memberof OpenSeadragon.DisplayRect#\n     */\n    this.minLevel = minLevel;\n    /**\n     * The highest zoom level supported.\n     * @member {Number} maxLevel\n     * @memberof OpenSeadragon.DisplayRect#\n     */\n    this.maxLevel = maxLevel;\n};\n\n$.extend( $.DisplayRect.prototype, $.Rect.prototype );\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Spring\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Spring\n * @memberof OpenSeadragon\n * @param {Object} options - Spring configuration settings.\n * @param {Number} options.springStiffness - Spring stiffness. Must be greater than zero.\n * The closer to zero, the closer to linear animation.\n * @param {Number} options.animationTime - Animation duration per spring, in seconds.\n * Must be zero or greater.\n * @param {Number} [options.initial=0] - Initial value of spring.\n * @param {Boolean} [options.exponential=false] - Whether this spring represents\n * an exponential scale (such as zoom) and should be animated accordingly. Note that\n * exponential springs must have non-zero values.\n */\n$.Spring = function( options ) {\n    var args = arguments;\n\n    if( typeof( options ) != \'object\' ){\n        //allows backward compatible use of ( initialValue, config ) as\n        //constructor parameters\n        options = {\n            initial: args.length && typeof ( args[ 0 ] ) == "number" ?\n                args[ 0 ] :\n                undefined,\n            /**\n             * Spring stiffness.\n             * @member {Number} springStiffness\n             * @memberof OpenSeadragon.Spring#\n             */\n            springStiffness: args.length > 1 ?\n                args[ 1 ].springStiffness :\n                5.0,\n            /**\n             * Animation duration per spring.\n             * @member {Number} animationTime\n             * @memberof OpenSeadragon.Spring#\n             */\n            animationTime: args.length > 1 ?\n                args[ 1 ].animationTime :\n                1.5\n        };\n    }\n\n    $.console.assert(typeof options.springStiffness === "number" && options.springStiffness !== 0,\n        "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number");\n\n    $.console.assert(typeof options.animationTime === "number" && options.animationTime >= 0,\n        "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0");\n\n    if (options.exponential) {\n        this._exponential = true;\n        delete options.exponential;\n    }\n\n    $.extend( true, this, options);\n\n    /**\n     * @member {Object} current\n     * @memberof OpenSeadragon.Spring#\n     * @property {Number} value\n     * @property {Number} time\n     */\n    this.current = {\n        value: typeof ( this.initial ) == "number" ?\n            this.initial :\n            (this._exponential ? 0 : 1),\n        time:  $.now() // always work in milliseconds\n    };\n\n    $.console.assert(!this._exponential || this.current.value !== 0,\n        "[OpenSeadragon.Spring] value must be non-zero for exponential springs");\n\n    /**\n     * @member {Object} start\n     * @memberof OpenSeadragon.Spring#\n     * @property {Number} value\n     * @property {Number} time\n     */\n    this.start = {\n        value: this.current.value,\n        time:  this.current.time\n    };\n\n    /**\n     * @member {Object} target\n     * @memberof OpenSeadragon.Spring#\n     * @property {Number} value\n     * @property {Number} time\n     */\n    this.target = {\n        value: this.current.value,\n        time:  this.current.time\n    };\n\n    if (this._exponential) {\n        this.start._logValue = Math.log(this.start.value);\n        this.target._logValue = Math.log(this.target.value);\n        this.current._logValue = Math.log(this.current.value);\n    }\n};\n\n/** @lends OpenSeadragon.Spring.prototype */\n$.Spring.prototype = {\n\n    /**\n     * @function\n     * @param {Number} target\n     */\n    resetTo: function( target ) {\n        $.console.assert(!this._exponential || target !== 0,\n            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs");\n\n        this.start.value = this.target.value = this.current.value = target;\n        this.start.time = this.target.time = this.current.time = $.now();\n\n        if (this._exponential) {\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n            this.current._logValue = Math.log(this.current.value);\n        }\n    },\n\n    /**\n     * @function\n     * @param {Number} target\n     */\n    springTo: function( target ) {\n        $.console.assert(!this._exponential || target !== 0,\n            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs");\n\n        this.start.value  = this.current.value;\n        this.start.time   = this.current.time;\n        this.target.value = target;\n        this.target.time  = this.start.time + 1000 * this.animationTime;\n\n        if (this._exponential) {\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n        }\n    },\n\n    /**\n     * @function\n     * @param {Number} delta\n     */\n    shiftBy: function( delta ) {\n        this.start.value  += delta;\n        this.target.value += delta;\n\n        if (this._exponential) {\n            $.console.assert(this.target.value !== 0 && this.start.value !== 0,\n                "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs");\n\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n        }\n    },\n\n    setExponential: function(value) {\n        this._exponential = value;\n\n        if (this._exponential) {\n            $.console.assert(this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,\n                "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs");\n\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n            this.current._logValue = Math.log(this.current.value);\n        }\n    },\n\n    /**\n     * @function\n     */\n    update: function() {\n        this.current.time  = $.now();\n\n        var startValue, targetValue;\n        if (this._exponential) {\n            startValue = this.start._logValue;\n            targetValue = this.target._logValue;\n        } else {\n            startValue = this.start.value;\n            targetValue = this.target.value;\n        }\n\n        var currentValue = (this.current.time >= this.target.time) ?\n            targetValue :\n            startValue +\n                ( targetValue - startValue ) *\n                transform(\n                    this.springStiffness,\n                    ( this.current.time - this.start.time ) /\n                    ( this.target.time  - this.start.time )\n                );\n\n        if (this._exponential) {\n            this.current.value = Math.exp(currentValue);\n        } else {\n            this.current.value = currentValue;\n        }\n    },\n\n    /**\n     * Returns whether the spring is at the target value\n     * @function\n     * @returns {Boolean} True if at target value, false otherwise\n     */\n    isAtTargetValue: function() {\n        return this.current.value === this.target.value;\n    }\n};\n\n/**\n * @private\n */\nfunction transform( stiffness, x ) {\n    return ( 1.0 - Math.exp( stiffness * -x ) ) /\n        ( 1.0 - Math.exp( -stiffness ) );\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ImageLoader\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// private class\nfunction ImageJob ( options ) {\n\n    $.extend( true, this, {\n        timeout:        $.DEFAULT_SETTINGS.timeout,\n        jobId:          null\n    }, options );\n\n    /**\n     * Image object which will contain downloaded image.\n     * @member {Image} image\n     * @memberof OpenSeadragon.ImageJob#\n     */\n    this.image = null;\n}\n\nImageJob.prototype = {\n    errorMsg: null,\n    start: function(){\n        var _this = this;\n\n        this.image = new Image();\n\n        if ( this.crossOriginPolicy !== false ) {\n            this.image.crossOrigin = this.crossOriginPolicy;\n        }\n\n        this.image.onload = function(){\n            _this.finish( true );\n        };\n        this.image.onabort = this.image.onerror = function(){\n            _this.errorMsg = "Image load aborted";\n            _this.finish( false );\n        };\n\n        this.jobId = window.setTimeout( function(){\n            _this.errorMsg = "Image load exceeded timeout";\n            _this.finish( false );\n        }, this.timeout);\n\n        this.image.src = this.src;\n    },\n\n    finish: function( successful ) {\n        this.image.onload = this.image.onerror = this.image.onabort = null;\n        if (!successful) {\n            this.image = null;\n        }\n\n        if ( this.jobId ) {\n            window.clearTimeout( this.jobId );\n        }\n\n        this.callback( this );\n    }\n\n};\n\n/**\n * @class ImageLoader\n * @memberof OpenSeadragon\n * @classdesc Handles downloading of a set of images using asynchronous queue pattern.\n * You generally won\'t have to interact with the ImageLoader directly.\n * @param {Object} options - Options for this ImageLoader.\n * @param {Number} [options.jobLimit] - The number of concurrent image requests. See imageLoaderLimit in {@link OpenSeadragon.Options} for details.\n */\n$.ImageLoader = function( options ) {\n\n    $.extend( true, this, {\n        jobLimit:       $.DEFAULT_SETTINGS.imageLoaderLimit,\n        jobQueue:       [],\n        jobsInProgress: 0\n    }, options );\n\n};\n\n/** @lends OpenSeadragon.ImageLoader.prototype */\n$.ImageLoader.prototype = {\n\n    /**\n     * Add an unloaded image to the loader queue.\n     * @method\n     * @param {String} src - URL of image to download.\n     * @param {String} crossOriginPolicy - CORS policy to use for downloads\n     * @param {Function} callback - Called once image has been downloaded.\n     */\n    addJob: function( options ) {\n        var _this = this,\n            complete = function( job ) {\n                completeJob( _this, job, options.callback );\n            },\n            jobOptions = {\n                src: options.src,\n                crossOriginPolicy: options.crossOriginPolicy,\n                callback: complete,\n                abort: options.abort\n            },\n            newJob = new ImageJob( jobOptions );\n\n        if ( !this.jobLimit || this.jobsInProgress < this.jobLimit ) {\n            newJob.start();\n            this.jobsInProgress++;\n        }\n        else {\n            this.jobQueue.push( newJob );\n        }\n    },\n\n    /**\n     * Clear any unstarted image loading jobs from the queue.\n     * @method\n     */\n    clear: function() {\n        for( var i = 0; i < this.jobQueue.length; i++ ) {\n            var job = this.jobQueue[i];\n            if ( typeof job.abort === "function" ) {\n                job.abort();\n            }\n        }\n\n        this.jobQueue = [];\n    }\n};\n\n/**\n * Cleans up ImageJob once completed.\n * @method\n * @private\n * @param loader - ImageLoader used to start job.\n * @param job - The ImageJob that has completed.\n * @param callback - Called once cleanup is finished.\n */\nfunction completeJob( loader, job, callback ) {\n    var nextJob;\n\n    loader.jobsInProgress--;\n\n    if ( (!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {\n        nextJob = loader.jobQueue.shift();\n        nextJob.start();\n        loader.jobsInProgress++;\n    }\n\n    callback( job.image, job.errorMsg );\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Tile\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Tile\n * @memberof OpenSeadragon\n * @param {Number} level The zoom level this tile belongs to.\n * @param {Number} x The vector component \'x\'.\n * @param {Number} y The vector component \'y\'.\n * @param {OpenSeadragon.Point} bounds Where this tile fits, in normalized\n *      coordinates.\n * @param {Boolean} exists Is this tile a part of a sparse image? ( Also has\n *      this tile failed to load? )\n * @param {String} url The URL of this tile\'s image.\n * @param {CanvasRenderingContext2D} context2D The context2D of this tile if it\n * is provided directly by the tile source.\n */\n$.Tile = function(level, x, y, bounds, exists, url, context2D) {\n    /**\n     * The zoom level this tile belongs to.\n     * @member {Number} level\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.level   = level;\n    /**\n     * The vector component \'x\'.\n     * @member {Number} x\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.x       = x;\n    /**\n     * The vector component \'y\'.\n     * @member {Number} y\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.y       = y;\n    /**\n     * Where this tile fits, in normalized coordinates\n     * @member {OpenSeadragon.Rect} bounds\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.bounds  = bounds;\n    /**\n     * Is this tile a part of a sparse image? Also has this tile failed to load?\n     * @member {Boolean} exists\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.exists  = exists;\n    /**\n     * The URL of this tile\'s image.\n     * @member {String} url\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.url     = url;\n    /**\n     * The context2D of this tile if it is provided directly by the tile source.\n     * @member {CanvasRenderingContext2D} context2D\n     * @memberOf OpenSeadragon.Tile#\n     */\n    this.context2D = context2D;\n    /**\n     * Is this tile loaded?\n     * @member {Boolean} loaded\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.loaded  = false;\n    /**\n     * Is this tile loading?\n     * @member {Boolean} loading\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.loading = false;\n\n    /**\n     * The HTML div element for this tile\n     * @member {Element} element\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.element    = null;\n    /**\n     * The HTML img element for this tile.\n     * @member {Element} imgElement\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.imgElement = null;\n    /**\n     * The Image object for this tile.\n     * @member {Object} image\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.image      = null;\n\n    /**\n     * The alias of this.element.style.\n     * @member {String} style\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.style      = null;\n    /**\n     * This tile\'s position on screen, in pixels.\n     * @member {OpenSeadragon.Point} position\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.position   = null;\n    /**\n     * This tile\'s size on screen, in pixels.\n     * @member {OpenSeadragon.Point} size\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.size       = null;\n    /**\n     * The start time of this tile\'s blending.\n     * @member {Number} blendStart\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.blendStart = null;\n    /**\n     * The current opacity this tile should be.\n     * @member {Number} opacity\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.opacity    = null;\n    /**\n     * The distance of this tile to the viewport center.\n     * @member {Number} distance\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.distance   = null;\n    /**\n     * The visibility score of this tile.\n     * @member {Number} visibility\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.visibility = null;\n\n    /**\n     * Whether this tile is currently being drawn.\n     * @member {Boolean} beingDrawn\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.beingDrawn     = false;\n    /**\n     * Timestamp the tile was last touched.\n     * @member {Number} lastTouchTime\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.lastTouchTime  = 0;\n};\n\n/** @lends OpenSeadragon.Tile.prototype */\n$.Tile.prototype = {\n\n    /**\n     * Provides a string representation of this tiles level and (x,y)\n     * components.\n     * @function\n     * @returns {String}\n     */\n    toString: function() {\n        return this.level + "/" + this.x + "_" + this.y;\n    },\n\n    // private\n    _hasTransparencyChannel: function() {\n        return !!this.context2D || this.url.match(\'.png\');\n    },\n\n    /**\n     * Renders the tile in an html container.\n     * @function\n     * @param {Element} container\n     */\n    drawHTML: function( container ) {\n        if (!this.cacheImageRecord) {\n            $.console.warn(\n                \'[Tile.drawHTML] attempting to draw tile %s when it\\\'s not cached\',\n                this.toString());\n            return;\n        }\n\n        if ( !this.loaded ) {\n            $.console.warn(\n                "Attempting to draw tile %s when it\'s not yet loaded.",\n                this.toString()\n            );\n            return;\n        }\n\n        //EXPERIMENTAL - trying to figure out how to scale the container\n        //               content during animation of the container size.\n\n        if ( !this.element ) {\n            this.element                              = $.makeNeutralElement( "div" );\n            this.imgElement                           = this.cacheImageRecord.getImage().cloneNode();\n            this.imgElement.style.msInterpolationMode = "nearest-neighbor";\n            this.imgElement.style.width               = "100%";\n            this.imgElement.style.height              = "100%";\n\n            this.style                     = this.element.style;\n            this.style.position            = "absolute";\n        }\n        if ( this.element.parentNode != container ) {\n            container.appendChild( this.element );\n        }\n        if ( this.imgElement.parentNode != this.element ) {\n            this.element.appendChild( this.imgElement );\n        }\n\n        this.style.top     = this.position.y + "px";\n        this.style.left    = this.position.x + "px";\n        this.style.height  = this.size.y + "px";\n        this.style.width   = this.size.x + "px";\n\n        $.setElementOpacity( this.element, this.opacity );\n    },\n\n    /**\n     * Renders the tile in a canvas-based context.\n     * @function\n     * @param {Canvas} context\n     * @param {Function} drawingHandler - Method for firing the drawing event.\n     * drawingHandler({context, tile, rendered})\n     * where <code>rendered</code> is the context with the pre-drawn image.\n     * @param {Number} [scale=1] - Apply a scale to position and size\n     * @param {OpenSeadragon.Point} [translate] - A translation vector\n     */\n    drawCanvas: function( context, drawingHandler, scale, translate ) {\n\n        var position = this.position.times($.pixelDensityRatio),\n            size     = this.size.times($.pixelDensityRatio),\n            rendered;\n\n        if (!this.context2D && !this.cacheImageRecord) {\n            $.console.warn(\n                \'[Tile.drawCanvas] attempting to draw tile %s when it\\\'s not cached\',\n                this.toString());\n            return;\n        }\n\n        rendered = this.context2D || this.cacheImageRecord.getRenderedContext();\n\n        if ( !this.loaded || !rendered ){\n            $.console.warn(\n                "Attempting to draw tile %s when it\'s not yet loaded.",\n                this.toString()\n            );\n\n            return;\n        }\n\n        context.save();\n\n        context.globalAlpha = this.opacity;\n\n        if (typeof scale === \'number\' && scale !== 1) {\n            // draw tile at a different scale\n            position = position.times(scale);\n            size = size.times(scale);\n        }\n\n        if (translate instanceof $.Point) {\n            // shift tile position slightly\n            position = position.plus(translate);\n        }\n\n        //if we are supposed to be rendering fully opaque rectangle,\n        //ie its done fading or fading is turned off, and if we are drawing\n        //an image with an alpha channel, then the only way\n        //to avoid seeing the tile underneath is to clear the rectangle\n        if (context.globalAlpha === 1 && this._hasTransparencyChannel()) {\n            //clearing only the inside of the rectangle occupied\n            //by the png prevents edge flikering\n            context.clearRect(\n                position.x + 1,\n                position.y + 1,\n                size.x - 2,\n                size.y - 2\n            );\n        }\n\n        // This gives the application a chance to make image manipulation\n        // changes as we are rendering the image\n        drawingHandler({context: context, tile: this, rendered: rendered});\n\n        context.drawImage(\n            rendered.canvas,\n            0,\n            0,\n            rendered.canvas.width,\n            rendered.canvas.height,\n            position.x,\n            position.y,\n            size.x,\n            size.y\n        );\n\n        context.restore();\n    },\n\n    /**\n     * Get the ratio between current and original size.\n     * @function\n     * @return {Float}\n     */\n    getScaleForEdgeSmoothing: function() {\n        var context;\n        if (this.cacheImageRecord) {\n            context = this.cacheImageRecord.getRenderedContext();\n        } else if (this.context2D) {\n            context = this.context2D;\n        } else {\n            $.console.warn(\n                \'[Tile.drawCanvas] attempting to get tile scale %s when tile\\\'s not cached\',\n                this.toString());\n            return 1;\n        }\n        return context.canvas.width / (this.size.x * $.pixelDensityRatio);\n    },\n\n    /**\n     * Get a translation vector that when applied to the tile position produces integer coordinates.\n     * Needed to avoid swimming and twitching.\n     * @function\n     * @param {Number} [scale=1] - Scale to be applied to position.\n     * @return {OpenSeadragon.Point}\n     */\n    getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {\n        // The translation vector must have positive values, otherwise the image goes a bit off\n        // the sketch canvas to the top and left and we must use negative coordinates to repaint it\n        // to the main canvas. In that case, some browsers throw:\n        // INDEX_SIZE_ERR: DOM Exception 1: Index or size was negative, or greater than the allowed value.\n        var x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));\n        var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));\n        return new $.Point(x, y).minus(\n            this.position\n                .times($.pixelDensityRatio)\n                .times(scale || 1)\n                .apply(function(x) {\n                    return x % 1;\n                })\n        );\n    },\n\n    /**\n     * Removes tile from its container.\n     * @function\n     */\n    unload: function() {\n        if ( this.imgElement && this.imgElement.parentNode ) {\n            this.imgElement.parentNode.removeChild( this.imgElement );\n        }\n        if ( this.element && this.element.parentNode ) {\n            this.element.parentNode.removeChild( this.element );\n        }\n\n        this.element    = null;\n        this.imgElement = null;\n        this.loaded     = false;\n        this.loading    = false;\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Overlay\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($) {\n\n    /**\n     * An enumeration of positions that an overlay may be assigned relative to\n     * the viewport.\n     * It is identical to OpenSeadragon.Placement but is kept for backward\n     * compatibility.\n     * @member OverlayPlacement\n     * @memberof OpenSeadragon\n     * @static\n     * @readonly\n     * @type {Object}\n     * @property {Number} CENTER\n     * @property {Number} TOP_LEFT\n     * @property {Number} TOP\n     * @property {Number} TOP_RIGHT\n     * @property {Number} RIGHT\n     * @property {Number} BOTTOM_RIGHT\n     * @property {Number} BOTTOM\n     * @property {Number} BOTTOM_LEFT\n     * @property {Number} LEFT\n     */\n    $.OverlayPlacement = $.Placement;\n\n    /**\n     * An enumeration of possible ways to handle overlays rotation\n     * @member OverlayRotationMode\n     * @memberOf OpenSeadragon\n     * @static\n     * @readonly\n     * @property {Number} NO_ROTATION The overlay ignore the viewport rotation.\n     * @property {Number} EXACT The overlay use CSS 3 transforms to rotate with\n     * the viewport. If the overlay contains text, it will get rotated as well.\n     * @property {Number} BOUNDING_BOX The overlay adjusts for rotation by\n     * taking the size of the bounding box of the rotated bounds.\n     * Only valid for overlays with Rect location and scalable in both directions.\n     */\n    $.OverlayRotationMode = $.freezeObject({\n        NO_ROTATION: 1,\n        EXACT: 2,\n        BOUNDING_BOX: 3\n    });\n\n    /**\n     * @class Overlay\n     * @classdesc Provides a way to float an HTML element on top of the viewer element.\n     *\n     * @memberof OpenSeadragon\n     * @param {Object} options\n     * @param {Element} options.element\n     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} options.location - The\n     * location of the overlay on the image. If a {@link OpenSeadragon.Point}\n     * is specified, the overlay will be located at this location with respect\n     * to the placement option. If a {@link OpenSeadragon.Rect} is specified,\n     * the overlay will be placed at this location with the corresponding width\n     * and height and placement TOP_LEFT.\n     * @param {OpenSeadragon.Placement} [options.placement=OpenSeadragon.Placement.TOP_LEFT]\n     * Defines what part of the overlay should be at the specified options.location\n     * @param {OpenSeadragon.Overlay.OnDrawCallback} [options.onDraw]\n     * @param {Boolean} [options.checkResize=true] Set to false to avoid to\n     * check the size of the overlay everytime it is drawn in the directions\n     * which are not scaled. It will improve performances but will cause a\n     * misalignment if the overlay size changes.\n     * @param {Number} [options.width] The width of the overlay in viewport\n     * coordinates. If specified, the width of the overlay will be adjusted when\n     * the zoom changes.\n     * @param {Number} [options.height] The height of the overlay in viewport\n     * coordinates. If specified, the height of the overlay will be adjusted when\n     * the zoom changes.\n     * @param {Boolean} [options.rotationMode=OpenSeadragon.OverlayRotationMode.EXACT]\n     * How to handle the rotation of the viewport.\n     */\n    $.Overlay = function(element, location, placement) {\n\n        /**\n         * onDraw callback signature used by {@link OpenSeadragon.Overlay}.\n         *\n         * @callback OnDrawCallback\n         * @memberof OpenSeadragon.Overlay\n         * @param {OpenSeadragon.Point} position\n         * @param {OpenSeadragon.Point} size\n         * @param {Element} element\n         */\n\n        var options;\n        if ($.isPlainObject(element)) {\n            options = element;\n        } else {\n            options = {\n                element: element,\n                location: location,\n                placement: placement\n            };\n        }\n\n        this.element = options.element;\n        this.style = options.element.style;\n        this._init(options);\n    };\n\n    /** @lends OpenSeadragon.Overlay.prototype */\n    $.Overlay.prototype = {\n\n        // private\n        _init: function(options) {\n            this.location = options.location;\n            this.placement = options.placement === undefined ?\n                $.Placement.TOP_LEFT : options.placement;\n            this.onDraw = options.onDraw;\n            this.checkResize = options.checkResize === undefined ?\n                true : options.checkResize;\n\n            // When this.width is not null, the overlay get scaled horizontally\n            this.width = options.width === undefined ? null : options.width;\n\n            // When this.height is not null, the overlay get scaled vertically\n            this.height = options.height === undefined ? null : options.height;\n\n            this.rotationMode = options.rotationMode || $.OverlayRotationMode.EXACT;\n\n            // Having a rect as location is a syntactic sugar\n            if (this.location instanceof $.Rect) {\n                this.width = this.location.width;\n                this.height = this.location.height;\n                this.location = this.location.getTopLeft();\n                this.placement = $.Placement.TOP_LEFT;\n            }\n\n            // Deprecated properties kept for backward compatibility.\n            this.scales = this.width !== null && this.height !== null;\n            this.bounds = new $.Rect(\n                this.location.x, this.location.y, this.width, this.height);\n            this.position = this.location;\n        },\n\n        /**\n         * Internal function to adjust the position of an overlay\n         * depending on it size and placement.\n         * @function\n         * @param {OpenSeadragon.Point} position\n         * @param {OpenSeadragon.Point} size\n         */\n        adjust: function(position, size) {\n            var properties = $.Placement.properties[this.placement];\n            if (!properties) {\n                return;\n            }\n            if (properties.isHorizontallyCentered) {\n                position.x -= size.x / 2;\n            } else if (properties.isRight) {\n                position.x -= size.x;\n            }\n            if (properties.isVerticallyCentered) {\n                position.y -= size.y / 2;\n            } else if (properties.isBottom) {\n                position.y -= size.y;\n            }\n        },\n\n        /**\n         * @function\n         */\n        destroy: function() {\n            var element = this.element;\n            var style = this.style;\n\n            if (element.parentNode) {\n                element.parentNode.removeChild(element);\n                //this should allow us to preserve overlays when required between\n                //pages\n                if (element.prevElementParent) {\n                    style.display = \'none\';\n                    //element.prevElementParent.insertBefore(\n                    //    element,\n                    //    element.prevNextSibling\n                    //);\n                    document.body.appendChild(element);\n                }\n            }\n\n            // clear the onDraw callback\n            this.onDraw = null;\n\n            style.top = "";\n            style.left = "";\n            style.position = "";\n\n            if (this.width !== null) {\n                style.width = "";\n            }\n            if (this.height !== null) {\n                style.height = "";\n            }\n            var transformOriginProp = $.getCssPropertyWithVendorPrefix(\n                \'transformOrigin\');\n            var transformProp = $.getCssPropertyWithVendorPrefix(\n                \'transform\');\n            if (transformOriginProp && transformProp) {\n                style[transformOriginProp] = "";\n                style[transformProp] = "";\n            }\n        },\n\n        /**\n         * @function\n         * @param {Element} container\n         */\n        drawHTML: function(container, viewport) {\n            var element = this.element;\n            if (element.parentNode !== container) {\n                //save the source parent for later if we need it\n                element.prevElementParent = element.parentNode;\n                element.prevNextSibling = element.nextSibling;\n                container.appendChild(element);\n\n                // this.size is used by overlays which don\'t get scaled in at\n                // least one direction when this.checkResize is set to false.\n                this.size = $.getElementSize(element);\n            }\n\n            var positionAndSize = this._getOverlayPositionAndSize(viewport);\n\n            var position = positionAndSize.position;\n            var size = this.size = positionAndSize.size;\n            var rotate = positionAndSize.rotate;\n\n            // call the onDraw callback if it exists to allow one to overwrite\n            // the drawing/positioning/sizing of the overlay\n            if (this.onDraw) {\n                this.onDraw(position, size, this.element);\n            } else {\n                var style = this.style;\n                style.left = position.x + "px";\n                style.top = position.y + "px";\n                if (this.width !== null) {\n                    style.width = size.x + "px";\n                }\n                if (this.height !== null) {\n                    style.height = size.y + "px";\n                }\n                var transformOriginProp = $.getCssPropertyWithVendorPrefix(\n                    \'transformOrigin\');\n                var transformProp = $.getCssPropertyWithVendorPrefix(\n                    \'transform\');\n                if (transformOriginProp && transformProp) {\n                    if (rotate) {\n                        style[transformOriginProp] = this._getTransformOrigin();\n                        style[transformProp] = "rotate(" + rotate + "deg)";\n                    } else {\n                        style[transformOriginProp] = "";\n                        style[transformProp] = "";\n                    }\n                }\n                style.position = "absolute";\n\n                if (style.display !== \'none\') {\n                    style.display = \'block\';\n                }\n            }\n        },\n\n        // private\n        _getOverlayPositionAndSize: function(viewport) {\n            var position = viewport.pixelFromPoint(this.location, true);\n            var size = this._getSizeInPixels(viewport);\n            this.adjust(position, size);\n\n            var rotate = 0;\n            if (viewport.degrees &&\n                this.rotationMode !== $.OverlayRotationMode.NO_ROTATION) {\n                // BOUNDING_BOX is only valid if both directions get scaled.\n                // Get replaced by EXACT otherwise.\n                if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX &&\n                    this.width !== null && this.height !== null) {\n                    var rect = new $.Rect(position.x, position.y, size.x, size.y);\n                    var boundingBox = this._getBoundingBox(rect, viewport.degrees);\n                    position = boundingBox.getTopLeft();\n                    size = boundingBox.getSize();\n                } else {\n                    rotate = viewport.degrees;\n                }\n            }\n\n            return {\n                position: position,\n                size: size,\n                rotate: rotate\n            };\n        },\n\n        // private\n        _getSizeInPixels: function(viewport) {\n            var width = this.size.x;\n            var height = this.size.y;\n            if (this.width !== null || this.height !== null) {\n                var scaledSize = viewport.deltaPixelsFromPointsNoRotate(\n                    new $.Point(this.width || 0, this.height || 0), true);\n                if (this.width !== null) {\n                    width = scaledSize.x;\n                }\n                if (this.height !== null) {\n                    height = scaledSize.y;\n                }\n            }\n            if (this.checkResize &&\n                (this.width === null || this.height === null)) {\n                var eltSize = this.size = $.getElementSize(this.element);\n                if (this.width === null) {\n                    width = eltSize.x;\n                }\n                if (this.height === null) {\n                    height = eltSize.y;\n                }\n            }\n            return new $.Point(width, height);\n        },\n\n        // private\n        _getBoundingBox: function(rect, degrees) {\n            var refPoint = this._getPlacementPoint(rect);\n            return rect.rotate(degrees, refPoint).getBoundingBox();\n        },\n\n        // private\n        _getPlacementPoint: function(rect) {\n            var result = new $.Point(rect.x, rect.y);\n            var properties = $.Placement.properties[this.placement];\n            if (properties) {\n                if (properties.isHorizontallyCentered) {\n                    result.x += rect.width / 2;\n                } else if (properties.isRight) {\n                    result.x += rect.width;\n                }\n                if (properties.isVerticallyCentered) {\n                    result.y += rect.height / 2;\n                } else if (properties.isBottom) {\n                    result.y += rect.height;\n                }\n            }\n            return result;\n        },\n\n        // private\n        _getTransformOrigin: function() {\n            var result = "";\n            var properties = $.Placement.properties[this.placement];\n            if (!properties) {\n                return result;\n            }\n            if (properties.isLeft) {\n                result = "left";\n            } else if (properties.isRight) {\n                result = "right";\n            }\n            if (properties.isTop) {\n                result += " top";\n            } else if (properties.isBottom) {\n                result += " bottom";\n            }\n            return result;\n        },\n\n        /**\n         * Changes the overlay settings.\n         * @function\n         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location\n         * If an object is specified, the options are the same than the constructor\n         * except for the element which can not be changed.\n         * @param {OpenSeadragon.Placement} position\n         */\n        update: function(location, placement) {\n            var options = $.isPlainObject(location) ? location : {\n                location: location,\n                placement: placement\n            };\n            this._init({\n                location: options.location || this.location,\n                placement: options.placement !== undefined ?\n                    options.placement : this.placement,\n                onDraw: options.onDraw || this.onDraw,\n                checkResize: options.checkResize || this.checkResize,\n                width: options.width !== undefined ? options.width : this.width,\n                height: options.height !== undefined ? options.height : this.height,\n                rotationMode: options.rotationMode || this.rotationMode\n            });\n        },\n\n        /**\n         * Returns the current bounds of the overlay in viewport coordinates\n         * @function\n         * @param {OpenSeadragon.Viewport} viewport the viewport\n         * @returns {OpenSeadragon.Rect} overlay bounds\n         */\n        getBounds: function(viewport) {\n            $.console.assert(viewport,\n                \'A viewport must now be passed to Overlay.getBounds.\');\n            var width = this.width;\n            var height = this.height;\n            if (width === null || height === null) {\n                var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);\n                if (width === null) {\n                    width = size.x;\n                }\n                if (height === null) {\n                    height = size.y;\n                }\n            }\n            var location = this.location.clone();\n            this.adjust(location, new $.Point(width, height));\n            return this._adjustBoundsForRotation(\n                viewport, new $.Rect(location.x, location.y, width, height));\n        },\n\n        // private\n        _adjustBoundsForRotation: function(viewport, bounds) {\n            if (!viewport ||\n                viewport.degrees === 0 ||\n                this.rotationMode === $.OverlayRotationMode.EXACT) {\n                return bounds;\n            }\n            if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX) {\n                // If overlay not fully scalable, BOUNDING_BOX falls back to EXACT\n                if (this.width === null || this.height === null) {\n                    return bounds;\n                }\n                // It is easier to just compute the position and size and\n                // convert to viewport coordinates.\n                var positionAndSize = this._getOverlayPositionAndSize(viewport);\n                return viewport.viewerElementToViewportRectangle(new $.Rect(\n                    positionAndSize.position.x,\n                    positionAndSize.position.y,\n                    positionAndSize.size.x,\n                    positionAndSize.size.y));\n            }\n\n            // NO_ROTATION case\n            return bounds.rotate(-viewport.degrees,\n                this._getPlacementPoint(bounds));\n        }\n    };\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - Drawer\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Drawer\n * @memberof OpenSeadragon\n * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.\n * @param {Object} options - Options for this Drawer.\n * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.\n * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.\n * @param {Element} options.element - Parent element.\n * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.\n */\n$.Drawer = function( options ) {\n\n    $.console.assert( options.viewer, "[Drawer] options.viewer is required" );\n\n    //backward compatibility for positional args while prefering more\n    //idiomatic javascript options object as the only argument\n    var args  = arguments;\n\n    if( !$.isPlainObject( options ) ){\n        options = {\n            source:     args[ 0 ], // Reference to Viewer tile source.\n            viewport:   args[ 1 ], // Reference to Viewer viewport.\n            element:    args[ 2 ]  // Parent element.\n        };\n    }\n\n    $.console.assert( options.viewport, "[Drawer] options.viewport is required" );\n    $.console.assert( options.element, "[Drawer] options.element is required" );\n\n    if ( options.source ) {\n        $.console.error( "[Drawer] options.source is no longer accepted; use TiledImage instead" );\n    }\n\n    this.viewer = options.viewer;\n    this.viewport = options.viewport;\n    this.debugGridColor = options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;\n    if (options.opacity) {\n        $.console.error( "[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead" );\n    }\n\n    this.useCanvas  = $.supportsCanvas && ( this.viewer ? this.viewer.useCanvas : true );\n    /**\n     * The parent element of this Drawer instance, passed in when the Drawer was created.\n     * The parent of {@link OpenSeadragon.Drawer#canvas}.\n     * @member {Element} container\n     * @memberof OpenSeadragon.Drawer#\n     */\n    this.container  = $.getElement( options.element );\n    /**\n     * A &lt;canvas&gt; element if the browser supports them, otherwise a &lt;div&gt; element.\n     * Child element of {@link OpenSeadragon.Drawer#container}.\n     * @member {Element} canvas\n     * @memberof OpenSeadragon.Drawer#\n     */\n    this.canvas     = $.makeNeutralElement( this.useCanvas ? "canvas" : "div" );\n    /**\n     * 2d drawing context for {@link OpenSeadragon.Drawer#canvas} if it\'s a &lt;canvas&gt; element, otherwise null.\n     * @member {Object} context\n     * @memberof OpenSeadragon.Drawer#\n     */\n    this.context    = this.useCanvas ? this.canvas.getContext( "2d" ) : null;\n\n    /**\n     * Sketch canvas used to temporarily draw tiles which cannot be drawn directly\n     * to the main canvas due to opacity. Lazily initialized.\n     */\n    this.sketchCanvas = null;\n    this.sketchContext = null;\n\n    /**\n     * @member {Element} element\n     * @memberof OpenSeadragon.Drawer#\n     * @deprecated Alias for {@link OpenSeadragon.Drawer#container}.\n     */\n    this.element    = this.container;\n\n    // We force our container to ltr because our drawing math doesn\'t work in rtl.\n    // This issue only affects our canvas renderer, but we do it always for consistency.\n    // Note that this means overlays you want to be rtl need to be explicitly set to rtl.\n    this.container.dir = \'ltr\';\n\n    // check canvas available width and height, set canvas width and height such that the canvas backing store is set to the proper pixel density\n    if (this.useCanvas) {\n        var viewportSize = this._calculateCanvasSize();\n        this.canvas.width = viewportSize.x;\n        this.canvas.height = viewportSize.y;\n    }\n\n    this.canvas.style.width     = "100%";\n    this.canvas.style.height    = "100%";\n    this.canvas.style.position  = "absolute";\n    $.setElementOpacity( this.canvas, this.opacity, true );\n\n    // explicit left-align\n    this.container.style.textAlign = "left";\n    this.container.appendChild( this.canvas );\n};\n\n/** @lends OpenSeadragon.Drawer.prototype */\n$.Drawer.prototype = {\n    // deprecated\n    addOverlay: function( element, location, placement, onDraw ) {\n        $.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");\n        this.viewer.addOverlay( element, location, placement, onDraw );\n        return this;\n    },\n\n    // deprecated\n    updateOverlay: function( element, location, placement ) {\n        $.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");\n        this.viewer.updateOverlay( element, location, placement );\n        return this;\n    },\n\n    // deprecated\n    removeOverlay: function( element ) {\n        $.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");\n        this.viewer.removeOverlay( element );\n        return this;\n    },\n\n    // deprecated\n    clearOverlays: function() {\n        $.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");\n        this.viewer.clearOverlays();\n        return this;\n    },\n\n    /**\n     * Set the opacity of the drawer.\n     * @param {Number} opacity\n     * @return {OpenSeadragon.Drawer} Chainable.\n     */\n    setOpacity: function( opacity ) {\n        $.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");\n        var world = this.viewer.world;\n        for (var i = 0; i < world.getItemCount(); i++) {\n            world.getItemAt( i ).setOpacity( opacity );\n        }\n        return this;\n    },\n\n    /**\n     * Get the opacity of the drawer.\n     * @returns {Number}\n     */\n    getOpacity: function() {\n        $.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");\n        var world = this.viewer.world;\n        var maxOpacity = 0;\n        for (var i = 0; i < world.getItemCount(); i++) {\n            var opacity = world.getItemAt( i ).getOpacity();\n            if ( opacity > maxOpacity ) {\n                maxOpacity = opacity;\n            }\n        }\n        return maxOpacity;\n    },\n\n    // deprecated\n    needsUpdate: function() {\n        $.console.error( "[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead." );\n        return this.viewer.world.needsDraw();\n    },\n\n    // deprecated\n    numTilesLoaded: function() {\n        $.console.error( "[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead." );\n        return this.viewer.tileCache.numTilesLoaded();\n    },\n\n    // deprecated\n    reset: function() {\n        $.console.error( "[Drawer.reset] this function is deprecated. Use World.resetItems instead." );\n        this.viewer.world.resetItems();\n        return this;\n    },\n\n    // deprecated\n    update: function() {\n        $.console.error( "[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead." );\n        this.clear();\n        this.viewer.world.draw();\n        return this;\n    },\n\n    /**\n     * @return {Boolean} True if rotation is supported.\n     */\n    canRotate: function() {\n        return this.useCanvas;\n    },\n\n    /**\n     * Destroy the drawer (unload current loaded tiles)\n     */\n    destroy: function() {\n        //force unloading of current canvas (1x1 will be gc later, trick not necessarily needed)\n        this.canvas.width  = 1;\n        this.canvas.height = 1;\n        this.sketchCanvas = null;\n        this.sketchContext = null;\n    },\n\n    /**\n     * Clears the Drawer so it\'s ready to draw another frame.\n     */\n    clear: function() {\n        this.canvas.innerHTML = "";\n        if ( this.useCanvas ) {\n            var viewportSize = this._calculateCanvasSize();\n            if( this.canvas.width != viewportSize.x ||\n                this.canvas.height != viewportSize.y ) {\n                this.canvas.width = viewportSize.x;\n                this.canvas.height = viewportSize.y;\n                if ( this.sketchCanvas !== null ) {\n                    var sketchCanvasSize = this._calculateSketchCanvasSize();\n                    this.sketchCanvas.width = sketchCanvasSize.x;\n                    this.sketchCanvas.height = sketchCanvasSize.y;\n                }\n            }\n            this._clear();\n        }\n    },\n\n    _clear: function (useSketch, bounds) {\n        if (!this.useCanvas) {\n            return;\n        }\n        var context = this._getContext(useSketch);\n        if (bounds) {\n            context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        } else {\n            var canvas = context.canvas;\n            context.clearRect(0, 0, canvas.width, canvas.height);\n        }\n    },\n\n    /**\n     * Scale from OpenSeadragon viewer rectangle to drawer rectangle\n     * (ignoring rotation)\n     * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.\n     * @return {OpenSeadragon.Rect} Rectangle in drawer coordinate system.\n     */\n    viewportToDrawerRectangle: function(rectangle) {\n        var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);\n        var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);\n\n        return new $.Rect(\n            topLeft.x * $.pixelDensityRatio,\n            topLeft.y * $.pixelDensityRatio,\n            size.x    * $.pixelDensityRatio,\n            size.y    * $.pixelDensityRatio\n        );\n    },\n\n    /**\n     * Draws the given tile.\n     * @param {OpenSeadragon.Tile} tile - The tile to draw.\n     * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.\n     * drawingHandler({context, tile, rendered})\n     * @param {Boolean} useSketch - Whether to use the sketch canvas or not.\n     * where <code>rendered</code> is the context with the pre-drawn image.\n     * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.\n     * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position\n     */\n    drawTile: function(tile, drawingHandler, useSketch, scale, translate) {\n        $.console.assert(tile, \'[Drawer.drawTile] tile is required\');\n        $.console.assert(drawingHandler, \'[Drawer.drawTile] drawingHandler is required\');\n\n        if (this.useCanvas) {\n            var context = this._getContext(useSketch);\n            scale = scale || 1;\n            tile.drawCanvas(context, drawingHandler, scale, translate);\n        } else {\n            tile.drawHTML( this.canvas );\n        }\n    },\n\n    _getContext: function( useSketch ) {\n        var context = this.context;\n        if ( useSketch ) {\n            if (this.sketchCanvas === null) {\n                this.sketchCanvas = document.createElement( "canvas" );\n                var sketchCanvasSize = this._calculateSketchCanvasSize();\n                this.sketchCanvas.width = sketchCanvasSize.x;\n                this.sketchCanvas.height = sketchCanvasSize.y;\n                this.sketchContext = this.sketchCanvas.getContext( "2d" );\n\n                // If the viewport is not currently rotated, the sketchCanvas\n                // will have the same size as the main canvas. However, if\n                // the viewport get rotated later on, we will need to resize it.\n                if (this.viewport.getRotation() === 0) {\n                    var self = this;\n                    this.viewer.addHandler(\'rotate\', function resizeSketchCanvas() {\n                        self.viewer.removeHandler(\'rotate\', resizeSketchCanvas);\n                        var sketchCanvasSize = self._calculateSketchCanvasSize();\n                        self.sketchCanvas.width = sketchCanvasSize.x;\n                        self.sketchCanvas.height = sketchCanvasSize.y;\n                    });\n                }\n            }\n            context = this.sketchContext;\n        }\n        return context;\n    },\n\n    // private\n    saveContext: function( useSketch ) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        this._getContext( useSketch ).save();\n    },\n\n    // private\n    restoreContext: function( useSketch ) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        this._getContext( useSketch ).restore();\n    },\n\n    // private\n    setClip: function(rect, useSketch) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        var context = this._getContext( useSketch );\n        context.beginPath();\n        context.rect(rect.x, rect.y, rect.width, rect.height);\n        context.clip();\n    },\n\n    // private\n    drawRectangle: function(rect, fillStyle, useSketch) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        var context = this._getContext( useSketch );\n        context.save();\n        context.fillStyle = fillStyle;\n        context.fillRect(rect.x, rect.y, rect.width, rect.height);\n        context.restore();\n    },\n\n    /**\n     * Blends the sketch canvas in the main canvas.\n     * @param {Object} options The options\n     * @param {Float} options.opacity The opacity of the blending.\n     * @param {Float} [options.scale=1] The scale at which tiles were drawn on\n     * the sketch. Default is 1.\n     * Use scale to draw at a lower scale and then enlarge onto the main canvas.\n     * @param {OpenSeadragon.Point} [options.translate] A translation vector\n     * that was used to draw the tiles\n     * @param {String} [options.compositeOperation] - How the image is\n     * composited onto other images; see compositeOperation in\n     * {@link OpenSeadragon.Options} for possible values.\n     * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch\n     * canvas to blend in the main canvas. If specified, options.scale and\n     * options.translate get ignored.\n     */\n    blendSketch: function(opacity, scale, translate, compositeOperation) {\n        var options = opacity;\n        if (!$.isPlainObject(options)) {\n            options = {\n                opacity: opacity,\n                scale: scale,\n                translate: translate,\n                compositeOperation: compositeOperation\n            };\n        }\n        if (!this.useCanvas || !this.sketchCanvas) {\n            return;\n        }\n        opacity = options.opacity;\n        compositeOperation = options.compositeOperation;\n        var bounds = options.bounds;\n\n        this.context.save();\n        this.context.globalAlpha = opacity;\n        if (compositeOperation) {\n            this.context.globalCompositeOperation = compositeOperation;\n        }\n        if (bounds) {\n            this.context.drawImage(\n                this.sketchCanvas,\n                bounds.x,\n                bounds.y,\n                bounds.width,\n                bounds.height,\n                bounds.x,\n                bounds.y,\n                bounds.width,\n                bounds.height\n            );\n        } else {\n            scale = options.scale || 1;\n            translate = options.translate;\n            var position = translate instanceof $.Point ?\n                translate : new $.Point(0, 0);\n\n            var widthExt = 0;\n            var heightExt = 0;\n            if (translate) {\n                var widthDiff = this.sketchCanvas.width - this.canvas.width;\n                var heightDiff = this.sketchCanvas.height - this.canvas.height;\n                widthExt = Math.round(widthDiff / 2);\n                heightExt = Math.round(heightDiff / 2);\n            }\n            this.context.drawImage(\n                this.sketchCanvas,\n                position.x - widthExt * scale,\n                position.y - heightExt * scale,\n                (this.canvas.width + 2 * widthExt) * scale,\n                (this.canvas.height  + 2 * heightExt) * scale,\n                -widthExt,\n                -heightExt,\n                this.canvas.width + 2 * widthExt,\n                this.canvas.height + 2 * heightExt\n            );\n        }\n        this.context.restore();\n    },\n\n    // private\n    drawDebugInfo: function( tile, count, i ){\n        if ( !this.useCanvas ) {\n            return;\n        }\n\n        var context = this.context;\n        context.save();\n        context.lineWidth = 2 * $.pixelDensityRatio;\n        context.font = \'small-caps bold \' + (13 * $.pixelDensityRatio) + \'px arial\';\n        context.strokeStyle = this.debugGridColor;\n        context.fillStyle = this.debugGridColor;\n\n        if ( this.viewport.degrees !== 0 ) {\n            this._offsetForRotation(this.viewport.degrees);\n        }\n\n        context.strokeRect(\n            tile.position.x * $.pixelDensityRatio,\n            tile.position.y * $.pixelDensityRatio,\n            tile.size.x * $.pixelDensityRatio,\n            tile.size.y * $.pixelDensityRatio\n        );\n\n        var tileCenterX = (tile.position.x + (tile.size.x / 2)) * $.pixelDensityRatio;\n        var tileCenterY = (tile.position.y + (tile.size.y / 2)) * $.pixelDensityRatio;\n\n        // Rotate the text the right way around.\n        context.translate( tileCenterX, tileCenterY );\n        context.rotate( Math.PI / 180 * -this.viewport.degrees );\n        context.translate( -tileCenterX, -tileCenterY );\n\n        if( tile.x === 0 && tile.y === 0 ){\n            context.fillText(\n                "Zoom: " + this.viewport.getZoom(),\n                tile.position.x * $.pixelDensityRatio,\n                (tile.position.y - 30) * $.pixelDensityRatio\n            );\n            context.fillText(\n                "Pan: " + this.viewport.getBounds().toString(),\n                tile.position.x * $.pixelDensityRatio,\n                (tile.position.y - 20) * $.pixelDensityRatio\n            );\n        }\n        context.fillText(\n            "Level: " + tile.level,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 20) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Column: " + tile.x,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 30) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Row: " + tile.y,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 40) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Order: " + i + " of " + count,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 50) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Size: " + tile.size.toString(),\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 60) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Position: " + tile.position.toString(),\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 70) * $.pixelDensityRatio\n        );\n\n        if ( this.viewport.degrees !== 0 ) {\n            this._restoreRotationChanges();\n        }\n        context.restore();\n    },\n\n    // private\n    debugRect: function(rect) {\n        if ( this.useCanvas ) {\n            var context = this.context;\n            context.save();\n            context.lineWidth = 2 * $.pixelDensityRatio;\n            context.strokeStyle = this.debugGridColor;\n            context.fillStyle = this.debugGridColor;\n\n            context.strokeRect(\n                rect.x * $.pixelDensityRatio,\n                rect.y * $.pixelDensityRatio,\n                rect.width * $.pixelDensityRatio,\n                rect.height * $.pixelDensityRatio\n            );\n\n            context.restore();\n        }\n    },\n\n    /**\n     * Get the canvas size\n     * @param {Boolean} sketch If set to true return the size of the sketch canvas\n     * @returns {OpenSeadragon.Point} The size of the canvas\n     */\n    getCanvasSize: function(sketch) {\n        var canvas = this._getContext(sketch).canvas;\n        return new $.Point(canvas.width, canvas.height);\n    },\n\n    // private\n    _offsetForRotation: function(degrees, useSketch) {\n        var cx = this.canvas.width / 2;\n        var cy = this.canvas.height / 2;\n\n        var context = this._getContext(useSketch);\n        context.save();\n\n        context.translate(cx, cy);\n        context.rotate(Math.PI / 180 * degrees);\n        context.translate(-cx, -cy);\n    },\n\n    // private\n    _restoreRotationChanges: function(useSketch) {\n        var context = this._getContext(useSketch);\n        context.restore();\n    },\n\n    // private\n    _calculateCanvasSize: function() {\n        var pixelDensityRatio = $.pixelDensityRatio;\n        var viewportSize = this.viewport.getContainerSize();\n        return {\n            x: viewportSize.x * pixelDensityRatio,\n            y: viewportSize.y * pixelDensityRatio\n        };\n    },\n\n    // private\n    _calculateSketchCanvasSize: function() {\n        var canvasSize = this._calculateCanvasSize();\n        if (this.viewport.getRotation() === 0) {\n            return canvasSize;\n        }\n        // If the viewport is rotated, we need a larger sketch canvas in order\n        // to support edge smoothing.\n        var sketchCanvasSize = Math.ceil(Math.sqrt(\n            canvasSize.x * canvasSize.x +\n            canvasSize.y * canvasSize.y));\n        return {\n            x: sketchCanvasSize,\n            y: sketchCanvasSize\n        };\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Viewport\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n\n/**\n * @class Viewport\n * @memberof OpenSeadragon\n * @classdesc Handles coordinate-related functionality (zoom, pan, rotation, etc.)\n * for an {@link OpenSeadragon.Viewer}.\n * @param {Object} options - Options for this Viewport.\n * @param {Object} [options.margins] - See viewportMargins in {@link OpenSeadragon.Options}.\n * @param {Number} [options.springStiffness] - See springStiffness in {@link OpenSeadragon.Options}.\n * @param {Number} [options.animationTime] - See animationTime in {@link OpenSeadragon.Options}.\n * @param {Number} [options.minZoomImageRatio] - See minZoomImageRatio in {@link OpenSeadragon.Options}.\n * @param {Number} [options.maxZoomPixelRatio] - See maxZoomPixelRatio in {@link OpenSeadragon.Options}.\n * @param {Number} [options.visibilityRatio] - See visibilityRatio in {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapHorizontal] - See wrapHorizontal in {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapVertical] - See wrapVertical in {@link OpenSeadragon.Options}.\n * @param {Number} [options.defaultZoomLevel] - See defaultZoomLevel in {@link OpenSeadragon.Options}.\n * @param {Number} [options.minZoomLevel] - See minZoomLevel in {@link OpenSeadragon.Options}.\n * @param {Number} [options.maxZoomLevel] - See maxZoomLevel in {@link OpenSeadragon.Options}.\n * @param {Number} [options.degrees] - See degrees in {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.homeFillsViewer] - See homeFillsViewer in {@link OpenSeadragon.Options}.\n */\n$.Viewport = function( options ) {\n\n    //backward compatibility for positional args while prefering more\n    //idiomatic javascript options object as the only argument\n    var args = arguments;\n    if(  args.length && args[ 0 ] instanceof $.Point ){\n        options = {\n            containerSize:  args[ 0 ],\n            contentSize:    args[ 1 ],\n            config:         args[ 2 ]\n        };\n    }\n\n    //options.config and the general config argument are deprecated\n    //in favor of the more direct specification of optional settings\n    //being passed directly on the options object\n    if ( options.config ){\n        $.extend( true, options, options.config );\n        delete options.config;\n    }\n\n    this._margins = $.extend({\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n    }, options.margins || {});\n\n    delete options.margins;\n\n    $.extend( true, this, {\n\n        //required settings\n        containerSize:      null,\n        contentSize:        null,\n\n        //internal state properties\n        zoomPoint:          null,\n        viewer:           null,\n\n        //configurable options\n        springStiffness:    $.DEFAULT_SETTINGS.springStiffness,\n        animationTime:      $.DEFAULT_SETTINGS.animationTime,\n        minZoomImageRatio:  $.DEFAULT_SETTINGS.minZoomImageRatio,\n        maxZoomPixelRatio:  $.DEFAULT_SETTINGS.maxZoomPixelRatio,\n        visibilityRatio:    $.DEFAULT_SETTINGS.visibilityRatio,\n        wrapHorizontal:     $.DEFAULT_SETTINGS.wrapHorizontal,\n        wrapVertical:       $.DEFAULT_SETTINGS.wrapVertical,\n        defaultZoomLevel:   $.DEFAULT_SETTINGS.defaultZoomLevel,\n        minZoomLevel:       $.DEFAULT_SETTINGS.minZoomLevel,\n        maxZoomLevel:       $.DEFAULT_SETTINGS.maxZoomLevel,\n        degrees:            $.DEFAULT_SETTINGS.degrees,\n        homeFillsViewer:    $.DEFAULT_SETTINGS.homeFillsViewer\n\n    }, options );\n\n    this._updateContainerInnerSize();\n\n    this.centerSpringX = new $.Spring({\n        initial: 0,\n        springStiffness: this.springStiffness,\n        animationTime:   this.animationTime\n    });\n    this.centerSpringY = new $.Spring({\n        initial: 0,\n        springStiffness: this.springStiffness,\n        animationTime:   this.animationTime\n    });\n    this.zoomSpring    = new $.Spring({\n        exponential: true,\n        initial: 1,\n        springStiffness: this.springStiffness,\n        animationTime:   this.animationTime\n    });\n\n    this._oldCenterX = this.centerSpringX.current.value;\n    this._oldCenterY = this.centerSpringY.current.value;\n    this._oldZoom    = this.zoomSpring.current.value;\n\n    this._setContentBounds(new $.Rect(0, 0, 1, 1), 1);\n\n    this.goHome(true);\n    this.update();\n};\n\n/** @lends OpenSeadragon.Viewport.prototype */\n$.Viewport.prototype = {\n    /**\n     * Updates the viewport\'s home bounds and constraints for the given content size.\n     * @function\n     * @param {OpenSeadragon.Point} contentSize - size of the content in content units\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:reset-size\n     */\n    resetContentSize: function(contentSize) {\n        $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");\n        $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");\n        $.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");\n        $.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");\n\n        this._setContentBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);\n        return this;\n    },\n\n    // deprecated\n    setHomeBounds: function(bounds, contentFactor) {\n        $.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");\n        this._setContentBounds(bounds, contentFactor);\n    },\n\n    // Set the viewport\'s content bounds\n    // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates\n    // without rotation\n    // @param {Number} contentFactor - how many content units per viewport unit\n    // @fires OpenSeadragon.Viewer.event:reset-size\n    // @private\n    _setContentBounds: function(bounds, contentFactor) {\n        $.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");\n        $.console.assert(bounds instanceof $.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");\n        $.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");\n        $.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");\n\n        this._contentBoundsNoRotate = bounds.clone();\n        this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(\n            contentFactor);\n\n        this._contentBounds = bounds.rotate(this.degrees).getBoundingBox();\n        this._contentSize = this._contentBounds.getSize().times(contentFactor);\n        this._contentAspectRatio = this._contentSize.x / this._contentSize.y;\n\n        if (this.viewer) {\n            /**\n             * Raised when the viewer\'s content size or home bounds are reset\n             * (see {@link OpenSeadragon.Viewport#resetContentSize}).\n             *\n             * @event reset-size\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {OpenSeadragon.Point} contentSize\n             * @property {OpenSeadragon.Rect} contentBounds - Content bounds.\n             * @property {OpenSeadragon.Rect} homeBounds - Content bounds.\n             * Deprecated use contentBounds instead.\n             * @property {Number} contentFactor\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent(\'reset-size\', {\n                contentSize: this._contentSizeNoRotate.clone(),\n                contentFactor: contentFactor,\n                homeBounds: this._contentBoundsNoRotate.clone(),\n                contentBounds: this._contentBounds.clone()\n            });\n        }\n    },\n\n    /**\n     * Returns the home zoom in "viewport zoom" value.\n     * @function\n     * @returns {Number} The home zoom in "viewport zoom".\n     */\n    getHomeZoom: function() {\n        if (this.defaultZoomLevel) {\n            return this.defaultZoomLevel;\n        }\n\n        var aspectFactor = this._contentAspectRatio / this.getAspectRatio();\n        var output;\n        if (this.homeFillsViewer) { // fill the viewer and clip the image\n            output = aspectFactor >= 1 ? aspectFactor : 1;\n        } else {\n            output = aspectFactor >= 1 ? 1 : aspectFactor;\n        }\n\n        return output / this._contentBounds.width;\n    },\n\n    /**\n     * Returns the home bounds in viewport coordinates.\n     * @function\n     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.\n     */\n    getHomeBounds: function() {\n        return this.getHomeBoundsNoRotate().rotate(-this.getRotation());\n    },\n\n    /**\n     * Returns the home bounds in viewport coordinates.\n     * This method ignores the viewport rotation. Use\n     * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.\n     * @function\n     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.\n     */\n    getHomeBoundsNoRotate: function() {\n        var center = this._contentBounds.getCenter();\n        var width  = 1.0 / this.getHomeZoom();\n        var height = width / this.getAspectRatio();\n\n        return new $.Rect(\n            center.x - (width / 2.0),\n            center.y - (height / 2.0),\n            width,\n            height\n        );\n    },\n\n    /**\n     * @function\n     * @param {Boolean} immediately\n     * @fires OpenSeadragon.Viewer.event:home\n     */\n    goHome: function(immediately) {\n        if (this.viewer) {\n            /**\n             * Raised when the "home" operation occurs (see {@link OpenSeadragon.Viewport#goHome}).\n             *\n             * @event home\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent(\'home\', {\n                immediately: immediately\n            });\n        }\n        return this.fitBounds(this.getHomeBounds(), immediately);\n    },\n\n    /**\n     * @function\n     */\n    getMinZoom: function() {\n        var homeZoom = this.getHomeZoom(),\n            zoom = this.minZoomLevel ?\n            this.minZoomLevel :\n                this.minZoomImageRatio * homeZoom;\n\n        return zoom;\n    },\n\n    /**\n     * @function\n     */\n    getMaxZoom: function() {\n        var zoom = this.maxZoomLevel;\n        if (!zoom) {\n            zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;\n            zoom /= this._contentBounds.width;\n        }\n\n        return Math.max( zoom, this.getHomeZoom() );\n    },\n\n    /**\n     * @function\n     */\n    getAspectRatio: function() {\n        return this._containerInnerSize.x / this._containerInnerSize.y;\n    },\n\n    /**\n     * @function\n     * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.\n     */\n    getContainerSize: function() {\n        return new $.Point(\n            this.containerSize.x,\n            this.containerSize.y\n        );\n    },\n\n    /**\n     * The margins push the "home" region in from the sides by the specified amounts.\n     * @function\n     * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.\n     */\n    getMargins: function() {\n        return $.extend({}, this._margins); // Make a copy so we are not returning our original\n    },\n\n    /**\n     * The margins push the "home" region in from the sides by the specified amounts.\n     * @function\n     * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.\n     */\n    setMargins: function(margins) {\n        $.console.assert($.type(margins) === \'object\', \'[Viewport.setMargins] margins must be an object\');\n\n        this._margins = $.extend({\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        }, margins);\n\n        this._updateContainerInnerSize();\n        if (this.viewer) {\n            this.viewer.forceRedraw();\n        }\n    },\n\n    /**\n     * Returns the bounds of the visible area in viewport coordinates.\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.\n     */\n    getBounds: function(current) {\n        return this.getBoundsNoRotate(current).rotate(-this.getRotation());\n    },\n\n    /**\n     * Returns the bounds of the visible area in viewport coordinates.\n     * This method ignores the viewport rotation. Use\n     * {@link OpenSeadragon.Viewport#getBounds} to take it into account.\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.\n     */\n    getBoundsNoRotate: function(current) {\n        var center = this.getCenter(current);\n        var width  = 1.0 / this.getZoom(current);\n        var height = width / this.getAspectRatio();\n\n        return new $.Rect(\n            center.x - (width / 2.0),\n            center.y - (height / 2.0),\n            width,\n            height\n        );\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,\n     * including the space taken by margins, in viewport coordinates.\n     */\n    getBoundsWithMargins: function(current) {\n        return this.getBoundsNoRotateWithMargins(current).rotate(\n            -this.getRotation(), this.getCenter(current));\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,\n     * including the space taken by margins, in viewport coordinates.\n     */\n    getBoundsNoRotateWithMargins: function(current) {\n        var bounds = this.getBoundsNoRotate(current);\n        var factor = this._containerInnerSize.x * this.getZoom(current);\n        bounds.x -= this._margins.left / factor;\n        bounds.y -= this._margins.top / factor;\n        bounds.width += (this._margins.left + this._margins.right) / factor;\n        bounds.height += (this._margins.top + this._margins.bottom) / factor;\n        return bounds;\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     */\n    getCenter: function( current ) {\n        var centerCurrent = new $.Point(\n                this.centerSpringX.current.value,\n                this.centerSpringY.current.value\n            ),\n            centerTarget = new $.Point(\n                this.centerSpringX.target.value,\n                this.centerSpringY.target.value\n            ),\n            oldZoomPixel,\n            zoom,\n            width,\n            height,\n            bounds,\n            newZoomPixel,\n            deltaZoomPixels,\n            deltaZoomPoints;\n\n        if ( current ) {\n            return centerCurrent;\n        } else if ( !this.zoomPoint ) {\n            return centerTarget;\n        }\n\n        oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);\n\n        zoom    = this.getZoom();\n        width   = 1.0 / zoom;\n        height  = width / this.getAspectRatio();\n        bounds  = new $.Rect(\n            centerCurrent.x - width / 2.0,\n            centerCurrent.y - height / 2.0,\n            width,\n            height\n        );\n\n        newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);\n        deltaZoomPixels = newZoomPixel.minus( oldZoomPixel );\n        deltaZoomPoints = deltaZoomPixels.divide( this._containerInnerSize.x * zoom );\n\n        return centerTarget.plus( deltaZoomPoints );\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     */\n    getZoom: function( current ) {\n        if ( current ) {\n            return this.zoomSpring.current.value;\n        } else {\n            return this.zoomSpring.target.value;\n        }\n    },\n\n    // private\n    _applyZoomConstraints: function(zoom) {\n        return Math.max(\n            Math.min(zoom, this.getMaxZoom()),\n            this.getMinZoom());\n    },\n\n    /**\n     * @function\n     * @private\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Rect} constrained bounds.\n     */\n    _applyBoundaryConstraints: function(bounds, immediately) {\n        var newBounds = new $.Rect(\n                bounds.x,\n                bounds.y,\n                bounds.width,\n                bounds.height);\n\n        if (this.wrapHorizontal) {\n            //do nothing\n        } else {\n            var horizontalThreshold = this.visibilityRatio * newBounds.width;\n            var boundsRight = newBounds.x + newBounds.width;\n            var contentRight = this._contentBoundsNoRotate.x + this._contentBoundsNoRotate.width;\n            var leftDx = this._contentBoundsNoRotate.x - boundsRight + horizontalThreshold;\n            var rightDx = contentRight - newBounds.x - horizontalThreshold;\n\n            if (horizontalThreshold > this._contentBoundsNoRotate.width) {\n                newBounds.x += (leftDx + rightDx) / 2;\n            } else if (rightDx < 0) {\n                newBounds.x += rightDx;\n            } else if (leftDx > 0) {\n                newBounds.x += leftDx;\n            }\n        }\n\n        if (this.wrapVertical) {\n            //do nothing\n        } else {\n            var verticalThreshold   = this.visibilityRatio * newBounds.height;\n            var boundsBottom = newBounds.y + newBounds.height;\n            var contentBottom = this._contentBoundsNoRotate.y + this._contentBoundsNoRotate.height;\n            var topDy = this._contentBoundsNoRotate.y - boundsBottom + verticalThreshold;\n            var bottomDy = contentBottom - newBounds.y - verticalThreshold;\n\n            if (verticalThreshold > this._contentBoundsNoRotate.height) {\n                newBounds.y += (topDy + bottomDy) / 2;\n            } else if (bottomDy < 0) {\n                newBounds.y += bottomDy;\n            } else if (topDy > 0) {\n                newBounds.y += topDy;\n            }\n        }\n\n        if (this.viewer) {\n            /**\n             * Raised when the viewport constraints are applied (see {@link OpenSeadragon.Viewport#applyConstraints}).\n             *\n             * @event constrain\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'constrain\', {\n                immediately: immediately\n            });\n        }\n\n        return newBounds;\n    },\n\n    /**\n     * Enforces the minZoom, maxZoom and visibilityRatio constraints by\n     * zooming and panning to the closest acceptable zoom and location.\n     * @function\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:constrain\n     */\n    applyConstraints: function(immediately) {\n        var actualZoom = this.getZoom();\n        var constrainedZoom = this._applyZoomConstraints(actualZoom);\n\n        if (actualZoom !== constrainedZoom) {\n            this.zoomTo(constrainedZoom, this.zoomPoint, immediately);\n        }\n\n        var bounds = this.getBoundsNoRotate();\n        var constrainedBounds = this._applyBoundaryConstraints(\n            bounds, immediately);\n\n        if (bounds.x !== constrainedBounds.x ||\n            bounds.y !== constrainedBounds.y ||\n            immediately) {\n            this.fitBounds(\n                constrainedBounds.rotate(-this.getRotation()),\n                immediately);\n        }\n        return this;\n    },\n\n    /**\n     * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}\n     * @function\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:constrain\n     */\n    ensureVisible: function(immediately) {\n        return this.applyConstraints(immediately);\n    },\n\n    /**\n     * @function\n     * @private\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Object} options (immediately=false, constraints=false)\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    _fitBounds: function(bounds, options) {\n        options = options || {};\n        var immediately = options.immediately || false;\n        var constraints = options.constraints || false;\n\n        var aspect = this.getAspectRatio();\n        var center = bounds.getCenter();\n\n        // Compute width and height of bounding box.\n        var newBounds = new $.Rect(\n            bounds.x,\n            bounds.y,\n            bounds.width,\n            bounds.height,\n            bounds.degrees + this.getRotation())\n            .getBoundingBox();\n\n        if (newBounds.getAspectRatio() >= aspect) {\n            newBounds.height = newBounds.width / aspect;\n        } else {\n            newBounds.width = newBounds.height * aspect;\n        }\n\n        // Compute x and y from width, height and center position\n        newBounds.x = center.x - newBounds.width / 2;\n        newBounds.y = center.y - newBounds.height / 2;\n        var newZoom = 1.0 / newBounds.width;\n\n        if (constraints) {\n            var newBoundsAspectRatio = newBounds.getAspectRatio();\n            var newConstrainedZoom = this._applyZoomConstraints(newZoom);\n\n            if (newZoom !== newConstrainedZoom) {\n                newZoom = newConstrainedZoom;\n                newBounds.width = 1.0 / newZoom;\n                newBounds.x = center.x - newBounds.width / 2;\n                newBounds.height = newBounds.width / newBoundsAspectRatio;\n                newBounds.y = center.y - newBounds.height / 2;\n            }\n\n            newBounds = this._applyBoundaryConstraints(newBounds, immediately);\n            center = newBounds.getCenter();\n        }\n\n        if (immediately) {\n            this.panTo(center, true);\n            return this.zoomTo(newZoom, null, true);\n        }\n\n        this.panTo(this.getCenter(true), true);\n        this.zoomTo(this.getZoom(true), null, true);\n\n        var oldBounds = this.getBounds();\n        var oldZoom   = this.getZoom();\n\n        if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 0.00000001) {\n            this.zoomTo(newZoom, true);\n            return this.panTo(center, immediately);\n        }\n\n        newBounds = newBounds.rotate(-this.getRotation());\n        var referencePoint = newBounds.getTopLeft().times(newZoom)\n            .minus(oldBounds.getTopLeft().times(oldZoom))\n            .divide(newZoom - oldZoom);\n\n        return this.zoomTo(newZoom, referencePoint, immediately);\n    },\n\n    /**\n     * Makes the viewport zoom and pan so that the specified bounds take\n     * as much space as possible in the viewport.\n     * Note: this method ignores the constraints (minZoom, maxZoom and\n     * visibilityRatio).\n     * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce\n     * them.\n     * @function\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitBounds: function(bounds, immediately) {\n        return this._fitBounds(bounds, {\n            immediately: immediately,\n            constraints: false\n        });\n    },\n\n    /**\n     * Makes the viewport zoom and pan so that the specified bounds take\n     * as much space as possible in the viewport while enforcing the constraints\n     * (minZoom, maxZoom and visibilityRatio).\n     * Note: because this method enforces the constraints, part of the\n     * provided bounds may end up outside of the viewport.\n     * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.\n     * @function\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitBoundsWithConstraints: function(bounds, immediately) {\n        return this._fitBounds(bounds, {\n            immediately: immediately,\n            constraints: true\n        });\n    },\n\n    /**\n     * Zooms so the image just fills the viewer vertically.\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitVertically: function(immediately) {\n        var box = new $.Rect(\n            this._contentBounds.x + (this._contentBounds.width / 2),\n            this._contentBounds.y,\n            0,\n            this._contentBounds.height);\n        return this.fitBounds(box, immediately);\n    },\n\n    /**\n     * Zooms so the image just fills the viewer horizontally.\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitHorizontally: function(immediately) {\n        var box = new $.Rect(\n            this._contentBounds.x,\n            this._contentBounds.y + (this._contentBounds.height / 2),\n            this._contentBounds.width,\n            0);\n        return this.fitBounds(box, immediately);\n    },\n\n\n    /**\n     * @function\n     * @param {OpenSeadragon.Point} delta\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pan\n     */\n    panBy: function( delta, immediately ) {\n        var center = new $.Point(\n            this.centerSpringX.target.value,\n            this.centerSpringY.target.value\n        );\n        return this.panTo( center.plus( delta ), immediately );\n    },\n\n    /**\n     * @function\n     * @param {OpenSeadragon.Point} center\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pan\n     */\n    panTo: function( center, immediately ) {\n        if ( immediately ) {\n            this.centerSpringX.resetTo( center.x );\n            this.centerSpringY.resetTo( center.y );\n        } else {\n            this.centerSpringX.springTo( center.x );\n            this.centerSpringY.springTo( center.y );\n        }\n\n        if( this.viewer ){\n            /**\n             * Raised when the viewport is panned (see {@link OpenSeadragon.Viewport#panBy} and {@link OpenSeadragon.Viewport#panTo}).\n             *\n             * @event pan\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {OpenSeadragon.Point} center\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'pan\', {\n                center: center,\n                immediately: immediately\n            });\n        }\n\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:zoom\n     */\n    zoomBy: function(factor, refPoint, immediately) {\n        return this.zoomTo(\n            this.zoomSpring.target.value * factor, refPoint, immediately);\n    },\n\n    /**\n     * Zooms to the specified zoom level\n     * @function\n     * @param {Number} zoom The zoom level to zoom to.\n     * @param {OpenSeadragon.Point} [refPoint] The point which will stay at\n     * the same screen location. Defaults to the viewport center.\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:zoom\n     */\n    zoomTo: function( zoom, refPoint, immediately ) {\n\n        this.zoomPoint = refPoint instanceof $.Point &&\n            !isNaN(refPoint.x) &&\n            !isNaN(refPoint.y) ?\n            refPoint :\n            null;\n\n        if ( immediately ) {\n            this.zoomSpring.resetTo( zoom );\n        } else {\n            this.zoomSpring.springTo( zoom );\n        }\n\n        if( this.viewer ){\n            /**\n             * Raised when the viewport zoom level changes (see {@link OpenSeadragon.Viewport#zoomBy} and {@link OpenSeadragon.Viewport#zoomTo}).\n             *\n             * @event zoom\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {Number} zoom\n             * @property {OpenSeadragon.Point} refPoint\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'zoom\', {\n                zoom: zoom,\n                refPoint: refPoint,\n                immediately: immediately\n            });\n        }\n\n        return this;\n    },\n\n    /**\n     * Rotates this viewport to the angle specified.\n     * @function\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    setRotation: function(degrees) {\n        if (!this.viewer || !this.viewer.drawer.canRotate()) {\n            return this;\n        }\n\n        degrees = degrees % 360;\n        if (degrees < 0) {\n            degrees += 360;\n        }\n        this.degrees = degrees;\n        this._setContentBounds(\n            this.viewer.world.getHomeBounds(),\n            this.viewer.world.getContentFactor());\n        this.viewer.forceRedraw();\n\n        /**\n         * Raised when rotation has been changed.\n         *\n         * @event rotate\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Number} degrees - The number of degrees the rotation was set to.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.viewer.raiseEvent(\'rotate\', {"degrees": degrees});\n        return this;\n    },\n\n    /**\n     * Gets the current rotation in degrees.\n     * @function\n     * @return {Number} The current rotation in degrees.\n     */\n    getRotation: function() {\n        return this.degrees;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:resize\n     */\n    resize: function( newContainerSize, maintain ) {\n        var oldBounds = this.getBoundsNoRotate(),\n            newBounds = oldBounds,\n            widthDeltaFactor;\n\n        this.containerSize.x = newContainerSize.x;\n        this.containerSize.y = newContainerSize.y;\n\n        this._updateContainerInnerSize();\n\n        if ( maintain ) {\n            // TODO: widthDeltaFactor will always be 1; probably not what\'s intended\n            widthDeltaFactor = newContainerSize.x / this.containerSize.x;\n            newBounds.width  = oldBounds.width * widthDeltaFactor;\n            newBounds.height = newBounds.width / this.getAspectRatio();\n        }\n\n        if( this.viewer ){\n            /**\n             * Raised when the viewer is resized (see {@link OpenSeadragon.Viewport#resize}).\n             *\n             * @event resize\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {OpenSeadragon.Point} newContainerSize\n             * @property {Boolean} maintain\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'resize\', {\n                newContainerSize: newContainerSize,\n                maintain: maintain\n            });\n        }\n\n        return this.fitBounds( newBounds, true );\n    },\n\n    // private\n    _updateContainerInnerSize: function() {\n        this._containerInnerSize = new $.Point(\n            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),\n            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))\n        );\n    },\n\n    /**\n     * Update the zoom and center (X and Y) springs.\n     * @function\n     * @returns {Boolean} True if any change has been made, false otherwise.\n     */\n    update: function() {\n\n        if (this.zoomPoint) {\n            var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);\n            this.zoomSpring.update();\n            var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);\n\n            var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);\n            var deltaZoomPoints = this.deltaPointsFromPixels(\n                deltaZoomPixels, true);\n\n            this.centerSpringX.shiftBy(deltaZoomPoints.x);\n            this.centerSpringY.shiftBy(deltaZoomPoints.y);\n\n            if (this.zoomSpring.isAtTargetValue()) {\n                this.zoomPoint = null;\n            }\n        } else {\n            this.zoomSpring.update();\n        }\n\n        this.centerSpringX.update();\n        this.centerSpringY.update();\n\n        var changed = this.centerSpringX.current.value !== this._oldCenterX ||\n            this.centerSpringY.current.value !== this._oldCenterY ||\n            this.zoomSpring.current.value !== this._oldZoom;\n\n        this._oldCenterX = this.centerSpringX.current.value;\n        this._oldCenterY = this.centerSpringY.current.value;\n        this._oldZoom    = this.zoomSpring.current.value;\n\n        return changed;\n    },\n\n    /**\n     * Convert a delta (translation vector) from viewport coordinates to pixels\n     * coordinates. This method does not take rotation into account.\n     * Consider using deltaPixelsFromPoints if you need to account for rotation.\n     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {\n        return deltaPoints.times(\n            this._containerInnerSize.x * this.getZoom(current)\n        );\n    },\n\n    /**\n     * Convert a delta (translation vector) from viewport coordinates to pixels\n     * coordinates.\n     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPixelsFromPoints: function(deltaPoints, current) {\n        return this.deltaPixelsFromPointsNoRotate(\n            deltaPoints.rotate(this.getRotation()),\n            current);\n    },\n\n    /**\n     * Convert a delta (translation vector) from pixels coordinates to viewport\n     * coordinates. This method does not take rotation into account.\n     * Consider using deltaPointsFromPixels if you need to account for rotation.\n     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {\n        return deltaPixels.divide(\n            this._containerInnerSize.x * this.getZoom(current)\n        );\n    },\n\n    /**\n     * Convert a delta (translation vector) from pixels coordinates to viewport\n     * coordinates.\n     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPointsFromPixels: function(deltaPixels, current) {\n        return this.deltaPointsFromPixelsNoRotate(deltaPixels, current)\n            .rotate(-this.getRotation());\n    },\n\n    /**\n     * Convert viewport coordinates to pixels coordinates.\n     * This method does not take rotation into account.\n     * Consider using pixelFromPoint if you need to account for rotation.\n     * @param {OpenSeadragon.Point} point the viewport coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pixelFromPointNoRotate: function(point, current) {\n        return this._pixelFromPointNoRotate(\n            point, this.getBoundsNoRotate(current));\n    },\n\n    /**\n     * Convert viewport coordinates to pixel coordinates.\n     * @param {OpenSeadragon.Point} point the viewport coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pixelFromPoint: function(point, current) {\n        return this._pixelFromPoint(point, this.getBoundsNoRotate(current));\n    },\n\n    // private\n    _pixelFromPointNoRotate: function(point, bounds) {\n        return point.minus(\n            bounds.getTopLeft()\n        ).times(\n            this._containerInnerSize.x / bounds.width\n        ).plus(\n            new $.Point(this._margins.left, this._margins.top)\n        );\n    },\n\n    // private\n    _pixelFromPoint: function(point, bounds) {\n        return this._pixelFromPointNoRotate(\n            point.rotate(this.getRotation(), this.getCenter(true)),\n            bounds);\n    },\n\n    /**\n     * Convert pixel coordinates to viewport coordinates.\n     * This method does not take rotation into account.\n     * Consider using pointFromPixel if you need to account for rotation.\n     * @param {OpenSeadragon.Point} pixel Pixel coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pointFromPixelNoRotate: function(pixel, current) {\n        var bounds = this.getBoundsNoRotate(current);\n        return pixel.minus(\n            new $.Point(this._margins.left, this._margins.top)\n        ).divide(\n            this._containerInnerSize.x / bounds.width\n        ).plus(\n            bounds.getTopLeft()\n        );\n    },\n\n    /**\n     * Convert pixel coordinates to viewport coordinates.\n     * @param {OpenSeadragon.Point} pixel Pixel coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pointFromPixel: function(pixel, current) {\n        return this.pointFromPixelNoRotate(pixel, current).rotate(\n            -this.getRotation(),\n            this.getCenter(true)\n        );\n    },\n\n    // private\n    _viewportToImageDelta: function( viewerX, viewerY ) {\n        var scale = this._contentBoundsNoRotate.width;\n        return new $.Point(\n            viewerX * this._contentSizeNoRotate.x / scale,\n            viewerY * this._contentSizeNoRotate.x / scale);\n    },\n\n    /**\n     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.\n     * This method can be called either by passing X,Y coordinates or an\n     * OpenSeadragon.Point\n     * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.\n     * @function\n     * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X\n     * coordinate in viewport coordinate system.\n     * @param {Number} [viewerY] Y coordinate in viewport coordinate system.\n     * @return {OpenSeadragon.Point} a point representing the coordinates in the image.\n     */\n    viewportToImageCoordinates: function(viewerX, viewerY) {\n        if (viewerX instanceof $.Point) {\n            //they passed a point instead of individual components\n            return this.viewportToImageCoordinates(viewerX.x, viewerX.y);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.viewportToImageCoordinates] is not accurate \' +\n                    \'with multi-image; use TiledImage.viewportToImageCoordinates instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageCoordinates\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.viewportToImageCoordinates(viewerX, viewerY, true);\n            }\n        }\n\n        return this._viewportToImageDelta(\n            viewerX - this._contentBoundsNoRotate.x,\n            viewerY - this._contentBoundsNoRotate.y);\n    },\n\n    // private\n    _imageToViewportDelta: function( imageX, imageY ) {\n        var scale = this._contentBoundsNoRotate.width;\n        return new $.Point(\n            imageX / this._contentSizeNoRotate.x * scale,\n            imageY / this._contentSizeNoRotate.x * scale);\n    },\n\n    /**\n     * Translates from image coordinate system to OpenSeadragon viewer coordinate system\n     * This method can be called either by passing X,Y coordinates or an\n     * OpenSeadragon.Point\n     * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.\n     * @function\n     * @param {(OpenSeadragon.Point | Number)} imageX the point or the\n     * X coordinate in image coordinate system.\n     * @param {Number} [imageY] Y coordinate in image coordinate system.\n     * @return {OpenSeadragon.Point} a point representing the coordinates in the viewport.\n     */\n    imageToViewportCoordinates: function(imageX, imageY) {\n        if (imageX instanceof $.Point) {\n            //they passed a point instead of individual components\n            return this.imageToViewportCoordinates(imageX.x, imageX.y);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.imageToViewportCoordinates] is not accurate \' +\n                    \'with multi-image; use TiledImage.imageToViewportCoordinates instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageCoordinates\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.imageToViewportCoordinates(imageX, imageY, true);\n            }\n        }\n\n        var point = this._imageToViewportDelta(imageX, imageY);\n        point.x += this._contentBoundsNoRotate.x;\n        point.y += this._contentBoundsNoRotate.y;\n        return point;\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of the image in\n     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an\n     * OpenSeadragon.Rect\n     * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.\n     * @function\n     * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X\n     * coordinate of the top left corner of the rectangle in image coordinate system.\n     * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle\n     * in image coordinate system.\n     * @param {Number} [pixelWidth] the width in pixel of the rectangle.\n     * @param {Number} [pixelHeight] the height in pixel of the rectangle.\n     */\n    imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {\n        var rect = imageX;\n        if (!(rect instanceof $.Rect)) {\n            //they passed individual components instead of a rectangle\n            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.imageToViewportRectangle] is not accurate \' +\n                    \'with multi-image; use TiledImage.imageToViewportRectangle instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.imageToViewportRectangle\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.imageToViewportRectangle(\n                    imageX, imageY, pixelWidth, pixelHeight, true);\n            }\n        }\n\n        var coordA = this.imageToViewportCoordinates(rect.x, rect.y);\n        var coordB = this._imageToViewportDelta(rect.width, rect.height);\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of\n     * the viewport in point coordinates to image rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an\n     * OpenSeadragon.Rect\n     * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.\n     * @function\n     * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or\n     * the X coordinate of the top left corner of the rectangle in viewport\n     * coordinate system.\n     * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle\n     * in viewport coordinate system.\n     * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.\n     * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.\n     */\n    viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {\n        var rect = viewerX;\n        if (!(rect instanceof $.Rect)) {\n            //they passed individual components instead of a rectangle\n            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.viewportToImageRectangle] is not accurate \' +\n                    \'with multi-image; use TiledImage.viewportToImageRectangle instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageCoordinates\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.viewportToImageRectangle(\n                    viewerX, viewerY, pointWidth, pointHeight, true);\n            }\n        }\n\n        var coordA = this.viewportToImageCoordinates(rect.x, rect.y);\n        var coordB = this._viewportToImageDelta(rect.width, rect.height);\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the viewer element to image\n     * coordinates.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    viewerElementToImageCoordinates: function( pixel ) {\n        var point = this.pointFromPixel( pixel, true );\n        return this.viewportToImageCoordinates( point );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the image to\n     * viewer element coordinates.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToViewerElementCoordinates: function( pixel ) {\n        var point = this.imageToViewportCoordinates( pixel );\n        return this.pixelFromPoint( point, true );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the window to image coordinates.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    windowToImageCoordinates: function(pixel) {\n        $.console.assert(this.viewer,\n            "[Viewport.windowToImageCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = pixel.minus(\n                $.getElementPosition(this.viewer.element));\n        return this.viewerElementToImageCoordinates(viewerCoordinates);\n    },\n\n    /**\n     * Convert image coordinates to pixel coordinates relative to the window.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToWindowCoordinates: function(pixel) {\n        $.console.assert(this.viewer,\n            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);\n        return viewerCoordinates.plus(\n                $.getElementPosition(this.viewer.element));\n    },\n\n    /**\n     * Convert pixel coordinates relative to the viewer element to viewport\n     * coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    viewerElementToViewportCoordinates: function( pixel ) {\n        return this.pointFromPixel( pixel, true );\n    },\n\n    /**\n     * Convert viewport coordinates to pixel coordinates relative to the\n     * viewer element.\n     * @param {OpenSeadragon.Point} point\n     * @returns {OpenSeadragon.Point}\n     */\n    viewportToViewerElementCoordinates: function( point ) {\n        return this.pixelFromPoint( point, true );\n    },\n\n    /**\n     * Convert a rectangle in pixel coordinates relative to the viewer element\n     * to viewport coordinates.\n     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert\n     * @returns {OpenSeadragon.Rect} the converted rectangle\n     */\n    viewerElementToViewportRectangle: function(rectangle) {\n        return $.Rect.fromSummits(\n            this.pointFromPixel(rectangle.getTopLeft(), true),\n            this.pointFromPixel(rectangle.getTopRight(), true),\n            this.pointFromPixel(rectangle.getBottomLeft(), true)\n        );\n    },\n\n    /**\n     * Convert a rectangle in viewport coordinates to pixel coordinates relative\n     * to the viewer element.\n     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert\n     * @returns {OpenSeadragon.Rect} the converted rectangle\n     */\n    viewportToViewerElementRectangle: function(rectangle) {\n        return $.Rect.fromSummits(\n            this.pixelFromPoint(rectangle.getTopLeft(), true),\n            this.pixelFromPoint(rectangle.getTopRight(), true),\n            this.pixelFromPoint(rectangle.getBottomLeft(), true)\n        );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the window to viewport coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    windowToViewportCoordinates: function(pixel) {\n        $.console.assert(this.viewer,\n            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = pixel.minus(\n                $.getElementPosition(this.viewer.element));\n        return this.viewerElementToViewportCoordinates(viewerCoordinates);\n    },\n\n    /**\n     * Convert viewport coordinates to pixel coordinates relative to the window.\n     * @param {OpenSeadragon.Point} point\n     * @returns {OpenSeadragon.Point}\n     */\n    viewportToWindowCoordinates: function(point) {\n        $.console.assert(this.viewer,\n            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = this.viewportToViewerElementCoordinates(point);\n        return viewerCoordinates.plus(\n                $.getElementPosition(this.viewer.element));\n    },\n\n    /**\n     * Convert a viewport zoom to an image zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * Note: not accurate with multi-image.\n     * @function\n     * @param {Number} viewportZoom The viewport zoom\n     * target zoom.\n     * @returns {Number} imageZoom The image zoom\n     */\n    viewportToImageZoom: function(viewportZoom) {\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.viewportToImageZoom] is not \' +\n                    \'accurate with multi-image.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageZoom\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.viewportToImageZoom(viewportZoom);\n            }\n        }\n\n        var imageWidth = this._contentSizeNoRotate.x;\n        var containerWidth = this._containerInnerSize.x;\n        var scale = this._contentBoundsNoRotate.width;\n        var viewportToImageZoomRatio = (containerWidth / imageWidth) * scale;\n        return viewportZoom * viewportToImageZoomRatio;\n    },\n\n    /**\n     * Convert an image zoom to a viewport zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * Note: not accurate with multi-image.\n     * @function\n     * @param {Number} imageZoom The image zoom\n     * target zoom.\n     * @returns {Number} viewportZoom The viewport zoom\n     */\n    imageToViewportZoom: function(imageZoom) {\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.imageToViewportZoom] is not accurate \' +\n                    \'with multi-image.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.imageToViewportZoom\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.imageToViewportZoom(imageZoom);\n            }\n        }\n\n        var imageWidth = this._contentSizeNoRotate.x;\n        var containerWidth = this._containerInnerSize.x;\n        var scale = this._contentBoundsNoRotate.width;\n        var viewportToImageZoomRatio = (imageWidth / containerWidth) / scale;\n        return imageZoom * viewportToImageZoomRatio;\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TiledImage\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * You shouldn\'t have to create a TiledImage directly; use {@link OpenSeadragon.Viewer#open}\n * or {@link OpenSeadragon.Viewer#addTiledImage} instead.\n * @class TiledImage\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.\n * A new instance is created for each TileSource opened.\n * @param {Object} options - Configuration for this TiledImage.\n * @param {OpenSeadragon.TileSource} options.source - The TileSource that defines this TiledImage.\n * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this TiledImage.\n * @param {OpenSeadragon.TileCache} options.tileCache - The TileCache for this TiledImage to use.\n * @param {OpenSeadragon.Drawer} options.drawer - The Drawer for this TiledImage to draw onto.\n * @param {OpenSeadragon.ImageLoader} options.imageLoader - The ImageLoader for this TiledImage to use.\n * @param {Number} [options.x=0] - Left position, in viewport coordinates.\n * @param {Number} [options.y=0] - Top position, in viewport coordinates.\n * @param {Number} [options.width=1] - Width, in viewport coordinates.\n * @param {Number} [options.height] - Height, in viewport coordinates.\n * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates\n * to fit the image into. If specified, x, y, width and height get ignored.\n * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]\n * How to anchor the image in the bounds if options.fitBounds is set.\n * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to\n * (portions of the image outside of this area will not be visible). Only works on\n * browsers that support the HTML5 canvas.\n * @param {Number} [options.springStiffness] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.animationTime] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.minZoomImageRatio] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapHorizontal] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapVertical] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.immediateRender] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.blendTime] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.alwaysBlend] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.minPixelRatio] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.smoothTileEdgesMinZoom] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.iOSDevice] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.opacity=1] - Opacity the tiled image should be drawn at.\n * @param {String} [options.compositeOperation] - How the image is composited onto other images; see compositeOperation in {@link OpenSeadragon.Options} for possible values.\n * @param {Boolean} [options.debugMode] - See {@link OpenSeadragon.Options}.\n * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.\n * @param {String|Boolean} [options.crossOriginPolicy] - See {@link OpenSeadragon.Options}.\n */\n$.TiledImage = function( options ) {\n    var _this = this;\n\n    $.console.assert( options.tileCache, "[TiledImage] options.tileCache is required" );\n    $.console.assert( options.drawer, "[TiledImage] options.drawer is required" );\n    $.console.assert( options.viewer, "[TiledImage] options.viewer is required" );\n    $.console.assert( options.imageLoader, "[TiledImage] options.imageLoader is required" );\n    $.console.assert( options.source, "[TiledImage] options.source is required" );\n    $.console.assert(!options.clip || options.clip instanceof $.Rect,\n        "[TiledImage] options.clip must be an OpenSeadragon.Rect if present");\n\n    $.EventSource.call( this );\n\n    this._tileCache = options.tileCache;\n    delete options.tileCache;\n\n    this._drawer = options.drawer;\n    delete options.drawer;\n\n    this._imageLoader = options.imageLoader;\n    delete options.imageLoader;\n\n    if (options.clip instanceof $.Rect) {\n        this._clip = options.clip.clone();\n    }\n\n    delete options.clip;\n\n    var x = options.x || 0;\n    delete options.x;\n    var y = options.y || 0;\n    delete options.y;\n\n    // Ratio of zoomable image height to width.\n    this.normHeight = options.source.dimensions.y / options.source.dimensions.x;\n    this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;\n\n    var scale = 1;\n    if ( options.width ) {\n        scale = options.width;\n        delete options.width;\n\n        if ( options.height ) {\n            $.console.error( "specifying both width and height to a tiledImage is not supported" );\n            delete options.height;\n        }\n    } else if ( options.height ) {\n        scale = options.height / this.normHeight;\n        delete options.height;\n    }\n\n    var fitBounds = options.fitBounds;\n    delete options.fitBounds;\n    var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;\n    delete options.fitBoundsPlacement;\n\n    $.extend( true, this, {\n\n        //internal state properties\n        viewer:         null,\n        tilesMatrix:    {},    // A \'3d\' dictionary [level][x][y] --\x3e Tile.\n        coverage:       {},    // A \'3d\' dictionary [level][x][y] --\x3e Boolean.\n        lastDrawn:      [],    // An unordered list of Tiles drawn last frame.\n        lastResetTime:  0,     // Last time for which the tiledImage was reset.\n        _midDraw:       false, // Is the tiledImage currently updating the viewport?\n        _needsDraw:     true,  // Does the tiledImage need to update the viewport again?\n        _hasOpaqueTile: false,  // Do we have even one fully opaque tile?\n        //configurable settings\n        springStiffness:        $.DEFAULT_SETTINGS.springStiffness,\n        animationTime:          $.DEFAULT_SETTINGS.animationTime,\n        minZoomImageRatio:      $.DEFAULT_SETTINGS.minZoomImageRatio,\n        wrapHorizontal:         $.DEFAULT_SETTINGS.wrapHorizontal,\n        wrapVertical:           $.DEFAULT_SETTINGS.wrapVertical,\n        immediateRender:        $.DEFAULT_SETTINGS.immediateRender,\n        blendTime:              $.DEFAULT_SETTINGS.blendTime,\n        alwaysBlend:            $.DEFAULT_SETTINGS.alwaysBlend,\n        minPixelRatio:          $.DEFAULT_SETTINGS.minPixelRatio,\n        smoothTileEdgesMinZoom: $.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,\n        iOSDevice:              $.DEFAULT_SETTINGS.iOSDevice,\n        debugMode:              $.DEFAULT_SETTINGS.debugMode,\n        crossOriginPolicy:      $.DEFAULT_SETTINGS.crossOriginPolicy,\n        placeholderFillStyle:   $.DEFAULT_SETTINGS.placeholderFillStyle,\n        opacity:                $.DEFAULT_SETTINGS.opacity,\n        compositeOperation:     $.DEFAULT_SETTINGS.compositeOperation\n\n    }, options );\n\n    this._xSpring = new $.Spring({\n        initial: x,\n        springStiffness: this.springStiffness,\n        animationTime: this.animationTime\n    });\n\n    this._ySpring = new $.Spring({\n        initial: y,\n        springStiffness: this.springStiffness,\n        animationTime: this.animationTime\n    });\n\n    this._scaleSpring = new $.Spring({\n        initial: scale,\n        springStiffness: this.springStiffness,\n        animationTime: this.animationTime\n    });\n\n    this._updateForScale();\n\n    if (fitBounds) {\n        this.fitBounds(fitBounds, fitBoundsPlacement, true);\n    }\n\n    // We need a callback to give image manipulation a chance to happen\n    this._drawingHandler = function(args) {\n      /**\n       * This event is fired just before the tile is drawn giving the application a chance to alter the image.\n       *\n       * NOTE: This event is only fired when the drawer is using a &lt;canvas&gt;.\n       *\n       * @event tile-drawing\n       * @memberof OpenSeadragon.Viewer\n       * @type {object}\n       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n       * @property {OpenSeadragon.Tile} tile - The Tile being drawn.\n       * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n       * @property {OpenSeadragon.Tile} context - The HTML canvas context being drawn into.\n       * @property {OpenSeadragon.Tile} rendered - The HTML canvas context containing the tile imagery.\n       * @property {?Object} userData - Arbitrary subscriber-defined object.\n       */\n        _this.viewer.raiseEvent(\'tile-drawing\', $.extend({\n            tiledImage: _this\n        }, args));\n    };\n};\n\n$.extend($.TiledImage.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.TiledImage.prototype */{\n    /**\n     * @returns {Boolean} Whether the TiledImage needs to be drawn.\n     */\n    needsDraw: function() {\n        return this._needsDraw;\n    },\n\n    /**\n     * Clears all tiles and triggers an update on the next call to\n     * {@link OpenSeadragon.TiledImage#update}.\n     */\n    reset: function() {\n        this._tileCache.clearTilesFor(this);\n        this.lastResetTime = $.now();\n        this._needsDraw = true;\n    },\n\n    /**\n     * Updates the TiledImage\'s bounds, animating if needed.\n     * @returns {Boolean} Whether the TiledImage animated.\n     */\n    update: function() {\n        var oldX = this._xSpring.current.value;\n        var oldY = this._ySpring.current.value;\n        var oldScale = this._scaleSpring.current.value;\n\n        this._xSpring.update();\n        this._ySpring.update();\n        this._scaleSpring.update();\n\n        if (this._xSpring.current.value !== oldX || this._ySpring.current.value !== oldY ||\n                this._scaleSpring.current.value !== oldScale) {\n            this._updateForScale();\n            this._needsDraw = true;\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Draws the TiledImage to its Drawer.\n     */\n    draw: function() {\n        if (this.opacity !== 0) {\n            this._midDraw = true;\n            updateViewport(this);\n            this._midDraw = false;\n        }\n    },\n\n    /**\n     * Destroy the TiledImage (unload current loaded tiles).\n     */\n    destroy: function() {\n        this.reset();\n    },\n\n    /**\n     * @returns {OpenSeadragon.Rect} This TiledImage\'s bounds in viewport coordinates.\n     * @param {Boolean} [current=false] - Pass true for the current location; false for target location.\n     */\n    getBounds: function(current) {\n        if (current) {\n            return new $.Rect( this._xSpring.current.value, this._ySpring.current.value,\n                this._worldWidthCurrent, this._worldHeightCurrent );\n        }\n\n        return new $.Rect( this._xSpring.target.value, this._ySpring.target.value,\n            this._worldWidthTarget, this._worldHeightTarget );\n    },\n\n    // deprecated\n    getWorldBounds: function() {\n        $.console.error(\'[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead\');\n        return this.getBounds();\n    },\n\n    /**\n     * Get the bounds of the displayed part of the tiled image.\n     * @param {Boolean} [current=false] Pass true for the current location,\n     * false for the target location.\n     * @returns {$.Rect} The clipped bounds in viewport coordinates.\n     */\n    getClippedBounds: function(current) {\n        var bounds = this.getBounds(current);\n        if (this._clip) {\n            var ratio = this._worldWidthCurrent / this.source.dimensions.x;\n            var clip = this._clip.times(ratio);\n            bounds = new $.Rect(\n                bounds.x + clip.x,\n                bounds.y + clip.y,\n                clip.width,\n                clip.height);\n        }\n        return bounds;\n    },\n\n    /**\n     * @returns {OpenSeadragon.Point} This TiledImage\'s content size, in original pixels.\n     */\n    getContentSize: function() {\n        return new $.Point(this.source.dimensions.x, this.source.dimensions.y);\n    },\n\n    // private\n    _viewportToImageDelta: function( viewerX, viewerY, current ) {\n        var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);\n        return new $.Point(viewerX * (this.source.dimensions.x / scale),\n            viewerY * ((this.source.dimensions.y * this.contentAspectX) / scale));\n    },\n\n    /**\n     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.\n     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.\n     * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.\n     * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Point} A point representing the coordinates in the image.\n     */\n    viewportToImageCoordinates: function( viewerX, viewerY, current ) {\n        if (viewerX instanceof $.Point) {\n            //they passed a point instead of individual components\n            current = viewerY;\n            viewerY = viewerX.y;\n            viewerX = viewerX.x;\n        }\n\n        if (current) {\n            return this._viewportToImageDelta(viewerX - this._xSpring.current.value,\n                viewerY - this._ySpring.current.value);\n        }\n\n        return this._viewportToImageDelta(viewerX - this._xSpring.target.value,\n            viewerY - this._ySpring.target.value);\n    },\n\n    // private\n    _imageToViewportDelta: function( imageX, imageY, current ) {\n        var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);\n        return new $.Point((imageX / this.source.dimensions.x) * scale,\n            (imageY / this.source.dimensions.y / this.contentAspectX) * scale);\n    },\n\n    /**\n     * Translates from image coordinate system to OpenSeadragon viewer coordinate system\n     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.\n     * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.\n     * @param {Number} [imageY] - The Y coordinate in image coordinate system.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Point} A point representing the coordinates in the viewport.\n     */\n    imageToViewportCoordinates: function( imageX, imageY, current ) {\n        if (imageX instanceof $.Point) {\n            //they passed a point instead of individual components\n            current = imageY;\n            imageY = imageX.y;\n            imageX = imageX.x;\n        }\n\n        var point = this._imageToViewportDelta(imageX, imageY);\n        if (current) {\n            point.x += this._xSpring.current.value;\n            point.y += this._ySpring.current.value;\n        } else {\n            point.x += this._xSpring.target.value;\n            point.y += this._ySpring.target.value;\n        }\n\n        return point;\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of the image in\n     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.\n     * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.\n     * @param {Number} [imageY] - The top coordinate in image coordinate system.\n     * @param {Number} [pixelWidth] - The width in pixel of the rectangle.\n     * @param {Number} [pixelHeight] - The height in pixel of the rectangle.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.\n     */\n    imageToViewportRectangle: function( imageX, imageY, pixelWidth, pixelHeight, current ) {\n        var rect = imageX;\n        if (rect instanceof $.Rect) {\n            //they passed a rect instead of individual components\n            current = imageY;\n        } else {\n            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);\n        }\n\n        var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);\n        var coordB = this._imageToViewportDelta(rect.width, rect.height, current);\n\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of\n     * the viewport in point coordinates to image rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.\n     * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.\n     * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.\n     * @param {Number} [pointWidth] - The width in viewport coordinate system.\n     * @param {Number} [pointHeight] - The height in viewport coordinate system.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Rect} A rect representing the coordinates in the image.\n     */\n    viewportToImageRectangle: function( viewerX, viewerY, pointWidth, pointHeight, current ) {\n        var rect = viewerX;\n        if (viewerX instanceof $.Rect) {\n            //they passed a rect instead of individual components\n            current = viewerY;\n        } else {\n            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);\n        }\n\n        var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);\n        var coordB = this._viewportToImageDelta(rect.width, rect.height, current);\n\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the viewer element to image\n     * coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    viewerElementToImageCoordinates: function( pixel ) {\n        var point = this.viewport.pointFromPixel( pixel, true );\n        return this.viewportToImageCoordinates( point );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the image to\n     * viewer element coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToViewerElementCoordinates: function( pixel ) {\n        var point = this.imageToViewportCoordinates( pixel );\n        return this.viewport.pixelFromPoint( point, true );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the window to image coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    windowToImageCoordinates: function( pixel ) {\n        var viewerCoordinates = pixel.minus(\n                OpenSeadragon.getElementPosition( this.viewer.element ));\n        return this.viewerElementToImageCoordinates( viewerCoordinates );\n    },\n\n    /**\n     * Convert image coordinates to pixel coordinates relative to the window.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToWindowCoordinates: function( pixel ) {\n        var viewerCoordinates = this.imageToViewerElementCoordinates( pixel );\n        return viewerCoordinates.plus(\n                OpenSeadragon.getElementPosition( this.viewer.element ));\n    },\n\n    /**\n     * Convert a viewport zoom to an image zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * @function\n     * @param {Number} viewportZoom The viewport zoom\n     * @returns {Number} imageZoom The image zoom\n     */\n    viewportToImageZoom: function( viewportZoom ) {\n        var ratio = this._scaleSpring.current.value *\n                this.viewport._containerInnerSize.x / this.source.dimensions.x;\n        return ratio * viewportZoom ;\n    },\n\n    /**\n     * Convert an image zoom to a viewport zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * Note: not accurate with multi-image.\n     * @function\n     * @param {Number} imageZoom The image zoom\n     * @returns {Number} viewportZoom The viewport zoom\n     */\n    imageToViewportZoom: function( imageZoom ) {\n        var ratio = this._scaleSpring.current.value *\n                this.viewport._containerInnerSize.x / this.source.dimensions.x;\n        return imageZoom / ratio;\n    },\n\n    /**\n     * Sets the TiledImage\'s position in the world.\n     * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.\n     * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    setPosition: function(position, immediately) {\n        var sameTarget = (this._xSpring.target.value === position.x &&\n            this._ySpring.target.value === position.y);\n\n        if (immediately) {\n            if (sameTarget && this._xSpring.current.value === position.x &&\n                    this._ySpring.current.value === position.y) {\n                return;\n            }\n\n            this._xSpring.resetTo(position.x);\n            this._ySpring.resetTo(position.y);\n            this._needsDraw = true;\n        } else {\n            if (sameTarget) {\n                return;\n            }\n\n            this._xSpring.springTo(position.x);\n            this._ySpring.springTo(position.y);\n            this._needsDraw = true;\n        }\n\n        if (!sameTarget) {\n            this._raiseBoundsChange();\n        }\n    },\n\n    /**\n     * Sets the TiledImage\'s width in the world, adjusting the height to match based on aspect ratio.\n     * @param {Number} width - The new width, in viewport coordinates.\n     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    setWidth: function(width, immediately) {\n        this._setScale(width, immediately);\n    },\n\n    /**\n     * Sets the TiledImage\'s height in the world, adjusting the width to match based on aspect ratio.\n     * @param {Number} height - The new height, in viewport coordinates.\n     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    setHeight: function(height, immediately) {\n        this._setScale(height / this.normHeight, immediately);\n    },\n\n    /**\n     * Positions and scales the TiledImage to fit in the specified bounds.\n     * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change\n     * twice\n     * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.\n     * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]\n     * How to anchor the image in the bounds.\n     * @param {Boolean} [immediately=false] Whether to animate to the new size\n     * or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    fitBounds: function(bounds, anchor, immediately) {\n        anchor = anchor || $.Placement.CENTER;\n        var anchorProperties = $.Placement.properties[anchor];\n        var aspectRatio = this.contentAspectX;\n        var xOffset = 0;\n        var yOffset = 0;\n        var displayedWidthRatio = 1;\n        var displayedHeightRatio = 1;\n        if (this._clip) {\n            aspectRatio = this._clip.getAspectRatio();\n            displayedWidthRatio = this._clip.width / this.source.dimensions.x;\n            displayedHeightRatio = this._clip.height / this.source.dimensions.y;\n            if (bounds.getAspectRatio() > aspectRatio) {\n                xOffset = this._clip.x / this._clip.height * bounds.height;\n                yOffset = this._clip.y / this._clip.height * bounds.height;\n            } else {\n                xOffset = this._clip.x / this._clip.width * bounds.width;\n                yOffset = this._clip.y / this._clip.width * bounds.width;\n            }\n        }\n\n        if (bounds.getAspectRatio() > aspectRatio) {\n            // We will have margins on the X axis\n            var height = bounds.height / displayedHeightRatio;\n            var marginLeft = 0;\n            if (anchorProperties.isHorizontallyCentered) {\n                marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;\n            } else if (anchorProperties.isRight) {\n                marginLeft = bounds.width - bounds.height * aspectRatio;\n            }\n            this.setPosition(\n                new $.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),\n                immediately);\n            this.setHeight(height, immediately);\n        } else {\n            // We will have margins on the Y axis\n            var width = bounds.width / displayedWidthRatio;\n            var marginTop = 0;\n            if (anchorProperties.isVerticallyCentered) {\n                marginTop = (bounds.height - bounds.width / aspectRatio) / 2;\n            } else if (anchorProperties.isBottom) {\n                marginTop = bounds.height - bounds.width / aspectRatio;\n            }\n            this.setPosition(\n                new $.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),\n                immediately);\n            this.setWidth(width, immediately);\n        }\n    },\n\n    /**\n     * @returns {OpenSeadragon.Rect|null} The TiledImage\'s current clip rectangle,\n     * in image pixels, or null if none.\n     */\n    getClip: function() {\n        if (this._clip) {\n            return this._clip.clone();\n        }\n\n        return null;\n    },\n\n    /**\n     * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to\n     * (portions of the image outside of this area will not be visible). Only works on\n     * browsers that support the HTML5 canvas.\n     */\n    setClip: function(newClip) {\n        $.console.assert(!newClip || newClip instanceof $.Rect,\n            "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null");\n\n        if (newClip instanceof $.Rect) {\n            this._clip = newClip.clone();\n        } else {\n            this._clip = null;\n        }\n\n        this._needsDraw = true;\n    },\n\n    /**\n     * @returns {Number} The TiledImage\'s current opacity.\n     */\n    getOpacity: function() {\n        return this.opacity;\n    },\n\n    /**\n     * @param {Number} opacity Opacity the tiled image should be drawn at.\n     */\n    setOpacity: function(opacity) {\n        this.opacity = opacity;\n        this._needsDraw = true;\n    },\n\n    /**\n     * @returns {String} The TiledImage\'s current compositeOperation.\n     */\n    getCompositeOperation: function() {\n        return this.compositeOperation;\n    },\n\n    /**\n     * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.\n     */\n    setCompositeOperation: function(compositeOperation) {\n        this.compositeOperation = compositeOperation;\n        this._needsDraw = true;\n    },\n\n    // private\n    _setScale: function(scale, immediately) {\n        var sameTarget = (this._scaleSpring.target.value === scale);\n        if (immediately) {\n            if (sameTarget && this._scaleSpring.current.value === scale) {\n                return;\n            }\n\n            this._scaleSpring.resetTo(scale);\n            this._updateForScale();\n            this._needsDraw = true;\n        } else {\n            if (sameTarget) {\n                return;\n            }\n\n            this._scaleSpring.springTo(scale);\n            this._updateForScale();\n            this._needsDraw = true;\n        }\n\n        if (!sameTarget) {\n            this._raiseBoundsChange();\n        }\n    },\n\n    // private\n    _updateForScale: function() {\n        this._worldWidthTarget = this._scaleSpring.target.value;\n        this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;\n        this._worldWidthCurrent = this._scaleSpring.current.value;\n        this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;\n    },\n\n    // private\n    _raiseBoundsChange: function() {\n        /**\n         * Raised when the TiledImage\'s bounds are changed.\n         * Note that this event is triggered only when the animation target is changed;\n         * not for every frame of animation.\n         * @event bounds-change\n         * @memberOf OpenSeadragon.TiledImage\n         * @type {object}\n         * @property {OpenSeadragon.World} eventSource - A reference to the TiledImage which raised the event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent(\'bounds-change\');\n    },\n\n    // private\n    _isBottomItem: function() {\n        return this.viewer.world.getItemAt(0) === this;\n    }\n});\n\n/**\n * @private\n * @inner\n * Pretty much every other line in this needs to be documented so it\'s clear\n * how each piece of this routine contributes to the drawing process.  That\'s\n * why there are so many TODO\'s inside this function.\n */\nfunction updateViewport( tiledImage ) {\n\n    tiledImage._needsDraw = false;\n\n    var tile,\n        level,\n        best            = null,\n        haveDrawn       = false,\n        currentTime     = $.now(),\n        viewportBounds  = tiledImage.viewport.getBoundsWithMargins( true ),\n        zeroRatioC      = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio( 0 ),\n            true\n        ).x * tiledImage._scaleSpring.current.value,\n        lowestLevel     = Math.max(\n            tiledImage.source.minLevel,\n            Math.floor(\n                Math.log( tiledImage.minZoomImageRatio ) /\n                Math.log( 2 )\n            )\n        ),\n        highestLevel    = Math.min(\n            Math.abs(tiledImage.source.maxLevel),\n            Math.abs(Math.floor(\n                Math.log( zeroRatioC / tiledImage.minPixelRatio ) /\n                Math.log( 2 )\n            ))\n        ),\n        renderPixelRatioC,\n        renderPixelRatioT,\n        zeroRatioT,\n        optimalRatio,\n        levelOpacity,\n        levelVisibility;\n\n    // Reset tile\'s internal drawn state\n    while (tiledImage.lastDrawn.length > 0) {\n        tile = tiledImage.lastDrawn.pop();\n        tile.beingDrawn = false;\n    }\n\n    if (!tiledImage.wrapHorizontal && !tiledImage.wrapVertical) {\n        var tiledImageBounds = tiledImage.getClippedBounds(true);\n        var intersection = viewportBounds.intersection(tiledImageBounds);\n        if (intersection === null) {\n            return;\n        }\n        viewportBounds = intersection;\n    }\n    viewportBounds = viewportBounds.getBoundingBox();\n    viewportBounds.x -= tiledImage._xSpring.current.value;\n    viewportBounds.y -= tiledImage._ySpring.current.value;\n\n    var viewportTL = viewportBounds.getTopLeft();\n    var viewportBR = viewportBounds.getBottomRight();\n\n    //Don\'t draw if completely outside of the viewport\n    if  ( !tiledImage.wrapHorizontal && (viewportBR.x < 0 || viewportTL.x > tiledImage._worldWidthCurrent ) ) {\n        return;\n    }\n\n    if ( !tiledImage.wrapVertical && ( viewportBR.y < 0 || viewportTL.y > tiledImage._worldHeightCurrent ) ) {\n        return;\n    }\n\n    // Calculate viewport rect / bounds\n    if ( !tiledImage.wrapHorizontal ) {\n        viewportTL.x = Math.max( viewportTL.x, 0 );\n        viewportBR.x = Math.min( viewportBR.x, tiledImage._worldWidthCurrent );\n    }\n\n    if ( !tiledImage.wrapVertical ) {\n        viewportTL.y = Math.max( viewportTL.y, 0 );\n        viewportBR.y = Math.min( viewportBR.y, tiledImage._worldHeightCurrent );\n    }\n\n    // Calculations for the interval of levels to draw\n    // (above in initial var statement)\n    // can return invalid intervals; fix that here if necessary\n    lowestLevel = Math.min( lowestLevel, highestLevel );\n\n    // Update any level that will be drawn\n    var drawLevel; // FIXME: drawLevel should have a more explanatory name\n    for ( level = highestLevel; level >= lowestLevel; level-- ) {\n        drawLevel = false;\n\n        //Avoid calculations for draw if we have already drawn this\n        renderPixelRatioC = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio( level ),\n            true\n        ).x * tiledImage._scaleSpring.current.value;\n\n        if ( ( !haveDrawn && renderPixelRatioC >= tiledImage.minPixelRatio ) ||\n             ( level == lowestLevel ) ) {\n            drawLevel = true;\n            haveDrawn = true;\n        } else if ( !haveDrawn ) {\n            continue;\n        }\n\n        //Perform calculations for draw if we haven\'t drawn this\n        renderPixelRatioT = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio( level ),\n            false\n        ).x * tiledImage._scaleSpring.current.value;\n\n        zeroRatioT      = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio(\n                Math.max(\n                    tiledImage.source.getClosestLevel( tiledImage.viewport.containerSize ) - 1,\n                    0\n                )\n            ),\n            false\n        ).x * tiledImage._scaleSpring.current.value;\n\n        optimalRatio    = tiledImage.immediateRender ?\n            1 :\n            zeroRatioT;\n\n        levelOpacity    = Math.min( 1, ( renderPixelRatioC - 0.5 ) / 0.5 );\n\n        levelVisibility = optimalRatio / Math.abs(\n            optimalRatio - renderPixelRatioT\n        );\n\n        // Update the level and keep track of \'best\' tile to load\n        best = updateLevel(\n            tiledImage,\n            haveDrawn,\n            drawLevel,\n            level,\n            levelOpacity,\n            levelVisibility,\n            viewportTL,\n            viewportBR,\n            currentTime,\n            best\n        );\n\n        // Stop the loop if lower-res tiles would all be covered by\n        // already drawn tiles\n        if (  providesCoverage( tiledImage.coverage, level ) ) {\n            break;\n        }\n    }\n\n    // Perform the actual drawing\n    drawTiles( tiledImage, tiledImage.lastDrawn );\n\n    // Load the new \'best\' tile\n    if (best && !best.context2D) {\n        loadTile( tiledImage, best, currentTime );\n    }\n\n}\n\n\nfunction updateLevel( tiledImage, haveDrawn, drawLevel, level, levelOpacity, levelVisibility, viewportTL, viewportBR, currentTime, best ){\n\n    var x, y,\n        tileTL,\n        tileBR,\n        numberOfTiles,\n        viewportCenter  = tiledImage.viewport.pixelFromPoint( tiledImage.viewport.getCenter() );\n\n\n    if( tiledImage.viewer ){\n        /**\n         * <em>- Needs documentation -</em>\n         *\n         * @event update-level\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n         * @property {Object} havedrawn\n         * @property {Object} level\n         * @property {Object} opacity\n         * @property {Object} visibility\n         * @property {Object} topleft\n         * @property {Object} bottomright\n         * @property {Object} currenttime\n         * @property {Object} best\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        tiledImage.viewer.raiseEvent( \'update-level\', {\n            tiledImage: tiledImage,\n            havedrawn: haveDrawn,\n            level: level,\n            opacity: levelOpacity,\n            visibility: levelVisibility,\n            topleft: viewportTL,\n            bottomright: viewportBR,\n            currenttime: currentTime,\n            best: best\n        });\n    }\n\n    //OK, a new drawing so do your calculations\n    tileTL    = tiledImage.source.getTileAtPoint( level, viewportTL.divide( tiledImage._scaleSpring.current.value ));\n    tileBR    = tiledImage.source.getTileAtPoint( level, viewportBR.divide( tiledImage._scaleSpring.current.value ));\n    numberOfTiles  = tiledImage.source.getNumTiles( level );\n\n    resetCoverage( tiledImage.coverage, level );\n\n    if ( !tiledImage.wrapHorizontal ) {\n        tileBR.x = Math.min( tileBR.x, numberOfTiles.x - 1 );\n    }\n    if ( !tiledImage.wrapVertical ) {\n        tileBR.y = Math.min( tileBR.y, numberOfTiles.y - 1 );\n    }\n\n    for ( x = tileTL.x; x <= tileBR.x; x++ ) {\n        for ( y = tileTL.y; y <= tileBR.y; y++ ) {\n\n            best = updateTile(\n                tiledImage,\n                drawLevel,\n                haveDrawn,\n                x, y,\n                level,\n                levelOpacity,\n                levelVisibility,\n                viewportCenter,\n                numberOfTiles,\n                currentTime,\n                best\n            );\n\n        }\n    }\n\n    return best;\n}\n\nfunction updateTile( tiledImage, drawLevel, haveDrawn, x, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best){\n\n    var tile = getTile(\n            x, y,\n            level,\n            tiledImage.source,\n            tiledImage.tilesMatrix,\n            currentTime,\n            numberOfTiles,\n            tiledImage._worldWidthCurrent,\n            tiledImage._worldHeightCurrent\n        ),\n        drawTile = drawLevel;\n\n    if( tiledImage.viewer ){\n        /**\n         * <em>- Needs documentation -</em>\n         *\n         * @event update-tile\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n         * @property {OpenSeadragon.Tile} tile\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        tiledImage.viewer.raiseEvent( \'update-tile\', {\n            tiledImage: tiledImage,\n            tile: tile\n        });\n    }\n\n    setCoverage( tiledImage.coverage, level, x, y, false );\n\n    if ( !tile.exists ) {\n        return best;\n    }\n\n    if ( haveDrawn && !drawTile ) {\n        if ( isCovered( tiledImage.coverage, level, x, y ) ) {\n            setCoverage( tiledImage.coverage, level, x, y, true );\n        } else {\n            drawTile = true;\n        }\n    }\n\n    if ( !drawTile ) {\n        return best;\n    }\n\n    positionTile(\n        tile,\n        tiledImage.source.tileOverlap,\n        tiledImage.viewport,\n        viewportCenter,\n        levelVisibility,\n        tiledImage\n    );\n\n    if (!tile.loaded) {\n        if (tile.context2D) {\n            setTileLoaded(tiledImage, tile);\n        } else {\n            var imageRecord = tiledImage._tileCache.getImageRecord(tile.url);\n            if (imageRecord) {\n                var image = imageRecord.getImage();\n                setTileLoaded(tiledImage, tile, image);\n            }\n        }\n    }\n\n    if ( tile.loaded ) {\n        var needsDraw = blendTile(\n            tiledImage,\n            tile,\n            x, y,\n            level,\n            levelOpacity,\n            currentTime\n        );\n\n        if ( needsDraw ) {\n            tiledImage._needsDraw = true;\n        }\n    } else if ( tile.loading ) {\n        // the tile is already in the download queue\n        // thanks josh1093 for finally translating this typo\n    } else {\n        best = compareTiles( best, tile );\n    }\n\n    return best;\n}\n\nfunction getTile( x, y, level, tileSource, tilesMatrix, time, numTiles, worldWidth, worldHeight ) {\n    var xMod,\n        yMod,\n        bounds,\n        exists,\n        url,\n        context2D,\n        tile;\n\n    if ( !tilesMatrix[ level ] ) {\n        tilesMatrix[ level ] = {};\n    }\n    if ( !tilesMatrix[ level ][ x ] ) {\n        tilesMatrix[ level ][ x ] = {};\n    }\n\n    if ( !tilesMatrix[ level ][ x ][ y ] ) {\n        xMod    = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;\n        yMod    = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;\n        bounds  = tileSource.getTileBounds( level, xMod, yMod );\n        exists  = tileSource.tileExists( level, xMod, yMod );\n        url     = tileSource.getTileUrl( level, xMod, yMod );\n        context2D = tileSource.getContext2D ?\n            tileSource.getContext2D(level, xMod, yMod) : undefined;\n\n        bounds.x += ( x - xMod ) / numTiles.x;\n        bounds.y += (worldHeight / worldWidth) * (( y - yMod ) / numTiles.y);\n\n        tilesMatrix[ level ][ x ][ y ] = new $.Tile(\n            level,\n            x,\n            y,\n            bounds,\n            exists,\n            url,\n            context2D\n        );\n    }\n\n    tile = tilesMatrix[ level ][ x ][ y ];\n    tile.lastTouchTime = time;\n\n    return tile;\n}\n\nfunction loadTile( tiledImage, tile, time ) {\n    tile.loading = true;\n    tiledImage._imageLoader.addJob({\n        src: tile.url,\n        crossOriginPolicy: tiledImage.crossOriginPolicy,\n        callback: function( image, errorMsg ){\n            onTileLoad( tiledImage, tile, time, image, errorMsg );\n        },\n        abort: function() {\n            tile.loading = false;\n        }\n    });\n}\n\nfunction onTileLoad( tiledImage, tile, time, image, errorMsg ) {\n    if ( !image ) {\n        $.console.log( "Tile %s failed to load: %s - error: %s", tile, tile.url, errorMsg );\n        /**\n         * Triggered when a tile fails to load.\n         *\n         * @event tile-load-failed\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Tile} tile - The tile that failed to load.\n         * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image the tile belongs to.\n         * @property {number} time - The time in milliseconds when the tile load began.\n         * @property {string} message - The error message.\n         */\n        tiledImage.viewer.raiseEvent("tile-load-failed", {tile: tile, tiledImage: tiledImage, time: time, message: errorMsg});\n        tile.loading = false;\n        tile.exists = false;\n        return;\n    }\n\n    if ( time < tiledImage.lastResetTime ) {\n        $.console.log( "Ignoring tile %s loaded before reset: %s", tile, tile.url );\n        tile.loading = false;\n        return;\n    }\n\n    var finish = function() {\n        var cutoff = Math.ceil( Math.log(\n            tiledImage.source.getTileWidth(tile.level) ) / Math.log( 2 ) );\n        setTileLoaded(tiledImage, tile, image, cutoff);\n    };\n\n    // Check if we\'re mid-update; this can happen on IE8 because image load events for\n    // cached images happen immediately there\n    if ( !tiledImage._midDraw ) {\n        finish();\n    } else {\n        // Wait until after the update, in case caching unloads any tiles\n        window.setTimeout( finish, 1);\n    }\n}\n\nfunction setTileLoaded(tiledImage, tile, image, cutoff) {\n    var increment = 0;\n\n    function getCompletionCallback() {\n        increment++;\n        return completionCallback;\n    }\n\n    function completionCallback() {\n        increment--;\n        if (increment === 0) {\n            tile.loading = false;\n            tile.loaded = true;\n            if (!tile.context2D) {\n                tiledImage._tileCache.cacheTile({\n                    image: image,\n                    tile: tile,\n                    cutoff: cutoff,\n                    tiledImage: tiledImage\n                });\n            }\n            tiledImage._needsDraw = true;\n        }\n    }\n\n    /**\n     * Triggered when a tile has just been loaded in memory. That means that the\n     * image has been downloaded and can be modified before being drawn to the canvas.\n     *\n     * @event tile-loaded\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {Image} image - The image of the tile.\n     * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the loaded tile.\n     * @property {OpenSeadragon.Tile} tile - The tile which has been loaded.\n     * @property {function} getCompletionCallback - A function giving a callback to call\n     * when the asynchronous processing of the image is done. The image will be\n     * marked as entirely loaded when the callback has been called once for each\n     * call to getCompletionCallback.\n     */\n    tiledImage.viewer.raiseEvent("tile-loaded", {\n        tile: tile,\n        tiledImage: tiledImage,\n        image: image,\n        getCompletionCallback: getCompletionCallback\n    });\n    // In case the completion callback is never called, we at least force it once.\n    getCompletionCallback()();\n}\n\nfunction positionTile( tile, overlap, viewport, viewportCenter, levelVisibility, tiledImage ){\n    var boundsTL     = tile.bounds.getTopLeft();\n\n    boundsTL.x *= tiledImage._scaleSpring.current.value;\n    boundsTL.y *= tiledImage._scaleSpring.current.value;\n    boundsTL.x += tiledImage._xSpring.current.value;\n    boundsTL.y += tiledImage._ySpring.current.value;\n\n    var boundsSize   = tile.bounds.getSize();\n\n    boundsSize.x *= tiledImage._scaleSpring.current.value;\n    boundsSize.y *= tiledImage._scaleSpring.current.value;\n\n    var positionC    = viewport.pixelFromPointNoRotate(boundsTL, true),\n        positionT    = viewport.pixelFromPointNoRotate(boundsTL, false),\n        sizeC        = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true),\n        sizeT        = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false),\n        tileCenter   = positionT.plus( sizeT.divide( 2 ) ),\n        tileDistance = viewportCenter.distanceTo( tileCenter );\n\n    if ( !overlap ) {\n        sizeC = sizeC.plus( new $.Point( 1, 1 ) );\n    }\n\n    tile.position   = positionC;\n    tile.size       = sizeC;\n    tile.distance   = tileDistance;\n    tile.visibility = levelVisibility;\n}\n\n\nfunction blendTile( tiledImage, tile, x, y, level, levelOpacity, currentTime ){\n    var blendTimeMillis = 1000 * tiledImage.blendTime,\n        deltaTime,\n        opacity;\n\n    if ( !tile.blendStart ) {\n        tile.blendStart = currentTime;\n    }\n\n    deltaTime   = currentTime - tile.blendStart;\n    opacity     = blendTimeMillis ? Math.min( 1, deltaTime / ( blendTimeMillis ) ) : 1;\n\n    if ( tiledImage.alwaysBlend ) {\n        opacity *= levelOpacity;\n    }\n\n    tile.opacity = opacity;\n\n    tiledImage.lastDrawn.push( tile );\n\n    if ( opacity == 1 ) {\n        setCoverage( tiledImage.coverage, level, x, y, true );\n        tiledImage._hasOpaqueTile = true;\n    } else if ( deltaTime < blendTimeMillis ) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * @private\n * @inner\n * Returns true if the given tile provides coverage to lower-level tiles of\n * lower resolution representing the same content. If neither x nor y is\n * given, returns true if the entire visible level provides coverage.\n *\n * Note that out-of-bounds tiles provide coverage in this sense, since\n * there\'s no content that they would need to cover. Tiles at non-existent\n * levels that are within the image bounds, however, do not.\n */\nfunction providesCoverage( coverage, level, x, y ) {\n    var rows,\n        cols,\n        i, j;\n\n    if ( !coverage[ level ] ) {\n        return false;\n    }\n\n    if ( x === undefined || y === undefined ) {\n        rows = coverage[ level ];\n        for ( i in rows ) {\n            if ( rows.hasOwnProperty( i ) ) {\n                cols = rows[ i ];\n                for ( j in cols ) {\n                    if ( cols.hasOwnProperty( j ) && !cols[ j ] ) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    return (\n        coverage[ level ][ x] === undefined ||\n        coverage[ level ][ x ][ y ] === undefined ||\n        coverage[ level ][ x ][ y ] === true\n    );\n}\n\n/**\n * @private\n * @inner\n * Returns true if the given tile is completely covered by higher-level\n * tiles of higher resolution representing the same content. If neither x\n * nor y is given, returns true if the entire visible level is covered.\n */\nfunction isCovered( coverage, level, x, y ) {\n    if ( x === undefined || y === undefined ) {\n        return providesCoverage( coverage, level + 1 );\n    } else {\n        return (\n             providesCoverage( coverage, level + 1, 2 * x, 2 * y ) &&\n             providesCoverage( coverage, level + 1, 2 * x, 2 * y + 1 ) &&\n             providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y ) &&\n             providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y + 1 )\n        );\n    }\n}\n\n/**\n * @private\n * @inner\n * Sets whether the given tile provides coverage or not.\n */\nfunction setCoverage( coverage, level, x, y, covers ) {\n    if ( !coverage[ level ] ) {\n        $.console.warn(\n            "Setting coverage for a tile before its level\'s coverage has been reset: %s",\n            level\n        );\n        return;\n    }\n\n    if ( !coverage[ level ][ x ] ) {\n        coverage[ level ][ x ] = {};\n    }\n\n    coverage[ level ][ x ][ y ] = covers;\n}\n\n/**\n * @private\n * @inner\n * Resets coverage information for the given level. This should be called\n * after every draw routine. Note that at the beginning of the next draw\n * routine, coverage for every visible tile should be explicitly set.\n */\nfunction resetCoverage( coverage, level ) {\n    coverage[ level ] = {};\n}\n\n/**\n * @private\n * @inner\n * Determines whether the \'last best\' tile for the area is better than the\n * tile in question.\n */\nfunction compareTiles( previousBest, tile ) {\n    if ( !previousBest ) {\n        return tile;\n    }\n\n    if ( tile.visibility > previousBest.visibility ) {\n        return tile;\n    } else if ( tile.visibility == previousBest.visibility ) {\n        if ( tile.distance < previousBest.distance ) {\n            return tile;\n        }\n    }\n\n    return previousBest;\n}\n\nfunction drawTiles( tiledImage, lastDrawn ) {\n    if (lastDrawn.length === 0) {\n        return;\n    }\n    var tile = lastDrawn[0];\n\n    var useSketch = tiledImage.opacity < 1 ||\n        (tiledImage.compositeOperation &&\n            tiledImage.compositeOperation !== \'source-over\') ||\n        (!tiledImage._isBottomItem() && tile._hasTransparencyChannel());\n\n    var sketchScale;\n    var sketchTranslate;\n\n    var zoom = tiledImage.viewport.getZoom(true);\n    var imageZoom = tiledImage.viewportToImageZoom(zoom);\n    if (imageZoom > tiledImage.smoothTileEdgesMinZoom && !tiledImage.iOSDevice) {\n        // When zoomed in a lot (>100%) the tile edges are visible.\n        // So we have to composite them at ~100% and scale them up together.\n        // Note: Disabled on iOS devices per default as it causes a native crash\n        useSketch = true;\n        sketchScale = tile.getScaleForEdgeSmoothing();\n        sketchTranslate = tile.getTranslationForEdgeSmoothing(sketchScale,\n            tiledImage._drawer.getCanvasSize(false),\n            tiledImage._drawer.getCanvasSize(true));\n    }\n\n    var bounds;\n    if (useSketch) {\n        if (!sketchScale) {\n            // Except when edge smoothing, we only clean the part of the\n            // sketch canvas we are going to use for performance reasons.\n            bounds = tiledImage.viewport.viewportToViewerElementRectangle(\n                tiledImage.getClippedBounds(true))\n                .getIntegerBoundingBox()\n                .times($.pixelDensityRatio);\n        }\n        tiledImage._drawer._clear(true, bounds);\n    }\n\n    // When scaling, we must rotate only when blending the sketch canvas to avoid\n    // interpolation\n    if (tiledImage.viewport.degrees !== 0 && !sketchScale) {\n        tiledImage._drawer._offsetForRotation(tiledImage.viewport.degrees, useSketch);\n    }\n\n    var usedClip = false;\n    if ( tiledImage._clip ) {\n        tiledImage._drawer.saveContext(useSketch);\n\n        var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);\n        var clipRect = tiledImage._drawer.viewportToDrawerRectangle(box);\n        if (sketchScale) {\n            clipRect = clipRect.times(sketchScale);\n        }\n        if (sketchTranslate) {\n            clipRect = clipRect.translate(sketchTranslate);\n        }\n        tiledImage._drawer.setClip(clipRect, useSketch);\n\n        usedClip = true;\n    }\n\n    if ( tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false ) {\n        var placeholderRect = tiledImage._drawer.viewportToDrawerRectangle(tiledImage.getBounds(true));\n        if (sketchScale) {\n            placeholderRect = placeholderRect.times(sketchScale);\n        }\n        if (sketchTranslate) {\n            placeholderRect = placeholderRect.translate(sketchTranslate);\n        }\n\n        var fillStyle = null;\n        if ( typeof tiledImage.placeholderFillStyle === "function" ) {\n            fillStyle = tiledImage.placeholderFillStyle(tiledImage, tiledImage._drawer.context);\n        }\n        else {\n            fillStyle = tiledImage.placeholderFillStyle;\n        }\n\n        tiledImage._drawer.drawRectangle(placeholderRect, fillStyle, useSketch);\n    }\n\n    for (var i = lastDrawn.length - 1; i >= 0; i--) {\n        tile = lastDrawn[ i ];\n        tiledImage._drawer.drawTile( tile, tiledImage._drawingHandler, useSketch, sketchScale, sketchTranslate );\n        tile.beingDrawn = true;\n\n        if( tiledImage.viewer ){\n            /**\n             * <em>- Needs documentation -</em>\n             *\n             * @event tile-drawn\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n             * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n             * @property {OpenSeadragon.Tile} tile\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            tiledImage.viewer.raiseEvent( \'tile-drawn\', {\n                tiledImage: tiledImage,\n                tile: tile\n            });\n        }\n    }\n\n    if ( usedClip ) {\n        tiledImage._drawer.restoreContext( useSketch );\n    }\n\n    if (tiledImage.viewport.degrees !== 0 && !sketchScale) {\n        tiledImage._drawer._restoreRotationChanges(useSketch);\n    }\n\n    if (useSketch) {\n        var offsetForRotation = tiledImage.viewport.degrees !== 0 && sketchScale;\n        if (offsetForRotation) {\n            tiledImage._drawer._offsetForRotation(tiledImage.viewport.degrees, false);\n        }\n        tiledImage._drawer.blendSketch({\n            opacity: tiledImage.opacity,\n            scale: sketchScale,\n            translate: sketchTranslate,\n            compositeOperation: tiledImage.compositeOperation,\n            bounds: bounds\n        });\n        if (offsetForRotation) {\n            tiledImage._drawer._restoreRotationChanges(false);\n        }\n    }\n    drawDebugInfo( tiledImage, lastDrawn );\n}\n\nfunction drawDebugInfo( tiledImage, lastDrawn ) {\n    if( tiledImage.debugMode ) {\n        for ( var i = lastDrawn.length - 1; i >= 0; i-- ) {\n            var tile = lastDrawn[ i ];\n            try {\n                tiledImage._drawer.drawDebugInfo( tile, lastDrawn.length, i );\n            } catch(e) {\n                $.console.error(e);\n            }\n        }\n    }\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TileCache\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// private class\nvar TileRecord = function( options ) {\n    $.console.assert( options, "[TileCache.cacheTile] options is required" );\n    $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );\n    $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );\n    this.tile = options.tile;\n    this.tiledImage = options.tiledImage;\n};\n\n// private class\nvar ImageRecord = function(options) {\n    $.console.assert( options, "[ImageRecord] options is required" );\n    $.console.assert( options.image, "[ImageRecord] options.image is required" );\n    this._image = options.image;\n    this._tiles = [];\n};\n\nImageRecord.prototype = {\n    destroy: function() {\n        this._image = null;\n        this._renderedContext = null;\n        this._tiles = null;\n    },\n\n    getImage: function() {\n        return this._image;\n    },\n\n    getRenderedContext: function() {\n        if (!this._renderedContext) {\n            var canvas = document.createElement( \'canvas\' );\n            canvas.width = this._image.width;\n            canvas.height = this._image.height;\n            this._renderedContext = canvas.getContext(\'2d\');\n            this._renderedContext.drawImage( this._image, 0, 0 );\n            //since we are caching the prerendered image on a canvas\n            //allow the image to not be held in memory\n            this._image = null;\n        }\n        return this._renderedContext;\n    },\n\n    setRenderedContext: function(renderedContext) {\n        $.console.error("ImageRecord.setRenderedContext is deprecated. " +\n                "The rendered context should be created by the ImageRecord " +\n                "itself when calling ImageRecord.getRenderedContext.");\n        this._renderedContext = renderedContext;\n    },\n\n    addTile: function(tile) {\n        $.console.assert(tile, \'[ImageRecord.addTile] tile is required\');\n        this._tiles.push(tile);\n    },\n\n    removeTile: function(tile) {\n        for (var i = 0; i < this._tiles.length; i++) {\n            if (this._tiles[i] === tile) {\n                this._tiles.splice(i, 1);\n                return;\n            }\n        }\n\n        $.console.warn(\'[ImageRecord.removeTile] trying to remove unknown tile\', tile);\n    },\n\n    getTileCount: function() {\n        return this._tiles.length;\n    }\n};\n\n/**\n * @class TileCache\n * @memberof OpenSeadragon\n * @classdesc Stores all the tiles displayed in a {@link OpenSeadragon.Viewer}.\n * You generally won\'t have to interact with the TileCache directly.\n * @param {Object} options - Configuration for this TileCache.\n * @param {Number} [options.maxImageCacheCount] - See maxImageCacheCount in\n * {@link OpenSeadragon.Options} for details.\n */\n$.TileCache = function( options ) {\n    options = options || {};\n\n    this._maxImageCacheCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;\n    this._tilesLoaded = [];\n    this._imagesLoaded = [];\n    this._imagesLoadedCount = 0;\n};\n\n/** @lends OpenSeadragon.TileCache.prototype */\n$.TileCache.prototype = {\n    /**\n     * @returns {Number} The total number of tiles that have been loaded by\n     * this TileCache.\n     */\n    numTilesLoaded: function() {\n        return this._tilesLoaded.length;\n    },\n\n    /**\n     * Caches the specified tile, removing an old tile if necessary to stay under the\n     * maxImageCacheCount specified on construction. Note that if multiple tiles reference\n     * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep\n     * the number of images below that number. Note, as well, that even the number of images\n     * may temporarily surpass that number, but should eventually come back down to the max specified.\n     * @param {Object} options - Tile info.\n     * @param {OpenSeadragon.Tile} options.tile - The tile to cache.\n     * @param {Image} options.image - The image of the tile to cache.\n     * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.\n     * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this\n     * function will release an old tile. The cutoff option specifies a tile level at or below which\n     * tiles will not be released.\n     */\n    cacheTile: function( options ) {\n        $.console.assert( options, "[TileCache.cacheTile] options is required" );\n        $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );\n        $.console.assert( options.tile.url, "[TileCache.cacheTile] options.tile.url is required" );\n        $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );\n\n        var cutoff = options.cutoff || 0;\n        var insertionIndex = this._tilesLoaded.length;\n\n        var imageRecord = this._imagesLoaded[options.tile.url];\n        if (!imageRecord) {\n            $.console.assert( options.image, "[TileCache.cacheTile] options.image is required to create an ImageRecord" );\n            imageRecord = this._imagesLoaded[options.tile.url] = new ImageRecord({\n                image: options.image\n            });\n\n            this._imagesLoadedCount++;\n        }\n\n        imageRecord.addTile(options.tile);\n        options.tile.cacheImageRecord = imageRecord;\n\n        // Note that just because we\'re unloading a tile doesn\'t necessarily mean\n        // we\'re unloading an image. With repeated calls it should sort itself out, though.\n        if ( this._imagesLoadedCount > this._maxImageCacheCount ) {\n            var worstTile       = null;\n            var worstTileIndex  = -1;\n            var worstTileRecord = null;\n            var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;\n\n            for ( var i = this._tilesLoaded.length - 1; i >= 0; i-- ) {\n                prevTileRecord = this._tilesLoaded[ i ];\n                prevTile = prevTileRecord.tile;\n\n                if ( prevTile.level <= cutoff || prevTile.beingDrawn ) {\n                    continue;\n                } else if ( !worstTile ) {\n                    worstTile       = prevTile;\n                    worstTileIndex  = i;\n                    worstTileRecord = prevTileRecord;\n                    continue;\n                }\n\n                prevTime    = prevTile.lastTouchTime;\n                worstTime   = worstTile.lastTouchTime;\n                prevLevel   = prevTile.level;\n                worstLevel  = worstTile.level;\n\n                if ( prevTime < worstTime ||\n                   ( prevTime == worstTime && prevLevel > worstLevel ) ) {\n                    worstTile       = prevTile;\n                    worstTileIndex  = i;\n                    worstTileRecord = prevTileRecord;\n                }\n            }\n\n            if ( worstTile && worstTileIndex >= 0 ) {\n                this._unloadTile(worstTileRecord);\n                insertionIndex = worstTileIndex;\n            }\n        }\n\n        this._tilesLoaded[ insertionIndex ] = new TileRecord({\n            tile: options.tile,\n            tiledImage: options.tiledImage\n        });\n    },\n\n    /**\n     * Clears all tiles associated with the specified tiledImage.\n     * @param {OpenSeadragon.TiledImage} tiledImage\n     */\n    clearTilesFor: function( tiledImage ) {\n        $.console.assert(tiledImage, \'[TileCache.clearTilesFor] tiledImage is required\');\n        var tileRecord;\n        for ( var i = 0; i < this._tilesLoaded.length; ++i ) {\n            tileRecord = this._tilesLoaded[ i ];\n            if ( tileRecord.tiledImage === tiledImage ) {\n                this._unloadTile(tileRecord);\n                this._tilesLoaded.splice( i, 1 );\n                i--;\n            }\n        }\n    },\n\n    // private\n    getImageRecord: function(url) {\n        $.console.assert(url, \'[TileCache.getImageRecord] url is required\');\n        return this._imagesLoaded[url];\n    },\n\n    // private\n    _unloadTile: function(tileRecord) {\n        $.console.assert(tileRecord, \'[TileCache._unloadTile] tileRecord is required\');\n        var tile = tileRecord.tile;\n        var tiledImage = tileRecord.tiledImage;\n\n        tile.unload();\n        tile.cacheImageRecord = null;\n\n        var imageRecord = this._imagesLoaded[tile.url];\n        imageRecord.removeTile(tile);\n        if (!imageRecord.getTileCount()) {\n            imageRecord.destroy();\n            delete this._imagesLoaded[tile.url];\n            this._imagesLoadedCount--;\n        }\n\n        /**\n         * Triggered when a tile has just been unloaded from memory.\n         *\n         * @event tile-unloaded\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the unloaded tile.\n         * @property {OpenSeadragon.Tile} tile - The tile which has been unloaded.\n         */\n        tiledImage.viewer.raiseEvent("tile-unloaded", {\n            tile: tile,\n            tiledImage: tiledImage\n        });\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - World\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class World\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @classdesc Keeps track of all of the tiled images in the scene.\n * @param {Object} options - World options.\n * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this World.\n **/\n$.World = function( options ) {\n    var _this = this;\n\n    $.console.assert( options.viewer, "[World] options.viewer is required" );\n\n    $.EventSource.call( this );\n\n    this.viewer = options.viewer;\n    this._items = [];\n    this._needsDraw = false;\n    this._autoRefigureSizes = true;\n    this._needsSizesFigured = false;\n    this._delegatedFigureSizes = function(event) {\n        if (_this._autoRefigureSizes) {\n            _this._figureSizes();\n        } else {\n            _this._needsSizesFigured = true;\n        }\n    };\n\n    this._figureSizes();\n};\n\n$.extend( $.World.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.World.prototype */{\n    /**\n     * Add the specified item.\n     * @param {OpenSeadragon.TiledImage} item - The item to add.\n     * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.\n     * @fires OpenSeadragon.World.event:add-item\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    addItem: function( item, options ) {\n        $.console.assert(item, "[World.addItem] item is required");\n        $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");\n\n        options = options || {};\n        if (options.index !== undefined) {\n            var index = Math.max(0, Math.min(this._items.length, options.index));\n            this._items.splice(index, 0, item);\n        } else {\n            this._items.push( item );\n        }\n\n        if (this._autoRefigureSizes) {\n            this._figureSizes();\n        } else {\n            this._needsSizesFigured = true;\n        }\n\n        this._needsDraw = true;\n\n        item.addHandler(\'bounds-change\', this._delegatedFigureSizes);\n\n        /**\n         * Raised when an item is added to the World.\n         * @event add-item\n         * @memberOf OpenSeadragon.World\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the World which raised the event.\n         * @property {OpenSeadragon.TiledImage} item - The item that has been added.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'add-item\', {\n            item: item\n        } );\n    },\n\n    /**\n     * Get the item at the specified index.\n     * @param {Number} index - The item\'s index.\n     * @returns {OpenSeadragon.TiledImage} The item at the specified index.\n     */\n    getItemAt: function( index ) {\n        $.console.assert(index !== undefined, "[World.getItemAt] index is required");\n        return this._items[ index ];\n    },\n\n    /**\n     * Get the index of the given item or -1 if not present.\n     * @param {OpenSeadragon.TiledImage} item - The item.\n     * @returns {Number} The index of the item or -1 if not present.\n     */\n    getIndexOfItem: function( item ) {\n        $.console.assert(item, "[World.getIndexOfItem] item is required");\n        return $.indexOf( this._items, item );\n    },\n\n    /**\n     * @returns {Number} The number of items used.\n     */\n    getItemCount: function() {\n        return this._items.length;\n    },\n\n    /**\n     * Change the index of a item so that it appears over or under others.\n     * @param {OpenSeadragon.TiledImage} item - The item to move.\n     * @param {Number} index - The new index.\n     * @fires OpenSeadragon.World.event:item-index-change\n     */\n    setItemIndex: function( item, index ) {\n        $.console.assert(item, "[World.setItemIndex] item is required");\n        $.console.assert(index !== undefined, "[World.setItemIndex] index is required");\n\n        var oldIndex = this.getIndexOfItem( item );\n\n        if ( index >= this._items.length ) {\n            throw new Error( "Index bigger than number of layers." );\n        }\n\n        if ( index === oldIndex || oldIndex === -1 ) {\n            return;\n        }\n\n        this._items.splice( oldIndex, 1 );\n        this._items.splice( index, 0, item );\n        this._needsDraw = true;\n\n        /**\n         * Raised when the order of the indexes has been changed.\n         * @event item-index-change\n         * @memberOf OpenSeadragon.World\n         * @type {object}\n         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.\n         * @property {OpenSeadragon.TiledImage} item - The item whose index has\n         * been changed\n         * @property {Number} previousIndex - The previous index of the item\n         * @property {Number} newIndex - The new index of the item\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'item-index-change\', {\n            item: item,\n            previousIndex: oldIndex,\n            newIndex: index\n        } );\n    },\n\n    /**\n     * Remove an item.\n     * @param {OpenSeadragon.TiledImage} item - The item to remove.\n     * @fires OpenSeadragon.World.event:remove-item\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    removeItem: function( item ) {\n        $.console.assert(item, "[World.removeItem] item is required");\n\n        var index = $.indexOf(this._items, item );\n        if ( index === -1 ) {\n            return;\n        }\n\n        item.removeHandler(\'bounds-change\', this._delegatedFigureSizes);\n        item.destroy();\n        this._items.splice( index, 1 );\n        this._figureSizes();\n        this._needsDraw = true;\n        this._raiseRemoveItem(item);\n    },\n\n    /**\n     * Remove all items.\n     * @fires OpenSeadragon.World.event:remove-item\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    removeAll: function() {\n        // We need to make sure any pending images are canceled so the world items don\'t get messed up\n        this.viewer._cancelPendingImages();\n        var item;\n        for (var i = 0; i < this._items.length; i++) {\n            item = this._items[i];\n            item.removeHandler(\'bounds-change\', this._delegatedFigureSizes);\n            item.destroy();\n        }\n\n        var removedItems = this._items;\n        this._items = [];\n        this._figureSizes();\n        this._needsDraw = true;\n\n        for (i = 0; i < removedItems.length; i++) {\n            item = removedItems[i];\n            this._raiseRemoveItem(item);\n        }\n    },\n\n    /**\n     * Clears all tiles and triggers updates for all items.\n     */\n    resetItems: function() {\n        for ( var i = 0; i < this._items.length; i++ ) {\n            this._items[i].reset();\n        }\n    },\n\n    /**\n     * Updates (i.e. animates bounds of) all items.\n     */\n    update: function() {\n        var animated = false;\n        for ( var i = 0; i < this._items.length; i++ ) {\n            animated = this._items[i].update() || animated;\n        }\n\n        return animated;\n    },\n\n    /**\n     * Draws all items.\n     */\n    draw: function() {\n        for ( var i = 0; i < this._items.length; i++ ) {\n            this._items[i].draw();\n        }\n\n        this._needsDraw = false;\n    },\n\n    /**\n     * @returns {Boolean} true if any items need updating.\n     */\n    needsDraw: function() {\n        for ( var i = 0; i < this._items.length; i++ ) {\n            if ( this._items[i].needsDraw() ) {\n                return true;\n            }\n        }\n        return this._needsDraw;\n    },\n\n    /**\n     * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.\n     */\n    getHomeBounds: function() {\n        return this._homeBounds.clone();\n    },\n\n    /**\n     * To facilitate zoom constraints, we keep track of the pixel density of the\n     * densest item in the World (i.e. the item whose content size to viewport size\n     * ratio is the highest) and save it as this "content factor".\n     * @returns {Number} the number of content units per viewport unit.\n     */\n    getContentFactor: function() {\n        return this._contentFactor;\n    },\n\n    /**\n     * As a performance optimization, setting this flag to false allows the bounds-change event handler\n     * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in\n     * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true\n     * or the system may behave oddly.\n     * @param {Boolean} [value] The value to which to set the flag.\n     */\n    setAutoRefigureSizes: function(value) {\n        this._autoRefigureSizes = value;\n        if (value & this._needsSizesFigured) {\n            this._figureSizes();\n            this._needsSizesFigured = false;\n        }\n    },\n\n    /**\n     * Arranges all of the TiledImages with the specified settings.\n     * @param {Object} options - Specifies how to arrange.\n     * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.\n     * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    arrange: function(options) {\n        options = options || {};\n        var immediately = options.immediately || false;\n        var layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;\n        var rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;\n        var columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;\n        var tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;\n        var tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;\n        var increment = tileSize + tileMargin;\n        var wrap;\n        if (!options.rows && columns) {\n            wrap = columns;\n        } else {\n            wrap = Math.ceil(this._items.length / rows);\n        }\n        var x = 0;\n        var y = 0;\n        var item, box, width, height, position;\n\n        this.setAutoRefigureSizes(false);\n        for (var i = 0; i < this._items.length; i++) {\n            if (i && (i % wrap) === 0) {\n                if (layout === \'horizontal\') {\n                    y += increment;\n                    x = 0;\n                } else {\n                    x += increment;\n                    y = 0;\n                }\n            }\n\n            item = this._items[i];\n            box = item.getBounds();\n            if (box.width > box.height) {\n                width = tileSize;\n            } else {\n                width = tileSize * (box.width / box.height);\n            }\n\n            height = width * (box.height / box.width);\n            position = new $.Point(x + ((tileSize - width) / 2),\n                y + ((tileSize - height) / 2));\n\n            item.setPosition(position, immediately);\n            item.setWidth(width, immediately);\n\n            if (layout === \'horizontal\') {\n                x += increment;\n            } else {\n                y += increment;\n            }\n        }\n        this.setAutoRefigureSizes(true);\n    },\n\n    // private\n    _figureSizes: function() {\n        var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;\n        var oldContentSize = this._contentSize ? this._contentSize.clone() : null;\n        var oldContentFactor = this._contentFactor || 0;\n\n        if (!this._items.length) {\n            this._homeBounds = new $.Rect(0, 0, 1, 1);\n            this._contentSize = new $.Point(1, 1);\n            this._contentFactor = 1;\n        } else {\n            var item = this._items[0];\n            var bounds = item.getBounds();\n            this._contentFactor = item.getContentSize().x / bounds.width;\n            var clippedBounds = item.getClippedBounds();\n            var left = clippedBounds.x;\n            var top = clippedBounds.y;\n            var right = clippedBounds.x + clippedBounds.width;\n            var bottom = clippedBounds.y + clippedBounds.height;\n            for (var i = 1; i < this._items.length; i++) {\n                item = this._items[i];\n                bounds = item.getBounds();\n                this._contentFactor = Math.max(this._contentFactor,\n                    item.getContentSize().x / bounds.width);\n                clippedBounds = item.getClippedBounds();\n                left = Math.min(left, clippedBounds.x);\n                top = Math.min(top, clippedBounds.y);\n                right = Math.max(right, clippedBounds.x + clippedBounds.width);\n                bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);\n            }\n\n            this._homeBounds = new $.Rect(left, top, right - left, bottom - top);\n            this._contentSize = new $.Point(\n                this._homeBounds.width * this._contentFactor,\n                this._homeBounds.height * this._contentFactor);\n        }\n\n        if (this._contentFactor !== oldContentFactor ||\n            !this._homeBounds.equals(oldHomeBounds) ||\n            !this._contentSize.equals(oldContentSize)) {\n            /**\n             * Raised when the home bounds or content factor change.\n             * @event metrics-change\n             * @memberOf OpenSeadragon.World\n             * @type {object}\n             * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent(\'metrics-change\', {});\n        }\n    },\n\n    // private\n    _raiseRemoveItem: function(item) {\n        /**\n         * Raised when an item is removed.\n         * @event remove-item\n         * @memberOf OpenSeadragon.World\n         * @type {object}\n         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.\n         * @property {OpenSeadragon.TiledImage} item - The item\'s underlying item.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'remove-item\', { item: item } );\n    }\n});\n\n}( OpenSeadragon ));\n\n//# sourceMappingURL=openseadragon.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9vcGVuc2VhZHJhZ29uL2J1aWxkL29wZW5zZWFkcmFnb24vb3BlbnNlYWRyYWdvbi5qcz80MjBmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxzRUFBc0U7QUFDdEUsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsU0FBUyx5Q0FBeUM7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBNkM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxnRUFBZ0U7QUFDOUk7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakU7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUUsNEJBQTRCO0FBQ25HO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUtBQXVLO0FBQzVNLHFDQUFxQyx1S0FBdUs7QUFDNU0scUNBQXFDLHVLQUF1SztBQUM1TSxxQ0FBcUMsdUtBQXVLO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFD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RUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsZ0RBQWdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFB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QTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUMsa0JBQWtCLHdCQUF3QjtBQUMxQyxrQkFBa0Isd0JBQXdCO0FBQzFDLGtCQUFrQix3QkFBd0I7QUFDMUMsa0JBQWtCLHdCQUF3QjtBQUMxQyxrQkFBa0Isd0JBQXdCO0FBQzFDLGtCQUFrQix3QkFBd0I7QUFDMUMsa0JBQWtCLHdCQUF3QjtBQUMxQyxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDLEVBQUUsU0FBUzs7QUFFM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FB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LHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IseUJBQXlCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwwQkFBMEIsb0JBQW9CO0FBQzlDLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsc0JBQXNCLG9CQUFvQjtBQUMxQyxzQkFBc0IseUJBQXlCO0FBQy9DLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQSxDQUFDOztBQUVELENBQUM7O0FBRUQiLCJmaWxlIjoiMTA1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8hIG9wZW5zZWFkcmFnb24gMi4yLjFcbi8vISBCdWlsdCBvbiAyMDE2LTA3LTAxXG4vLyEgR2l0IGNvbW1pdDogdjIuMi4xLTAtYmFiZGVmZFxuLy8hIGh0dHA6Ly9vcGVuc2VhZHJhZ29uLmdpdGh1Yi5pb1xuLy8hIExpY2Vuc2U6IGh0dHA6Ly9vcGVuc2VhZHJhZ29uLmdpdGh1Yi5pby9saWNlbnNlL1xuXG4vKlxuICogT3BlblNlYWRyYWdvblxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKlxuICogUG9ydGlvbnMgb2YgdGhpcyBzb3VyY2UgZmlsZSB0YWtlbiBmcm9tIGpRdWVyeTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBKb2huIFJlc2lnXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypcbiAqIFBvcnRpb25zIG9mIHRoaXMgc291cmNlIGZpbGUgdGFrZW4gZnJvbSBtYXR0c25pZGVyLmNvbTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAxMyBNYXR0IFNuaWRlclxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbiAqIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlRcbiAqIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUlxuICogVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgT3BlblNlYWRyYWdvblxuICogQHZlcnNpb24gb3BlbnNlYWRyYWdvbiAyLjIuMVxuICogQGNsYXNzZGVzYyBUaGUgcm9vdCBuYW1lc3BhY2UgZm9yIE9wZW5TZWFkcmFnb24uICBBbGwgdXRpbGl0eSBtZXRob2RzXG4gKiBhbmQgY2xhc3NlcyBhcmUgZGVmaW5lZCBvbiBvciBiZWxvdyB0aGlzIG5hbWVzcGFjZS5cbiAqXG4gKi9cblxuXG4vLyBUeXBlZGVmc1xuXG4gLyoqXG4gICogQWxsIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBzZXR0aW5ncyBmb3IgaW5zdGFudGlhdGluZyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBPcGVuU2VhZHJhZ29uIGltYWdlIHZpZXdlci5cbiAgKlxuICAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGlkXG4gICogICAgIElkIG9mIHRoZSBlbGVtZW50IHRvIGFwcGVuZCB0aGUgdmlld2VyJ3MgY29udGFpbmVyIGVsZW1lbnQgdG8uIElmIG5vdCBwcm92aWRlZCwgdGhlICdlbGVtZW50JyBwcm9wZXJ0eSBtdXN0IGJlIHByb3ZpZGVkLlxuICAqICAgICBJZiBib3RoIHRoZSBlbGVtZW50IGFuZCBpZCBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQsIHRoZSB2aWV3ZXIgaXMgYXBwZW5kZWQgdG8gdGhlIGVsZW1lbnQgcHJvdmlkZWQgaW4gdGhlIGVsZW1lbnQgcHJvcGVydHkuXG4gICpcbiAgKiBAcHJvcGVydHkge0VsZW1lbnR9IGVsZW1lbnRcbiAgKiAgICAgVGhlIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB2aWV3ZXIncyBjb250YWluZXIgZWxlbWVudCB0by4gSWYgbm90IHByb3ZpZGVkLCB0aGUgJ2lkJyBwcm9wZXJ0eSBtdXN0IGJlIHByb3ZpZGVkLlxuICAqICAgICBJZiBib3RoIHRoZSBlbGVtZW50IGFuZCBpZCBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQsIHRoZSB2aWV3ZXIgaXMgYXBwZW5kZWQgdG8gdGhlIGVsZW1lbnQgcHJvdmlkZWQgaW4gdGhlIGVsZW1lbnQgcHJvcGVydHkuXG4gICpcbiAgKiBAcHJvcGVydHkge0FycmF5fFN0cmluZ3xGdW5jdGlvbnxPYmplY3R9IFt0aWxlU291cmNlcz1udWxsXVxuICAqICAgICBUaWxlIHNvdXJjZShzKSB0byBvcGVuIGluaXRpYWxseS4gVGhpcyBpcyBhIGNvbXBsZXggcGFyYW1ldGVyOyBzZWVcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI29wZW59IGZvciBkZXRhaWxzLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0YWJJbmRleD0wXVxuICAqICAgICBUYWJiaW5nIG9yZGVyIGluZGV4IHRvIGFzc2lnbiB0byB0aGUgdmlld2VyIGVsZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBhcmUgc2VsZWN0ZWQgaW4gaW5jcmVhc2luZyBvcmRlci4gV2hlbiB0YWJJbmRleCBpcyAwXG4gICogICAgIHNvdXJjZSBvcmRlciBpcyB1c2VkLiBBIG5lZ2F0aXZlIHZhbHVlIG9taXRzIHRoZSB2aWV3ZXIgZnJvbSB0aGUgdGFiYmluZyBvcmRlci5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG92ZXJsYXlzIEFycmF5IG9mIG9iamVjdHMgZGVmaW5pbmcgcGVybWFuZW50IG92ZXJsYXlzIG9mXG4gICogICAgIHRoZSB2aWV3ZXIuIFRoZSBvdmVybGF5cyBhZGRlZCB2aWEgdGhpcyBvcHRpb24gYW5kIGxhdGVyIHJlbW92ZWQgd2l0aFxuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjcmVtb3ZlT3ZlcmxheX0gd2lsbCBiZSBhZGRlZCBiYWNrIHdoZW4gYSBuZXdcbiAgKiAgICAgaW1hZ2UgaXMgb3BlbmVkLlxuICAqICAgICBUbyBhZGQgb3ZlcmxheXMgd2hpY2ggY2FuIGJlIGRlZmluaXRpdmVseSByZW1vdmVkLCBvbmUgbXVzdCB1c2VcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZE92ZXJsYXl9XG4gICogICAgIElmIGRpc3BsYXlpbmcgYSBzZXF1ZW5jZSBvZiBpbWFnZXMsIHRoZSBvdmVybGF5cyBjYW4gYmUgYXNzb2NpYXRlZFxuICAqICAgICB3aXRoIGEgc3BlY2lmaWMgcGFnZSBieSBwYXNzaW5nIHRoZSBvdmVybGF5cyBhcnJheSB0byB0aGUgcGFnZSdzXG4gICogICAgIHRpbGUgc291cmNlIGNvbmZpZ3VyYXRpb24uXG4gICogICAgIEV4cGVjdGVkIHByb3BlcnRpZXM6XG4gICogICAgICogeCwgeSwgKG9yIHB4LCBweSBmb3IgcGl4ZWwgY29vcmRpbmF0ZXMpIHRvIGRlZmluZSB0aGUgbG9jYXRpb24uXG4gICogICAgICogd2lkdGgsIGhlaWdodCBpbiBwb2ludCBpZiB1c2luZyB4LHkgb3IgaW4gcGl4ZWxzIGlmIHVzaW5nIHB4LHB5LiBJZiB3aWR0aFxuICAqICAgICAgIGFuZCBoZWlnaHQgYXJlIHNwZWNpZmllZCwgdGhlIG92ZXJsYXkgc2l6ZSBpcyBhZGp1c3RlZCB3aGVuIHpvb21pbmcsXG4gICogICAgICAgb3RoZXJ3aXNlIHRoZSBzaXplIHN0YXlzIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IChvciB0aGUgc2l6ZSBkZWZpbmVkIGJ5IENTUykuXG4gICogICAgICogY2xhc3NOYW1lIHRvIGFzc29jaWF0ZSBhIGNsYXNzIHRvIHRoZSBvdmVybGF5XG4gICogICAgICogaWQgdG8gc2V0IHRoZSBvdmVybGF5IGVsZW1lbnQuIElmIGFuIGVsZW1lbnQgd2l0aCB0aGlzIGlkIGFscmVhZHkgZXhpc3RzLFxuICAqICAgICAgIGl0IGlzIHJldXNlZCwgb3RoZXJ3aXNlIGl0IGlzIGNyZWF0ZWQuIElmIG5vdCBzcGVjaWZpZWQsIGEgbmV3IGVsZW1lbnQgaXNcbiAgKiAgICAgICBjcmVhdGVkLlxuICAqICAgICAqIHBsYWNlbWVudCBhIHN0cmluZyB0byBkZWZpbmUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSB2aWV3cG9ydC5cbiAgKiAgICAgICBPbmx5IHVzZWQgaWYgbm8gd2lkdGggYW5kIGhlaWdodCBhcmUgc3BlY2lmaWVkLiBEZWZhdWx0OiAnVE9QX0xFRlQnLlxuICAqICAgICAgIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IGZvciBwb3NzaWJsZSB2YWx1ZXMuXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gW3htbFBhdGg9bnVsbF1cbiAgKiAgICAgPHN0cm9uZz5ERVBSRUNBVEVEPC9zdHJvbmc+LiBBIHJlbGF0aXZlIHBhdGggdG8gbG9hZCBhIERaSSBmaWxlIGZyb20gdGhlIHNlcnZlci5cbiAgKiAgICAgUHJlZmVyIHRoZSBuZXdlciBPcHRpb25zLnRpbGVTb3VyY2VzLlxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcmVmaXhVcmw9Jy9pbWFnZXMvJ11cbiAgKiAgICAgUHJlcGVuZHMgdGhlIHByZWZpeFVybCB0byBuYXZJbWFnZXMgcGF0aHMsIHdoaWNoIGlzIHZlcnkgdXNlZnVsXG4gICogICAgIHNpbmNlIHRoZSBkZWZhdWx0IHBhdGhzIGFyZSByYXJlbHkgdXNlZnVsIGZvciBwcm9kdWN0aW9uXG4gICogICAgIGVudmlyb25tZW50cy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5OYXZJbWFnZXN9IFtuYXZJbWFnZXNdXG4gICogICAgIEFuIG9iamVjdCB3aXRoIGEgcHJvcGVydHkgZm9yIGVhY2ggYnV0dG9uIG9yIG90aGVyIGJ1aWx0LWluIG5hdmlnYXRpb25cbiAgKiAgICAgY29udHJvbCwgZWcgdGhlIGN1cnJlbnQgJ3pvb21JbicsICd6b29tT3V0JywgJ2hvbWUnLCBhbmQgJ2Z1bGxwYWdlJy5cbiAgKiAgICAgRWFjaCBvZiB0aG9zZSBpbiB0dXJuIHByb3ZpZGVzIGFuIGltYWdlIHBhdGggZm9yIGVhY2ggc3RhdGUgb2YgdGhlIGJ1dHRvblxuICAqICAgICBvciBuYXZpZ2F0aW9uIGNvbnRyb2wsIGVnICdSRVNUJywgJ0dST1VQJywgJ0hPVkVSJywgJ1BSRVNTJy4gRmluYWxseSB0aGVcbiAgKiAgICAgaW1hZ2UgcGF0aHMsIGJ5IGRlZmF1bHQgYXNzdW1lIHRoZXJlIGlzIGEgZm9sZGVyIG9uIHRoZSBzZXJ2ZXJzIHJvb3QgcGF0aFxuICAqICAgICBjYWxsZWQgJy9pbWFnZXMnLCBlZyAnL2ltYWdlcy96b29taW5fcmVzdC5wbmcnLiAgSWYgeW91IG5lZWQgdG8gYWRqdXN0XG4gICogICAgIHRoZXNlIHBhdGhzLCBwcmVmZXIgc2V0dGluZyB0aGUgb3B0aW9uLnByZWZpeFVybCByYXRoZXIgdGhhbiBvdmVycmlkaW5nXG4gICogICAgIGV2ZXJ5IGltYWdlIHBhdGggZGlyZWN0bHkgdGhyb3VnaCB0aGlzIHNldHRpbmcuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkZWJ1Z01vZGU9ZmFsc2VdXG4gICogICAgIFRPRE86IHByb3ZpZGUgYW4gaW4tc2NyZWVuIHBhbmVsIHByb3ZpZGluZyBldmVudCBkZXRhaWwgZmVlZGJhY2suXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gW2RlYnVnR3JpZENvbG9yPScjNDM3QUIyJ11cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmxlbmRUaW1lPTBdXG4gICogICAgIFNwZWNpZmllcyB0aGUgZHVyYXRpb24gb2YgYW5pbWF0aW9uIGFzIGhpZ2hlciBvciBsb3dlciBsZXZlbCB0aWxlcyBhcmVcbiAgKiAgICAgcmVwbGFjaW5nIHRoZSBleGlzdGluZyB0aWxlLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbYWx3YXlzQmxlbmQ9ZmFsc2VdXG4gICogICAgIEZvcmNlcyB0aGUgdGlsZSB0byBhbHdheXMgYmxlbmQuICBCeSBkZWZhdWx0IHRoZSB0aWxlcyBza2lwIGJsZW5kaW5nXG4gICogICAgIHdoZW4gdGhlIGJsZW5kVGltZSBpcyBzdXJwYXNzZWQgYW5kIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZSB3b3VsZFxuICAqICAgICBub3QgY29tcGxldGUgdGhlIGJsZW5kLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbYXV0b0hpZGVDb250cm9scz10cnVlXVxuICAqICAgICBJZiB0aGUgdXNlciBzdG9wcyBpbnRlcmFjdGluZyB3aXRoIHRoZSB2aWV3cG9ydCwgZmFkZSB0aGUgbmF2aWdhdGlvblxuICAqICAgICBjb250cm9scy4gIFVzZWZ1bCBmb3IgcHJlc2VudGF0aW9uIHNpbmNlIHRoZSBjb250cm9scyBhcmUgYnkgZGVmYXVsdFxuICAqICAgICBmbG9hdGVkIG9uIHRvcCBvZiB0aGUgaW1hZ2UgdGhlIHVzZXIgaXMgdmlld2luZy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ltbWVkaWF0ZVJlbmRlcj1mYWxzZV1cbiAgKiAgICAgUmVuZGVyIHRoZSBiZXN0IGNsb3Nlc3QgbGV2ZWwgZmlyc3QsIGlnbm9yaW5nIHRoZSBsb3dlcmluZyBsZXZlbHMgd2hpY2hcbiAgKiAgICAgcHJvdmlkZSB0aGUgZWZmZWN0IG9mIHZlcnkgYmx1cnJ5IHRvIHNoYXJwLiBJdCBpcyByZWNvbW1lbmRlZCB0byBjaGFuZ2VcbiAgKiAgICAgc2V0dGluZyB0byB0cnVlIGZvciBtb2JpbGUgZGV2aWNlcy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGVmYXVsdFpvb21MZXZlbD0wXVxuICAqICAgICBab29tIGxldmVsIHRvIHVzZSB3aGVuIGltYWdlIGlzIGZpcnN0IG9wZW5lZCBvciB0aGUgaG9tZSBidXR0b24gaXMgY2xpY2tlZC5cbiAgKiAgICAgSWYgMCwgYWRqdXN0cyB0byBmaXQgdmlld2VyLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtvcGFjaXR5PTFdXG4gICogICAgIERlZmF1bHQgb3BhY2l0eSBvZiB0aGUgdGlsZWQgaW1hZ2VzICgxPW9wYXF1ZSwgMD10cmFuc3BhcmVudClcbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29tcG9zaXRlT3BlcmF0aW9uPW51bGxdXG4gICogICAgIFZhbGlkIHZhbHVlcyBhcmUgJ3NvdXJjZS1vdmVyJywgJ3NvdXJjZS1hdG9wJywgJ3NvdXJjZS1pbicsICdzb3VyY2Utb3V0JyxcbiAgKiAgICAgJ2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24tYXRvcCcsICdkZXN0aW5hdGlvbi1pbicsXG4gICogICAgICdkZXN0aW5hdGlvbi1vdXQnLCAnbGlnaHRlcicsICdjb3B5JyBvciAneG9yJ1xuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd8Q2FudmFzR3JhZGllbnR8Q2FudmFzUGF0dGVybnxGdW5jdGlvbn0gW3BsYWNlaG9sZGVyRmlsbFN0eWxlPW51bGxdXG4gICogICAgIERyYXdzIGEgY29sb3JlZCByZWN0YW5nbGUgYmVoaW5kIHRoZSB0aWxlIGlmIGl0IGlzIG5vdCBsb2FkZWQgeWV0LlxuICAqICAgICBZb3UgY2FuIHBhc3MgYSBDU1MgY29sb3IgdmFsdWUgbGlrZSBcIiNGRjg4MDBcIi5cbiAgKiAgICAgV2hlbiBwYXNzaW5nIGEgZnVuY3Rpb24gdGhlIHRpbGVkSW1hZ2UgYW5kIGNhbnZhcyBjb250ZXh0IGFyZSBhdmFpbGFibGUgYXMgYXJndW1lbnQgd2hpY2ggaXMgdXNlZnVsIHdoZW4geW91IGRyYXcgYSBncmFkaWVudCBvciBwYXR0ZXJuLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkZWdyZWVzPTBdXG4gICogICAgIEluaXRpYWwgcm90YXRpb24uXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW21pblpvb21MZXZlbD1udWxsXVxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYXhab29tTGV2ZWw9bnVsbF1cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2hvbWVGaWxsc1ZpZXdlcj1mYWxzZV1cbiAgKiAgICAgTWFrZSB0aGUgJ2hvbWUnIGJ1dHRvbiBmaWxsIHRoZSB2aWV3ZXIgYW5kIGNsaXAgdGhlIGltYWdlLCBpbnN0ZWFkXG4gICogICAgIG9mIGZpdHRpbmcgdGhlIGltYWdlIHRvIHRoZSB2aWV3ZXIgYW5kIGxldHRlcmJveGluZy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Bhbkhvcml6b250YWw9dHJ1ZV1cbiAgKiAgICAgQWxsb3cgaG9yaXpvbnRhbCBwYW4uXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwYW5WZXJ0aWNhbD10cnVlXVxuICAqICAgICBBbGxvdyB2ZXJ0aWNhbCBwYW4uXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb25zdHJhaW5EdXJpbmdQYW49ZmFsc2VdXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt3cmFwSG9yaXpvbnRhbD1mYWxzZV1cbiAgKiAgICAgU2V0IHRvIHRydWUgdG8gZm9yY2UgdGhlIGltYWdlIHRvIHdyYXAgaG9yaXpvbnRhbGx5IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gICogICAgIFVzZWZ1bCBmb3IgbWFwcyBvciBpbWFnZXMgcmVwcmVzZW50aW5nIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlIG9yIGN5bGluZGVyLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbd3JhcFZlcnRpY2FsPWZhbHNlXVxuICAqICAgICBTZXQgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgaW1hZ2UgdG8gd3JhcCB2ZXJ0aWNhbGx5IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gICogICAgIFVzZWZ1bCBmb3IgbWFwcyBvciBpbWFnZXMgcmVwcmVzZW50aW5nIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlIG9yIGN5bGluZGVyLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFttaW5ab29tSW1hZ2VSYXRpbz0wLjldXG4gICogICAgIFRoZSBtaW5pbXVtIHBlcmNlbnRhZ2UgKCBleHByZXNzZWQgYXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxICkgb2ZcbiAgKiAgICAgdGhlIHZpZXdwb3J0IGhlaWdodCBvciB3aWR0aCBhdCB3aGljaCB0aGUgem9vbSBvdXQgd2lsbCBiZSBjb25zdHJhaW5lZC5cbiAgKiAgICAgU2V0dGluZyBpdCB0byAwLCBmb3IgZXhhbXBsZSB3aWxsIGFsbG93IHlvdSB0byB6b29tIG91dCBpbmZpbml0eS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWF4Wm9vbVBpeGVsUmF0aW89MS4xXVxuICAqICAgICBUaGUgbWF4aW11bSByYXRpbyB0byBhbGxvdyBhIHpvb20taW4gdG8gYWZmZWN0IHRoZSBoaWdoZXN0IGxldmVsIHBpeGVsXG4gICogICAgIHJhdGlvLiBUaGlzIGNhbiBiZSBzZXQgdG8gSW5maW5pdHkgdG8gYWxsb3cgJ2luZmluaXRlJyB6b29taW5nIGludG8gdGhlXG4gICogICAgIGltYWdlIHRob3VnaCBpdCBpcyBsZXNzIGVmZmVjdGl2ZSB2aXN1YWxseSBpZiB0aGUgSFRNTDUgQ2FudmFzIGlzIG5vdFxuICAqICAgICBhdmFpbGJsZSBvbiB0aGUgdmlld2luZyBkZXZpY2UuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3Ntb290aFRpbGVFZGdlc01pblpvb209MS4xXVxuICAqICAgICBBIHpvb20gcGVyY2VudGFnZSAoIHdoZXJlIDEgaXMgMTAwJSApIG9mIHRoZSBoaWdoZXN0IHJlc29sdXRpb24gbGV2ZWwuXG4gICogICAgIFdoZW4gem9vbWVkIGluIGJleW9uZCB0aGlzIHZhbHVlIGFsdGVybmF0aXZlIGNvbXBvc2l0aW5nIHdpbGwgYmUgdXNlZCB0b1xuICAqICAgICBzbW9vdGggb3V0IHRoZSBlZGdlcyBiZXR3ZWVuIHRpbGVzLiBUaGlzIHdpbGwgaGF2ZSBhIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgKiAgICAgQ2FuIGJlIHNldCB0byBJbmZpbml0eSB0byB0dXJuIGl0IG9mZi5cbiAgKiAgICAgTm90ZTogVGhpcyBzZXR0aW5nIGlzIGlnbm9yZWQgb24gaU9TIGRldmljZXMgZHVlIHRvIGEga25vd24gYnVnIChTZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuc2VhZHJhZ29uL29wZW5zZWFkcmFnb24vaXNzdWVzLzk1Mn0pXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpT1NEZXZpY2U9P11cbiAgKiAgICAgVHJ1ZSBpZiBydW5uaW5nIG9uIGFuIGlPUyBkZXZpY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAgKiAgICAgVXNlZCB0byBkaXNhYmxlIGNlcnRhaW4gZmVhdHVyZXMgdGhhdCBiZWhhdmUgZGlmZmVyZW50bHkgb24gaU9TIGRldmljZXMuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthdXRvUmVzaXplPXRydWVdXG4gICogICAgIFNldCB0byBmYWxzZSB0byBwcmV2ZW50IHBvbGxpbmcgZm9yIHZpZXdlciBzaXplIGNoYW5nZXMuIFVzZWZ1bCBmb3IgcHJvdmlkaW5nIGN1c3RvbSByZXNpemUgYmVoYXZpb3IuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwcmVzZXJ2ZUltYWdlU2l6ZU9uUmVzaXplPWZhbHNlXVxuICAqICAgICBTZXQgdG8gdHJ1ZSB0byBoYXZlIHRoZSBpbWFnZSBzaXplIHByZXNlcnZlZCB3aGVuIHRoZSB2aWV3ZXIgaXMgcmVzaXplZC4gVGhpcyByZXF1aXJlcyBhdXRvUmVzaXplPXRydWUgKGRlZmF1bHQpLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFttaW5TY3JvbGxEZWx0YVRpbWU9NTBdXG4gICogICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYmV0d2VlbiBjYW52YXMtc2Nyb2xsIGV2ZW50cy4gVGhpcyB2YWx1ZSBoZWxwcyBub3JtYWxpemUgdGhlIHJhdGUgb2YgY2FudmFzLXNjcm9sbFxuICAqICAgICBldmVudHMgYmV0d2VlbiBkaWZmZXJlbnQgZGV2aWNlcywgY2F1c2luZyB0aGUgZmFzdGVyIGRldmljZXMgdG8gc2xvdyBkb3duIGVub3VnaCB0byBtYWtlIHRoZSB6b29tIGNvbnRyb2xcbiAgKiAgICAgbW9yZSBtYW5hZ2VhYmxlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaXhlbHNQZXJXaGVlbExpbmU9NDBdXG4gICogICAgIEZvciBwaXhlbC1yZXNvbHV0aW9uIHNjcm9sbGluZyBkZXZpY2VzLCB0aGUgbnVtYmVyIG9mIHBpeGVscyBlcXVhbCB0byBvbmUgc2Nyb2xsIGxpbmUuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3Zpc2liaWxpdHlSYXRpbz0wLjVdXG4gICogICAgIFRoZSBwZXJjZW50YWdlICggYXMgYSBudW1iZXIgZnJvbSAwIHRvIDEgKSBvZiB0aGUgc291cmNlIGltYWdlIHdoaWNoXG4gICogICAgIG11c3QgYmUga2VwdCB3aXRoaW4gdGhlIHZpZXdwb3J0LiAgSWYgdGhlIGltYWdlIGlzIGRyYWdnZWQgYmV5b25kIHRoYXRcbiAgKiAgICAgbGltaXQsIGl0IHdpbGwgJ2JvdW5jZScgYmFjayB1bnRpbCB0aGUgbWluaW11bSB2aXNpYmlsaXR5IHJhdGlvIGlzXG4gICogICAgIGFjaGlldmVkLiAgU2V0dGluZyB0aGlzIHRvIDAgYW5kIHdyYXBIb3Jpem9udGFsICggb3Igd3JhcFZlcnRpY2FsICkgdG9cbiAgKiAgICAgdHJ1ZSB3aWxsIHByb3ZpZGUgdGhlIGVmZmVjdCBvZiBhbiBpbmZpbml0ZWx5IHNjcm9sbGluZyB2aWV3cG9ydC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdmlld3BvcnRNYXJnaW5zPXt9XVxuICAqICAgICBQdXNoZXMgdGhlIFwiaG9tZVwiIHJlZ2lvbiBpbiBmcm9tIHRoZSBzaWRlcyBieSB0aGUgc3BlY2lmaWVkIGFtb3VudHMuXG4gICogICAgIFBvc3NpYmxlIHN1YnByb3BlcnRpZXMgKE51bWJlcnMsIGluIHNjcmVlbiBjb29yZGluYXRlcyk6IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbaW1hZ2VMb2FkZXJMaW1pdD0wXVxuICAqICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW1hZ2UgcmVxdWVzdHMgdG8gbWFrZSBjb25jdXJyZW50bHkuIEJ5IGRlZmF1bHRcbiAgKiAgICAgaXQgaXMgc2V0IHRvIDAgYWxsb3dpbmcgdGhlIGJyb3dzZXIgdG8gbWFrZSB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgKiAgICAgaW1hZ2UgcmVxdWVzdHMgaW4gcGFyYWxsZWwgYXMgYWxsb3dlZCBieSB0aGUgYnJvd3NlcnMgcG9saWN5LlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjbGlja1RpbWVUaHJlc2hvbGQ9MzAwXVxuICAqICAgICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgd2l0aGluIHdoaWNoIGEgcG9pbnRlciBkb3duLXVwIGV2ZW50IGNvbWJpbmF0aW9uXG4gICogICAgICB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBjbGljayBnZXN0dXJlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjbGlja0Rpc3RUaHJlc2hvbGQ9NV1cbiAgKiAgICAgIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGFsbG93ZWQgYmV0d2VlbiBhIHBvaW50ZXIgZG93biBldmVudCBhbmQgYSBwb2ludGVyIHVwIGV2ZW50XG4gICogICAgICB0byBiZSB0cmVhdGVkIGFzIGEgY2xpY2sgZ2VzdHVyZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGJsQ2xpY2tUaW1lVGhyZXNob2xkPTMwMF1cbiAgKiAgICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHdpdGhpbiB3aGljaCB0d28gcG9pbnRlciBkb3duLXVwIGV2ZW50IGNvbWJpbmF0aW9uc1xuICAqICAgICAgd2lsbCBiZSB0cmVhdGVkIGFzIGEgZG91YmxlLWNsaWNrIGdlc3R1cmUuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2RibENsaWNrRGlzdFRocmVzaG9sZD0yMF1cbiAgKiAgICAgIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGFsbG93ZWQgYmV0d2VlbiB0d28gcG9pbnRlciBjbGljayBldmVudHNcbiAgKiAgICAgIHRvIGJlIHRyZWF0ZWQgYXMgYSBkb3VibGUtY2xpY2sgZ2VzdHVyZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3ByaW5nU3RpZmZuZXNzPTYuNV1cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYW5pbWF0aW9uVGltZT0xLjJdXG4gICogICAgIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIHBlciBlYWNoIHtAbGluayBPcGVuU2VhZHJhZ29uLlNwcmluZ31cbiAgKiAgICAgd2hpY2ggb2NjdXIgd2hlbiB0aGUgaW1hZ2UgaXMgZHJhZ2dlZCBvciB6b29tZWQuXG4gICpcbiAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uR2VzdHVyZVNldHRpbmdzfSBbZ2VzdHVyZVNldHRpbmdzTW91c2VdXG4gICogICAgIFNldHRpbmdzIGZvciBnZXN0dXJlcyBnZW5lcmF0ZWQgYnkgYSBtb3VzZSBwb2ludGVyIGRldmljZS4gKFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5HZXN0dXJlU2V0dGluZ3N9KVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc01vdXNlLnNjcm9sbFRvWm9vbT10cnVlXSAtIFpvb20gb24gc2Nyb2xsIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NNb3VzZS5jbGlja1RvWm9vbT10cnVlXSAtIFpvb20gb24gY2xpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc01vdXNlLmRibENsaWNrVG9ab29tPWZhbHNlXSAtIFpvb20gb24gZG91YmxlLWNsaWNrIGdlc3R1cmUuIE5vdGU6IElmIHNldCB0byB0cnVlXG4gICogICAgIHRoZW4gY2xpY2tUb1pvb20gc2hvdWxkIGJlIHNldCB0byBmYWxzZSB0byBwcmV2ZW50IG11bHRpcGxlIHpvb21zLlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc01vdXNlLnBpbmNoVG9ab29tPWZhbHNlXSAtIFpvb20gb24gcGluY2ggZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc01vdXNlLmZsaWNrRW5hYmxlZD1mYWxzZV0gLSBFbmFibGUgZmxpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2VzdHVyZVNldHRpbmdzTW91c2UuZmxpY2tNaW5TcGVlZD0xMjBdIC0gSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtaW5pbXVtIHNwZWVkIHRvIGluaXRpYXRlIGEgZmxpY2sgZ2VzdHVyZSAocGl4ZWxzLXBlci1zZWNvbmQpXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnZXN0dXJlU2V0dGluZ3NNb3VzZS5mbGlja01vbWVudHVtPTAuMjVdIC0gSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtb21lbnR1bSBmYWN0b3IgZm9yIHRoZSBmbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzTW91c2UucGluY2hSb3RhdGU9ZmFsc2VdIC0gSWYgcGluY2hSb3RhdGUgaXMgdHJ1ZSwgdGhlIHVzZXIgd2lsbCBoYXZlIHRoZSBhYmlsaXR5IHRvIHJvdGF0ZSB0aGUgaW1hZ2UgdXNpbmcgdGhlaXIgZmluZ2Vycy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5HZXN0dXJlU2V0dGluZ3N9IFtnZXN0dXJlU2V0dGluZ3NUb3VjaF1cbiAgKiAgICAgU2V0dGluZ3MgZm9yIGdlc3R1cmVzIGdlbmVyYXRlZCBieSBhIHRvdWNoIHBvaW50ZXIgZGV2aWNlLiAoU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLkdlc3R1cmVTZXR0aW5nc30pXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzVG91Y2guc2Nyb2xsVG9ab29tPWZhbHNlXSAtIFpvb20gb24gc2Nyb2xsIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NUb3VjaC5jbGlja1RvWm9vbT1mYWxzZV0gLSBab29tIG9uIGNsaWNrIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NUb3VjaC5kYmxDbGlja1RvWm9vbT10cnVlXSAtIFpvb20gb24gZG91YmxlLWNsaWNrIGdlc3R1cmUuIE5vdGU6IElmIHNldCB0byB0cnVlXG4gICogICAgIHRoZW4gY2xpY2tUb1pvb20gc2hvdWxkIGJlIHNldCB0byBmYWxzZSB0byBwcmV2ZW50IG11bHRpcGxlIHpvb21zLlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1RvdWNoLnBpbmNoVG9ab29tPXRydWVdIC0gWm9vbSBvbiBwaW5jaCBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzVG91Y2guZmxpY2tFbmFibGVkPXRydWVdIC0gRW5hYmxlIGZsaWNrIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2dlc3R1cmVTZXR0aW5nc1RvdWNoLmZsaWNrTWluU3BlZWQ9MTIwXSAtIElmIGZsaWNrRW5hYmxlZCBpcyB0cnVlLCB0aGUgbWluaW11bSBzcGVlZCB0byBpbml0aWF0ZSBhIGZsaWNrIGdlc3R1cmUgKHBpeGVscy1wZXItc2Vjb25kKVxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2VzdHVyZVNldHRpbmdzVG91Y2guZmxpY2tNb21lbnR1bT0wLjI1XSAtIElmIGZsaWNrRW5hYmxlZCBpcyB0cnVlLCB0aGUgbW9tZW50dW0gZmFjdG9yIGZvciB0aGUgZmxpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1RvdWNoLnBpbmNoUm90YXRlPWZhbHNlXSAtIElmIHBpbmNoUm90YXRlIGlzIHRydWUsIHRoZSB1c2VyIHdpbGwgaGF2ZSB0aGUgYWJpbGl0eSB0byByb3RhdGUgdGhlIGltYWdlIHVzaW5nIHRoZWlyIGZpbmdlcnMuXG4gICpcbiAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uR2VzdHVyZVNldHRpbmdzfSBbZ2VzdHVyZVNldHRpbmdzUGVuXVxuICAqICAgICBTZXR0aW5ncyBmb3IgZ2VzdHVyZXMgZ2VuZXJhdGVkIGJ5IGEgcGVuIHBvaW50ZXIgZGV2aWNlLiAoU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLkdlc3R1cmVTZXR0aW5nc30pXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzUGVuLnNjcm9sbFRvWm9vbT1mYWxzZV0gLSBab29tIG9uIHNjcm9sbCBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzUGVuLmNsaWNrVG9ab29tPXRydWVdIC0gWm9vbSBvbiBjbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzUGVuLmRibENsaWNrVG9ab29tPWZhbHNlXSAtIFpvb20gb24gZG91YmxlLWNsaWNrIGdlc3R1cmUuIE5vdGU6IElmIHNldCB0byB0cnVlXG4gICogICAgIHRoZW4gY2xpY2tUb1pvb20gc2hvdWxkIGJlIHNldCB0byBmYWxzZSB0byBwcmV2ZW50IG11bHRpcGxlIHpvb21zLlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Blbi5waW5jaFRvWm9vbT1mYWxzZV0gLSBab29tIG9uIHBpbmNoIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NQZW4uZmxpY2tFbmFibGVkPWZhbHNlXSAtIEVuYWJsZSBmbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnZXN0dXJlU2V0dGluZ3NQZW4uZmxpY2tNaW5TcGVlZD0xMjBdIC0gSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtaW5pbXVtIHNwZWVkIHRvIGluaXRpYXRlIGEgZmxpY2sgZ2VzdHVyZSAocGl4ZWxzLXBlci1zZWNvbmQpXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnZXN0dXJlU2V0dGluZ3NQZW4uZmxpY2tNb21lbnR1bT0wLjI1XSAtIElmIGZsaWNrRW5hYmxlZCBpcyB0cnVlLCB0aGUgbW9tZW50dW0gZmFjdG9yIGZvciB0aGUgZmxpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Blbi5waW5jaFJvdGF0ZT1mYWxzZV0gLSBJZiBwaW5jaFJvdGF0ZSBpcyB0cnVlLCB0aGUgdXNlciB3aWxsIGhhdmUgdGhlIGFiaWxpdHkgdG8gcm90YXRlIHRoZSBpbWFnZSB1c2luZyB0aGVpciBmaW5nZXJzLlxuICAqXG4gICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkdlc3R1cmVTZXR0aW5nc30gW2dlc3R1cmVTZXR0aW5nc1Vua25vd25dXG4gICogICAgIFNldHRpbmdzIGZvciBnZXN0dXJlcyBnZW5lcmF0ZWQgYnkgdW5rbm93biBwb2ludGVyIGRldmljZXMuIChTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uR2VzdHVyZVNldHRpbmdzfSlcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NVbmtub3duLnNjcm9sbFRvWm9vbT10cnVlXSAtIFpvb20gb24gc2Nyb2xsIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NVbmtub3duLmNsaWNrVG9ab29tPWZhbHNlXSAtIFpvb20gb24gY2xpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Vua25vd24uZGJsQ2xpY2tUb1pvb209dHJ1ZV0gLSBab29tIG9uIGRvdWJsZS1jbGljayBnZXN0dXJlLiBOb3RlOiBJZiBzZXQgdG8gdHJ1ZVxuICAqICAgICB0aGVuIGNsaWNrVG9ab29tIHNob3VsZCBiZSBzZXQgdG8gZmFsc2UgdG8gcHJldmVudCBtdWx0aXBsZSB6b29tcy5cbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NVbmtub3duLnBpbmNoVG9ab29tPXRydWVdIC0gWm9vbSBvbiBwaW5jaCBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzVW5rbm93bi5mbGlja0VuYWJsZWQ9dHJ1ZV0gLSBFbmFibGUgZmxpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2VzdHVyZVNldHRpbmdzVW5rbm93bi5mbGlja01pblNwZWVkPTEyMF0gLSBJZiBmbGlja0VuYWJsZWQgaXMgdHJ1ZSwgdGhlIG1pbmltdW0gc3BlZWQgdG8gaW5pdGlhdGUgYSBmbGljayBnZXN0dXJlIChwaXhlbHMtcGVyLXNlY29uZClcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2dlc3R1cmVTZXR0aW5nc1Vua25vd24uZmxpY2tNb21lbnR1bT0wLjI1XSAtIElmIGZsaWNrRW5hYmxlZCBpcyB0cnVlLCB0aGUgbW9tZW50dW0gZmFjdG9yIGZvciB0aGUgZmxpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Vua25vd24ucGluY2hSb3RhdGU9ZmFsc2VdIC0gSWYgcGluY2hSb3RhdGUgaXMgdHJ1ZSwgdGhlIHVzZXIgd2lsbCBoYXZlIHRoZSBhYmlsaXR5IHRvIHJvdGF0ZSB0aGUgaW1hZ2UgdXNpbmcgdGhlaXIgZmluZ2Vycy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbem9vbVBlckNsaWNrPTIuMF1cbiAgKiAgICAgVGhlIFwiem9vbSBkaXN0YW5jZVwiIHBlciBtb3VzZSBjbGljayBvciB0b3VjaCB0YXAuIDxlbT48c3Ryb25nPk5vdGU6PC9zdHJvbmc+IFNldHRpbmcgdGhpcyB0byAxLjAgZWZmZWN0aXZlbHkgZGlzYWJsZXMgdGhlIGNsaWNrLXRvLXpvb20gZmVhdHVyZSAoYWxzbyBzZWUgZ2VzdHVyZVNldHRpbmdzW01vdXNlfFRvdWNofFBlbl0uY2xpY2tUb1pvb20vZGJsQ2xpY2tUb1pvb20pLjwvZW0+XG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3pvb21QZXJTY3JvbGw9MS4yXVxuICAqICAgICBUaGUgXCJ6b29tIGRpc3RhbmNlXCIgcGVyIG1vdXNlIHNjcm9sbCBvciB0b3VjaCBwaW5jaC4gPGVtPjxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gU2V0dGluZyB0aGlzIHRvIDEuMCBlZmZlY3RpdmVseSBkaXNhYmxlcyB0aGUgbW91c2Utd2hlZWwgem9vbSBmZWF0dXJlIChhbHNvIHNlZSBnZXN0dXJlU2V0dGluZ3NbTW91c2V8VG91Y2h8UGVuXS5zY3JvbGxUb1pvb219KS48L2VtPlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFt6b29tUGVyU2Vjb25kPTEuMF1cbiAgKiAgICAgVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGFuaW1hdGUgYSBzaW5nbGUgem9vbSBldmVudCBvdmVyLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbc2hvd05hdmlnYXRvcj1mYWxzZV1cbiAgKiAgICAgU2V0IHRvIHRydWUgdG8gbWFrZSB0aGUgbmF2aWdhdG9yIG1pbmltYXAgYXBwZWFyLlxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IFtuYXZpZ2F0b3JJZD1uYXZpZ2F0b3ItR0VORVJBVEVEIERBVEVdXG4gICogICAgIFRoZSBJRCBvZiBhIGRpdiB0byBob2xkIHRoZSBuYXZpZ2F0b3IgbWluaW1hcC5cbiAgKiAgICAgSWYgYW4gSUQgaXMgc3BlY2lmaWVkLCB0aGUgbmF2aWdhdG9yUG9zaXRpb24sIG5hdmlnYXRvclNpemVSYXRpbywgbmF2aWdhdG9yTWFpbnRhaW5TaXplUmF0aW8sIG5hdmlnYXRvcltUb3B8TGVmdHxIZWlnaHR8V2lkdGhdIGFuZCBuYXZpZ2F0b3JBdXRvRmFkZSBvcHRpb25zIHdpbGwgYmUgaWdub3JlZC5cbiAgKiAgICAgSWYgYW4gSUQgaXMgbm90IHNwZWNpZmllZCwgYSBkaXYgZWxlbWVudCB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgcGxhY2VkIG9uIHRvcCBvZiB0aGUgbWFpbiBpbWFnZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbbmF2aWdhdG9yUG9zaXRpb249J1RPUF9SSUdIVCddXG4gICogICAgIFZhbGlkIHZhbHVlcyBhcmUgJ1RPUF9MRUZUJywgJ1RPUF9SSUdIVCcsICdCT1RUT01fTEVGVCcsICdCT1RUT01fUklHSFQnLCBvciAnQUJTT0xVVEUnLjxicj5cbiAgKiAgICAgSWYgJ0FCU09MVVRFJyBpcyBzcGVjaWZpZWQsIHRoZW4gbmF2aWdhdG9yW1RvcHxMZWZ0fEhlaWdodHxXaWR0aF0gZGV0ZXJtaW5lcyB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhlIG5hdmlnYXRvciBtaW5pbWFwIGluIHRoZSB2aWV3ZXIsIGFuZCBuYXZpZ2F0b3JTaXplUmF0aW8gYW5kIG5hdmlnYXRvck1haW50YWluU2l6ZVJhdGlvIGFyZSBpZ25vcmVkLjxicj5cbiAgKiAgICAgRm9yICdUT1BfTEVGVCcsICdUT1BfUklHSFQnLCAnQk9UVE9NX0xFRlQnLCBhbmQgJ0JPVFRPTV9SSUdIVCcsIHRoZSBuYXZpZ2F0b3JTaXplUmF0aW8gb3IgbmF2aWdhdG9yW0hlaWdodHxXaWR0aF0gdmFsdWVzIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgbmF2aWdhdG9yIG1pbmltYXAuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW25hdmlnYXRvclNpemVSYXRpbz0wLjJdXG4gICogICAgIFJhdGlvIG9mIG5hdmlnYXRvciBzaXplIHRvIHZpZXdlciBzaXplLiBJZ25vcmVkIGlmIG5hdmlnYXRvcltIZWlnaHR8V2lkdGhdIGFyZSBzcGVjaWZpZWQuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtuYXZpZ2F0b3JNYWludGFpblNpemVSYXRpbz1mYWxzZV1cbiAgKiAgICAgSWYgdHJ1ZSwgdGhlIG5hdmlnYXRvciBtaW5pbWFwIGlzIHJlc2l6ZWQgKHVzaW5nIG5hdmlnYXRvclNpemVSYXRpbykgd2hlbiB0aGUgdmlld2VyIHNpemUgY2hhbmdlcy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfFN0cmluZ30gW25hdmlnYXRvclRvcD1udWxsXVxuICAqICAgICBTcGVjaWZpZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBuYXZpZ2F0b3IgbWluaW1hcCAoc2VlIG5hdmlnYXRvclBvc2l0aW9uKS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfFN0cmluZ30gW25hdmlnYXRvckxlZnQ9bnVsbF1cbiAgKiAgICAgU3BlY2lmaWVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgbmF2aWdhdG9yIG1pbmltYXAgKHNlZSBuYXZpZ2F0b3JQb3NpdGlvbikuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtuYXZpZ2F0b3JIZWlnaHQ9bnVsbF1cbiAgKiAgICAgU3BlY2lmaWVzIHRoZSBzaXplIG9mIHRoZSBuYXZpZ2F0b3IgbWluaW1hcCAoc2VlIG5hdmlnYXRvclBvc2l0aW9uKS5cbiAgKiAgICAgSWYgc3BlY2lmaWVkLCBuYXZpZ2F0b3JTaXplUmF0aW8gYW5kIG5hdmlnYXRvck1haW50YWluU2l6ZVJhdGlvIGFyZSBpZ25vcmVkLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBbbmF2aWdhdG9yV2lkdGg9bnVsbF1cbiAgKiAgICAgU3BlY2lmaWVzIHRoZSBzaXplIG9mIHRoZSBuYXZpZ2F0b3IgbWluaW1hcCAoc2VlIG5hdmlnYXRvclBvc2l0aW9uKS5cbiAgKiAgICAgSWYgc3BlY2lmaWVkLCBuYXZpZ2F0b3JTaXplUmF0aW8gYW5kIG5hdmlnYXRvck1haW50YWluU2l6ZVJhdGlvIGFyZSBpZ25vcmVkLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbbmF2aWdhdG9yQXV0b1Jlc2l6ZT10cnVlXVxuICAqICAgICBTZXQgdG8gZmFsc2UgdG8gcHJldmVudCBwb2xsaW5nIGZvciBuYXZpZ2F0b3Igc2l6ZSBjaGFuZ2VzLiBVc2VmdWwgZm9yIHByb3ZpZGluZyBjdXN0b20gcmVzaXplIGJlaGF2aW9yLlxuICAqICAgICBTZXR0aW5nIHRvIGZhbHNlIGNhbiBhbHNvIGltcHJvdmUgcGVyZm9ybWFuY2Ugd2hlbiB0aGUgbmF2aWdhdG9yIGlzIGNvbmZpZ3VyZWQgdG8gYSBmaXhlZCBzaXplLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbbmF2aWdhdG9yQXV0b0ZhZGU9dHJ1ZV1cbiAgKiAgICAgSWYgdGhlIHVzZXIgc3RvcHMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlld3BvcnQsIGZhZGUgdGhlIG5hdmlnYXRvciBtaW5pbWFwLlxuICAqICAgICBTZXR0aW5nIHRvIGZhbHNlIHdpbGwgbWFrZSB0aGUgbmF2aWdhdG9yIG1pbmltYXAgYWx3YXlzIHZpc2libGUuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtuYXZpZ2F0b3JSb3RhdGU9dHJ1ZV1cbiAgKiAgICAgSWYgdHJ1ZSwgdGhlIG5hdmlnYXRvciB3aWxsIGJlIHJvdGF0ZWQgdG9nZXRoZXIgd2l0aCB0aGUgdmlld2VyLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb250cm9sc0ZhZGVEZWxheT0yMDAwXVxuICAqICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IG9uY2UgdGhlIHVzZXIgaGFzIHN0b3BwZWQgaW50ZXJhY3RpbmdcbiAgKiAgICAgd2l0aCB0aGUgaW50ZXJmYWNlIGJlZm9yZSBiZWdpbmluZyB0byBmYWRlIHRoZSBjb250cm9scy4gQXNzdW1lc1xuICAqICAgICBzaG93TmF2aWdhdGlvbkNvbnRyb2wgYW5kIGF1dG9IaWRlQ29udHJvbHMgYXJlIGJvdGggdHJ1ZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbY29udHJvbHNGYWRlTGVuZ3RoPTE1MDBdXG4gICogICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGFuaW1hdGUgdGhlIGNvbnRyb2xzIGZhZGluZyBvdXQuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW21heEltYWdlQ2FjaGVDb3VudD0yMDBdXG4gICogICAgIFRoZSBtYXggbnVtYmVyIG9mIGltYWdlcyB3ZSBzaG91bGQga2VlcCBpbiBtZW1vcnkgKHBlciBkcmF3ZXIpLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aW1lb3V0PTMwMDAwXVxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbdXNlQ2FudmFzPXRydWVdXG4gICogICAgIFNldCB0byBmYWxzZSB0byBub3QgdXNlIGFuIEhUTUwgY2FudmFzIGVsZW1lbnQgZm9yIGltYWdlIHJlbmRlcmluZyBldmVuIGlmIGNhbnZhcyBpcyBzdXBwb3J0ZWQuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW21pblBpeGVsUmF0aW89MC41XVxuICAqICAgICBUaGUgaGlnaGVyIHRoZSBtaW5QaXhlbFJhdGlvLCB0aGUgbG93ZXIgdGhlIHF1YWxpdHkgb2YgdGhlIGltYWdlIHRoYXRcbiAgKiAgICAgaXMgY29uc2lkZXJlZCBzdWZmaWNpZW50IHRvIHN0b3AgcmVuZGVyaW5nIGEgZ2l2ZW4gem9vbSBsZXZlbC4gIEZvclxuICAqICAgICBleGFtcGxlLCBpZiB5b3UgYXJlIHRhcmdldGluZyBtb2JpbGUgZGV2aWNlcyB3aXRoIGxlc3MgYmFuZHdpdGggeW91IG1heVxuICAqICAgICB0cnkgc2V0dGluZyB0aGlzIHRvIDEuNSBvciBoaWdoZXIuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFttb3VzZU5hdkVuYWJsZWQ9dHJ1ZV1cbiAgKiAgICAgSXMgdGhlIHVzZXIgYWJsZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBpbWFnZSB2aWEgbW91c2Ugb3IgdG91Y2guIERlZmF1bHRcbiAgKiAgICAgaW50ZXJhY3Rpb25zIGluY2x1ZGUgZHJhZ2luZyB0aGUgaW1hZ2UgaW4gYSBwbGFuZSwgYW5kIHpvb21pbmcgaW4gdG93YXJkXG4gICogICAgIGFuZCBhd2F5IGZyb20gdGhlIGltYWdlLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbc2hvd05hdmlnYXRpb25Db250cm9sPXRydWVdXG4gICogICAgIFNldCB0byBmYWxzZSB0byBwcmV2ZW50IHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkZWZhdWx0IG5hdmlnYXRpb24gY29udHJvbHMuPGJyPlxuICAqICAgICBOb3RlIHRoYXQgaWYgc2V0IHRvIGZhbHNlLCB0aGUgY3VzdG9tcyBidXR0b25zIHNldCBieSB0aGUgb3B0aW9uc1xuICAqICAgICB6b29tSW5CdXR0b24sIHpvb21PdXRCdXR0b24gZXRjLCBhcmUgcmVuZGVyZWQgaW5hY3RpdmUuXG4gICpcbiAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uQ29udHJvbEFuY2hvcn0gW25hdmlnYXRpb25Db250cm9sQW5jaG9yPVRPUF9MRUZUXVxuICAqICAgICBQbGFjZW1lbnQgb2YgdGhlIGRlZmF1bHQgbmF2aWdhdGlvbiBjb250cm9scy5cbiAgKiAgICAgVG8gc2V0IHRoZSBwbGFjZW1lbnQgb2YgdGhlIHNlcXVlbmNlIGNvbnRyb2xzLCBzZWUgdGhlXG4gICogICAgIHNlcXVlbmNlQ29udHJvbEFuY2hvciBvcHRpb24uXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzaG93Wm9vbUNvbnRyb2w9dHJ1ZV1cbiAgKiAgICAgSWYgdHJ1ZSB0aGVuICsgYW5kIC0gYnV0dG9ucyB0byB6b29tIGluIGFuZCBvdXQgYXJlIGRpc3BsYXllZC48YnI+XG4gICogICAgIE5vdGU6IHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnMuc2hvd05hdmlnYXRpb25Db250cm9sfSBpcyBvdmVycmlkaW5nXG4gICogICAgIHRoaXMgc2V0dGluZyB3aGVuIHNldCB0byBmYWxzZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Nob3dIb21lQ29udHJvbD10cnVlXVxuICAqICAgICBJZiB0cnVlIHRoZW4gdGhlICdHbyBob21lJyBidXR0b24gaXMgZGlzcGxheWVkIHRvIGdvIGJhY2sgdG8gdGhlIG9yaWdpbmFsXG4gICogICAgIHpvb20gYW5kIHBhbi48YnI+XG4gICogICAgIE5vdGU6IHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnMuc2hvd05hdmlnYXRpb25Db250cm9sfSBpcyBvdmVycmlkaW5nXG4gICogICAgIHRoaXMgc2V0dGluZyB3aGVuIHNldCB0byBmYWxzZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Nob3dGdWxsUGFnZUNvbnRyb2w9dHJ1ZV1cbiAgKiAgICAgSWYgdHJ1ZSB0aGVuIHRoZSAnVG9nZ2xlIGZ1bGwgcGFnZScgYnV0dG9uIGlzIGRpc3BsYXllZCB0byBzd2l0Y2hcbiAgKiAgICAgYmV0d2VlbiBmdWxsIHBhZ2UgYW5kIG5vcm1hbCBtb2RlLjxicj5cbiAgKiAgICAgTm90ZToge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5zaG93TmF2aWdhdGlvbkNvbnRyb2x9IGlzIG92ZXJyaWRpbmdcbiAgKiAgICAgdGhpcyBzZXR0aW5nIHdoZW4gc2V0IHRvIGZhbHNlLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbc2hvd1JvdGF0aW9uQ29udHJvbD1mYWxzZV1cbiAgKiAgICAgSWYgdHJ1ZSB0aGVuIHRoZSByb3RhdGUgbGVmdC9yaWdodCBjb250cm9scyB3aWxsIGJlIGRpc3BsYXllZCBhcyBwYXJ0IG9mIHRoZVxuICAqICAgICBzdGFuZGFyZCBjb250cm9scy4gVGhpcyBpcyBhbHNvIHN1YmplY3QgdG8gdGhlIGJyb3dzZXIgc3VwcG9ydCBmb3Igcm90YXRlXG4gICogICAgIChlLmcuIHZpZXdlci5kcmF3ZXIuY2FuUm90YXRlKCkpLjxicj5cbiAgKiAgICAgTm90ZToge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5zaG93TmF2aWdhdGlvbkNvbnRyb2x9IGlzIG92ZXJyaWRpbmdcbiAgKiAgICAgdGhpcyBzZXR0aW5nIHdoZW4gc2V0IHRvIGZhbHNlLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbc2hvd1NlcXVlbmNlQ29udHJvbD10cnVlXVxuICAqICAgICBJZiBzZXF1ZW5jZU1vZGUgaXMgdHJ1ZSwgdGhlbiBwcm92aWRlIGJ1dHRvbnMgZm9yIG5hdmlnYXRpbmcgZm9yd2FyZCBhbmRcbiAgKiAgICAgYmFja3dhcmQgdGhyb3VnaCB0aGUgaW1hZ2VzLlxuICAqXG4gICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkNvbnRyb2xBbmNob3J9IFtzZXF1ZW5jZUNvbnRyb2xBbmNob3I9VE9QX0xFRlRdXG4gICogICAgIFBsYWNlbWVudCBvZiB0aGUgZGVmYXVsdCBzZXF1ZW5jZSBjb250cm9scy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW25hdlByZXZOZXh0V3JhcD1mYWxzZV1cbiAgKiAgICAgSWYgdHJ1ZSB0aGVuIHRoZSAncHJldmlvdXMnIGJ1dHRvbiB3aWxsIHdyYXAgdG8gdGhlIGxhc3QgaW1hZ2Ugd2hlblxuICAqICAgICB2aWV3aW5nIHRoZSBmaXJzdCBpbWFnZSBhbmQgdGhlICduZXh0JyBidXR0b24gd2lsbCB3cmFwIHRvIHRoZSBmaXJzdFxuICAqICAgICBpbWFnZSB3aGVuIHZpZXdpbmcgdGhlIGxhc3QgaW1hZ2UuXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbUluQnV0dG9uXG4gICogICAgIFNldCB0aGUgaWQgb2YgdGhlIGN1c3RvbSAnWm9vbSBpbicgYnV0dG9uIHRvIHVzZS5cbiAgKiAgICAgVGhpcyBpcyB1c2VmdWwgdG8gaGF2ZSBhIGN1c3RvbSBidXR0b24gYW55d2hlcmUgaW4gdGhlIHdlYiBwYWdlLjxicj5cbiAgKiAgICAgVG8gb25seSBjaGFuZ2UgdGhlIGJ1dHRvbiBpbWFnZXMsIGNvbnNpZGVyIHVzaW5nXG4gICogICAgIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnMubmF2SW1hZ2VzfVxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHpvb21PdXRCdXR0b25cbiAgKiAgICAgU2V0IHRoZSBpZCBvZiB0aGUgY3VzdG9tICdab29tIG91dCcgYnV0dG9uIHRvIHVzZS5cbiAgKiAgICAgVGhpcyBpcyB1c2VmdWwgdG8gaGF2ZSBhIGN1c3RvbSBidXR0b24gYW55d2hlcmUgaW4gdGhlIHdlYiBwYWdlLjxicj5cbiAgKiAgICAgVG8gb25seSBjaGFuZ2UgdGhlIGJ1dHRvbiBpbWFnZXMsIGNvbnNpZGVyIHVzaW5nXG4gICogICAgIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnMubmF2SW1hZ2VzfVxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGhvbWVCdXR0b25cbiAgKiAgICAgU2V0IHRoZSBpZCBvZiB0aGUgY3VzdG9tICdHbyBob21lJyBidXR0b24gdG8gdXNlLlxuICAqICAgICBUaGlzIGlzIHVzZWZ1bCB0byBoYXZlIGEgY3VzdG9tIGJ1dHRvbiBhbnl3aGVyZSBpbiB0aGUgd2ViIHBhZ2UuPGJyPlxuICAqICAgICBUbyBvbmx5IGNoYW5nZSB0aGUgYnV0dG9uIGltYWdlcywgY29uc2lkZXIgdXNpbmdcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5uYXZJbWFnZXN9XG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbFBhZ2VCdXR0b25cbiAgKiAgICAgU2V0IHRoZSBpZCBvZiB0aGUgY3VzdG9tICdUb2dnbGUgZnVsbCBwYWdlJyBidXR0b24gdG8gdXNlLlxuICAqICAgICBUaGlzIGlzIHVzZWZ1bCB0byBoYXZlIGEgY3VzdG9tIGJ1dHRvbiBhbnl3aGVyZSBpbiB0aGUgd2ViIHBhZ2UuPGJyPlxuICAqICAgICBUbyBvbmx5IGNoYW5nZSB0aGUgYnV0dG9uIGltYWdlcywgY29uc2lkZXIgdXNpbmdcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5uYXZJbWFnZXN9XG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlTGVmdEJ1dHRvblxuICAqICAgICBTZXQgdGhlIGlkIG9mIHRoZSBjdXN0b20gJ1JvdGF0ZSBsZWZ0JyBidXR0b24gdG8gdXNlLlxuICAqICAgICBUaGlzIGlzIHVzZWZ1bCB0byBoYXZlIGEgY3VzdG9tIGJ1dHRvbiBhbnl3aGVyZSBpbiB0aGUgd2ViIHBhZ2UuPGJyPlxuICAqICAgICBUbyBvbmx5IGNoYW5nZSB0aGUgYnV0dG9uIGltYWdlcywgY29uc2lkZXIgdXNpbmdcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5uYXZJbWFnZXN9XG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlUmlnaHRCdXR0b25cbiAgKiAgICAgU2V0IHRoZSBpZCBvZiB0aGUgY3VzdG9tICdSb3RhdGUgcmlnaHQnIGJ1dHRvbiB0byB1c2UuXG4gICogICAgIFRoaXMgaXMgdXNlZnVsIHRvIGhhdmUgYSBjdXN0b20gYnV0dG9uIGFueXdoZXJlIGluIHRoZSB3ZWIgcGFnZS48YnI+XG4gICogICAgIFRvIG9ubHkgY2hhbmdlIHRoZSBidXR0b24gaW1hZ2VzLCBjb25zaWRlciB1c2luZ1xuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLm5hdkltYWdlc31cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcmV2aW91c0J1dHRvblxuICAqICAgICBTZXQgdGhlIGlkIG9mIHRoZSBjdXN0b20gJ1ByZXZpb3VzIHBhZ2UnIGJ1dHRvbiB0byB1c2UuXG4gICogICAgIFRoaXMgaXMgdXNlZnVsIHRvIGhhdmUgYSBjdXN0b20gYnV0dG9uIGFueXdoZXJlIGluIHRoZSB3ZWIgcGFnZS48YnI+XG4gICogICAgIFRvIG9ubHkgY2hhbmdlIHRoZSBidXR0b24gaW1hZ2VzLCBjb25zaWRlciB1c2luZ1xuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLm5hdkltYWdlc31cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuZXh0QnV0dG9uXG4gICogICAgIFNldCB0aGUgaWQgb2YgdGhlIGN1c3RvbSAnTmV4dCBwYWdlJyBidXR0b24gdG8gdXNlLlxuICAqICAgICBUaGlzIGlzIHVzZWZ1bCB0byBoYXZlIGEgY3VzdG9tIGJ1dHRvbiBhbnl3aGVyZSBpbiB0aGUgd2ViIHBhZ2UuPGJyPlxuICAqICAgICBUbyBvbmx5IGNoYW5nZSB0aGUgYnV0dG9uIGltYWdlcywgY29uc2lkZXIgdXNpbmdcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5uYXZJbWFnZXN9XG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzZXF1ZW5jZU1vZGU9ZmFsc2VdXG4gICogICAgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIHZpZXdlciB0cmVhdCB5b3VyIHRpbGVzb3VyY2VzIGFzIGEgc2VxdWVuY2Ugb2YgaW1hZ2VzIHRvXG4gICogICAgIGJlIG9wZW5lZCBvbmUgYXQgYSB0aW1lIHJhdGhlciB0aGFuIGFsbCBhdCBvbmNlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtpbml0aWFsUGFnZT0wXVxuICAqICAgICBJZiBzZXF1ZW5jZU1vZGUgaXMgdHJ1ZSwgZGlzcGxheSB0aGlzIHBhZ2UgaW5pdGlhbGx5LlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbcHJlc2VydmVWaWV3cG9ydD1mYWxzZV1cbiAgKiAgICAgSWYgc2VxdWVuY2VNb2RlIGlzIHRydWUsIHRoZW4gbm9ybWFsbHkgbmF2aWdhdGluZyB0aHJvdWdoIGVhY2ggaW1hZ2UgcmVzZXRzIHRoZVxuICAqICAgICB2aWV3cG9ydCB0byAnaG9tZScgcG9zaXRpb24uICBJZiBwcmVzZXJ2ZVZpZXdwb3J0IGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZSB2aWV3cG9ydFxuICAqICAgICBwb3NpdGlvbiBpcyBwcmVzZXJ2ZWQgd2hlbiBuYXZpZ2F0aW5nIGJldHdlZW4gaW1hZ2VzIGluIHRoZSBzZXF1ZW5jZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3ByZXNlcnZlT3ZlcmxheXM9ZmFsc2VdXG4gICogICAgIElmIHNlcXVlbmNlTW9kZSBpcyB0cnVlLCB0aGVuIG5vcm1hbGx5IG5hdmlnYXRpbmcgdGhyb3VnaCBlYWNoIGltYWdlXG4gICogICAgIHJlc2V0cyB0aGUgb3ZlcmxheXMuXG4gICogICAgIElmIHByZXNlcnZlT3ZlcmxheXMgaXMgc2V0IHRvIHRydWUsIHRoZW4gdGhlIG92ZXJsYXlzIGFkZGVkIHdpdGgge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZE92ZXJsYXl9XG4gICogICAgIGFyZSBwcmVzZXJ2ZWQgd2hlbiBuYXZpZ2F0aW5nIGJldHdlZW4gaW1hZ2VzIGluIHRoZSBzZXF1ZW5jZS5cbiAgKiAgICAgTm90ZTogc2V0dGluZyBwcmVzZXJ2ZU92ZXJsYXlzIG92ZXJyaWRlcyBhbnkgb3ZlcmxheXMgc3BlY2lmaWVkIGluIHRoZSBnbG9iYWxcbiAgKiAgICAgXCJvdmVybGF5c1wiIG9wdGlvbiBmb3IgdGhlIFZpZXdlci4gSXQncyBhbHNvIG5vdCBjb21wYXRpYmxlIHdpdGggc3BlY2lmeWluZ1xuICAqICAgICBwZXItdGlsZVNvdXJjZSBvdmVybGF5cyB2aWEgdGhlIG9wdGlvbnMsIGFzIHRob3NlIG92ZXJsYXlzIHdpbGwgcGVyc2lzdFxuICAqICAgICBldmVuIGFmdGVyIHRoZSB0aWxlU291cmNlIGlzIGNsb3NlZC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Nob3dSZWZlcmVuY2VTdHJpcD1mYWxzZV1cbiAgKiAgICAgSWYgc2VxdWVuY2VNb2RlIGlzIHRydWUsIHRoZW4gZGlzcGxheSBhIHNjcm9sbGluZyBzdHJpcCBvZiBpbWFnZSB0aHVtYm5haWxzIGZvclxuICAqICAgICBuYXZpZ2F0aW5nIHRocm91Z2ggdGhlIGltYWdlcy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcmVmZXJlbmNlU3RyaXBTY3JvbGw9J2hvcml6b250YWwnXVxuICAqXG4gICogQHByb3BlcnR5IHtFbGVtZW50fSBbcmVmZXJlbmNlU3RyaXBFbGVtZW50PW51bGxdXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3JlZmVyZW5jZVN0cmlwSGVpZ2h0PW51bGxdXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3JlZmVyZW5jZVN0cmlwV2lkdGg9bnVsbF1cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcmVmZXJlbmNlU3RyaXBQb3NpdGlvbj0nQk9UVE9NX0xFRlQnXVxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyZWZlcmVuY2VTdHJpcFNpemVSYXRpbz0wLjJdXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb2xsZWN0aW9uTW9kZT1mYWxzZV1cbiAgKiAgICAgU2V0IHRvIHRydWUgdG8gaGF2ZSB0aGUgdmlld2VyIGFycmFuZ2UgeW91ciBUaWxlZEltYWdlcyBpbiBhIGdyaWQgb3IgbGluZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbY29sbGVjdGlvblJvd3M9M11cbiAgKiAgICAgSWYgY29sbGVjdGlvbk1vZGUgaXMgdHJ1ZSwgc3BlY2lmaWVzIGhvdyBtYW55IHJvd3MgdGhlIGdyaWQgc2hvdWxkIGhhdmUuIFVzZSAxIHRvIG1ha2UgYSBsaW5lLlxuICAqICAgICBJZiBjb2xsZWN0aW9uTGF5b3V0IGlzICd2ZXJ0aWNhbCcsIHNwZWNpZmllcyBob3cgbWFueSBjb2x1bW5zIGluc3RlYWQuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbGxlY3Rpb25Db2x1bW5zPTBdXG4gICogICAgIElmIGNvbGxlY3Rpb25Nb2RlIGlzIHRydWUsIHNwZWNpZmllcyBob3cgbWFueSBjb2x1bW5zIHRoZSBncmlkIHNob3VsZCBoYXZlLiBVc2UgMSB0byBtYWtlIGEgbGluZS5cbiAgKiAgICAgSWYgY29sbGVjdGlvbkxheW91dCBpcyAndmVydGljYWwnLCBzcGVjaWZpZXMgaG93IG1hbnkgcm93cyBpbnN0ZWFkLiBJZ25vcmVkIGlmIGNvbGxlY3Rpb25Sb3dzIGlzIG5vdCBzZXQgdG8gYSBmYWxzeSB2YWx1ZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29sbGVjdGlvbkxheW91dD0naG9yaXpvbnRhbCddXG4gICogICAgIElmIGNvbGxlY3Rpb25Nb2RlIGlzIHRydWUsIHNwZWNpZmllcyB3aGV0aGVyIHRvIGFycmFuZ2UgdmVydGljYWxseSBvciBob3Jpem9udGFsbHkuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbGxlY3Rpb25UaWxlU2l6ZT04MDBdXG4gICogICAgIElmIGNvbGxlY3Rpb25Nb2RlIGlzIHRydWUsIHNwZWNpZmllcyB0aGUgc2l6ZSwgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMsIGZvciBlYWNoIFRpbGVkSW1hZ2UgdG8gZml0IGludG8uXG4gICogICAgIFRoZSBUaWxlZEltYWdlIHdpbGwgYmUgY2VudGVyZWQgd2l0aGluIGEgc3F1YXJlIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbY29sbGVjdGlvblRpbGVNYXJnaW49ODBdXG4gICogICAgIElmIGNvbGxlY3Rpb25Nb2RlIGlzIHRydWUsIHNwZWNpZmllcyB0aGUgbWFyZ2luLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcywgYmV0d2VlbiBlYWNoIFRpbGVkSW1hZ2UuXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ3xCb29sZWFufSBbY3Jvc3NPcmlnaW5Qb2xpY3k9ZmFsc2VdXG4gICogICAgIFZhbGlkIHZhbHVlcyBhcmUgJ0Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnLCBhbmQgZmFsc2UuIElmIGZhbHNlLCBjYW52YXMgcmVxdWVzdHMgd2lsbFxuICAqICAgICBub3QgdXNlIENPUlMsIGFuZCB0aGUgY2FudmFzIHdpbGwgYmUgdGFpbnRlZC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FqYXhXaXRoQ3JlZGVudGlhbHM9ZmFsc2VdXG4gICogICAgIFdoZXRoZXIgdG8gc2V0IHRoZSB3aXRoQ3JlZGVudGlhbHMgWEhSIGZsYWcgZm9yIEFKQVggcmVxdWVzdHMgKHdoZW4gbG9hZGluZyB0aWxlIHNvdXJjZXMpLlxuICAqICAgICBOb3RlIHRoYXQgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBhdCB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZX0gbGV2ZWwuXG4gICpcbiAgKi9cblxuIC8qKlxuICAqIFNldHRpbmdzIGZvciBnZXN0dXJlcyBnZW5lcmF0ZWQgYnkgYSBwb2ludGVyIGRldmljZS5cbiAgKlxuICAqIEB0eXBlZGVmIHtPYmplY3R9IEdlc3R1cmVTZXR0aW5nc1xuICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNjcm9sbFRvWm9vbVxuICAqICAgICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nIG9uIHNjcm9sbCBnZXN0dXJlcy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY2xpY2tUb1pvb21cbiAgKiAgICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZyBvbiBjbGljayBnZXN0dXJlcy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGJsQ2xpY2tUb1pvb21cbiAgKiAgICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZyBvbiBkb3VibGUtY2xpY2sgZ2VzdHVyZXMuIE5vdGU6IElmIHNldCB0byB0cnVlXG4gICogICAgIHRoZW4gY2xpY2tUb1pvb20gc2hvdWxkIGJlIHNldCB0byBmYWxzZSB0byBwcmV2ZW50IG11bHRpcGxlIHpvb21zLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBwaW5jaFRvWm9vbVxuICAqICAgICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nIG9uIHBpbmNoIGdlc3R1cmVzLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBmbGlja0VuYWJsZWRcbiAgKiAgICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIGtpbmV0aWMgcGFubmluZyBlZmZlY3QgKGZsaWNrKSBhdCB0aGUgZW5kIG9mIGEgZHJhZyBnZXN0dXJlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IGZsaWNrTWluU3BlZWRcbiAgKiAgICAgSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtaW5pbXVtIHNwZWVkIChpbiBwaXhlbHMtcGVyLXNlY29uZCkgcmVxdWlyZWQgdG8gY2F1c2UgdGhlIGtpbmV0aWMgcGFubmluZyBlZmZlY3QgKGZsaWNrKSBhdCB0aGUgZW5kIG9mIGEgZHJhZyBnZXN0dXJlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IGZsaWNrTW9tZW50dW1cbiAgKiAgICAgSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIGEgY29uc3RhbnQgbXVsdGlwbGllZCBieSB0aGUgdmVsb2NpdHkgdG8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBvZiB0aGUga2luZXRpYyBwYW5uaW5nIGVmZmVjdCAoZmxpY2spIGF0IHRoZSBlbmQgb2YgYSBkcmFnIGdlc3R1cmUuXG4gICogICAgIEEgbGFyZ2VyIHZhbHVlIHdpbGwgbWFrZSB0aGUgZmxpY2sgZmVlbCBcImxpZ2h0ZXJcIiwgd2hpbGUgYSBzbWFsbGVyIHZhbHVlIHdpbGwgbWFrZSB0aGUgZmxpY2sgZmVlbCBcImhlYXZpZXJcIi5cbiAgKiAgICAgTm90ZTogc3ByaW5nU3RpZmZuZXNzIGFuZCBhbmltYXRpb25UaW1lIGFsc28gYWZmZWN0IHRoZSBcInNwcmluZ1wiIHVzZWQgdG8gc3RvcCB0aGUgZmxpY2sgYW5pbWF0aW9uLlxuICAqXG4gICovXG5cbi8qKlxuICAqIFRoZSBuYW1lcyBmb3IgdGhlIGltYWdlIHJlc291cmNlcyB1c2VkIGZvciB0aGUgaW1hZ2UgbmF2aWdhdGlvbiBidXR0b25zLlxuICAqXG4gICogQHR5cGVkZWYge09iamVjdH0gTmF2SW1hZ2VzXG4gICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB6b29tSW4gLSBJbWFnZXMgZm9yIHRoZSB6b29tLWluIGJ1dHRvbi5cbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbUluLlJFU1RcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbUluLkdST1VQXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHpvb21Jbi5IT1ZFUlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB6b29tSW4uRE9XTlxuICAqXG4gICogQHByb3BlcnR5IHtPYmplY3R9IHpvb21PdXQgLSBJbWFnZXMgZm9yIHRoZSB6b29tLW91dCBidXR0b24uXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHpvb21PdXQuUkVTVFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB6b29tT3V0LkdST1VQXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHpvb21PdXQuSE9WRVJcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbU91dC5ET1dOXG4gICpcbiAgKiBAcHJvcGVydHkge09iamVjdH0gaG9tZSAtIEltYWdlcyBmb3IgdGhlIGhvbWUgYnV0dG9uLlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBob21lLlJFU1RcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gaG9tZS5HUk9VUFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBob21lLkhPVkVSXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGhvbWUuRE9XTlxuICAqXG4gICogQHByb3BlcnR5IHtPYmplY3R9IGZ1bGxwYWdlIC0gSW1hZ2VzIGZvciB0aGUgZnVsbC1wYWdlIGJ1dHRvbi5cbiAgKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbHBhZ2UuUkVTVFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxscGFnZS5HUk9VUFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxscGFnZS5IT1ZFUlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxscGFnZS5ET1dOXG4gICpcbiAgKiBAcHJvcGVydHkge09iamVjdH0gcm90YXRlbGVmdCAtIEltYWdlcyBmb3IgdGhlIHJvdGF0ZSBsZWZ0IGJ1dHRvbi5cbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlbGVmdC5SRVNUXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHJvdGF0ZWxlZnQuR1JPVVBcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlbGVmdC5IT1ZFUlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVsZWZ0LkRPV05cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByb3RhdGVyaWdodCAtIEltYWdlcyBmb3IgdGhlIHJvdGF0ZSByaWdodCBidXR0b24uXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHJvdGF0ZXJpZ2h0LlJFU1RcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlcmlnaHQuR1JPVVBcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlcmlnaHQuSE9WRVJcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlcmlnaHQuRE9XTlxuICAqXG4gICogQHByb3BlcnR5IHtPYmplY3R9IHByZXZpb3VzIC0gSW1hZ2VzIGZvciB0aGUgcHJldmlvdXMgYnV0dG9uLlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcmV2aW91cy5SRVNUXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHByZXZpb3VzLkdST1VQXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHByZXZpb3VzLkhPVkVSXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHByZXZpb3VzLkRPV05cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBuZXh0IC0gSW1hZ2VzIGZvciB0aGUgbmV4dCBidXR0b24uXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IG5leHQuUkVTVFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuZXh0LkdST1VQXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IG5leHQuSE9WRVJcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gbmV4dC5ET1dOXG4gICpcbiAgKi9cblxuXG4gLyoqXG4gICogVGhpcyBmdW5jdGlvbiBzZXJ2ZXMgYXMgYSBzaW5nbGUgcG9pbnQgb2YgaW5zdGFudGlhdGlvbiBmb3IgYW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyfSwgaW5jbHVkaW5nIGFsbFxuICAqIGNvbWJpbmF0aW9ucyBvZiBvdXQtb2YtdGhlLWJveCBjb25maWd1cmFibGUgZmVhdHVyZXMuXG4gICpcbiAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uT3B0aW9uc30gb3B0aW9ucyAtIFZpZXdlciBvcHRpb25zLlxuICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn1cbiAgKi9cbndpbmRvdy5PcGVuU2VhZHJhZ29uID0gd2luZG93Lk9wZW5TZWFkcmFnb24gfHwgZnVuY3Rpb24oIG9wdGlvbnMgKXtcblxuICAgIHJldHVybiBuZXcgT3BlblNlYWRyYWdvbi5WaWV3ZXIoIG9wdGlvbnMgKTtcblxufTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICByZXR1cm4gKHdpbmRvdy5PcGVuU2VhZHJhZ29uKTtcbiAgIH0pO1xufVxuXG5cbihmdW5jdGlvbiggJCApe1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgT3BlblNlYWRyYWdvbiB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBPcGVuU2VhZHJhZ29uLnZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gdmVyc2lvblN0ciAtIFRoZSB2ZXJzaW9uIG51bWJlciBhcyBhIHN0cmluZyAoJ21ham9yLm1pbm9yLnJldmlzaW9uJykuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1ham9yIC0gVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5vciAtIFRoZSBtaW5vciB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmV2aXNpb24gLSBUaGUgcmV2aXNpb24gbnVtYmVyLlxuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqL1xuICAgICQudmVyc2lvbiA9IHtcbiAgICAgICAgdmVyc2lvblN0cjogJzIuMi4xJyxcbiAgICAgICAgbWFqb3I6IHBhcnNlSW50KCcyJywgMTApLFxuICAgICAgICBtaW5vcjogcGFyc2VJbnQoJzInLCAxMCksXG4gICAgICAgIHJldmlzaW9uOiBwYXJzZUludCgnMScsIDEwKVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFRha2VuIGZyb20ganF1ZXJ5IDEuNi4xXG4gICAgICogW1tDbGFzc11dIC0+IHR5cGUgcGFpcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhciBjbGFzczJ0eXBlID0ge1xuICAgICAgICAgICAgJ1tvYmplY3QgQm9vbGVhbl0nOiAgICAgJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgJ1tvYmplY3QgTnVtYmVyXSc6ICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAnW29iamVjdCBTdHJpbmddJzogICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdbb2JqZWN0IEZ1bmN0aW9uXSc6ICAgICdmdW5jdGlvbicsXG4gICAgICAgICAgICAnW29iamVjdCBBcnJheV0nOiAgICAgICAnYXJyYXknLFxuICAgICAgICAgICAgJ1tvYmplY3QgRGF0ZV0nOiAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgJ1tvYmplY3QgUmVnRXhwXSc6ICAgICAgJ3JlZ2V4cCcsXG4gICAgICAgICAgICAnW29iamVjdCBPYmplY3RdJzogICAgICAnb2JqZWN0J1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHNvbWUgY29yZSBtZXRob2RzXG4gICAgICAgIHRvU3RyaW5nICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgaGFzT3duICAgICAgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqXG4gICAgICogVGFrZW4gZnJvbSBqUXVlcnkgMS42LjFcbiAgICAgKiBAZnVuY3Rpb24gaXNGdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5qcXVlcnkuY29tLyBqUXVlcnl9XG4gICAgICovXG4gICAgJC5pc0Z1bmN0aW9uID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgcmV0dXJuICQudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogVGFrZW4gZnJvbSBqUXVlcnkgMS42LjFcbiAgICAgKiBAZnVuY3Rpb24gaXNBcnJheVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5qcXVlcnkuY29tLyBqUXVlcnl9XG4gICAgICovXG4gICAgJC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICByZXR1cm4gJC50eXBlKG9iaikgPT09IFwiYXJyYXlcIjtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBBIGNydWRlIHdheSBvZiBkZXRlcm1pbmluZyBpZiBhbiBvYmplY3QgaXMgYSB3aW5kb3cuXG4gICAgICogVGFrZW4gZnJvbSBqUXVlcnkgMS42LjFcbiAgICAgKiBAZnVuY3Rpb24gaXNXaW5kb3dcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuanF1ZXJ5LmNvbS8galF1ZXJ5fVxuICAgICAqL1xuICAgICQuaXNXaW5kb3cgPSBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgXCJzZXRJbnRlcnZhbFwiIGluIG9iajtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBUYWtlbiBmcm9tIGpRdWVyeSAxLjYuMVxuICAgICAqIEBmdW5jdGlvbiB0eXBlXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmpxdWVyeS5jb20vIGpRdWVyeX1cbiAgICAgKi9cbiAgICAkLnR5cGUgPSBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICByZXR1cm4gKCBvYmogPT09IG51bGwgKSB8fCAoIG9iaiA9PT0gdW5kZWZpbmVkICkgP1xuICAgICAgICAgICAgU3RyaW5nKCBvYmogKSA6XG4gICAgICAgICAgICBjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKG9iaikgXSB8fCBcIm9iamVjdFwiO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFRha2VuIGZyb20galF1ZXJ5IDEuNi4xXG4gICAgICogQGZ1bmN0aW9uIGlzUGxhaW5PYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuanF1ZXJ5LmNvbS8galF1ZXJ5fVxuICAgICAqL1xuICAgICQuaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIC8vIE11c3QgYmUgYW4gT2JqZWN0LlxuICAgICAgICAvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgRE9NIG5vZGVzIGFuZCB3aW5kb3cgb2JqZWN0cyBkb24ndCBwYXNzIHRocm91Z2gsIGFzIHdlbGxcbiAgICAgICAgaWYgKCAhb2JqIHx8IE9wZW5TZWFkcmFnb24udHlwZShvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCAkLmlzV2luZG93KCBvYmogKSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3RcbiAgICAgICAgaWYgKCBvYmouY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICFoYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcbiAgICAgICAgICAgICFoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcbiAgICAgICAgLy8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cbiAgICAgICAgdmFyIGxhc3RLZXk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmogKSB7XG4gICAgICAgICAgICBsYXN0S2V5ID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhc3RLZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBsYXN0S2V5ICk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogVGFrZW4gZnJvbSBqUXVlcnkgMS42LjFcbiAgICAgKiBAZnVuY3Rpb24gaXNFbXB0eU9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5qcXVlcnkuY29tLyBqUXVlcnl9XG4gICAgICovXG4gICAgJC5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gb2JqICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaGltIGFyb3VuZCBPYmplY3QuZnJlZXplLiBEb2VzIG5vdGhpbmcgaWYgT2JqZWN0LmZyZWV6ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBmcmVlemUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmogVGhlIGZyb3plbiBvYmplY3QuXG4gICAgICovXG4gICAgJC5mcmVlemVPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICQuZnJlZXplT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuZnJlZXplT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQuZnJlZXplT2JqZWN0KG9iaik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEhUTUw1IGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc3VwcG9ydHNDYW52YXNcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqL1xuICAgICQuc3VwcG9ydHNDYW52YXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgIHJldHVybiAhISggJC5pc0Z1bmN0aW9uKCBjYW52YXNFbGVtZW50LmdldENvbnRleHQgKSAmJlxuICAgICAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50LmdldENvbnRleHQoICcyZCcgKSApO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIHN1Ym1pdHRlZCBjYW52YXMgaXMgdGFpbnRlZCBvciBub3QuXG4gICAgICogQGFyZ3VtZW50IHtDYW52YXN9IGNhbnZhcyBUaGUgY2FudmFzIHRvIHRlc3QuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIGNhbnZhcyBpcyB0YWludGVkLlxuICAgICAqL1xuICAgICQuaXNDYW52YXNUYWludGVkID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIHZhciBpc1RhaW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlIHRlc3QgaWYgdGhlIGNhbnZhcyBpcyB0YWludGVkIGJ5IHJldHJpZXZpbmcgZGF0YSBmcm9tIGl0LlxuICAgICAgICAgICAgLy8gQW4gZXhjZXB0aW9uIHdpbGwgYmUgcmFpc2VkIGlmIHRoZSBjYW52YXMgaXMgdGFpbnRlZC5cbiAgICAgICAgICAgIHZhciBkYXRhID0gY2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpc1RhaW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1RhaW50ZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgcmF0aW8gY29tcGFyaW5nIHRoZSBkZXZpY2Ugc2NyZWVuJ3MgcGl4ZWwgZGVuc2l0eSB0byB0aGUgY2FudmFzJ3MgYmFja2luZyBzdG9yZSBwaXhlbCBkZW5zaXR5LiBEZWZhdWx0cyB0byAxIGlmIGNhbnZhcyBpc24ndCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBwaXhlbERlbnNpdHlSYXRpb1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICovXG4gICAgJC5waXhlbERlbnNpdHlSYXRpbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICggJC5zdXBwb3J0c0NhbnZhcyApIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9KCkpO1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKipcbiAqICBUaGlzIGNsb3N1cmUgZGVmaW5lcyBhbGwgc3RhdGljIG1ldGhvZHMgYXZhaWxhYmxlIHRvIHRoZSBPcGVuU2VhZHJhZ29uXG4gKiAgbmFtZXNwYWNlLiAgTWFueSwgaWYgbm90IG1vc3QsIGFyZSB0YWtlZCBkaXJlY3RseSBmcm9tIGpRdWVyeSBmb3IgdXNlXG4gKiAgdG8gc2ltcGxpZnkgYW5kIHJlZHVjZSBjb21tb24gcHJvZ3JhbW1pbmcgcGF0dGVybnMuICBNb3JlIHN0YXRpYyBtZXRob2RzXG4gKiAgZnJvbSBqUXVlcnkgbWF5IGV2ZW50dWFsbHkgbWFrZSB0aGVpciB3YXkgaW50byB0aGlzIHRob3VnaCB3ZSBhcmVcbiAqICBhdHRlbXB0aW5nIHRvIGF2b2lkIGFuIGV4cGxpY2l0IGRlcGVuZGVuY3kgb24galF1ZXJ5IG9ubHkgYmVjYXVzZVxuICogIE9wZW5TZWFkcmFnb24gaXMgYSBicm9hZGx5IHVzZWZ1bCBjb2RlIGJhc2UgYW5kIHdvdWxkIGJlIG1hZGUgbGVzcyBicm9hZFxuICogIGJ5IHJlcXVpcmluZyBqUXVlcnkgZnVsbHkuXG4gKlxuICogIFNvbWUgc3RhdGljIG1ldGhvZHMgaGF2ZSBhbHNvIGJlZW4gcmVmYWN0b3JlZCBmcm9tIHRoZSBvcmlnaW5hbCBPcGVuU2VhZHJhZ29uXG4gKiAgcHJvamVjdC5cbiAqL1xuKGZ1bmN0aW9uKCAkICl7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlbiBmcm9tIGpRdWVyeSAxLjYuMVxuICAgICAqIEBmdW5jdGlvbiBleHRlbmRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuanF1ZXJ5LmNvbS8galF1ZXJ5fVxuICAgICAqL1xuICAgICQuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICBjb3B5SXNBcnJheSxcbiAgICAgICAgICAgIGNsb25lLFxuICAgICAgICAgICAgdGFyZ2V0ICA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuICAgICAgICAgICAgbGVuZ3RoICA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBkZWVwICAgID0gZmFsc2UsXG4gICAgICAgICAgICBpICAgICAgID0gMTtcblxuICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICBkZWVwICAgID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGFyZ2V0ICA9IGFyZ3VtZW50c1sgMSBdIHx8IHt9O1xuICAgICAgICAgICAgLy8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICAgICAgaSA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFPcGVuU2VhZHJhZ29uLmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuICAgICAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKCBsZW5ndGggPT09IGkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgLS1pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzWyBpIF07XG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMgIT09IG51bGwgfHwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRlZXAgJiYgY29weSAmJiAoIE9wZW5TZWFkcmFnb24uaXNQbGFpbk9iamVjdCggY29weSApIHx8ICggY29weUlzQXJyYXkgPSBPcGVuU2VhZHJhZ29uLmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgT3BlblNlYWRyYWdvbi5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIE9wZW5TZWFkcmFnb24uaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IE9wZW5TZWFkcmFnb24uZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgdmFyIGlzSU9TRGV2aWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgIHVzZXJBZ2VudC5pbmRleE9mKCdpUGFkJykgIT09IC0xIHx8XG4gICAgICAgICAgICAgICB1c2VyQWdlbnQuaW5kZXhPZignaVBvZCcpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgJC5leHRlbmQoICQsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbiAqL3tcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIG9wdGlvbmFsIHNldHRpbmdzIGRvY3VtZW50ZWQgYXQge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIERFRkFVTFRfU0VUVElOR1M6IHtcbiAgICAgICAgICAgIC8vREFUQSBTT1VSQ0UgREVUQUlMU1xuICAgICAgICAgICAgeG1sUGF0aDogICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRpbGVTb3VyY2VzOiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0aWxlSG9zdDogICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgaW5pdGlhbFBhZ2U6ICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luUG9saWN5OiAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYWpheFdpdGhDcmVkZW50aWFsczogICAgZmFsc2UsXG5cbiAgICAgICAgICAgIC8vUEFOIEFORCBaT09NIFNFVFRJTkdTIEFORCBDT05TVFJBSU5UU1xuICAgICAgICAgICAgcGFuSG9yaXpvbnRhbDogICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHBhblZlcnRpY2FsOiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBjb25zdHJhaW5EdXJpbmdQYW46ICAgICBmYWxzZSxcbiAgICAgICAgICAgIHdyYXBIb3Jpem9udGFsOiAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgd3JhcFZlcnRpY2FsOiAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICB2aXNpYmlsaXR5UmF0aW86ICAgICAgICAwLjUsIC8vLT4gaG93IG11Y2ggb2YgdGhlIHZpZXdlciBjYW4gYmUgbmVnYXRpdmUgc3BhY2VcbiAgICAgICAgICAgIG1pblBpeGVsUmF0aW86ICAgICAgICAgIDAuNSwgLy8tPmNsb3NlciB0byAwIGRyYXdzIHRpbGVzIG1lYW50IGZvciBhIGhpZ2hlciB6b29tIGF0IHRoaXMgem9vbVxuICAgICAgICAgICAgZGVmYXVsdFpvb21MZXZlbDogICAgICAgMCxcbiAgICAgICAgICAgIG1pblpvb21MZXZlbDogICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBtYXhab29tTGV2ZWw6ICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgaG9tZUZpbGxzVmlld2VyOiAgICAgICAgZmFsc2UsXG5cbiAgICAgICAgICAgIC8vVUkgUkVTUE9OU0lWRU5FU1MgQU5EIEZFRUxcbiAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogICAgIDMwMCxcbiAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogICAgIDUsXG4gICAgICAgICAgICBkYmxDbGlja1RpbWVUaHJlc2hvbGQ6ICAzMDAsXG4gICAgICAgICAgICBkYmxDbGlja0Rpc3RUaHJlc2hvbGQ6ICAyMCxcbiAgICAgICAgICAgIHNwcmluZ1N0aWZmbmVzczogICAgICAgIDYuNSxcbiAgICAgICAgICAgIGFuaW1hdGlvblRpbWU6ICAgICAgICAgIDEuMixcbiAgICAgICAgICAgIGdlc3R1cmVTZXR0aW5nc01vdXNlOiAgIHsgc2Nyb2xsVG9ab29tOiB0cnVlLCAgY2xpY2tUb1pvb206IHRydWUsICBkYmxDbGlja1RvWm9vbTogZmFsc2UsIHBpbmNoVG9ab29tOiBmYWxzZSwgZmxpY2tFbmFibGVkOiBmYWxzZSwgZmxpY2tNaW5TcGVlZDogMTIwLCBmbGlja01vbWVudHVtOiAwLjI1LCBwaW5jaFJvdGF0ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIGdlc3R1cmVTZXR0aW5nc1RvdWNoOiAgIHsgc2Nyb2xsVG9ab29tOiBmYWxzZSwgY2xpY2tUb1pvb206IGZhbHNlLCBkYmxDbGlja1RvWm9vbTogdHJ1ZSwgIHBpbmNoVG9ab29tOiB0cnVlLCAgZmxpY2tFbmFibGVkOiB0cnVlLCAgZmxpY2tNaW5TcGVlZDogMTIwLCBmbGlja01vbWVudHVtOiAwLjI1LCBwaW5jaFJvdGF0ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIGdlc3R1cmVTZXR0aW5nc1BlbjogICAgIHsgc2Nyb2xsVG9ab29tOiBmYWxzZSwgY2xpY2tUb1pvb206IHRydWUsICBkYmxDbGlja1RvWm9vbTogZmFsc2UsIHBpbmNoVG9ab29tOiBmYWxzZSwgZmxpY2tFbmFibGVkOiBmYWxzZSwgZmxpY2tNaW5TcGVlZDogMTIwLCBmbGlja01vbWVudHVtOiAwLjI1LCBwaW5jaFJvdGF0ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIGdlc3R1cmVTZXR0aW5nc1Vua25vd246IHsgc2Nyb2xsVG9ab29tOiBmYWxzZSwgY2xpY2tUb1pvb206IGZhbHNlLCBkYmxDbGlja1RvWm9vbTogdHJ1ZSwgIHBpbmNoVG9ab29tOiB0cnVlLCAgZmxpY2tFbmFibGVkOiB0cnVlLCAgZmxpY2tNaW5TcGVlZDogMTIwLCBmbGlja01vbWVudHVtOiAwLjI1LCBwaW5jaFJvdGF0ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIHpvb21QZXJDbGljazogICAgICAgICAgIDIsXG4gICAgICAgICAgICB6b29tUGVyU2Nyb2xsOiAgICAgICAgICAxLjIsXG4gICAgICAgICAgICB6b29tUGVyU2Vjb25kOiAgICAgICAgICAxLjAsXG4gICAgICAgICAgICBibGVuZFRpbWU6ICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgYWx3YXlzQmxlbmQ6ICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBhdXRvSGlkZUNvbnRyb2xzOiAgICAgICB0cnVlLFxuICAgICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBtaW5ab29tSW1hZ2VSYXRpbzogICAgICAwLjksIC8vLT4gY2xvc2VyIHRvIDAgYWxsb3dzIHpvb20gb3V0IHRvIGluZmluaXR5XG4gICAgICAgICAgICBtYXhab29tUGl4ZWxSYXRpbzogICAgICAxLjEsIC8vLT4gaGlnaGVyIGFsbG93cyAnb3ZlciB6b29tJyBpbnRvIHBpeGVsc1xuICAgICAgICAgICAgc21vb3RoVGlsZUVkZ2VzTWluWm9vbTogMS4xLCAvLy0+IGhpZ2hlciB0aGFuIG1heFpvb21QaXhlbFJhdGlvIGRpc2FibGVzIGl0XG4gICAgICAgICAgICBpT1NEZXZpY2U6ICAgICAgICAgICAgICBpc0lPU0RldmljZSgpLFxuICAgICAgICAgICAgcGl4ZWxzUGVyV2hlZWxMaW5lOiAgICAgNDAsXG4gICAgICAgICAgICBhdXRvUmVzaXplOiAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgcHJlc2VydmVJbWFnZVNpemVPblJlc2l6ZTogZmFsc2UsIC8vIHJlcXVpcmVzIGF1dG9SZXNpemU9dHJ1ZVxuICAgICAgICAgICAgbWluU2Nyb2xsRGVsdGFUaW1lOiAgICAgNTAsXG5cbiAgICAgICAgICAgIC8vREVGQVVMVCBDT05UUk9MIFNFVFRJTkdTXG4gICAgICAgICAgICBzaG93U2VxdWVuY2VDb250cm9sOiAgICAgdHJ1ZSwgIC8vU0VRVUVOQ0VcbiAgICAgICAgICAgIHNlcXVlbmNlQ29udHJvbEFuY2hvcjogICBudWxsLCAgLy9TRVFVRU5DRVxuICAgICAgICAgICAgcHJlc2VydmVWaWV3cG9ydDogICAgICAgIGZhbHNlLCAvL1NFUVVFTkNFXG4gICAgICAgICAgICBwcmVzZXJ2ZU92ZXJsYXlzOiAgICAgICAgZmFsc2UsIC8vU0VRVUVOQ0VcbiAgICAgICAgICAgIG5hdlByZXZOZXh0V3JhcDogICAgICAgICBmYWxzZSwgLy9TRVFVRU5DRVxuICAgICAgICAgICAgc2hvd05hdmlnYXRpb25Db250cm9sOiAgIHRydWUsICAvL1pPT00vSE9NRS9GVUxML1JPVEFUSU9OXG4gICAgICAgICAgICBuYXZpZ2F0aW9uQ29udHJvbEFuY2hvcjogbnVsbCwgIC8vWk9PTS9IT01FL0ZVTEwvUk9UQVRJT05cbiAgICAgICAgICAgIHNob3dab29tQ29udHJvbDogICAgICAgICB0cnVlLCAgLy9aT09NXG4gICAgICAgICAgICBzaG93SG9tZUNvbnRyb2w6ICAgICAgICAgdHJ1ZSwgIC8vSE9NRVxuICAgICAgICAgICAgc2hvd0Z1bGxQYWdlQ29udHJvbDogICAgIHRydWUsICAvL0ZVTExcbiAgICAgICAgICAgIHNob3dSb3RhdGlvbkNvbnRyb2w6ICAgICBmYWxzZSwgLy9ST1RBVElPTlxuICAgICAgICAgICAgY29udHJvbHNGYWRlRGVsYXk6ICAgICAgIDIwMDAsICAvL1pPT00vSE9NRS9GVUxML1NFUVVFTkNFXG4gICAgICAgICAgICBjb250cm9sc0ZhZGVMZW5ndGg6ICAgICAgMTUwMCwgIC8vWk9PTS9IT01FL0ZVTEwvU0VRVUVOQ0VcbiAgICAgICAgICAgIG1vdXNlTmF2RW5hYmxlZDogICAgICAgICB0cnVlLCAgLy9HRU5FUkFMIE1PVVNFIElOVEVSQUNUSVZJVFlcblxuICAgICAgICAgICAgLy9WSUVXUE9SVCBOQVZJR0FUT1IgU0VUVElOR1NcbiAgICAgICAgICAgIHNob3dOYXZpZ2F0b3I6ICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIG5hdmlnYXRvcklkOiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmF2aWdhdG9yUG9zaXRpb246ICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXZpZ2F0b3JTaXplUmF0aW86ICAgICAgICAgMC4yLFxuICAgICAgICAgICAgbmF2aWdhdG9yTWFpbnRhaW5TaXplUmF0aW86IGZhbHNlLFxuICAgICAgICAgICAgbmF2aWdhdG9yVG9wOiAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXZpZ2F0b3JMZWZ0OiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5hdmlnYXRvckhlaWdodDogICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmF2aWdhdG9yV2lkdGg6ICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXZpZ2F0b3JBdXRvUmVzaXplOiAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIG5hdmlnYXRvckF1dG9GYWRlOiAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgbmF2aWdhdG9yUm90YXRlOiAgICAgICAgICAgIHRydWUsXG5cbiAgICAgICAgICAgIC8vIElOSVRJQUwgUk9UQVRJT05cbiAgICAgICAgICAgIGRlZ3JlZXM6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgICAgICAgICAvLyBBUFBFQVJBTkNFXG4gICAgICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZU9wZXJhdGlvbjogICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJGaWxsU3R5bGU6ICAgICAgIG51bGwsXG5cbiAgICAgICAgICAgIC8vUkVGRVJFTkNFIFNUUklQIFNFVFRJTkdTXG4gICAgICAgICAgICBzaG93UmVmZXJlbmNlU3RyaXA6ICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgcmVmZXJlbmNlU3RyaXBTY3JvbGw6ICAgICAgICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZVN0cmlwRWxlbWVudDogICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZVN0cmlwSGVpZ2h0OiAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZVN0cmlwV2lkdGg6ICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZVN0cmlwUG9zaXRpb246ICAgICAgJ0JPVFRPTV9MRUZUJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZVN0cmlwU2l6ZVJhdGlvOiAgICAgMC4yLFxuXG4gICAgICAgICAgICAvL0NPTExFQ1RJT04gVklTVUFMSVpBVElPTiBTRVRUSU5HU1xuICAgICAgICAgICAgY29sbGVjdGlvblJvd3M6ICAgICAgICAgMywgLy9vciBjb2x1bW5zIGRlcGVuZGluZyBvbiBsYXlvdXRcbiAgICAgICAgICAgIGNvbGxlY3Rpb25Db2x1bW5zOiAgICAgIDAsIC8vY29sdW1ucyBpbiBob3Jpem9udGFsIGxheW91dCwgcm93cyBpbiB2ZXJ0aWNhbCBsYXlvdXRcbiAgICAgICAgICAgIGNvbGxlY3Rpb25MYXlvdXQ6ICAgICAgICdob3Jpem9udGFsJywgLy92ZXJ0aWNhbFxuICAgICAgICAgICAgY29sbGVjdGlvbk1vZGU6ICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBjb2xsZWN0aW9uVGlsZVNpemU6ICAgICA4MDAsXG4gICAgICAgICAgICBjb2xsZWN0aW9uVGlsZU1hcmdpbjogICA4MCxcblxuICAgICAgICAgICAgLy9QRVJGT1JNQU5DRSBTRVRUSU5HU1xuICAgICAgICAgICAgaW1hZ2VMb2FkZXJMaW1pdDogICAgICAgMCxcbiAgICAgICAgICAgIG1heEltYWdlQ2FjaGVDb3VudDogICAgIDIwMCxcbiAgICAgICAgICAgIHRpbWVvdXQ6ICAgICAgICAgICAgICAgIDMwMDAwLFxuICAgICAgICAgICAgdXNlQ2FudmFzOiAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFVzZSBjYW52YXMgZWxlbWVudCBmb3IgZHJhd2luZyBpZiBhdmFpbGFibGVcblxuICAgICAgICAgICAgLy9JTlRFUkZBQ0UgUkVTT1VSQ0UgU0VUVElOR1NcbiAgICAgICAgICAgIHByZWZpeFVybDogICAgICAgICAgICAgIFwiL2ltYWdlcy9cIixcbiAgICAgICAgICAgIG5hdkltYWdlczoge1xuICAgICAgICAgICAgICAgIHpvb21Jbjoge1xuICAgICAgICAgICAgICAgICAgICBSRVNUOiAgICd6b29taW5fcmVzdC5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBHUk9VUDogICd6b29taW5fZ3JvdXBob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBIT1ZFUjogICd6b29taW5faG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgRE9XTjogICAnem9vbWluX3ByZXNzZWQucG5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgem9vbU91dDoge1xuICAgICAgICAgICAgICAgICAgICBSRVNUOiAgICd6b29tb3V0X3Jlc3QucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgR1JPVVA6ICAnem9vbW91dF9ncm91cGhvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEhPVkVSOiAgJ3pvb21vdXRfaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgRE9XTjogICAnem9vbW91dF9wcmVzc2VkLnBuZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgUkVTVDogICAnaG9tZV9yZXN0LnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEdST1VQOiAgJ2hvbWVfZ3JvdXBob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBIT1ZFUjogICdob21lX2hvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIERPV046ICAgJ2hvbWVfcHJlc3NlZC5wbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdWxscGFnZToge1xuICAgICAgICAgICAgICAgICAgICBSRVNUOiAgICdmdWxscGFnZV9yZXN0LnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEdST1VQOiAgJ2Z1bGxwYWdlX2dyb3VwaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgSE9WRVI6ICAnZnVsbHBhZ2VfaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgRE9XTjogICAnZnVsbHBhZ2VfcHJlc3NlZC5wbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByb3RhdGVsZWZ0OiB7XG4gICAgICAgICAgICAgICAgICAgIFJFU1Q6ICAgJ3JvdGF0ZWxlZnRfcmVzdC5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBHUk9VUDogICdyb3RhdGVsZWZ0X2dyb3VwaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgSE9WRVI6ICAncm90YXRlbGVmdF9ob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBET1dOOiAgICdyb3RhdGVsZWZ0X3ByZXNzZWQucG5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcm90YXRlcmlnaHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgUkVTVDogICAncm90YXRlcmlnaHRfcmVzdC5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBHUk9VUDogICdyb3RhdGVyaWdodF9ncm91cGhvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEhPVkVSOiAgJ3JvdGF0ZXJpZ2h0X2hvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIERPV046ICAgJ3JvdGF0ZXJpZ2h0X3ByZXNzZWQucG5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHtcbiAgICAgICAgICAgICAgICAgICAgUkVTVDogICAncHJldmlvdXNfcmVzdC5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBHUk9VUDogICdwcmV2aW91c19ncm91cGhvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEhPVkVSOiAgJ3ByZXZpb3VzX2hvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIERPV046ICAgJ3ByZXZpb3VzX3ByZXNzZWQucG5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV4dDoge1xuICAgICAgICAgICAgICAgICAgICBSRVNUOiAgICduZXh0X3Jlc3QucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgR1JPVVA6ICAnbmV4dF9ncm91cGhvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEhPVkVSOiAgJ25leHRfaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgRE9XTjogICAnbmV4dF9wcmVzc2VkLnBuZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0RFVkVMT1BFUiBTRVRUSU5HU1xuICAgICAgICAgICAgZGVidWdNb2RlOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBkZWJ1Z0dyaWRDb2xvcjogICAgICAgICAnIzQzN0FCMidcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBnZXQgcmlkIG9mIHRoaXMuICBJIGNhbid0IHNlZSBob3cgaXQncyByZXF1aXJlZCBhdCBhbGwuICBMb29rc1xuICAgICAgICAgKiAgICAgICBsaWtlIGFuIGVhcmx5IGxlZ2FjeSBjb2RlIGFydGlmYWN0LlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIFNJR05BTDogXCItLS0tc2VhZHJhZ29uLS0tLVwiLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBpbnZva2VzIHRoZSBtZXRob2QgYXMgaWYgaXQgd2VyZSBhIG1ldGhvZCBiZWxvbmdpbmcgdG8gdGhlIG9iamVjdC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGVnYXRlOiBmdW5jdGlvbiggb2JqZWN0LCBtZXRob2QgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAoIGFyZ3MgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoIG9iamVjdCwgYXJncyApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBlbnVtZXJhdGlvbiBvZiBCcm93c2VyIHZlbmRvcnMuXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFVOS05PV05cbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IElFXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBGSVJFRk9YXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBTQUZBUklcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENIUk9NRVxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gT1BFUkFcbiAgICAgICAgICovXG4gICAgICAgIEJST1dTRVJTOiB7XG4gICAgICAgICAgICBVTktOT1dOOiAgICAwLFxuICAgICAgICAgICAgSUU6ICAgICAgICAgMSxcbiAgICAgICAgICAgIEZJUkVGT1g6ICAgIDIsXG4gICAgICAgICAgICBTQUZBUkk6ICAgICAzLFxuICAgICAgICAgICAgQ0hST01FOiAgICAgNCxcbiAgICAgICAgICAgIE9QRVJBOiAgICAgIDVcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgRE9NIEVsZW1lbnQgZm9yIHRoZSBnaXZlbiBpZCBvciBlbGVtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gZWxlbWVudCBBY2NlcHRzIGFuIGlkIG9yIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBpZCwgbnVsbCwgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiAoIGVsZW1lbnQgKSA9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggZWxlbWVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgcG9zaXRpb24gb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudCAtIHRoZSBlbGVtZW5ldCB3ZSB3YW50IHRoZSBwb3NpdGlvbiBmb3IuXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSAtIHRoZSBwb3NpdGlvbiBvZiB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbGVtZW50UG9zaXRpb246IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyAkLlBvaW50KCksXG4gICAgICAgICAgICAgICAgaXNGaXhlZCxcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQ7XG5cbiAgICAgICAgICAgIGVsZW1lbnQgICAgICA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICAgICAgaXNGaXhlZCAgICAgID0gJC5nZXRFbGVtZW50U3R5bGUoIGVsZW1lbnQgKS5wb3NpdGlvbiA9PSBcImZpeGVkXCI7XG4gICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoIGVsZW1lbnQsIGlzRml4ZWQgKTtcblxuICAgICAgICAgICAgd2hpbGUgKCBvZmZzZXRQYXJlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQueCArPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnkgKz0gZWxlbWVudC5vZmZzZXRUb3A7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzRml4ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5wbHVzKCAkLmdldFBhZ2VTY3JvbGwoKSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBvZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgaXNGaXhlZCA9ICQuZ2V0RWxlbWVudFN0eWxlKCBlbGVtZW50ICkucG9zaXRpb24gPT0gXCJmaXhlZFwiO1xuICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudCggZWxlbWVudCwgaXNGaXhlZCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgZWxlbWVudCBhZGp1c3RlZCBmb3IgY3VycmVudCBwYWdlIGFuZC9vciBlbGVtZW50IHNjcm9sbC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB3ZSB3YW50IHRoZSBwb3NpdGlvbiBmb3IuXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSAtIHRoZSBwb3NpdGlvbiBvZiB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnQgYWRqdXN0ZWQgZm9yIGN1cnJlbnQgcGFnZSBhbmQvb3IgZWxlbWVudCBzY3JvbGwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbGVtZW50T2Zmc2V0OiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgdmFyIGRvYyA9IGVsZW1lbnQgJiYgZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGRvY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgd2luLFxuICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgICAgICAgICAgIGlmICggIWRvYyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9jRWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSB0eXBlb2YgdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbiA9ICggZG9jID09IGRvYy53aW5kb3cgKSA/XG4gICAgICAgICAgICAgICAgZG9jIDpcbiAgICAgICAgICAgICAgICAoIGRvYy5ub2RlVHlwZSA9PT0gOSApID9cbiAgICAgICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgOlxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ICsgKCB3aW4ucGFnZVhPZmZzZXQgfHwgZG9jRWxlbWVudC5zY3JvbGxMZWZ0ICkgLSAoIGRvY0VsZW1lbnQuY2xpZW50TGVmdCB8fCAwICksXG4gICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0LnRvcCArICggd2luLnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW1lbnQuc2Nyb2xsVG9wICkgLSAoIGRvY0VsZW1lbnQuY2xpZW50VG9wIHx8IDAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEVsZW1lbnRTaXplOiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgQ1NTU3R5bGUgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybnMge0NTU1N0eWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RWxlbWVudFN0eWxlOlxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSA/XG4gICAgICAgICAgICBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY3VycmVudFN0eWxlO1xuICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtZW50LCBcIlwiICk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB3aXRoIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXggYXBwZW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcHJvcGVydHkgd2l0aCB0aGUgY29ycmVjdCBwcmVmaXggb3IgbnVsbCBpZiBub3RcbiAgICAgICAgICogc3VwcG9ydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q3NzUHJvcGVydHlXaXRoVmVuZG9yUHJlZml4OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdmFyIG1lbW8gPSB7fTtcblxuICAgICAgICAgICAgJC5nZXRDc3NQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXggPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGlmIChtZW1vW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdNUycsICdPJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9ICQuY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcmVmaXhlc1tpXSArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZW1vW3Byb3BlcnR5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkLmdldENzc1Byb3BlcnR5V2l0aFZlbmRvclByZWZpeChwcm9wZXJ0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcGl0YWxpemVzIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHdpdGggdGhlIGZpcnN0IGxldHRlciBjYXBpdGFsaXplZFxuICAgICAgICAgKi9cbiAgICAgICAgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgYSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAoaGl0LXRlc3QpLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50XG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRJbkVsZW1lbnQ6IGZ1bmN0aW9uKCBlbGVtZW50LCBwb2ludCApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAkLmdldEVsZW1lbnRPZmZzZXQoIGVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICBzaXplID0gJC5nZXRFbGVtZW50U2l6ZSggZWxlbWVudCApO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gb2Zmc2V0LnggJiYgcG9pbnQueCA8IG9mZnNldC54ICsgc2l6ZS54ICYmIHBvaW50LnkgPCBvZmZzZXQueSArIHNpemUueSAmJiBwb2ludC55ID49IG9mZnNldC55O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGxhdGVzdCBldmVudCwgcmVhbGx5IG9ubHkgdXNlZnVsIGludGVybmFsbHkgc2luY2UgaXRzXG4gICAgICAgICAqIHNwZWNpZmljIHRvIElFIGJlaGF2aW9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gW2V2ZW50XVxuICAgICAgICAgKiBAcmV0dXJucyB7RXZlbnR9XG4gICAgICAgICAqIEBkZXByZWNhdGVkIEZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXZlbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGlmKCBldmVudCApe1xuICAgICAgICAgICAgICAgICQuZ2V0RXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkLmdldEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkLmdldEV2ZW50KCBldmVudCApO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBvbiB0aGUgc2NyZWVuIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gW2V2ZW50XVxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1vdXNlUG9zaXRpb246IGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YoIGV2ZW50LnBhZ2VYICkgPT0gXCJudW1iZXJcIiApIHtcbiAgICAgICAgICAgICAgICAkLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbiggZXZlbnQgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyAkLlBvaW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQueCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQueSA9IGV2ZW50LnBhZ2VZO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiggZXZlbnQuY2xpZW50WCApID09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICAgICAgJC5nZXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oIGV2ZW50ICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgJC5Qb2ludCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2xpZW50WCArXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC55ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNsaWVudFkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJVbmtub3duIGV2ZW50IG1vdXNlIHBvc2l0aW9uLCBubyBrbm93biB0ZWNobmlxdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJC5nZXRNb3VzZVBvc2l0aW9uKCBldmVudCApO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIHBhZ2UncyBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UGFnZVNjcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZG9jRWxlbWVudCAgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwge30sXG4gICAgICAgICAgICAgICAgYm9keSAgICAgICAgPSBkb2N1bWVudC5ib2R5IHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiggd2luZG93LnBhZ2VYT2Zmc2V0ICkgPT0gXCJudW1iZXJcIiApIHtcbiAgICAgICAgICAgICAgICAkLmdldFBhZ2VTY3JvbGwgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggYm9keS5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsVG9wICkge1xuICAgICAgICAgICAgICAgICQuZ2V0UGFnZVNjcm9sbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGRvY0VsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2NFbGVtZW50LnNjcm9sbFRvcCApIHtcbiAgICAgICAgICAgICAgICAkLmdldFBhZ2VTY3JvbGwgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCByZWFzc2lnbiB0aGUgZnVuY3Rpb24geWV0LCBhcyB0aGVyZSB3YXMgbm8gc2Nyb2xsLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCgwLDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJC5nZXRQYWdlU2Nyb2xsKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcGFnZSBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIHNldFBhZ2VTY3JvbGw6IGZ1bmN0aW9uKCBzY3JvbGwgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiAoIHdpbmRvdy5zY3JvbGxUbyApICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICAgICAgICAgICQuc2V0UGFnZVNjcm9sbCA9IGZ1bmN0aW9uKCBzY3JvbGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyggc2Nyb2xsLngsIHNjcm9sbC55ICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2Nyb2xsID0gJC5nZXRQYWdlU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgaWYgKCBvcmlnaW5hbFNjcm9sbC54ID09PSBzY3JvbGwueCAmJlxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNjcm9sbC55ID09PSBzY3JvbGwueSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFscmVhZHkgY29ycmVjdGx5IHBvc2l0aW9uZWQgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vIHdheSB0byBkZXRlY3QgdGhlIGNvcnJlY3QgbWV0aG9kLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID0gc2Nyb2xsLng7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSBzY3JvbGwueTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNjcm9sbCA9ICQuZ2V0UGFnZVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIGlmICggY3VycmVudFNjcm9sbC54ICE9PSBvcmlnaW5hbFNjcm9sbC54ICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY3JvbGwueSAhPT0gb3JpZ2luYWxTY3JvbGwueSApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5zZXRQYWdlU2Nyb2xsID0gZnVuY3Rpb24oIHNjcm9sbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA9IHNjcm9sbC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSBzY3JvbGwueTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsLng7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbC55O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTY3JvbGwgPSAkLmdldFBhZ2VTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAoIGN1cnJlbnRTY3JvbGwueCAhPT0gb3JpZ2luYWxTY3JvbGwueCAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Nyb2xsLnkgIT09IG9yaWdpbmFsU2Nyb2xsLnkgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuc2V0UGFnZVNjcm9sbCA9IGZ1bmN0aW9uKCBzY3JvbGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbC55O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZmluZCBhbnl0aGluZyB3b3JraW5nLCBzbyB3ZSBkbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgICQuc2V0UGFnZVNjcm9sbCA9IGZ1bmN0aW9uKCBzY3JvbGwgKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICQuc2V0UGFnZVNjcm9sbCggc2Nyb2xsICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIHNpemUgb2YgdGhlIGJyb3dzZXJzIHdpbmRvdy5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2luZG93U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCB7fSxcbiAgICAgICAgICAgICAgICBib2R5ICAgID0gZG9jdW1lbnQuYm9keSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YoIHdpbmRvdy5pbm5lcldpZHRoICkgPT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgJC5nZXRXaW5kb3dTaXplID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggZG9jRWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2NFbGVtZW50LmNsaWVudEhlaWdodCApIHtcbiAgICAgICAgICAgICAgICAkLmdldFdpbmRvd1NpemUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJvZHkuY2xpZW50V2lkdGggfHwgYm9keS5jbGllbnRIZWlnaHQgKSB7XG4gICAgICAgICAgICAgICAgJC5nZXRXaW5kb3dTaXplID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB3aW5kb3cgc2l6ZSwgbm8ga25vd24gdGVjaG5pcXVlLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICQuZ2V0V2luZG93U2l6ZSgpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXBzIHRoZSBnaXZlbiBlbGVtZW50IGluIGEgbmVzdCBvZiBkaXZzIHNvIHRoYXQgdGhlIGVsZW1lbnQgY2FuXG4gICAgICAgICAqIGJlIGVhc2lseSBjZW50ZXJlZCB1c2luZyBDU1MgdGFibGVzXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBvdXRlcm1vc3Qgd3JhcHBlciBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBtYWtlQ2VudGVyZWROb2RlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgYSBwb3NzaWJsZSBJRCB0byBhbiBhY3R1YWwgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBDU1MgdGFibGVzIHJlcXVpcmUgeW91IHRvIGhhdmUgYSBkaXNwbGF5OnRhYmxlL3Jvdy9jZWxsIGhpZXJhcmNoeSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZVxuICAgICAgICAgICAgICAgIHRocmVlIG5lc3RlZCB3cmFwcGVyIGRpdnM6XG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgdmFyIHdyYXBwZXJzID0gW1xuICAgICAgICAgICAgICAgICQubWFrZU5ldXRyYWxFbGVtZW50KCAnZGl2JyApLFxuICAgICAgICAgICAgICAgICQubWFrZU5ldXRyYWxFbGVtZW50KCAnZGl2JyApLFxuICAgICAgICAgICAgICAgICQubWFrZU5ldXRyYWxFbGVtZW50KCAnZGl2JyApXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAvLyBJdCBmZWVscyBsaWtlIHdlIHNob3VsZCBiZSBhYmxlIHRvIHBhc3Mgc3R5bGUgZGljdHMgdG8gbWFrZU5ldXRyYWxFbGVtZW50OlxuICAgICAgICAgICAgJC5leHRlbmQod3JhcHBlcnNbMF0uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcInRhYmxlXCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkLmV4dGVuZCh3cmFwcGVyc1sxXS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwidGFibGUtcm93XCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkLmV4dGVuZCh3cmFwcGVyc1syXS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwidGFibGUtY2VsbFwiLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd3JhcHBlcnNbMF0uYXBwZW5kQ2hpbGQod3JhcHBlcnNbMV0pO1xuICAgICAgICAgICAgd3JhcHBlcnNbMV0uYXBwZW5kQ2hpbGQod3JhcHBlcnNbMl0pO1xuICAgICAgICAgICAgd3JhcHBlcnNbMl0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyc1swXTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGVhc2lseSBwb3NpdGlvbmFibGUgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZSB0aGF0IHRoZXJlZm9yXG4gICAgICAgICAqIHNlcnZlcyBhcyBhbiBleGNlbGxlbnQgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIG1ha2VOZXV0cmFsRWxlbWVudDogZnVuY3Rpb24oIHRhZ05hbWUgKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHRhZ05hbWUgKSxcbiAgICAgICAgICAgICAgICBzdHlsZSAgID0gZWxlbWVudC5zdHlsZTtcblxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZCA9IFwidHJhbnNwYXJlbnQgbm9uZVwiO1xuICAgICAgICAgICAgc3R5bGUuYm9yZGVyICAgICA9IFwibm9uZVwiO1xuICAgICAgICAgICAgc3R5bGUubWFyZ2luICAgICA9IFwiMHB4XCI7XG4gICAgICAgICAgICBzdHlsZS5wYWRkaW5nICAgID0gXCIwcHhcIjtcbiAgICAgICAgICAgIHN0eWxlLnBvc2l0aW9uICAgPSBcInN0YXRpY1wiO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1pbGxpc2Vjb25kcywgdXNpbmcgRGF0ZS5ub3coKSBpZiBhdmFpbGFibGVcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBub3c6IGZ1bmN0aW9uKCApIHtcbiAgICAgICAgICBpZiAoRGF0ZS5ub3cpIHtcbiAgICAgICAgICAgICQubm93ID0gRGF0ZS5ub3c7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQubm93ID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJC5ub3coKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnN1cmVzIGFuIGltYWdlIGlzIGxvYWRlZCBjb3JyZWN0bHkgdG8gc3VwcG9ydCBhbHBoYSB0cmFuc3BhcmVuY3kuXG4gICAgICAgICAqIEdlbmVyYWxseSBvbmx5IElFIGhhcyBpc3N1ZXMgZG9pbmcgdGhpcyBjb3JyZWN0bHkgZm9yIGZvcm1hdHMgbGlrZVxuICAgICAgICAgKiBwbmcuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZVRyYW5zcGFyZW50SW1hZ2U6IGZ1bmN0aW9uKCBzcmMgKSB7XG5cbiAgICAgICAgICAgICQubWFrZVRyYW5zcGFyZW50SW1hZ2UgPSBmdW5jdGlvbiggc3JjICl7XG4gICAgICAgICAgICAgICAgdmFyIGltZyA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImltZ1wiICk7XG5cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gc3JjO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGltZztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICggJC5Ccm93c2VyLnZlbmRvciA9PSAkLkJST1dTRVJTLklFICYmICQuQnJvd3Nlci52ZXJzaW9uIDwgNyApIHtcblxuICAgICAgICAgICAgICAgICQubWFrZVRyYW5zcGFyZW50SW1hZ2UgPSBmdW5jdGlvbiggc3JjICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWcgICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiaW1nXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAkLm1ha2VOZXV0cmFsRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCAgPSBlbGVtZW50LnN0eWxlLndpZHRoIHx8IGltZy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gZWxlbWVudC5zdHlsZS5oZWlnaHQgfHwgaW1nLmhlaWdodCArIFwicHhcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcgPSBudWxsOyAgICAgLy8gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZpbHRlciA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYUltYWdlTG9hZGVyKHNyYz0nXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJywgc2l6aW5nTWV0aG9kPSdzY2FsZScpXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJC5tYWtlVHJhbnNwYXJlbnRJbWFnZSggc3JjICk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcGFjaXR5XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZXNBbHBoYV1cbiAgICAgICAgICovXG4gICAgICAgIHNldEVsZW1lbnRPcGFjaXR5OiBmdW5jdGlvbiggZWxlbWVudCwgb3BhY2l0eSwgdXNlc0FscGhhICkge1xuXG4gICAgICAgICAgICB2YXIgaWVPcGFjaXR5LFxuICAgICAgICAgICAgICAgIGllRmlsdGVyO1xuXG4gICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG5cbiAgICAgICAgICAgIGlmICggdXNlc0FscGhhICYmICEkLkJyb3dzZXIuYWxwaGEgKSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IE1hdGgucm91bmQoIG9wYWNpdHkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAkLkJyb3dzZXIub3BhY2l0eSApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5IDwgMSA/IG9wYWNpdHkgOiBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIG9wYWNpdHkgPCAxICkge1xuICAgICAgICAgICAgICAgICAgICBpZU9wYWNpdHkgPSBNYXRoLnJvdW5kKCAxMDAgKiBvcGFjaXR5ICk7XG4gICAgICAgICAgICAgICAgICAgIGllRmlsdGVyICA9IFwiYWxwaGEob3BhY2l0eT1cIiArIGllT3BhY2l0eSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZpbHRlciA9IGllRmlsdGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZmlsdGVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQncyB0b3VjaC1hY3Rpb24gc3R5bGUgYXR0cmlidXRlIHRvICdub25lJy5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHNldEVsZW1lbnRUb3VjaEFjdGlvbk5vbmU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBlbGVtZW50LnN0eWxlLm1zVG91Y2hBY3Rpb24gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdGhlIHNwZWNpZmllZCBDU1MgY2xhc3MgdG8gdGhlIGVsZW1lbnQgaWYgbm90IHByZXNlbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwgY2xhc3NOYW1lICkge1xuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuXG4gICAgICAgICAgICBpZiAoICEgZWxlbWVudC5jbGFzc05hbWUgKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAoICcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICkuXG4gICAgICAgICAgICAgICAgaW5kZXhPZiggJyAnICsgY2xhc3NOYW1lICsgJyAnICkgPT09IC0xICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYW4gZWxlbWVudCBpcyBmb3VuZCBpbiBhbiBhcnJheSBvciAtMVxuICAgICAgICAgKiBpZiBub3QgcHJlc2VudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29kZSB0YWtlbiBhbmQgYWRhcHRlZCBmcm9tXG4gICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YjQ29tcGF0aWJpbGl0eVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IGZyb20gd2hpY2ggdG8gZmluZCB0aGUgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VhcmNoRWxlbWVudCBUaGUgZWxlbWVudCB0byBmaW5kXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4PTBdIEluZGV4IHRvIHN0YXJ0IHJlc2VhcmNoLlxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXhPZjogZnVuY3Rpb24oIGFycmF5LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggKSB7XG4gICAgICAgICAgICBpZiAoIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhPZiA9IGZ1bmN0aW9uKCBhcnJheSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZiggc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4ICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE9mID0gZnVuY3Rpb24oIGFycmF5LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGl2b3QgPSAoIGZyb21JbmRleCApID8gZnJvbUluZGV4IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhYXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gMCB8fCBwaXZvdCA+PSBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBpdm90IDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpdm90ID0gbGVuZ3RoIC0gTWF0aC5hYnMoIHBpdm90ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gcGl2b3Q7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKCBhcnJheSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgc3BlY2lmaWVkIENTUyBjbGFzcyBmcm9tIHRoZSBlbGVtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGNsYXNzTmFtZSApIHtcbiAgICAgICAgICAgIHZhciBvbGRDbGFzc2VzLFxuICAgICAgICAgICAgICAgIG5ld0NsYXNzZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICBvbGRDbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoIC9cXHMrLyApO1xuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBvbGRDbGFzc2VzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggb2xkQ2xhc3Nlc1sgaSBdICYmIG9sZENsYXNzZXNbIGkgXSAhPT0gY2xhc3NOYW1lICkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goIG9sZENsYXNzZXNbIGkgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3Q2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGVsZW1lbnQsIGV2ZW50TmFtZSBhbmQgaGFuZGxlci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gICAgICAgICAqL1xuICAgICAgICBhZGRFdmVudDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICggd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHdpbmRvdy5hdHRhY2hFdmVudCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRhY2hFdmVudCggJ29uJyArIGV2ZW50TmFtZSwgaGFuZGxlciApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJObyBrbm93biBldmVudCBtb2RlbC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KCkpLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIGdpdmVuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCwgZXZlbnQgdHlwZSBhbmRcbiAgICAgICAgICogaGFuZGxlci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVFdmVudDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICggd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHdpbmRvdy5kZXRhY2hFdmVudCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCAnb24nICsgZXZlbnROYW1lLCBoYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIk5vIGtub3duIGV2ZW50IG1vZGVsLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0oKSksXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuY2VscyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGhhZCB0aGUgZXZlbnQgcHJvcGFnYXRlZCBhbGxcbiAgICAgICAgICogdGhlIHdheSB1cCB0aGUgRE9NIHRvIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gW2V2ZW50XVxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsRXZlbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICAgICAgaWYgKCBldmVudC5wcmV2ZW50RGVmYXVsdCApIHtcbiAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFczQyBmb3IgcHJldmVudGluZyBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApe1xuICAgICAgICAgICAgICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlZ2FjeSBmb3IgcHJldmVudGluZyBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIGZvciBwcmV2ZW50aW5nIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50IHVwIHRoZSBET00uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnRdXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wRXZlbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICAgICAgaWYgKCBldmVudC5zdG9wUHJvcGFnYXRpb24gKSB7XG4gICAgICAgICAgICAgICAgLy8gVzNDIGZvciBzdG9wcGluZyBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICAgICQuc3RvcEV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICl7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElFIGZvciBzdG9wcGluZyBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICAgICQuc3RvcEV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICl7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuc3RvcEV2ZW50KCBldmVudCApO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbWlsYXIgdG8gT3BlblNlYWRyYWdvbi5kZWxlZ2F0ZSwgYnV0IGl0IGRvZXMgbm90IGltbWVkaWF0ZWx5IGNhbGxcbiAgICAgICAgICogdGhlIG1ldGhvZCBvbiB0aGUgb2JqZWN0LCByZXR1cm5pbmcgYSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkXG4gICAgICAgICAqIHJlcGVhdGVkbHkgdG8gZGVsZWdhdGUgdGhlIG1ldGhvZC4gSXQgYWxzbyBhbGxvd3MgYWRkaXRvbmFsIGFyZ3VtZW50c1xuICAgICAgICAgKiB0byBiZSBwYXNzZWQgZHVyaW5nIGNvbnN0cnVjdGlvbiB3aGljaCB3aWxsIGJlIGFkZGVkIGR1cmluZyBlYWNoXG4gICAgICAgICAqIGludm9jYXRpb24sIGFuZCBlYWNoIGludm9jYXRpb24gY2FuIGFkZCBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcyB3ZWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIFthcmdzXSBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gdGhlXG4gICAgICAgICAqICBjcmVhdGVkIGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNhbGxiYWNrOiBmdW5jdGlvbiggb2JqZWN0LCBtZXRob2QgKSB7XG4gICAgICAgICAgICAvL1RPRE86IFRoaXMgcGF0dGVybiBpcyBwYWluZnVsIHRvIHVzZSBhbmQgZGVidWcuICBJdCdzIG11Y2ggY2xlYW5lclxuICAgICAgICAgICAgLy8gICAgICB0byB1c2UgcGlubmluZyBwbHVzIGFub255bW91cyBmdW5jdGlvbnMuICBHZXQgcmlkIG9mIHRoaXNcbiAgICAgICAgICAgIC8vICAgICAgcGF0dGVybiFcbiAgICAgICAgICAgIHZhciBpbml0aWFsQXJncyA9IFtdLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKCBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsQXJncy5wdXNoKCBhcmd1bWVudHNbIGkgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBpbml0aWFsQXJncy5jb25jYXQoIFtdICksXG4gICAgICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCggYXJndW1lbnRzWyBpIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KCBvYmplY3QsIGFyZ3MgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmVpdmVzIHRoZSB2YWx1ZSBvZiBhIHVybCBwYXJhbWV0ZXIgZnJvbSB0aGUgd2luZG93LmxvY2F0aW9uIHN0cmluZy5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSB1cmwgcGFyYW1ldGVyIG9yIG51bGwgaWYgbm8gcGFyYW0gbWF0Y2hlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldFVybFBhcmFtZXRlcjogZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IFVSTFBBUkFNU1sga2V5IF07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgcHJvdG9jb2wgdXNlZCBieSB0aGUgdXJsLiBUaGUgdXJsIGNhbiBlaXRoZXIgYmUgYWJzb2x1dGVcbiAgICAgICAgICogb3IgcmVsYXRpdmUuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gcmV0cmlldmUgdGhlIHByb3RvY29sIGZyb20uXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHByb3RvY29sIChodHRwOiwgaHR0cHM6LCBmaWxlOiwgZnRwOiAuLi4pXG4gICAgICAgICAqL1xuICAgICAgICBnZXRVcmxQcm90b2NvbDogZnVuY3Rpb24oIHVybCApIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHVybC5tYXRjaCgvXihbYS16XSs6KVxcL1xcLy9pKTtcbiAgICAgICAgICAgIGlmICggbWF0Y2ggPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVsYXRpdmUgVVJMLCByZXRyaXZlIHRoZSBwcm90b2NvbCBmcm9tIHdpbmRvdy5sb2NhdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIFhIUiBvYmplY3RcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSBbbG9jYWxdIElmIHNldCB0byB0cnVlLCB0aGUgWEhSIHdpbGwgYmUgZmlsZTogcHJvdG9jb2xcbiAgICAgICAgICogY29tcGF0aWJsZSBpZiBwb3NzaWJsZSAoYnV0IG1heSByYWlzZSBhIHdhcm5pbmcgaW4gdGhlIGJyb3dzZXIpLlxuICAgICAgICAgKiBAcmV0dXJucyB7WE1MSHR0cFJlcXVlc3R9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVBamF4UmVxdWVzdDogZnVuY3Rpb24oIGxvY2FsICkge1xuICAgICAgICAgICAgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IHdpbmRvdy5BY3RpdmVYT2JqZWN0IHNvIHdlIGp1c3QgdHJ5IHRvXG4gICAgICAgICAgICAvLyBjcmVhdGUgb25lIHRvIHNlZSBpZiBpdCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kbjQyMzk0OCUyOHY9dnMuODUlMjkuYXNweFxuICAgICAgICAgICAgdmFyIHN1cHBvcnRBY3RpdmVYO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvKiBnbG9iYWwgQWN0aXZlWE9iamVjdDp0cnVlICovXG4gICAgICAgICAgICAgICAgc3VwcG9ydEFjdGl2ZVggPSAhIW5ldyBBY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxIVFRQXCIgKTtcbiAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydEFjdGl2ZVggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBzdXBwb3J0QWN0aXZlWCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5jcmVhdGVBamF4UmVxdWVzdCA9IGZ1bmN0aW9uKCBsb2NhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbG9jYWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxIVFRQXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkLmNyZWF0ZUFqYXhSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTEhUVFBcIiApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCApIHtcbiAgICAgICAgICAgICAgICAkLmNyZWF0ZUFqYXhSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiQnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkLmNyZWF0ZUFqYXhSZXF1ZXN0KCBsb2NhbCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBSkFYIHJlcXVlc3QuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIHRoZSB1cmwgdG8gcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnN1Y2Nlc3MgLSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZXJyb3IgLSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM9ZmFsc2VdIC0gd2hldGhlciB0byBzZXQgdGhlIFhIUidzIHdpdGhDcmVkZW50aWFsc1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIG1ha2VBamF4UmVxdWVzdDogZnVuY3Rpb24oIHVybCwgb25TdWNjZXNzLCBvbkVycm9yICkge1xuICAgICAgICAgICAgdmFyIHdpdGhDcmVkZW50aWFscztcblxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG91ciBwcmVmZXJyZWQgQVBJIGlzIHRoYXQgeW91IHBhc3MgaW4gYSBzaW5nbGUgb2JqZWN0OyB0aGUgbmFtZWRcbiAgICAgICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgZm9yIGxlZ2FjeSBzdXBwb3J0LlxuICAgICAgICAgICAgaWYoICQuaXNQbGFpbk9iamVjdCggdXJsICkgKXtcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3MgPSB1cmwuc3VjY2VzcztcbiAgICAgICAgICAgICAgICBvbkVycm9yID0gdXJsLmVycm9yO1xuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFscyA9IHVybC53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3RvY29sID0gJC5nZXRVcmxQcm90b2NvbCggdXJsICk7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9ICQuY3JlYXRlQWpheFJlcXVlc3QoIHByb3RvY29sID09PSBcImZpbGU6XCIgKTtcblxuICAgICAgICAgICAgaWYgKCAhJC5pc0Z1bmN0aW9uKCBvblN1Y2Nlc3MgKSApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwibWFrZUFqYXhSZXF1ZXN0IHJlcXVpcmVzIGEgc3VjY2VzcyBjYWxsYmFja1wiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gNCA9IERPTkUgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdCNQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGlmICggcmVxdWVzdC5yZWFkeVN0YXRlID09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdpdGggcHJvdG9jb2xzIG90aGVyIHRoYW4gaHR0cC9odHRwcywgdGhlIHN0YXR1cyBpcyAyMDBcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gRmlyZWZveCBhbmQgMCBvbiBvdGhlciBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICggcmVxdWVzdC5zdGF0dXMgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wgIT09IFwiaHR0cDpcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCAhPT0gXCJodHRwczpcIiApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MoIHJlcXVlc3QgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuY29uc29sZS5sb2coIFwiQUpBWCByZXF1ZXN0IHJldHVybmVkICVkOiAlc1wiLCByZXF1ZXN0LnN0YXR1cywgdXJsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBvbkVycm9yICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvciggcmVxdWVzdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHdpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCggbnVsbCApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBlLm1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBJRSA8IDEwIGRvZXMgbm90IHN1cHBvcnQgQ09SUyBhbmQgYW4gWEhSIHJlcXVlc3QgdG8gYSBkaWZmZXJlbnQgb3JpZ2luIHdpbGwgZmFpbCBhcyBzb29uXG4gICAgICAgICAgICAgICAgICAgIGFzIHNlbmQoKSBpcyBjYWxsZWQuIFRoaXMgaXMgcGFydGljdWxhcmx5IGVhc3kgdG8gbWlzcyBkdXJpbmcgZGV2ZWxvcG1lbnQgYW5kIGFwcGVhciBpblxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0aW9uIGlmIHlvdSB1c2UgYSBDRE4gb3IgZG9tYWluIHNoYXJkaW5nIGFuZCB0aGUgc2VjdXJpdHkgcG9saWN5IGlzIGxpa2VseSB0byBicmVha1xuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb24gaGFuZGxlcnMgc2luY2UgYW55IGF0dGVtcHQgdG8gYWNjZXNzIGEgcHJvcGVydHkgb2YgdGhlIHJlcXVlc3Qgb2JqZWN0IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UgYW4gYWNjZXNzIGRlbmllZCBUeXBlRXJyb3IgaW5zaWRlIHRoZSBjYXRjaCBibG9jay5cblxuICAgICAgICAgICAgICAgICAgICBUbyBiZSBmcmllbmRsaWVyLCB3ZSdsbCBjaGVjayBmb3IgdGhpcyBzcGVjaWZpYyBlcnJvciBhbmQgYWRkIGEgZG9jdW1lbnRhdGlvbiBwb2ludGVyXG4gICAgICAgICAgICAgICAgICAgIHRvIHBvaW50IGRldmVsb3BlcnMgaW4gdGhlIHJpZ2h0IGRpcmVjdGlvbi4gV2UgdGVzdCB0aGUgZXhjZXB0aW9uIG51bWJlciBiZWNhdXNlIElFJ3NcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgbWVzc2FnZXMgYXJlIGxvY2FsaXplZC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBvbGRJRSA9ICQuQnJvd3Nlci52ZW5kb3IgPT0gJC5CUk9XU0VSUy5JRSAmJiAkLkJyb3dzZXIudmVyc2lvbiA8IDEwO1xuICAgICAgICAgICAgICAgIGlmICggb2xkSUUgJiYgdHlwZW9mKCBlLm51bWJlciApICE9IFwidW5kZWZpbmVkXCIgJiYgZS5udW1iZXIgPT0gLTIxNDcwMjQ4OTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIlxcblNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDUodj12cy44NSkuYXNweCN4ZG9tYWluXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJC5jb25zb2xlLmxvZyggXCIlcyB3aGlsZSBtYWtpbmcgQUpBWCByZXF1ZXN0OiAlc1wiLCBlLm5hbWUsIG1zZyApO1xuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe307XG5cbiAgICAgICAgICAgICAgICBpZiAod2luZG93LlhEb21haW5SZXF1ZXN0KSB7IC8vIElFOSBvciBJRTggbWlnaHQgYXMgd2VsbCB0cnkgdG8gdXNlIFhEb21haW5SZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ZHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhkcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIG9uU3VjY2VzcyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MoeyAvLyBGYWtpbmcgYW4geGhyIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiB4ZHIucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsIC8vIFhEb21haW5SZXF1ZXN0IGRvZXNuJ3Qgc3VwcG9ydCBzdGF0dXMgY29kZXMsIHNvIHdlIGp1c3QgZmFrZSBvbmUhIDovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24gKCBvbkVycm9yICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoeyAvLyBGYWtpbmcgYW4geGhyIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiB4ZHIucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0NDQsIC8vIDQ0NCBObyBSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ0FuIGVycm9yIGhhcHBlbmVkLiBEdWUgdG8gYW4gWERvbWFpblJlcXVlc3QgZGVmaWNpZW5jeSB3ZSBjYW4gbm90IGV4dHJhY3QgYW55IGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZXJyb3IuIFVwZ3JhZGUgeW91ciBicm93c2VyLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGRyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGRyLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIG9uRXJyb3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvciggcmVxdWVzdCwgZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBvbkVycm9yICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKCByZXF1ZXN0LCBlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VuIGZyb20galF1ZXJ5IDEuNi4xXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmxcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5jYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW09J2NhbGxiYWNrJ10gVGhlIG5hbWUgb2YgdGhlIHVybCBwYXJhbWV0ZXJcbiAgICAgICAgICogICAgICB0byByZXF1ZXN0IHRoZSBqc29ucCBwcm92aWRlciB3aXRoLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2FsbGJhY2tOYW1lPV0gVGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrIHRvXG4gICAgICAgICAqICAgICAgcmVxdWVzdCB0aGUganNvbnAgcHJvdmlkZXIgd2l0aC5cbiAgICAgICAgICovXG4gICAgICAgIGpzb25wOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgICAgICAgdmFyIHNjcmlwdCxcbiAgICAgICAgICAgICAgICB1cmwgICAgID0gb3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgaGVhZCAgICA9IGRvY3VtZW50LmhlYWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiaGVhZFwiIClbIDAgXSB8fFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAganNvbnBDYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2tOYW1lIHx8ICdvcGVuc2VhZHJhZ29uJyArICQubm93KCksXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgICAgICA9IHdpbmRvd1sganNvbnBDYWxsYmFjayBdLFxuICAgICAgICAgICAgICAgIHJlcGxhY2UgICAgICAgPSBcIiQxXCIgKyBqc29ucENhbGxiYWNrICsgXCIkMlwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrUGFyYW0gPSBvcHRpb25zLnBhcmFtIHx8ICdjYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgICAgICA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCAvKFxcPSlcXD8oJnwkKXxcXD9cXD8vaSwgcmVwbGFjZSApO1xuICAgICAgICAgICAgLy8gQWRkIGNhbGxiYWNrIG1hbnVhbGx5XG4gICAgICAgICAgICB1cmwgKz0gKC9cXD8vLnRlc3QoIHVybCApID8gXCImXCIgOiBcIj9cIikgKyBjYWxsYmFja1BhcmFtICsgXCI9XCIgKyBqc29ucENhbGxiYWNrO1xuXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrXG4gICAgICAgICAgICB3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXSA9IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoICFwcmV2aW91cyApe1xuICAgICAgICAgICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93WyBqc29ucENhbGxiYWNrIF07XG4gICAgICAgICAgICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3dhbGxvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93WyBqc29ucENhbGxiYWNrIF0gPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIGNhbGxiYWNrICYmICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSApe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggcmVzcG9uc2UgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cbiAgICAgICAgICAgIC8vVE9ETzogaGF2aW5nIGFuIGlzc3VlIHdpdGggYXN5bmMgaW5mbyByZXF1ZXN0c1xuICAgICAgICAgICAgaWYoIHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5hc3luYyB8fCBmYWxzZSAhPT0gb3B0aW9ucy5hc3luYyApe1xuICAgICAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IFwiYXN5bmNcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvcHRpb25zLnNjcmlwdENoYXJzZXQgKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0LmNoYXJzZXQgPSBvcHRpb25zLnNjcmlwdENoYXJzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgYWxsIGJyb3dzZXJzXG4gICAgICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpc0Fib3J0IHx8ICFzY3JpcHQucmVhZHlTdGF0ZSB8fCAvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KCBzY3JpcHQucmVhZHlTdGF0ZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoZWFkICYmIHNjcmlwdC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gVXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIGFwcGVuZENoaWxkICB0byBjaXJjdW12ZW50IGFuIElFNiBidWcuXG4gICAgICAgICAgICAvLyBUaGlzIGFyaXNlcyB3aGVuIGEgYmFzZSBub2RlIGlzIHVzZWQgKCMyNzA5IGFuZCAjNDM3OCkuXG4gICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZSggc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQgKTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bGx5IGRlcHJlY2F0ZWQuIFdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI29wZW59XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGcm9tRFpJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IFwiT3BlblNlYWRyYWdvbi5jcmVhdGVGcm9tRFpJIGlzIGRlcHJlY2F0ZWQsIHVzZSBWaWV3ZXIub3Blbi5cIjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGFuIFhNTCBzdHJpbmcgaW50byBhIERPTSBEb2N1bWVudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICAgICAgICogQHJldHVybnMge0RvY3VtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2VYbWw6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgICAgICAgICBpZiAoIHdpbmRvdy5ET01QYXJzZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAkLnBhcnNlWG1sID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhtbERvYyA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgICAgICB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCBzdHJpbmcsIFwidGV4dC94bWxcIiApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHdpbmRvdy5BY3RpdmVYT2JqZWN0ICkge1xuXG4gICAgICAgICAgICAgICAgJC5wYXJzZVhtbCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4bWxEb2MgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHhtbERvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxET01cIiApO1xuICAgICAgICAgICAgICAgICAgICB4bWxEb2MuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgeG1sRG9jLmxvYWRYTUwoIHN0cmluZyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIkJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IFhNTCBET00uXCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICQucGFyc2VYbWwoIHN0cmluZyApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgSmF2YXNjcmlwdCBvYmplY3QuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZUpTT046IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5KU09OICYmIHdpbmRvdy5KU09OLnBhcnNlKSB7XG4gICAgICAgICAgICAgICAgJC5wYXJzZUpTT04gPSB3aW5kb3cuSlNPTi5wYXJzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBieSBJRTggaW4gbm9uIHN0YW5kYXJkcyBtb2RlXG4gICAgICAgICAgICAgICAgJC5wYXJzZUpTT04gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgZXZpbDp0cnVlKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWwoJygnICsgc3RyaW5nICsgJyknKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQucGFyc2VKU09OKHN0cmluZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcG9ydHMgd2hldGhlciB0aGUgaW1hZ2UgZm9ybWF0IGlzIHN1cHBvcnRlZCBmb3IgdGlsaW5nIGluIHRoaXNcbiAgICAgICAgICogdmVyc2lvbi5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXh0ZW5zaW9uXVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGltYWdlRm9ybWF0U3VwcG9ydGVkOiBmdW5jdGlvbiggZXh0ZW5zaW9uICkge1xuICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uID8gZXh0ZW5zaW9uIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiAhIUZJTEVGT1JNQVRTWyBleHRlbnNpb24udG9Mb3dlckNhc2UoKSBdO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgYnJvd3NlciB2ZW5kb3IsIHZlcnNpb24sIGFuZCByZWxhdGVkIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBkZXRlY3RlZCBmZWF0dXJlcy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IEJyb3dzZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5CUk9XU0VSU30gdmVuZG9yIC0gT25lIG9mIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5CUk9XU0VSU30gZW51bWVyYXRpb24gdmFsdWVzLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB2ZXJzaW9uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBhbHBoYSAtIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBpbWFnZSBhbHBoYSB0cmFuc3BhcmVuY3kuXG4gICAgICovXG4gICAgJC5Ccm93c2VyID0ge1xuICAgICAgICB2ZW5kb3I6ICAgICAkLkJST1dTRVJTLlVOS05PV04sXG4gICAgICAgIHZlcnNpb246ICAgIDAsXG4gICAgICAgIGFscGhhOiAgICAgIHRydWVcbiAgICB9O1xuXG5cbiAgICB2YXIgRklMRUZPUk1BVFMgPSB7XG4gICAgICAgICAgICBcImJtcFwiOiAgZmFsc2UsXG4gICAgICAgICAgICBcImpwZWdcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwianBnXCI6ICB0cnVlLFxuICAgICAgICAgICAgXCJwbmdcIjogIHRydWUsXG4gICAgICAgICAgICBcInRpZlwiOiAgZmFsc2UsXG4gICAgICAgICAgICBcIndkcFwiOiAgZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgVVJMUEFSQU1TID0ge307XG5cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vQSBzbWFsbCBhdXRvLWV4ZWN1dGluZyByb3V0aW5lIHRvIGRldGVybWluZSB0aGUgYnJvd3NlciB2ZW5kb3IsXG4gICAgICAgIC8vdmVyc2lvbiBhbmQgc3VwcG9ydGluZyBmZWF0dXJlIHNldHMuXG4gICAgICAgIHZhciBhcHAgPSBuYXZpZ2F0b3IuYXBwTmFtZSxcbiAgICAgICAgICAgIHZlciA9IG5hdmlnYXRvci5hcHBWZXJzaW9uLFxuICAgICAgICAgICAgdWEgID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHJlZ2V4O1xuXG4gICAgICAgIC8vY29uc29sZS5lcnJvciggJ2FwcE5hbWU6ICcgKyBuYXZpZ2F0b3IuYXBwTmFtZSApO1xuICAgICAgICAvL2NvbnNvbGUuZXJyb3IoICdhcHBWZXJzaW9uOiAnICsgbmF2aWdhdG9yLmFwcFZlcnNpb24gKTtcbiAgICAgICAgLy9jb25zb2xlLmVycm9yKCAndXNlckFnZW50OiAnICsgbmF2aWdhdG9yLnVzZXJBZ2VudCApO1xuXG4gICAgICAgIHN3aXRjaCggbmF2aWdhdG9yLmFwcE5hbWUgKXtcbiAgICAgICAgICAgIGNhc2UgXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIjpcbiAgICAgICAgICAgICAgICBpZiggISF3aW5kb3cuYXR0YWNoRXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgISF3aW5kb3cuQWN0aXZlWE9iamVjdCApIHtcblxuICAgICAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVuZG9yID0gJC5CUk9XU0VSUy5JRTtcbiAgICAgICAgICAgICAgICAgICAgJC5Ccm93c2VyLnZlcnNpb24gPSBwYXJzZUZsb2F0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdWEuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVhLmluZGV4T2YoIFwiTVNJRVwiICkgKyA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVhLmluZGV4T2YoIFwiO1wiLCB1YS5pbmRleE9mKCBcIk1TSUVcIiApICkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTmV0c2NhcGVcIjpcbiAgICAgICAgICAgICAgICBpZiggISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHVhLmluZGV4T2YoIFwiRmlyZWZveFwiICkgPj0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZW5kb3IgPSAkLkJST1dTRVJTLkZJUkVGT1g7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWEuc3Vic3RyaW5nKCB1YS5pbmRleE9mKCBcIkZpcmVmb3hcIiApICsgOCApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB1YS5pbmRleE9mKCBcIlNhZmFyaVwiICkgPj0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZW5kb3IgPSB1YS5pbmRleE9mKCBcIkNocm9tZVwiICkgPj0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5CUk9XU0VSUy5DSFJPTUUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuQlJPV1NFUlMuU0FGQVJJO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5Ccm93c2VyLnZlcnNpb24gPSBwYXJzZUZsb2F0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVhLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWEuc3Vic3RyaW5nKCAwLCB1YS5pbmRleE9mKCBcIlNhZmFyaVwiICkgKS5sYXN0SW5kZXhPZiggXCIvXCIgKSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVhLmluZGV4T2YoIFwiU2FmYXJpXCIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoIFwiVHJpZGVudC8uKnJ2OihbMC05XXsxLH1bLjAtOV17MCx9KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVnZXguZXhlYyggdWEgKSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVuZG9yID0gJC5CUk9XU0VSUy5JRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk9wZXJhXCI6XG4gICAgICAgICAgICAgICAgJC5Ccm93c2VyLnZlbmRvciA9ICQuQlJPV1NFUlMuT1BFUkE7XG4gICAgICAgICAgICAgICAgJC5Ccm93c2VyLnZlcnNpb24gPSBwYXJzZUZsb2F0KCB2ZXIgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZ25vcmUgJz8nIHBvcnRpb24gb2YgcXVlcnkgc3RyaW5nXG4gICAgICAgIHZhciBxdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKCAxICksXG4gICAgICAgICAgICBwYXJ0cyA9IHF1ZXJ5LnNwbGl0KCcmJyksXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgc2VwLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgcGFydCA9IHBhcnRzWyBpIF07XG4gICAgICAgICAgICBzZXAgID0gcGFydC5pbmRleE9mKCAnPScgKTtcblxuICAgICAgICAgICAgaWYgKCBzZXAgPiAwICkge1xuICAgICAgICAgICAgICAgIFVSTFBBUkFNU1sgcGFydC5zdWJzdHJpbmcoIDAsIHNlcCApIF0gPVxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVVUklDb21wb25lbnQoIHBhcnQuc3Vic3RyaW5nKCBzZXAgKyAxICkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vZGV0ZXJtaW5lIGlmIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBpbWFnZSBhbHBoYSB0cmFuc3BhcmVuY3lcbiAgICAgICAgJC5Ccm93c2VyLmFscGhhID0gIShcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVuZG9yID09ICQuQlJPV1NFUlMuSUUgJiZcbiAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA8IDlcbiAgICAgICAgICAgICkgfHwgKFxuICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZW5kb3IgPT0gJC5CUk9XU0VSUy5DSFJPTUUgJiZcbiAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA8IDJcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvL2RldGVybWluZSBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgZWxlbWVudC5zdHlsZS5vcGFjaXR5XG4gICAgICAgICQuQnJvd3Nlci5vcGFjaXR5ID0gIShcbiAgICAgICAgICAgICQuQnJvd3Nlci52ZW5kb3IgPT0gJC5CUk9XU0VSUy5JRSAmJlxuICAgICAgICAgICAgJC5Ccm93c2VyLnZlcnNpb24gPCA5XG4gICAgICAgICk7XG5cbiAgICB9KSgpO1xuXG5cbiAgICAvL1RPRE86ICQuY29uc29sZSBpcyBvZnRlbiB1c2VkIGluc2lkZSBhIHRyeS9jYXRjaCBibG9jayB3aGljaCBnZW5lcmFsbHlcbiAgICAvLyAgICAgIHByZXZlbnRzIGFsbG93aW5ncyBlcnJvcnMgdG8gb2NjdXIgd2l0aCBkZXRlY3Rpb24gdW50aWwgYSBkZWJ1Z2dlclxuICAgIC8vICAgICAgaXMgYXR0YWNoZWQuICBBbHRob3VnaCBJJ3ZlIGJlZW4gZ3VpbHR5IG9mIHRoZSBzYW1lIGFudGktcGF0dGVyblxuICAgIC8vICAgICAgSSBldmVudHVhbGx5IHdhcyBjb252aW5jZWQgdGhhdCBlcnJvcnMgc2hvdWxkIG5hdHVyYWxseSBwcm9wb2dhdGUgaW5cbiAgICAvLyAgICAgIGFsbCBidXQgdGhlIG1vc3Qgc3BlY2lhbCBjYXNlcy5cbiAgICAvKipcbiAgICAgKiBBIGNvbnZlbmllbnQgYWxpYXMgZm9yIGNvbnNvbGUgd2hlbiBhdmFpbGFibGUsIGFuZCBhIHNpbXBsZSBudWxsXG4gICAgICogZnVuY3Rpb24gd2hlbiBjb25zb2xlIGlzIHVuYXZhaWxhYmxlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhciBudWxsZnVuY3Rpb24gPSBmdW5jdGlvbiggbXNnICl7XG4gICAgICAgICAgICAvL2RvY3VtZW50LmxvY2F0aW9uLmhhc2ggPSBtc2c7XG4gICAgICAgIH07XG5cbiAgICAkLmNvbnNvbGUgPSB3aW5kb3cuY29uc29sZSB8fCB7XG4gICAgICAgIGxvZzogICAgbnVsbGZ1bmN0aW9uLFxuICAgICAgICBkZWJ1ZzogIG51bGxmdW5jdGlvbixcbiAgICAgICAgaW5mbzogICBudWxsZnVuY3Rpb24sXG4gICAgICAgIHdhcm46ICAgbnVsbGZ1bmN0aW9uLFxuICAgICAgICBlcnJvcjogIG51bGxmdW5jdGlvbixcbiAgICAgICAgYXNzZXJ0OiBudWxsZnVuY3Rpb25cbiAgICB9O1xuXG5cbiAgICAvLyBBZGRpbmcgc3VwcG9ydCBmb3IgSFRNTDUncyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYXMgc3VnZ2VzdGVkIGJ5IGFjZGhhLlxuICAgIC8vIEltcGxlbWVudGF0aW9uIHRha2VuIGZyb20gbWF0dCBzeW5kZXIncyBwb3N0IGhlcmU6XG4gICAgLy8gaHR0cDovL21hdHRzbmlkZXIuY29tL2Nyb3NzLWJyb3dzZXItYW5kLWxlZ2FjeS1zdXBwb3J0ZWQtcmVxdWVzdGZyYW1lYW5pbWF0aW9uL1xuICAgIChmdW5jdGlvbiggdyApIHtcblxuICAgICAgICAvLyBtb3N0IGJyb3dzZXJzIGhhdmUgYW4gaW1wbGVtZW50YXRpb25cbiAgICAgICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHcubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbiAgICAgICAgdmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgICAgIC8vIHBvbHlmaWxsLCB3aGVuIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIHJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiBjYW5jZWxBbmltYXRpb25GcmFtZSApIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGFzc2lnbiB0aGVzZSB3aW5kb3cgbWV0aG9kcyBkaXJlY3RseSB0byAkIGJlY2F1c2UgdGhleVxuICAgICAgICAgICAgLy8gZXhwZWN0IHRoZWlyIFwidGhpc1wiIHRvIGJlIFwid2luZG93XCIsIHNvIHdlIGNhbGwgdGhlbSBpbiB3cmFwcGVycy5cbiAgICAgICAgICAgICQucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmFwcGx5KCB3LCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsQW5pbWF0aW9uRnJhbWUuYXBwbHkoIHcsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhQW5pbVF1ZXVlID0gW10sXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZyA9IFtdLFxuICAgICAgICAgICAgICAgIGlSZXF1ZXN0SWQgPSAwLFxuICAgICAgICAgICAgICAgIGlJbnRlcnZhbElkO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBtb2NrIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvblxuICAgICAgICAgICAgJC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgYUFuaW1RdWV1ZS5wdXNoKCBbICsraVJlcXVlc3RJZCwgY2FsbGJhY2sgXSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhaUludGVydmFsSWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhQW5pbVF1ZXVlLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9ICQubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhbGwgb2YgdGhlIGN1cnJlbnRseSBvdXRzdGFuZGluZyBmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RzLCBidXQgbm9uZSB0aGF0IGdldCBhZGRlZCBkdXJpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2FwIHRoZSBhcnJheXMgc28gd2UgZG9uJ3QgaGF2ZSB0byBjcmVhdGUgYSBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBldmVyeSBmcmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHByb2Nlc3Npbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZyA9IGFBbmltUXVldWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYUFuaW1RdWV1ZSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBwcm9jZXNzaW5nLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZy5zaGlmdCgpWyAxIF0oIHRpbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGNvbnRpbnVlIHRoZSBpbnRlcnZhbCwgaWYgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCBpSW50ZXJ2YWxJZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlJbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAxMDAwIC8gNTApOyAgLy8gZXN0aW1hdGluZyBzdXBwb3J0IGZvciA1MCBmcmFtZXMgcGVyIHNlY29uZFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBpUmVxdWVzdElkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbW9jayBjYW5jZWxBbmltYXRpb25GcmFtZSBmdW5jdGlvblxuICAgICAgICAgICAgJC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCByZXF1ZXN0SWQgKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgcmVxdWVzdCBJRCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgdmFyIGksIGo7XG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGogPSBhQW5pbVF1ZXVlLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhQW5pbVF1ZXVlWyBpIF1bIDAgXSA9PT0gcmVxdWVzdElkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYUFuaW1RdWV1ZS5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IGluIHRoZSBxdWV1ZSwgaXQgbWF5IGJlIGluIHRoZSBzZXQgd2UncmUgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyAoaWYgY2FuY2VsQW5pbWF0aW9uRnJhbWUgaXMgY2FsbGVkIGZyb20gd2l0aGluIGFcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2spLlxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBqID0gcHJvY2Vzc2luZy5sZW5ndGg7IGkgPCBqOyBpICs9IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcHJvY2Vzc2luZ1sgaSBdWyAwIF0gPT09IHJlcXVlc3RJZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Npbmcuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoIHdpbmRvdyApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0ZpeGVkXVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudCggZWxlbWVudCwgaXNGaXhlZCApIHtcbiAgICAgICAgaWYgKCBpc0ZpeGVkICYmIGVsZW1lbnQgIT0gZG9jdW1lbnQuYm9keSApIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuXG59KE9wZW5TZWFkcmFnb24pKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBmdWxsLXNjcmVlbiBzdXBwb3J0IGZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKSB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIG5hdGl2ZSBmdWxsIHNjcmVlbiBzdXBwb3J0IHdlIGNhbiBnZXQgZnJvbSB0aGUgYnJvd3Nlci5cbiAgICAgKiBAbWVtYmVyIGZ1bGxTY3JlZW5BcGlcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzdXBwb3J0c0Z1bGxTY3JlZW4gUmV0dXJuIHRydWUgaWYgZnVsbCBzY3JlZW4gQVBJIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpc0Z1bGxTY3JlZW4gUmV0dXJuIHRydWUgaWYgY3VycmVudGx5IGluIGZ1bGwgc2NyZWVuIG1vZGUuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0RnVsbFNjcmVlbkVsZW1lbnQgUmV0dXJuIHRoZSBlbGVtZW50IGN1cnJlbnRseSBpbiBmdWxsIHNjcmVlbiBtb2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlcXVlc3RGdWxsU2NyZWVuIE1ha2UgYSByZXF1ZXN0IHRvIGdvIGluIGZ1bGwgc2NyZWVuIG1vZGUuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZXhpdEZ1bGxTY3JlZW4gTWFrZSBhIHJlcXVlc3QgdG8gZXhpdCBmdWxsIHNjcmVlbiBtb2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNhbmNlbEZ1bGxTY3JlZW4gRGVwcmVjYXRlZCwgdXNlIGV4aXRGdWxsU2NyZWVuIGluc3RlYWQuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZ1bGxTY3JlZW5FdmVudE5hbWUgRXZlbnQgZmlyZWQgd2hlbiB0aGUgZnVsbCBzY3JlZW4gbW9kZSBjaGFuZ2UuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZ1bGxTY3JlZW5FcnJvckV2ZW50TmFtZSBFdmVudCBmaXJlZCB3aGVuIGEgcmVxdWVzdCB0byBnb1xuICAgICAqIGluIGZ1bGwgc2NyZWVuIG1vZGUgZmFpbGVkLlxuICAgICAqL1xuICAgIHZhciBmdWxsU2NyZWVuQXBpID0ge1xuICAgICAgICBzdXBwb3J0c0Z1bGxTY3JlZW46IGZhbHNlLFxuICAgICAgICBpc0Z1bGxTY3JlZW46IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgIGdldEZ1bGxTY3JlZW5FbGVtZW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlcXVlc3RGdWxsU2NyZWVuOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBleGl0RnVsbFNjcmVlbjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgY2FuY2VsRnVsbFNjcmVlbjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgZnVsbFNjcmVlbkV2ZW50TmFtZTogJycsXG4gICAgICAgIGZ1bGxTY3JlZW5FcnJvckV2ZW50TmFtZTogJydcbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgZm9yIG5hdGl2ZSBzdXBwb3J0XG4gICAgaWYgKCBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiApIHtcbiAgICAgICAgLy8gVzNDIHN0YW5kYXJkXG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuc3VwcG9ydHNGdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5nZXRGdWxsU2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLnJlcXVlc3RGdWxsU2NyZWVuID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmV4aXRGdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FdmVudE5hbWUgPSBcImZ1bGxzY3JlZW5jaGFuZ2VcIjtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5mdWxsU2NyZWVuRXJyb3JFdmVudE5hbWUgPSBcImZ1bGxzY3JlZW5lcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4gKSB7XG4gICAgICAgIC8vIElFIDExXG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuc3VwcG9ydHNGdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5nZXRGdWxsU2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkucmVxdWVzdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FdmVudE5hbWUgPSBcIk1TRnVsbHNjcmVlbkNoYW5nZVwiO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FcnJvckV2ZW50TmFtZSA9IFwiTVNGdWxsc2NyZWVuRXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKCBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiApIHtcbiAgICAgICAgLy8gUmVjZW50IHdlYmtpdFxuICAgICAgICBmdWxsU2NyZWVuQXBpLnN1cHBvcnRzRnVsbFNjcmVlbiA9IHRydWU7XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZ2V0RnVsbFNjcmVlbkVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5yZXF1ZXN0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5mdWxsU2NyZWVuRXZlbnROYW1lID0gXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCI7XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZnVsbFNjcmVlbkVycm9yRXZlbnROYW1lID0gXCJ3ZWJraXRmdWxsc2NyZWVuZXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKCBkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuICkge1xuICAgICAgICAvLyBPbGQgd2Via2l0XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuc3VwcG9ydHNGdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5nZXRGdWxsU2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LndlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5yZXF1ZXN0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FdmVudE5hbWUgPSBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIjtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5mdWxsU2NyZWVuRXJyb3JFdmVudE5hbWUgPSBcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4gKSB7XG4gICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSB0cnVlO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmdldEZ1bGxTY3JlZW5FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkucmVxdWVzdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5mdWxsU2NyZWVuRXZlbnROYW1lID0gXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCI7XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZnVsbFNjcmVlbkVycm9yRXZlbnROYW1lID0gXCJtb3pmdWxsc2NyZWVuZXJyb3JcIjtcbiAgICB9XG4gICAgZnVsbFNjcmVlbkFwaS5pc0Z1bGxTY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGxTY3JlZW5BcGkuZ2V0RnVsbFNjcmVlbkVsZW1lbnQoKSAhPT0gbnVsbDtcbiAgICB9O1xuICAgIGZ1bGxTY3JlZW5BcGkuY2FuY2VsRnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXCJjYW5jZWxGdWxsU2NyZWVuIGlzIGRlcHJlY2F0ZWQuIFVzZSBleGl0RnVsbFNjcmVlbiBpbnN0ZWFkLlwiKTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5leGl0RnVsbFNjcmVlbigpO1xuICAgIH07XG5cbiAgICAvLyBleHBvcnQgYXBpXG4gICAgJC5leHRlbmQoICQsIGZ1bGxTY3JlZW5BcGkgKTtcblxufSkoIE9wZW5TZWFkcmFnb24gKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBFdmVudFNvdXJjZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oJCl7XG5cbi8qKlxuICogRXZlbnQgaGFuZGxlciBtZXRob2Qgc2lnbmF0dXJlIHVzZWQgYnkgYWxsIE9wZW5TZWFkcmFnb24gZXZlbnRzLlxuICpcbiAqIEBjYWxsYmFjayBFdmVudEhhbmRsZXJcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBTZWUgaW5kaXZpZHVhbCBldmVudHMgZm9yIGV2ZW50LXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzcyBFdmVudFNvdXJjZVxuICogQGNsYXNzZGVzYyBGb3IgdXNlIGJ5IGNsYXNzZXMgd2hpY2ggd2FudCB0byBzdXBwb3J0IGN1c3RvbSwgbm9uLWJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKi9cbiQuRXZlbnRTb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xufTtcblxuLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLkV2ZW50U291cmNlLnByb3RvdHlwZSAqL1xuJC5FdmVudFNvdXJjZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgaGFuZGxlciB0byBiZSB0cmlnZ2VyZWQgb25seSBvbmNlIChvciBhIGdpdmVuIG51bWJlciBvZiB0aW1lcylcbiAgICAgKiBmb3IgYSBnaXZlbiBldmVudC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiBldmVudCB0byByZWdpc3Rlci5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBoYW5kbGVyIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGV2ZW50XG4gICAgICogaXMgdHJpZ2dlcmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlckRhdGE9bnVsbF0gLSBBcmJpdHJhcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCB1bmNoYW5nZWRcbiAgICAgKiB0byB0aGUgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVzPTFdIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBoYW5kbGUgdGhlIGV2ZW50XG4gICAgICogYmVmb3JlIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIGFkZE9uY2VIYW5kbGVyOiBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIsIHVzZXJEYXRhLCB0aW1lcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRpbWVzID0gdGltZXMgfHwgMTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIG9uY2VIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IHRpbWVzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVIYW5kbGVyKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSGFuZGxlcihldmVudE5hbWUsIG9uY2VIYW5kbGVyLCB1c2VyRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBoYW5kbGVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIGV2ZW50IHRvIHJlZ2lzdGVyLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IGhhbmRsZXIgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlckRhdGE9bnVsbF0gLSBBcmJpdHJhcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCB1bmNoYW5nZWQgdG8gdGhlIGhhbmRsZXIuXG4gICAgICovXG4gICAgYWRkSGFuZGxlcjogZnVuY3Rpb24gKCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZXJEYXRhICkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHNbIGV2ZW50TmFtZSBdO1xuICAgICAgICBpZiAoICFldmVudHMgKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1sgZXZlbnROYW1lIF0gPSBldmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGhhbmRsZXIgJiYgJC5pc0Z1bmN0aW9uKCBoYW5kbGVyICkgKSB7XG4gICAgICAgICAgICBldmVudHNbIGV2ZW50cy5sZW5ndGggXSA9IHsgaGFuZGxlcjogaGFuZGxlciwgdXNlckRhdGE6IHVzZXJEYXRhIHx8IG51bGwgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzcGVjaWZpYyBldmVudCBoYW5kbGVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIGV2ZW50IGZvciB3aGljaCB0aGUgaGFuZGxlciBpcyB0byBiZSByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IGhhbmRsZXIgLSBGdW5jdGlvbiB0byBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZUhhbmRsZXI6IGZ1bmN0aW9uICggZXZlbnROYW1lLCBoYW5kbGVyICkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHNbIGV2ZW50TmFtZSBdLFxuICAgICAgICAgICAgaGFuZGxlcnMgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGlmICggIWV2ZW50cyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICQuaXNBcnJheSggZXZlbnRzICkgKSB7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGV2ZW50c1tpXS5oYW5kbGVyICE9PSBoYW5kbGVyICkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKCBldmVudHNbIGkgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRzWyBldmVudE5hbWUgXSA9IGhhbmRsZXJzO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyBmb3IgYSBnaXZlbiBldmVudCB0eXBlLiBJZiBubyB0eXBlIGlzIGdpdmVuIGFsbFxuICAgICAqIGV2ZW50IGhhbmRsZXJzIGZvciBldmVyeSBldmVudCB0eXBlIGFyZSByZW1vdmVkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIGV2ZW50IGZvciB3aGljaCBhbGwgaGFuZGxlcnMgYXJlIHRvIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsSGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG4gICAgICAgIGlmICggZXZlbnROYW1lICl7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1sgZXZlbnROYW1lIF0gPSBbXTtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgZm9yICggdmFyIGV2ZW50VHlwZSBpbiB0aGlzLmV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1sgZXZlbnRUeXBlIF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBmdW5jdGlvbiB3aGljaCBpdGVyYXRlcyB0aGUgbGlzdCBvZiBhbGwgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudCwgY2FsbGluZyB0aGUgaGFuZGxlciBmb3IgZWFjaC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiBldmVudCB0byBnZXQgaGFuZGxlcnMgZm9yLlxuICAgICAqL1xuICAgIGdldEhhbmRsZXI6IGZ1bmN0aW9uICggZXZlbnROYW1lICkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHNbIGV2ZW50TmFtZSBdO1xuICAgICAgICBpZiAoICFldmVudHMgfHwgIWV2ZW50cy5sZW5ndGggKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBldmVudHMgPSBldmVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgIFsgZXZlbnRzWyAwIF0gXSA6XG4gICAgICAgICAgICBBcnJheS5hcHBseSggbnVsbCwgZXZlbnRzICk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHNvdXJjZSwgYXJncyApIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggZXZlbnRzWyBpIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuZXZlbnRTb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudXNlckRhdGEgPSBldmVudHNbIGkgXS51c2VyRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzWyBpIF0uaGFuZGxlciggYXJncyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhbiBldmVudCwgb3B0aW9uYWxseSBwYXNzaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgZXZlbnQgdG8gcmVnaXN0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50QXJncyAtIEV2ZW50LXNwZWNpZmljIGRhdGEuXG4gICAgICovXG4gICAgcmFpc2VFdmVudDogZnVuY3Rpb24oIGV2ZW50TmFtZSwgZXZlbnRBcmdzICkge1xuICAgICAgICAvL3VuY29tbWVudCBpZiB5b3Ugd2FudCB0byBnZXQgYSBsb2cgb2YgYWxsIGV2ZW50c1xuICAgICAgICAvLyQuY29uc29sZS5sb2coIGV2ZW50TmFtZSApO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuZ2V0SGFuZGxlciggZXZlbnROYW1lICk7XG5cbiAgICAgICAgaWYgKCBoYW5kbGVyICkge1xuICAgICAgICAgICAgaWYgKCAhZXZlbnRBcmdzICkge1xuICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVyKCB0aGlzLCBldmVudEFyZ3MgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gTW91c2VUcmFja2VyXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiAoICQgKSB7XG5cbiAgICAvLyBBbGwgTW91c2VUcmFja2VyIGluc3RhbmNlc1xuICAgIHZhciBNT1VTRVRSQUNLRVJTICA9IFtdO1xuXG4gICAgLy8gZGljdGlvbmFyeSBmcm9tIGhhc2ggdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgdmFyIFRISVMgICAgICAgICAgID0ge307XG5cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBNb3VzZVRyYWNrZXJcbiAgICAgKiBAY2xhc3NkZXNjIFByb3ZpZGVzIHNpbXBsaWZpZWQgaGFuZGxpbmcgb2YgY29tbW9uIHBvaW50ZXIgZGV2aWNlIChtb3VzZSwgdG91Y2gsIHBlbiwgZXRjLikgZ2VzdHVyZXNcbiAgICAgKiAgICAgICAgICAgIGFuZCBrZXlib2FyZCBldmVudHMgb24gYSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogICAgICBBbGxvd3MgY29uZmlndXJhYmxlIHByb3BlcnRpZXMgdG8gYmUgZW50aXJlbHkgc3BlY2lmaWVkIGJ5IHBhc3NpbmdcbiAgICAgKiAgICAgIGFuIG9wdGlvbnMgb2JqZWN0IHRvIHRoZSBjb25zdHJ1Y3Rvci4gIFRoZSBjb25zdHJ1Y3RvciBhbHNvIHN1cHBvcnRzXG4gICAgICogICAgICB0aGUgb3JpZ2luYWwgcG9zaXRpb25hbCBhcmd1bWVudHMgJ2VsZW1lbnQnLCAnY2xpY2tUaW1lVGhyZXNob2xkJyxcbiAgICAgKiAgICAgIGFuZCAnY2xpY2tEaXN0VGhyZXNob2xkJyBpbiB0aGF0IG9yZGVyLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IG9wdGlvbnMuZWxlbWVudFxuICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gYW4gZWxlbWVudCBvciBhbiBlbGVtZW50IGlkIGZvciB3aGljaCB0aGUgcG9pbnRlci9rZXlcbiAgICAgKiAgICAgIGV2ZW50cyB3aWxsIGJlIG1vbml0b3JlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0YXJ0RGlzYWJsZWQ9ZmFsc2VdXG4gICAgICogICAgICBJZiB0cnVlLCBldmVudCB0cmFja2luZyBvbiB0aGUgZWxlbWVudCB3aWxsIG5vdCBzdGFydCB1bnRpbFxuICAgICAqICAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLnNldFRyYWNraW5nfHNldFRyYWNraW5nfSBpcyBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuY2xpY2tUaW1lVGhyZXNob2xkXG4gICAgICogICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB3aXRoaW4gd2hpY2ggYSBwb2ludGVyIGRvd24tdXAgZXZlbnQgY29tYmluYXRpb25cbiAgICAgKiAgICAgIHdpbGwgYmUgdHJlYXRlZCBhcyBhIGNsaWNrIGdlc3R1cmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuY2xpY2tEaXN0VGhyZXNob2xkXG4gICAgICogICAgICBUaGUgbWF4aW11bSBkaXN0YW5jZSBhbGxvd2VkIGJldHdlZW4gYSBwb2ludGVyIGRvd24gZXZlbnQgYW5kIGEgcG9pbnRlciB1cCBldmVudFxuICAgICAqICAgICAgdG8gYmUgdHJlYXRlZCBhcyBhIGNsaWNrIGdlc3R1cmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGJsQ2xpY2tUaW1lVGhyZXNob2xkXG4gICAgICogICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB3aXRoaW4gd2hpY2ggdHdvIHBvaW50ZXIgZG93bi11cCBldmVudCBjb21iaW5hdGlvbnNcbiAgICAgKiAgICAgIHdpbGwgYmUgdHJlYXRlZCBhcyBhIGRvdWJsZS1jbGljayBnZXN0dXJlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRibENsaWNrRGlzdFRocmVzaG9sZFxuICAgICAqICAgICAgVGhlIG1heGltdW0gZGlzdGFuY2UgYWxsb3dlZCBiZXR3ZWVuIHR3byBwb2ludGVyIGNsaWNrIGV2ZW50c1xuICAgICAqICAgICAgdG8gYmUgdHJlYXRlZCBhcyBhIGNsaWNrIGdlc3R1cmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0b3BEZWxheT01MF1cbiAgICAgKiAgICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHdpdGhvdXQgcG9pbnRlciBtb3ZlIGJlZm9yZSB0aGUgc3RvcFxuICAgICAqICAgICAgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMuZW50ZXJIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBwb2ludGVyIGVudGVyLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmV4aXRIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBwb2ludGVyIGV4aXQuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMucHJlc3NIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBwb2ludGVyIHByZXNzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLm5vblByaW1hcnlQcmVzc0hhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgbm9uLXByaW1hcnkgYnV0dG9uIHByZXNzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLnJlbGVhc2VIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBwb2ludGVyIHJlbGVhc2UuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMubm9uUHJpbWFyeVJlbGVhc2VIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBwb2ludGVyIG5vbi1wcmltYXJ5IGJ1dHRvbiByZWxlYXNlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLm1vdmVIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBwb2ludGVyIG1vdmUuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMuc2Nyb2xsSGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3IgbW91c2Ugd2hlZWwgc2Nyb2xsLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmNsaWNrSGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3IgcG9pbnRlciBjbGljay5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5kYmxDbGlja0hhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgZG91YmxlLWNsaWNrLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmRyYWdIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZHJhZyBnZXN0dXJlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmRyYWdFbmRIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBhZnRlciBhIGRyYWcgZ2VzdHVyZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5waW5jaEhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBwaW5jaCBnZXN0dXJlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmtleURvd25IYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBrZXlkb3duLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmtleVVwSGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3Iga2V5dXAuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMua2V5SGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3Iga2V5cHJlc3MuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMuZm9jdXNIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBmb2N1cy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5ibHVySGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3IgYmx1ci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudXNlckRhdGE9bnVsbF1cbiAgICAgKiAgICAgIEFyYml0cmFyeSBvYmplY3QgdG8gYmUgcGFzc2VkIHVuY2hhbmdlZCB0byBhbnkgYXR0YWNoZWQgaGFuZGxlciBtZXRob2RzLlxuICAgICAqL1xuICAgICQuTW91c2VUcmFja2VyID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG4gICAgICAgIE1PVVNFVFJBQ0tFUlMucHVzaCggdGhpcyApO1xuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIGlmICggISQuaXNQbGFpbk9iamVjdCggb3B0aW9ucyApICkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiAgICAgICAgICAgIGFyZ3NbIDAgXSxcbiAgICAgICAgICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IGFyZ3NbIDEgXSxcbiAgICAgICAgICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6IGFyZ3NbIDIgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzaCAgICAgICAgICAgICAgID0gTWF0aC5yYW5kb20oKTsgLy8gQW4gdW5pcXVlIGhhc2ggZm9yIHRoaXMgdHJhY2tlci5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbGVtZW50IGZvciB3aGljaCBwb2ludGVyIGV2ZW50cyBhcmUgYmVpbmcgbW9uaXRvcmVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWxlbWVudCAgICAgICAgICAgID0gJC5nZXRFbGVtZW50KCBvcHRpb25zLmVsZW1lbnQgKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHdpdGhpbiB3aGljaCBhIHBvaW50ZXIgZG93bi11cCBldmVudCBjb21iaW5hdGlvblxuICAgICAgICAgKiB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBjbGljayBnZXN0dXJlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNsaWNrVGltZVRocmVzaG9sZFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCA9IG9wdGlvbnMuY2xpY2tUaW1lVGhyZXNob2xkIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5jbGlja1RpbWVUaHJlc2hvbGQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBkaXN0YW5jZSBhbGxvd2VkIGJldHdlZW4gYSBwb2ludGVyIGRvd24gZXZlbnQgYW5kIGEgcG9pbnRlciB1cCBldmVudFxuICAgICAgICAgKiB0byBiZSB0cmVhdGVkIGFzIGEgY2xpY2sgZ2VzdHVyZS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjbGlja0Rpc3RUaHJlc2hvbGRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQgPSBvcHRpb25zLmNsaWNrRGlzdFRocmVzaG9sZCB8fCAkLkRFRkFVTFRfU0VUVElOR1MuY2xpY2tEaXN0VGhyZXNob2xkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgd2l0aGluIHdoaWNoIHR3byBwb2ludGVyIGRvd24tdXAgZXZlbnQgY29tYmluYXRpb25zXG4gICAgICAgICAqIHdpbGwgYmUgdHJlYXRlZCBhcyBhIGRvdWJsZS1jbGljayBnZXN0dXJlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGRibENsaWNrVGltZVRocmVzaG9sZFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRibENsaWNrVGltZVRocmVzaG9sZCA9IG9wdGlvbnMuZGJsQ2xpY2tUaW1lVGhyZXNob2xkIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5kYmxDbGlja1RpbWVUaHJlc2hvbGQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBkaXN0YW5jZSBhbGxvd2VkIGJldHdlZW4gdHdvIHBvaW50ZXIgY2xpY2sgZXZlbnRzXG4gICAgICAgICAqIHRvIGJlIHRyZWF0ZWQgYXMgYSBjbGljayBnZXN0dXJlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNsaWNrRGlzdFRocmVzaG9sZFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRibENsaWNrRGlzdFRocmVzaG9sZCA9IG9wdGlvbnMuZGJsQ2xpY2tEaXN0VGhyZXNob2xkIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5kYmxDbGlja0Rpc3RUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMudXNlckRhdGEgICAgICAgICAgICAgID0gb3B0aW9ucy51c2VyRGF0YSAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLnN0b3BEZWxheSAgICAgICAgICAgICA9IG9wdGlvbnMuc3RvcERlbGF5ICAgICAgICAgfHwgNTA7XG5cbiAgICAgICAgdGhpcy5lbnRlckhhbmRsZXIgICAgICAgICAgICAgPSBvcHRpb25zLmVudGVySGFuZGxlciAgICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLmV4aXRIYW5kbGVyICAgICAgICAgICAgICA9IG9wdGlvbnMuZXhpdEhhbmRsZXIgICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMucHJlc3NIYW5kbGVyICAgICAgICAgICAgID0gb3B0aW9ucy5wcmVzc0hhbmRsZXIgICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5ub25QcmltYXJ5UHJlc3NIYW5kbGVyICAgPSBvcHRpb25zLm5vblByaW1hcnlQcmVzc0hhbmRsZXIgICB8fCBudWxsO1xuICAgICAgICB0aGlzLnJlbGVhc2VIYW5kbGVyICAgICAgICAgICA9IG9wdGlvbnMucmVsZWFzZUhhbmRsZXIgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMubm9uUHJpbWFyeVJlbGVhc2VIYW5kbGVyID0gb3B0aW9ucy5ub25QcmltYXJ5UmVsZWFzZUhhbmRsZXIgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tb3ZlSGFuZGxlciAgICAgICAgICAgICAgPSBvcHRpb25zLm1vdmVIYW5kbGVyICAgICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXIgICAgICAgICAgICA9IG9wdGlvbnMuc2Nyb2xsSGFuZGxlciAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuY2xpY2tIYW5kbGVyICAgICAgICAgICAgID0gb3B0aW9ucy5jbGlja0hhbmRsZXIgICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5kYmxDbGlja0hhbmRsZXIgICAgICAgICAgPSBvcHRpb25zLmRibENsaWNrSGFuZGxlciAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLmRyYWdIYW5kbGVyICAgICAgICAgICAgICA9IG9wdGlvbnMuZHJhZ0hhbmRsZXIgICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ0VuZEhhbmRsZXIgICAgICAgICAgID0gb3B0aW9ucy5kcmFnRW5kSGFuZGxlciAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5waW5jaEhhbmRsZXIgICAgICAgICAgICAgPSBvcHRpb25zLnBpbmNoSGFuZGxlciAgICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLnN0b3BIYW5kbGVyICAgICAgICAgICAgICA9IG9wdGlvbnMuc3RvcEhhbmRsZXIgICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMua2V5RG93bkhhbmRsZXIgICAgICAgICAgID0gb3B0aW9ucy5rZXlEb3duSGFuZGxlciAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5rZXlVcEhhbmRsZXIgICAgICAgICAgICAgPSBvcHRpb25zLmtleVVwSGFuZGxlciAgICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLmtleUhhbmRsZXIgICAgICAgICAgICAgICA9IG9wdGlvbnMua2V5SGFuZGxlciAgICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyICAgICAgICAgICAgID0gb3B0aW9ucy5mb2N1c0hhbmRsZXIgICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciAgICAgICAgICAgICAgPSBvcHRpb25zLmJsdXJIYW5kbGVyICAgICAgICAgICAgICB8fCBudWxsO1xuXG4gICAgICAgIC8vU3RvcmUgcHJpdmF0ZSBwcm9wZXJ0aWVzIGluIGEgc2NvcGUgc2VhbGVkIGhhc2ggbWFwXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdHJhY2tpbmdcbiAgICAgICAgICogICAgICBBcmUgd2UgY3VycmVudGx5IHRyYWNraW5nIHBvaW50ZXIgZXZlbnRzIGZvciB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBUSElTWyB0aGlzLmhhc2ggXSA9IHtcbiAgICAgICAgICAgIGNsaWNrOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25DbGljayggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBkYmxjbGljazogICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uRGJsQ2xpY2soIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAga2V5ZG93bjogICAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbktleURvd24oIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAga2V5dXA6ICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbktleVVwKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIGtleXByZXNzOiAgICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25LZXlQcmVzcyggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBmb2N1czogICAgICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uRm9jdXMoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgYmx1cjogICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbkJsdXIoIF90aGlzLCBldmVudCApOyB9LFxuXG4gICAgICAgICAgICB3aGVlbDogICAgICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uV2hlZWwoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgbW91c2V3aGVlbDogICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlV2hlZWwoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgRE9NTW91c2VTY3JvbGw6ICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlV2hlZWwoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgTW96TW91c2VQaXhlbFNjcm9sbDogICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlV2hlZWwoIF90aGlzLCBldmVudCApOyB9LFxuXG4gICAgICAgICAgICBtb3VzZWVudGVyOiAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VFbnRlciggX3RoaXMsIGV2ZW50ICk7IH0sIC8vIFVzZWQgb24gSUU4IG9ubHlcbiAgICAgICAgICAgIG1vdXNlbGVhdmU6ICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Nb3VzZUxlYXZlKCBfdGhpcywgZXZlbnQgKTsgfSwgLy8gVXNlZCBvbiBJRTggb25seVxuICAgICAgICAgICAgbW91c2VvdmVyOiAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlT3ZlciggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBtb3VzZW91dDogICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VPdXQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgbW91c2Vkb3duOiAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlRG93biggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBtb3VzZXVwOiAgICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VVcCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBtb3VzZXVwY2FwdHVyZWQ6ICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VVcENhcHR1cmVkKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIG1vdXNlbW92ZTogICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Nb3VzZU1vdmUoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgbW91c2Vtb3ZlY2FwdHVyZWQ6ICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlTW92ZUNhcHR1cmVkKCBfdGhpcywgZXZlbnQgKTsgfSxcblxuICAgICAgICAgICAgdG91Y2hzdGFydDogICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblRvdWNoU3RhcnQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgdG91Y2hlbmQ6ICAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblRvdWNoRW5kKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIHRvdWNoZW5kY2FwdHVyZWQ6ICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Ub3VjaEVuZENhcHR1cmVkKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIHRvdWNobW92ZTogICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Ub3VjaE1vdmUoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgdG91Y2htb3ZlY2FwdHVyZWQ6ICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblRvdWNoTW92ZUNhcHR1cmVkKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIHRvdWNoY2FuY2VsOiAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Ub3VjaENhbmNlbCggX3RoaXMsIGV2ZW50ICk7IH0sXG5cbiAgICAgICAgICAgIGdlc3R1cmVzdGFydDogICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25HZXN0dXJlU3RhcnQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgZ2VzdHVyZWNoYW5nZTogICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbkdlc3R1cmVDaGFuZ2UoIF90aGlzLCBldmVudCApOyB9LFxuXG4gICAgICAgICAgICBwb2ludGVyb3ZlcjogICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlck92ZXIoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgTVNQb2ludGVyT3ZlcjogICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJPdmVyKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIHBvaW50ZXJvdXQ6ICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyT3V0KCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIE1TUG9pbnRlck91dDogICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyT3V0KCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIHBvaW50ZXJkb3duOiAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyRG93biggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBNU1BvaW50ZXJEb3duOiAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlckRvd24oIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgcG9pbnRlcnVwOiAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJVcCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBNU1BvaW50ZXJVcDogICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlclVwKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIHBvaW50ZXJtb3ZlOiAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyTW92ZSggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBNU1BvaW50ZXJNb3ZlOiAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlck1vdmUoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgcG9pbnRlcmNhbmNlbDogICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJDYW5jZWwoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgTVNQb2ludGVyQ2FuY2VsOiAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJDYW5jZWwoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgcG9pbnRlcnVwY2FwdHVyZWQ6ICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJVcENhcHR1cmVkKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIHBvaW50ZXJtb3ZlY2FwdHVyZWQ6ICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyTW92ZUNhcHR1cmVkKCBfdGhpcywgZXZlbnQgKTsgfSxcblxuICAgICAgICAgICAgdHJhY2tpbmc6ICAgICAgICAgICAgICBmYWxzZSxcblxuICAgICAgICAgICAgLy8gQWN0aXZlIHBvaW50ZXJzIGxpc3RzLiBBcnJheSBvZiBHZXN0dXJlUG9pbnRMaXN0IG9iamVjdHMsIG9uZSBmb3IgZWFjaCBwb2ludGVyIGRldmljZSB0eXBlLlxuICAgICAgICAgICAgLy8gR2VzdHVyZVBvaW50TGlzdCBvYmplY3RzIGFyZSBhZGRlZCBlYWNoIHRpbWUgYSBwb2ludGVyIGlzIHRyYWNrZWQgYnkgYSBuZXcgcG9pbnRlciBkZXZpY2UgdHlwZSAoc2VlIGdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSgpKS5cbiAgICAgICAgICAgIC8vIEFjdGl2ZSBwb2ludGVycyBhcmUgYW55IHBvaW50ZXIgYmVpbmcgdHJhY2tlZCBmb3IgdGhpcyBlbGVtZW50IHdoaWNoIGFyZSBpbiB0aGUgaGl0LXRlc3QgYXJlYVxuICAgICAgICAgICAgLy8gICAgIG9mIHRoZSBlbGVtZW50IChmb3IgaG92ZXItY2FwYWJsZSBkZXZpY2VzKSBhbmQvb3IgaGF2ZSBjb250YWN0IG9yIGEgYnV0dG9uIHByZXNzIGluaXRpYXRlZCBpbiB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgIGFjdGl2ZVBvaW50ZXJzTGlzdHM6ICAgW10sXG5cbiAgICAgICAgICAgIC8vIFRyYWNraW5nIGZvciBkb3VibGUtY2xpY2sgZ2VzdHVyZVxuICAgICAgICAgICAgbGFzdENsaWNrUG9zOiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgZGJsQ2xpY2tUaW1lT3V0OiAgICAgICBudWxsLFxuXG4gICAgICAgICAgICAvLyBUcmFja2luZyBmb3IgcGluY2ggZ2VzdHVyZVxuICAgICAgICAgICAgcGluY2hHUG9pbnRzOiAgICAgICAgICBbXSxcbiAgICAgICAgICAgIGxhc3RQaW5jaERpc3Q6ICAgICAgICAgMCxcbiAgICAgICAgICAgIGN1cnJlbnRQaW5jaERpc3Q6ICAgICAgMCxcbiAgICAgICAgICAgIGxhc3RQaW5jaENlbnRlcjogICAgICAgbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRQaW5jaENlbnRlcjogICAgbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggIW9wdGlvbnMuc3RhcnREaXNhYmxlZCApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhY2tpbmcoIHRydWUgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLnByb3RvdHlwZSAqL1xuICAgICQuTW91c2VUcmFja2VyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYW4gdXAgYW55IGV2ZW50cyBvciBvYmplY3RzIGNyZWF0ZWQgYnkgdGhlIHRyYWNrZXIuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIHN0b3BUcmFja2luZyggdGhpcyApO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBNT1VTRVRSQUNLRVJTLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggTU9VU0VUUkFDS0VSU1sgaSBdID09PSB0aGlzICkge1xuICAgICAgICAgICAgICAgICAgICBNT1VTRVRSQUNLRVJTLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdID0gbnVsbDtcbiAgICAgICAgICAgIGRlbGV0ZSBUSElTWyB0aGlzLmhhc2ggXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJlIHdlIGN1cnJlbnRseSB0cmFja2luZyBldmVudHMgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBKdXN0IHVzZSB0aGlzLnRyYWNraW5nXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQXJlIHdlIGN1cnJlbnRseSB0cmFja2luZyBldmVudHMgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgaXNUcmFja2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFRISVNbIHRoaXMuaGFzaCBdLnRyYWNraW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB3aGV0aGVyIG9yIG5vdCB3ZSBhcmUgdHJhY2tpbmcgZXZlbnRzIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJhY2sgVHJ1ZSB0byBzdGFydCB0cmFja2luZywgZmFsc2UgdG8gc3RvcCB0cmFja2luZy5cbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBDaGFpbmFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRUcmFja2luZzogZnVuY3Rpb24gKCB0cmFjayApIHtcbiAgICAgICAgICAgIGlmICggdHJhY2sgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUcmFja2luZyggdGhpcyApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9wVHJhY2tpbmcoIHRoaXMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY2hhaW5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdHxHZXN0dXJlUG9pbnRMaXN0fSBmb3IgdGhlIGdpdmVuIHBvaW50ZXIgZGV2aWNlIHR5cGUsXG4gICAgICAgICAqIGNyZWF0aW5nIGFuZCBjYWNoaW5nIGEgbmV3IHtAbGluayBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0fEdlc3R1cmVQb2ludExpc3R9IGlmIG9uZSBkb2Vzbid0IGFscmVhZHkgZXhpc3QgZm9yIHRoZSB0eXBlLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgcG9pbnRlciBkZXZpY2UgdHlwZTogXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGU6IGZ1bmN0aW9uICggdHlwZSApIHtcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0ZSA9IFRISVNbIHRoaXMuaGFzaCBdLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbGVuID0gZGVsZWdhdGUuYWN0aXZlUG9pbnRlcnNMaXN0cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbGlzdDtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGRlbGVnYXRlLmFjdGl2ZVBvaW50ZXJzTGlzdHNbIGkgXS50eXBlID09PSB0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuYWN0aXZlUG9pbnRlcnNMaXN0c1sgaSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdCA9IG5ldyAkLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0KCB0eXBlICk7XG4gICAgICAgICAgICBkZWxlZ2F0ZS5hY3RpdmVQb2ludGVyc0xpc3RzLnB1c2goIGxpc3QgKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgcG9pbnRlcnMgY3VycmVudGx5IGFjdGl2ZSBvbiB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFjdGl2ZVBvaW50ZXJDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdGhpcy5oYXNoIF0sXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBsZW4gPSBkZWxlZ2F0ZS5hY3RpdmVQb2ludGVyc0xpc3RzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gZGVsZWdhdGUuYWN0aXZlUG9pbnRlcnNMaXN0c1sgaSBdLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmJ1dHRvbnNcbiAgICAgICAgICogICAgICBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC5cbiAgICAgICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQucG9pbnRlcnNcbiAgICAgICAgICogICAgICBOdW1iZXIgb2YgcG9pbnRlcnMgKGFsbCB0eXBlcykgYWN0aXZlIGluIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgd2FzXG4gICAgICAgICAqICAgICAgaW5pdGlhdGVkIGluc2lkZSB0aGUgdHJhY2tlZCBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuYnV0dG9uRG93bkFueVxuICAgICAgICAgKiAgICAgIFdhcyB0aGUgYnV0dG9uIGRvd24gYW55d2hlcmUgaW4gdGhlIHNjcmVlbiBkdXJpbmcgdGhlIGV2ZW50LiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgYnV0dG9ucyBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZW50ZXJIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmJ1dHRvbnNcbiAgICAgICAgICogICAgICBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC5cbiAgICAgICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQucG9pbnRlcnNcbiAgICAgICAgICogICAgICBOdW1iZXIgb2YgcG9pbnRlcnMgKGFsbCB0eXBlcykgYWN0aXZlIGluIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgd2FzXG4gICAgICAgICAqICAgICAgaW5pdGlhdGVkIGluc2lkZSB0aGUgdHJhY2tlZCBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuYnV0dG9uRG93bkFueVxuICAgICAgICAgKiAgICAgIFdhcyB0aGUgYnV0dG9uIGRvd24gYW55d2hlcmUgaW4gdGhlIHNjcmVlbiBkdXJpbmcgdGhlIGV2ZW50LiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgYnV0dG9ucyBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZXhpdEhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LnBvc2l0aW9uXG4gICAgICAgICAqICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYnV0dG9uc1xuICAgICAgICAgKiAgICAgIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLlxuICAgICAgICAgKiAgICAgIENvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNUb3VjaEV2ZW50XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgb3JpZ2luYWwgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgb3RoZXJ3aXNlIGZhbHNlLiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgcG9pbnRlclR5cGUgYW5kL29yIG9yaWdpbmFsRXZlbnQgaW5zdGVhZC48L3NwYW4+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByZXNzSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25cbiAgICAgICAgICogICAgICBCdXR0b24gd2hpY2ggY2F1c2VkIHRoZSBldmVudC5cbiAgICAgICAgICogICAgICAtMTogbm9uZSwgMDogcHJpbWFyeS9sZWZ0LCAxOiBhdXgvbWlkZGxlLCAyOiBzZWNvbmRhcnkvcmlnaHQsIDM6IFgxL2JhY2ssIDQ6IFgyL2ZvcndhcmQsIDU6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25zXG4gICAgICAgICAqICAgICAgQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbm9uUHJpbWFyeVByZXNzSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25zXG4gICAgICAgICAqICAgICAgQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB3YXNcbiAgICAgICAgICogICAgICBpbml0aWF0ZWQgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pbnNpZGVFbGVtZW50UmVsZWFzZWRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBjdXJzb3IgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQgd2hlbiB0aGUgYnV0dG9uIHdhcyByZWxlYXNlZC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVsZWFzZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LnBvc2l0aW9uXG4gICAgICAgICAqICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYnV0dG9uXG4gICAgICAgICAqICAgICAgQnV0dG9uIHdoaWNoIGNhdXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqICAgICAgLTE6IG5vbmUsIDA6IHByaW1hcnkvbGVmdCwgMTogYXV4L21pZGRsZSwgMjogc2Vjb25kYXJ5L3JpZ2h0LCAzOiBYMS9iYWNrLCA0OiBYMi9mb3J3YXJkLCA1OiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYnV0dG9uc1xuICAgICAgICAgKiAgICAgIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLlxuICAgICAgICAgKiAgICAgIENvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNUb3VjaEV2ZW50XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgb3JpZ2luYWwgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgb3RoZXJ3aXNlIGZhbHNlLiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgcG9pbnRlclR5cGUgYW5kL29yIG9yaWdpbmFsRXZlbnQgaW5zdGVhZC48L3NwYW4+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIG5vblByaW1hcnlSZWxlYXNlSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25zXG4gICAgICAgICAqICAgICAgQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LnBvc2l0aW9uXG4gICAgICAgICAqICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuc2Nyb2xsXG4gICAgICAgICAqICAgICAgVGhlIHNjcm9sbCBkZWx0YSBmb3IgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnNoaWZ0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuIFRvdWNoIGRldmljZXMgbm8gbG9uZ2VyIGdlbmVyYXRlIHNjcm9sbCBldmVudC48L3NwYW4+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LnBvc2l0aW9uXG4gICAgICAgICAqICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnF1aWNrXG4gICAgICAgICAqICAgICAgVHJ1ZSBvbmx5IGlmIHRoZSBjbGlja0Rpc3RUaHJlc2hvbGQgYW5kIGNsaWNrVGltZVRocmVzaG9sZCBhcmUgYm90aCBwYXNzZWQuIFVzZWZ1bCBmb3IgaWdub3JpbmcgZHJhZyBldmVudHMuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuc2hpZnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNUb3VjaEV2ZW50XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgb3JpZ2luYWwgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgb3RoZXJ3aXNlIGZhbHNlLiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgcG9pbnRlclR5cGUgYW5kL29yIG9yaWdpbmFsRXZlbnQgaW5zdGVhZC48L3NwYW4+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGNsaWNrSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuc2hpZnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNUb3VjaEV2ZW50XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgb3JpZ2luYWwgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgb3RoZXJ3aXNlIGZhbHNlLiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgcG9pbnRlclR5cGUgYW5kL29yIG9yaWdpbmFsRXZlbnQgaW5zdGVhZC48L3NwYW4+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGRibENsaWNrSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25zXG4gICAgICAgICAqICAgICAgQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5kZWx0YVxuICAgICAgICAgKiAgICAgIFRoZSB4LHkgY29tcG9uZW50cyBvZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCB0aGUgbGFzdCBkcmFnIGV2ZW50IHBvc2l0aW9uLiAgVXNlZnVsIGZvciBpZ25vcmluZyBvciB3ZWlnaHRpbmcgdGhlIGV2ZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LnNwZWVkXG4gICAgICAgICAqICAgICBDdXJyZW50IGNvbXB1dGVkIHNwZWVkLCBpbiBwaXhlbHMgcGVyIHNlY29uZC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmRpcmVjdGlvblxuICAgICAgICAgKiAgICAgQ3VycmVudCBjb21wdXRlZCBkaXJlY3Rpb24sIGV4cHJlc3NlZCBhcyBhbiBhbmdsZSBjb3VudGVyY2xvY2t3aXNlIHJlbGF0aXZlIHRvIHRoZSBwb3NpdGl2ZSBYIGF4aXMgKC1waSB0byBwaSwgaW4gcmFkaWFucykuIE9ubHkgdmFsaWQgaWYgc3BlZWQgPiAwLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnNoaWZ0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5zcGVlZFxuICAgICAgICAgKiAgICAgU3BlZWQgYXQgdGhlIGVuZCBvZiBhIGRyYWcgZ2VzdHVyZSwgaW4gcGl4ZWxzIHBlciBzZWNvbmQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5kaXJlY3Rpb25cbiAgICAgICAgICogICAgIERpcmVjdGlvbiBhdCB0aGUgZW5kIG9mIGEgZHJhZyBnZXN0dXJlLCBleHByZXNzZWQgYXMgYW4gYW5nbGUgY291bnRlcmNsb2Nrd2lzZSByZWxhdGl2ZSB0byB0aGUgcG9zaXRpdmUgWCBheGlzICgtcGkgdG8gcGksIGluIHJhZGlhbnMpLiBPbmx5IHZhbGlkIGlmIHNwZWVkID4gMC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5zaGlmdFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0VuZEhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnQ+fSBldmVudC5nZXN0dXJlUG9pbnRzXG4gICAgICAgICAqICAgICAgR2VzdHVyZSBwb2ludHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnZXN0dXJlLiBWZWxvY2l0eSBkYXRhIGNhbiBiZSBmb3VuZCBoZXJlLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50Lmxhc3RDZW50ZXJcbiAgICAgICAgICogICAgICBUaGUgcHJldmlvdXMgY2VudGVyIHBvaW50IG9mIHRoZSB0d28gcGluY2ggY29udGFjdCBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5jZW50ZXJcbiAgICAgICAgICogICAgICBUaGUgY2VudGVyIHBvaW50IG9mIHRoZSB0d28gcGluY2ggY29udGFjdCBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50Lmxhc3REaXN0YW5jZVxuICAgICAgICAgKiAgICAgIFRoZSBwcmV2aW91cyBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcGluY2ggY29udGFjdCBwb2ludHMgaW4gQ1NTIHBpeGVscy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmRpc3RhbmNlXG4gICAgICAgICAqICAgICAgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwaW5jaCBjb250YWN0IHBvaW50cyBpbiBDU1MgcGl4ZWxzLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnNoaWZ0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwaW5jaEhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LnBvc2l0aW9uXG4gICAgICAgICAqICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYnV0dG9uc1xuICAgICAgICAgKiAgICAgIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLlxuICAgICAgICAgKiAgICAgIENvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNUb3VjaEV2ZW50XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgb3JpZ2luYWwgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgb3RoZXJ3aXNlIGZhbHNlLiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgcG9pbnRlclR5cGUgYW5kL29yIG9yaWdpbmFsRXZlbnQgaW5zdGVhZC48L3NwYW4+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHN0b3BIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5rZXlDb2RlXG4gICAgICAgICAqICAgICAgVGhlIGtleSBjb2RlIHRoYXQgd2FzIHByZXNzZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuY3RybFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGN0cmwga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnNoaWZ0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmFsdFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGFsdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQubWV0YVxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG1ldGEga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBrZXlEb3duSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQua2V5Q29kZVxuICAgICAgICAgKiAgICAgIFRoZSBrZXkgY29kZSB0aGF0IHdhcyBwcmVzc2VkLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmN0cmxcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBjdHJsIGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5zaGlmdFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5hbHRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBhbHQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50Lm1ldGFcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBtZXRhIGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAga2V5VXBIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5rZXlDb2RlXG4gICAgICAgICAqICAgICAgVGhlIGtleSBjb2RlIHRoYXQgd2FzIHByZXNzZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuY3RybFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGN0cmwga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnNoaWZ0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmFsdFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGFsdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQubWV0YVxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG1ldGEga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBrZXlIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBibHVySGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgY29udGludW91cyBjb21wdXRhdGlvbiBvZiB2ZWxvY2l0eSAoc3BlZWQgYW5kIGRpcmVjdGlvbikgb2YgYWN0aXZlIHBvaW50ZXJzLlxuICAgICAqIFRoaXMgaXMgYSBzaW5nbGV0b24sIHVzZWQgYnkgYWxsIE1vdXNlVHJhY2tlciBpbnN0YW5jZXMsIGFzIGl0IGlzIHVubGlrZWx5IHRoZXJlIHdpbGwgZXZlciBiZSBtb3JlIHRoYW5cbiAgICAgKiB0d28gYWN0aXZlIGdlc3R1cmUgcG9pbnRlcnMgYXQgYSB0aW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIGdlc3R1cmVQb2ludFZlbG9jaXR5VHJhY2tlclxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlclxuICAgICAqL1xuICAgICQuTW91c2VUcmFja2VyLmdlc3R1cmVQb2ludFZlbG9jaXR5VHJhY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFja2VyUG9pbnRzID0gW10sXG4gICAgICAgICAgICBpbnRlcnZhbElkID0gMCxcbiAgICAgICAgICAgIGxhc3RUaW1lID0gMDtcblxuICAgICAgICAvLyBHZW5lcmF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYSB0cmFja2VkIGdlc3R1cmUgcG9pbnRcbiAgICAgICAgdmFyIF9nZW5lcmF0ZUd1aWQgPSBmdW5jdGlvbiAoIHRyYWNrZXIsIGdQb2ludCApIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFja2VyLmhhc2gudG9TdHJpbmcoKSArIGdQb2ludC50eXBlICsgZ1BvaW50LmlkLnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJ2YWwgdGltZXIgY2FsbGJhY2suIENvbXB1dGVzIHZlbG9jaXR5IGZvciBhbGwgdHJhY2tlZCBnZXN0dXJlIHBvaW50cy5cbiAgICAgICAgdmFyIF9kb1RyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbGVuID0gdHJhY2tlclBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdHJhY2tQb2ludCxcbiAgICAgICAgICAgICAgICBnUG9pbnQsXG4gICAgICAgICAgICAgICAgbm93ID0gJC5ub3coKSxcbiAgICAgICAgICAgICAgICBlbGFwc2VkVGltZSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBzcGVlZDtcblxuICAgICAgICAgICAgZWxhcHNlZFRpbWUgPSBub3cgLSBsYXN0VGltZTtcbiAgICAgICAgICAgIGxhc3RUaW1lID0gbm93O1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIHRyYWNrUG9pbnQgPSB0cmFja2VyUG9pbnRzWyBpIF07XG4gICAgICAgICAgICAgICAgZ1BvaW50ID0gdHJhY2tQb2ludC5nUG9pbnQ7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5hdGFuMiBnaXZlcyB1cyBqdXN0IHdoYXQgd2UgbmVlZCBmb3IgYSB2ZWxvY2l0eSB2ZWN0b3IsIGFzIHdlIGNhbiBzaW1wbHlcbiAgICAgICAgICAgICAgICAvLyAgIHVzZSBjb3MoKS9zaW4oKSB0byBleHRyYWN0IHRoZSB4L3kgdmVsb2NpdHkgY29tcG9uZW50cy5cbiAgICAgICAgICAgICAgICBnUG9pbnQuZGlyZWN0aW9uID0gTWF0aC5hdGFuMiggZ1BvaW50LmN1cnJlbnRQb3MueSAtIHRyYWNrUG9pbnQubGFzdFBvcy55LCBnUG9pbnQuY3VycmVudFBvcy54IC0gdHJhY2tQb2ludC5sYXN0UG9zLnggKTtcbiAgICAgICAgICAgICAgICAvLyBzcGVlZCA9IGRpc3RhbmNlIC8gZWxhcHNlZCB0aW1lXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSB0cmFja1BvaW50Lmxhc3RQb3MuZGlzdGFuY2VUbyggZ1BvaW50LmN1cnJlbnRQb3MgKTtcbiAgICAgICAgICAgICAgICB0cmFja1BvaW50Lmxhc3RQb3MgPSBnUG9pbnQuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICBzcGVlZCA9IDEwMDAgKiBkaXN0YW5jZSAvICggZWxhcHNlZFRpbWUgKyAxICk7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIGJpYXNlZCBhdmVyYWdlLCBmYXZvcnMgdGhlIG1vc3QgcmVjZW50IHNwZWVkIGNvbXB1dGF0aW9uLiBTbW9vdGhzIG91dCBlcnJhdGljIGdlc3R1cmVzIGEgYml0LlxuICAgICAgICAgICAgICAgIGdQb2ludC5zcGVlZCA9IDAuNzUgKiBzcGVlZCArIDAuMjUgKiBnUG9pbnQuc3BlZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljLiBBZGQgYSBnZXN0dXJlIHBvaW50IHRvIGJlIHRyYWNrZWRcbiAgICAgICAgdmFyIGFkZFBvaW50ID0gZnVuY3Rpb24gKCB0cmFja2VyLCBnUG9pbnQgKSB7XG4gICAgICAgICAgICB2YXIgZ3VpZCA9IF9nZW5lcmF0ZUd1aWQoIHRyYWNrZXIsIGdQb2ludCApO1xuXG4gICAgICAgICAgICB0cmFja2VyUG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBndWlkOiBndWlkLFxuICAgICAgICAgICAgICAgICAgICBnUG9pbnQ6IGdQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvczogZ1BvaW50LmN1cnJlbnRQb3NcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgZmlyZSB1cCB0aGUgaW50ZXJ2YWwgdGltZXIgd2hlbiB0aGVyZSdzIGdlc3R1cmUgcG9pbnRlcnMgdG8gdHJhY2tcbiAgICAgICAgICAgIGlmICggdHJhY2tlclBvaW50cy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgbGFzdFRpbWUgPSAkLm5vdygpO1xuICAgICAgICAgICAgICAgIGludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoIF9kb1RyYWNraW5nLCA1MCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYy4gU3RvcCB0cmFja2luZyBhIGdlc3R1cmUgcG9pbnRcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ID0gZnVuY3Rpb24gKCB0cmFja2VyLCBnUG9pbnQgKSB7XG4gICAgICAgICAgICB2YXIgZ3VpZCA9IF9nZW5lcmF0ZUd1aWQoIHRyYWNrZXIsIGdQb2ludCApLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbGVuID0gdHJhY2tlclBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggdHJhY2tlclBvaW50c1sgaSBdLmd1aWQgPT09IGd1aWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZXJQb2ludHMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBpbnRlcnZhbCB0aW1lciBpZiB0aGVyZXMgZ2VzdHVyZSBwb2ludGVycyB0byB0cmFja1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsZW4gPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCggaW50ZXJ2YWxJZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkUG9pbnQ6ICAgIGFkZFBvaW50LFxuICAgICAgICAgICAgcmVtb3ZlUG9pbnQ6IHJlbW92ZVBvaW50XG4gICAgICAgIH07XG4gICAgfSApKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUG9pbnRlciBldmVudCBtb2RlbCBhbmQgZmVhdHVyZSBkZXRlY3Rpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgYXZhaWxhYmxlIG1vdXNlIHdoZWVsIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgJC5Nb3VzZVRyYWNrZXIud2hlZWxFdmVudE5hbWUgPSAoICQuQnJvd3Nlci52ZW5kb3IgPT0gJC5CUk9XU0VSUy5JRSAmJiAkLkJyb3dzZXIudmVyc2lvbiA+IDggKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKSApID8gJ3doZWVsJyA6IC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0ICd3aGVlbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkID8gJ21vdXNld2hlZWwnIDogICAgICAgICAgICAgICAgICAgICAvLyBXZWJraXQgYW5kIElFIHN1cHBvcnQgYXQgbGVhc3QgJ21vdXNld2hlZWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRE9NTW91c2VTY3JvbGwnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIG9sZCBGaXJlZm94XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgbGVnYWN5IG1vdXNlIGNhcHR1cmUgc3VwcG9ydC5cbiAgICAgKi9cbiAgICAkLk1vdXNlVHJhY2tlci5zdXBwb3J0c01vdXNlQ2FwdHVyZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXZFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgcmV0dXJuICQuaXNGdW5jdGlvbiggZGl2RWxlbWVudC5zZXRDYXB0dXJlICkgJiYgJC5pc0Z1bmN0aW9uKCBkaXZFbGVtZW50LnJlbGVhc2VDYXB0dXJlICk7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBicm93c2VyIHBvaW50ZXIgZGV2aWNlIGV2ZW50IG1vZGVsKHMpIGFuZCBidWlsZCBhcHByb3ByaWF0ZSBsaXN0IG9mIGV2ZW50cyB0byBzdWJzY3JpYmUgdG8uXG4gICAgICovXG4gICAgJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzID0gWyBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJrZXlkb3duXCIsIFwia2V5dXBcIiwgXCJrZXlwcmVzc1wiLCBcImZvY3VzXCIsIFwiYmx1clwiLCAkLk1vdXNlVHJhY2tlci53aGVlbEV2ZW50TmFtZSBdO1xuXG4gICAgaWYoICQuTW91c2VUcmFja2VyLndoZWVsRXZlbnROYW1lID09IFwiRE9NTW91c2VTY3JvbGxcIiApIHtcbiAgICAgICAgLy8gT2xkZXIgRmlyZWZveFxuICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJNb3pNb3VzZVBpeGVsU2Nyb2xsXCIgKTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGUgaXMgZGVwcmVjYXRlZCBvbiBJRSAxMSBhbmQgbm90IHBhcnQgb2YgVzNDIHNwZWMuXG4gICAgaWYgKCB3aW5kb3cuUG9pbnRlckV2ZW50ICYmICggd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCAkLkJyb3dzZXIudmVuZG9yICE9PSAkLkJST1dTRVJTLklFICkgKSB7XG4gICAgICAgIC8vIElFMTEgYW5kIG90aGVyIFczQyBQb2ludGVyIEV2ZW50IGltcGxlbWVudGF0aW9ucyAoc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMpXG4gICAgICAgICQuTW91c2VUcmFja2VyLmhhdmVQb2ludGVyRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzLnB1c2goIFwicG9pbnRlcm92ZXJcIiwgXCJwb2ludGVyb3V0XCIsIFwicG9pbnRlcmRvd25cIiwgXCJwb2ludGVydXBcIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJjYW5jZWxcIiApO1xuICAgICAgICAkLk1vdXNlVHJhY2tlci51bnByZWZpeGVkUG9pbnRlckV2ZW50cyA9IHRydWU7XG4gICAgICAgIGlmKCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgKSB7XG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5tYXhUb3VjaFBvaW50cyA9IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuTW91c2VUcmFja2VyLm1heFRvdWNoUG9pbnRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAkLk1vdXNlVHJhY2tlci5oYXZlTW91c2VFbnRlciA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XG4gICAgICAgIC8vIElFMTBcbiAgICAgICAgJC5Nb3VzZVRyYWNrZXIuaGF2ZVBvaW50ZXJFdmVudHMgPSB0cnVlO1xuICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJNU1BvaW50ZXJPdmVyXCIsIFwiTVNQb2ludGVyT3V0XCIsIFwiTVNQb2ludGVyRG93blwiLCBcIk1TUG9pbnRlclVwXCIsIFwiTVNQb2ludGVyTW92ZVwiLCBcIk1TUG9pbnRlckNhbmNlbFwiICk7XG4gICAgICAgICQuTW91c2VUcmFja2VyLnVucHJlZml4ZWRQb2ludGVyRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIGlmKCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyApIHtcbiAgICAgICAgICAgICQuTW91c2VUcmFja2VyLm1heFRvdWNoUG9pbnRzID0gbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5tYXhUb3VjaFBvaW50cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgJC5Nb3VzZVRyYWNrZXIuaGF2ZU1vdXNlRW50ZXIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMZWdhY3kgVzNDIG1vdXNlIGV2ZW50c1xuICAgICAgICAkLk1vdXNlVHJhY2tlci5oYXZlUG9pbnRlckV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBpZiAoICQuQnJvd3Nlci52ZW5kb3IgPT09ICQuQlJPV1NFUlMuSUUgJiYgJC5Ccm93c2VyLnZlcnNpb24gPCA5ICkge1xuICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzLnB1c2goIFwibW91c2VlbnRlclwiLCBcIm1vdXNlbGVhdmVcIiApO1xuICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuaGF2ZU1vdXNlRW50ZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzLnB1c2goIFwibW91c2VvdmVyXCIsIFwibW91c2VvdXRcIiApO1xuICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuaGF2ZU1vdXNlRW50ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJtb3VzZWRvd25cIiwgXCJtb3VzZXVwXCIsIFwibW91c2Vtb3ZlXCIgKTtcbiAgICAgICAgaWYgKCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgKSB7XG4gICAgICAgICAgICAvLyBpT1MsIEFuZHJvaWQsIGFuZCBvdGhlciBXM2MgVG91Y2ggRXZlbnQgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICAvLyAgICAoc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy8pXG4gICAgICAgICAgICAvLyAgICAoc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2lvcy9kb2N1bWVudGF0aW9uL0FwcGxlQXBwbGljYXRpb25zL1JlZmVyZW5jZS9TYWZhcmlXZWJDb250ZW50L0hhbmRsaW5nRXZlbnRzL0hhbmRsaW5nRXZlbnRzLmh0bWwpXG4gICAgICAgICAgICAvLyAgICAoc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL0FwcGxlQXBwbGljYXRpb25zL1JlZmVyZW5jZS9TYWZhcmlXZWJDb250ZW50L0hhbmRsaW5nRXZlbnRzL0hhbmRsaW5nRXZlbnRzLmh0bWwpXG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2hlbmRcIiwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGNhbmNlbFwiICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAnb25nZXN0dXJlc3RhcnQnIGluIHdpbmRvdyApIHtcbiAgICAgICAgICAgIC8vIGlPUyAoc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2lvcy9kb2N1bWVudGF0aW9uL0FwcGxlQXBwbGljYXRpb25zL1JlZmVyZW5jZS9TYWZhcmlXZWJDb250ZW50L0hhbmRsaW5nRXZlbnRzL0hhbmRsaW5nRXZlbnRzLmh0bWwpXG4gICAgICAgICAgICAvLyAgIFN1YnNjcmliZSB0byB0aGVzZSB0byBwcmV2ZW50IGRlZmF1bHQgZ2VzdHVyZSBoYW5kbGluZ1xuICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzLnB1c2goIFwiZ2VzdHVyZXN0YXJ0XCIsIFwiZ2VzdHVyZWNoYW5nZVwiICk7XG4gICAgICAgIH1cbiAgICAgICAgJC5Nb3VzZVRyYWNrZXIubW91c2VQb2ludGVySWQgPSBcImxlZ2FjeS1tb3VzZVwiO1xuICAgICAgICAkLk1vdXNlVHJhY2tlci5tYXhUb3VjaFBvaW50cyA9IDEwO1xuICAgIH1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDbGFzc2VzIGFuZCB0eXBlZGVmc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHBvaW50IG9mIGNvbnRhY3Qgb24gdGhlIHNjcmVlbiBtYWRlIGJ5IGEgbW91c2UgY3Vyc29yLCBwZW4sIHRvdWNoLCBvciBvdGhlciBwb2ludGVyIGRldmljZS5cbiAgICAgKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IEdlc3R1cmVQb2ludFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkXG4gICAgICogICAgIElkZW50aWZpZXIgdW5pcXVlIGZyb20gYWxsIG90aGVyIGFjdGl2ZSBHZXN0dXJlUG9pbnRzIGZvciBhIGdpdmVuIHBvaW50ZXIgZGV2aWNlLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlXG4gICAgICogICAgIFRoZSBwb2ludGVyIGRldmljZSB0eXBlOiBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY2FwdHVyZWRcbiAgICAgKiAgICAgVHJ1ZSBpZiBldmVudHMgZm9yIHRoZSBnZXN0dXJlIHBvaW50IGFyZSBjYXB0dXJlZCB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNQcmltYXJ5XG4gICAgICogICAgIFRydWUgaWYgdGhlIGdlc3R1cmUgcG9pbnQgaXMgYSBtYXN0ZXIgcG9pbnRlciBhbW9uZ3N0IHRoZSBzZXQgb2YgYWN0aXZlIHBvaW50ZXJzIGZvciBlYWNoIHBvaW50ZXIgdHlwZS4gVHJ1ZSBmb3IgbW91c2UgYW5kIHByaW1hcnkgKGZpcnN0KSB0b3VjaC9wZW4gcG9pbnRlcnMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbnNpZGVFbGVtZW50UHJlc3NlZFxuICAgICAqICAgICBUcnVlIGlmIGJ1dHRvbiBwcmVzc2VkIG9yIGNvbnRhY3QgcG9pbnQgaW5pdGlhdGVkIGluc2lkZSB0aGUgc2NyZWVuIGFyZWEgb2YgdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGluc2lkZUVsZW1lbnRcbiAgICAgKiAgICAgVHJ1ZSBpZiBwb2ludGVyIG9yIGNvbnRhY3QgcG9pbnQgaXMgY3VycmVudGx5IGluc2lkZSB0aGUgYm91bmRzIG9mIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNwZWVkXG4gICAgICogICAgIEN1cnJlbnQgY29tcHV0ZWQgc3BlZWQsIGluIHBpeGVscyBwZXIgc2Vjb25kLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAgICAgKiAgICAgQ3VycmVudCBjb21wdXRlZCBkaXJlY3Rpb24sIGV4cHJlc3NlZCBhcyBhbiBhbmdsZSBjb3VudGVyY2xvY2t3aXNlIHJlbGF0aXZlIHRvIHRoZSBwb3NpdGl2ZSBYIGF4aXMgKC1waSB0byBwaSwgaW4gcmFkaWFucykuIE9ubHkgdmFsaWQgaWYgc3BlZWQgPiAwLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gY29udGFjdFBvc1xuICAgICAqICAgICBUaGUgaW5pdGlhbCBwb2ludGVyIGNvbnRhY3QgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSBwYWdlIGluY2x1ZGluZyBhbnkgc2Nyb2xsaW5nLiBPbmx5IHZhbGlkIGlmIHRoZSBwb2ludGVyIGhhcyBjb250YWN0IChwcmVzc2VkLCB0b3VjaCBjb250YWN0LCBwZW4gY29udGFjdCkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRhY3RUaW1lXG4gICAgICogICAgIFRoZSBpbml0aWFsIHBvaW50ZXIgY29udGFjdCB0aW1lLCBpbiBtaWxsaXNlY29uZHMuIE9ubHkgdmFsaWQgaWYgdGhlIHBvaW50ZXIgaGFzIGNvbnRhY3QgKHByZXNzZWQsIHRvdWNoIGNvbnRhY3QsIHBlbiBjb250YWN0KS5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IGxhc3RQb3NcbiAgICAgKiAgICAgVGhlIGxhc3QgcG9pbnRlciBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHBhZ2UgaW5jbHVkaW5nIGFueSBzY3JvbGxpbmcuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxhc3RUaW1lXG4gICAgICogICAgIFRoZSBsYXN0IHBvaW50ZXIgY29udGFjdCB0aW1lLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBjdXJyZW50UG9zXG4gICAgICogICAgIFRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSBwYWdlIGluY2x1ZGluZyBhbnkgc2Nyb2xsaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50VGltZVxuICAgICAqICAgICBUaGUgY3VycmVudCBwb2ludGVyIGNvbnRhY3QgdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgR2VzdHVyZVBvaW50TGlzdFxuICAgICAqIEBjbGFzc2Rlc2MgUHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gZm9yIGEgc2V0IG9mIGFjdGl2ZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50fEdlc3R1cmVQb2ludH0gb2JqZWN0cyBmb3IgYSBnaXZlbiBwb2ludGVyIGRldmljZSB0eXBlLlxuICAgICAqICAgICAgICAgICAgQWN0aXZlIHBvaW50ZXJzIGFyZSBhbnkgcG9pbnRlciBiZWluZyB0cmFja2VkIGZvciB0aGlzIGVsZW1lbnQgd2hpY2ggYXJlIGluIHRoZSBoaXQtdGVzdCBhcmVhXG4gICAgICogICAgICAgICAgICBvZiB0aGUgZWxlbWVudCAoZm9yIGhvdmVyLWNhcGFibGUgZGV2aWNlcykgYW5kL29yIGhhdmUgY29udGFjdCBvciBhIGJ1dHRvbiBwcmVzcyBpbml0aWF0ZWQgaW4gdGhlIGVsZW1lbnQuXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgcG9pbnRlciBkZXZpY2UgdHlwZTogXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgKi9cbiAgICAkLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0ID0gZnVuY3Rpb24gKCB0eXBlICkge1xuICAgICAgICB0aGlzLl9nUG9pbnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9pbnRlciBkZXZpY2UgdHlwZTogXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0I1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkIGZvciB0aGUgZGV2aWNlLlxuICAgICAgICAgKiBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGJ1dHRvbnNcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1dHRvbnMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBudW1iZXIgb2YgY29udGFjdCBwb2ludHMgKHRvdWNoIHBvaW50cywgbW91c2UgZG93biwgZXRjLikgZm9yIHRoZSBkZXZpY2UuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29udGFjdHNcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRhY3RzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgbnVtYmVyIG9mIGNsaWNrcyBmb3IgdGhlIGRldmljZS4gVXNlZCBmb3IgbXVsdGlwbGUgY2xpY2sgZ2VzdHVyZSB0cmFja2luZy5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjbGlja3NcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IG51bWJlciBvZiBjYXB0dXJlZCBwb2ludGVycyBmb3IgdGhlIGRldmljZS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjYXB0dXJlQ291bnRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhcHR1cmVDb3VudCA9IDA7XG4gICAgfTtcblxuICAgIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdC5wcm90b3R5cGUgKi9cbiAgICAkLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2YgZ2VzdHVyZSBwb2ludHMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludD59IFRoZSBsaXN0IG9mIGdlc3R1cmUgcG9pbnRzIGluIHRoZSBsaXN0IGFzIGFuIGFycmF5IChyZWFkLW9ubHkpLlxuICAgICAgICAgKi9cbiAgICAgICAgYXNBcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dQb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnR9IGdlc3R1cmVQb2ludCAtIEEgZ2VzdHVyZSBwb2ludCB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiBnZXN0dXJlIHBvaW50cyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKCBncCApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nUG9pbnRzLnB1c2goIGdwICk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIC0gVGhlIGlkIG9mIHRoZSBnZXN0dXJlIHBvaW50IHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2YgZ2VzdHVyZSBwb2ludHMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5fZ1BvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5fZ1BvaW50c1sgaSBdLmlkID09PSBpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ1BvaW50cy5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dQb2ludHMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgZ2VzdHVyZSBwb2ludCB0byByZXRyaWV2ZSBmcm9tIHRoZSBsaXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50fG51bGx9IFRoZSBnZXN0dXJlIHBvaW50IGF0IHRoZSBnaXZlbiBpbmRleCwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCeUluZGV4OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuICAgICAgICAgICAgaWYgKCBpbmRleCA8IHRoaXMuX2dQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dQb2ludHNbIGluZGV4IF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAtIFRoZSBpZCBvZiB0aGUgZ2VzdHVyZSBwb2ludCB0byByZXRyaWV2ZSBmcm9tIHRoZSBsaXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50fG51bGx9IFRoZSBnZXN0dXJlIHBvaW50IHdpdGggdGhlIGdpdmVuIGlkLCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9nUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLl9nUG9pbnRzWyBpIF0uaWQgPT09IGlkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ1BvaW50c1sgaSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnR8bnVsbH0gVGhlIHByaW1hcnkgZ2VzdHVyZSBwb2ludCBpbiB0aGUgbGlzdCwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQcmltYXJ5OiBmdW5jdGlvbiAoIGlkICkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5fZ1BvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5fZ1BvaW50c1sgaSBdLmlzUHJpbWFyeSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dQb2ludHNbIGkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRyYWNrZWQgcG9pbnRlcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhclRyYWNrZWRQb2ludGVycyggdHJhY2tlciApIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdHJhY2tlci5oYXNoIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcG9pbnRlckxpc3RDb3VudCA9IGRlbGVnYXRlLmFjdGl2ZVBvaW50ZXJzTGlzdHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgcG9pbnRlckxpc3RDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCBkZWxlZ2F0ZS5hY3RpdmVQb2ludGVyc0xpc3RzWyBpIF0uY2FwdHVyZUNvdW50ID4gMCApIHtcbiAgICAgICAgICAgICAgICAkLnJlbW92ZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5jYXB0dXJlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLm1vdXNlbW92ZWNhcHR1cmVkLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAkLnJlbW92ZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5jYXB0dXJlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNldXAnLFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5tb3VzZXVwY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci51bnByZWZpeGVkUG9pbnRlckV2ZW50cyA/ICdwb2ludGVybW92ZScgOiAnTVNQb2ludGVyTW92ZScsXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLnBvaW50ZXJtb3ZlY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci51bnByZWZpeGVkUG9pbnRlckV2ZW50cyA/ICdwb2ludGVydXAnIDogJ01TUG9pbnRlclVwJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUucG9pbnRlcnVwY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUudG91Y2htb3ZlY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS50b3VjaGVuZGNhcHR1cmVkLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGRlbGVnYXRlLmFjdGl2ZVBvaW50ZXJzTGlzdHNbIGkgXS5jYXB0dXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBwb2ludGVyTGlzdENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZS5hY3RpdmVQb2ludGVyc0xpc3RzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRyYWNraW5nIHBvaW50ZXIgZXZlbnRzIG9uIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydFRyYWNraW5nKCB0cmFja2VyICkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0cmFja2VyLmhhc2ggXSxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAoICFkZWxlZ2F0ZS50cmFja2luZyApIHtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzWyBpIF07XG4gICAgICAgICAgICAgICAgJC5hZGRFdmVudChcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlci5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVbIGV2ZW50IF0sXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYXJUcmFja2VkUG9pbnRlcnMoIHRyYWNrZXIgKTtcblxuICAgICAgICAgICAgZGVsZWdhdGUudHJhY2tpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgdHJhY2tpbmcgcG9pbnRlciBldmVudHMgb24gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3BUcmFja2luZyggdHJhY2tlciApIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdHJhY2tlci5oYXNoIF0sXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgaWYgKCBkZWxlZ2F0ZS50cmFja2luZyApIHtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gJC5Nb3VzZVRyYWNrZXIuc3Vic2NyaWJlRXZlbnRzWyBpIF07XG4gICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudChcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlci5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVbIGV2ZW50IF0sXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYXJUcmFja2VkUG9pbnRlcnMoIHRyYWNrZXIgKTtcblxuICAgICAgICAgICAgZGVsZWdhdGUudHJhY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2FwdHVyZUV2ZW50UGFyYW1zKCB0cmFja2VyLCBwb2ludGVyVHlwZSApIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdHJhY2tlci5oYXNoIF07XG5cbiAgICAgICAgaWYgKCBwb2ludGVyVHlwZSA9PT0gJ3BvaW50ZXJldmVudCcgKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVwTmFtZTogJC5Nb3VzZVRyYWNrZXIudW5wcmVmaXhlZFBvaW50ZXJFdmVudHMgPyAncG9pbnRlcnVwJyA6ICdNU1BvaW50ZXJVcCcsXG4gICAgICAgICAgICAgICAgdXBIYW5kbGVyOiBkZWxlZ2F0ZS5wb2ludGVydXBjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICBtb3ZlTmFtZTogJC5Nb3VzZVRyYWNrZXIudW5wcmVmaXhlZFBvaW50ZXJFdmVudHMgPyAncG9pbnRlcm1vdmUnIDogJ01TUG9pbnRlck1vdmUnLFxuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVyOiBkZWxlZ2F0ZS5wb2ludGVybW92ZWNhcHR1cmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCBwb2ludGVyVHlwZSA9PT0gJ21vdXNlJyApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBOYW1lOiAnbW91c2V1cCcsXG4gICAgICAgICAgICAgICAgdXBIYW5kbGVyOiBkZWxlZ2F0ZS5tb3VzZXVwY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgbW92ZU5hbWU6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVyOiBkZWxlZ2F0ZS5tb3VzZW1vdmVjYXB0dXJlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICggcG9pbnRlclR5cGUgPT09ICd0b3VjaCcgKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVwTmFtZTogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgICB1cEhhbmRsZXI6IGRlbGVnYXRlLnRvdWNoZW5kY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgbW92ZU5hbWU6ICd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVyOiBkZWxlZ2F0ZS50b3VjaG1vdmVjYXB0dXJlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJNb3VzZVRyYWNrZXIuZ2V0Q2FwdHVyZUV2ZW50UGFyYW1zOiBVbmtub3duIHBvaW50ZXIgdHlwZS5cIiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmVnaW4gY2FwdHVyaW5nIHBvaW50ZXIgZXZlbnRzIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXB0dXJlUG9pbnRlciggdHJhY2tlciwgcG9pbnRlclR5cGUsIHBvaW50ZXJDb3VudCApIHtcbiAgICAgICAgdmFyIHBvaW50c0xpc3QgPSB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggcG9pbnRlclR5cGUgKSxcbiAgICAgICAgICAgIGV2ZW50UGFyYW1zO1xuXG4gICAgICAgIHBvaW50c0xpc3QuY2FwdHVyZUNvdW50ICs9IChwb2ludGVyQ291bnQgfHwgMSk7XG5cbiAgICAgICAgaWYgKCBwb2ludHNMaXN0LmNhcHR1cmVDb3VudCA9PT0gMSApIHtcbiAgICAgICAgICAgIGlmICggJC5Ccm93c2VyLnZlbmRvciA9PT0gJC5CUk9XU0VSUy5JRSAmJiAkLkJyb3dzZXIudmVyc2lvbiA8IDkgKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tlci5lbGVtZW50LnNldENhcHR1cmUoIHRydWUgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMgPSBnZXRDYXB0dXJlRXZlbnRQYXJhbXMoIHRyYWNrZXIsICQuTW91c2VUcmFja2VyLmhhdmVQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJldmVudCcgOiBwb2ludGVyVHlwZSApO1xuICAgICAgICAgICAgICAgIC8vIFdlIGVtdWxhdGUgbW91c2UgY2FwdHVyZSBieSBoYW5naW5nIGxpc3RlbmVycyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgICAgICAgICAgICAgIC8vICAgIChOb3RlIHdlIGxpc3RlbiBvbiB0aGUgY2FwdHVyZSBwaGFzZSBzbyB0aGUgY2FwdHVyZWQgaGFuZGxlcnMgd2lsbCBnZXQgY2FsbGVkIGZpcnN0KVxuICAgICAgICAgICAgICAgIGlmIChpc0luSWZyYW1lICYmIGNhbkFjY2Vzc0V2ZW50cyh3aW5kb3cudG9wKSkge1xuICAgICAgICAgICAgICAgICAgICAkLmFkZEV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLnVwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLnVwSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJC5hZGRFdmVudChcbiAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLnVwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAkLmFkZEV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5jYXB0dXJlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMubW92ZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLm1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU3RvcCBjYXB0dXJpbmcgcG9pbnRlciBldmVudHMgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbGVhc2VQb2ludGVyKCB0cmFja2VyLCBwb2ludGVyVHlwZSwgcG9pbnRlckNvdW50ICkge1xuICAgICAgICB2YXIgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCBwb2ludGVyVHlwZSApLFxuICAgICAgICAgICAgZXZlbnRQYXJhbXM7XG5cbiAgICAgICAgcG9pbnRzTGlzdC5jYXB0dXJlQ291bnQgLT0gKHBvaW50ZXJDb3VudCB8fCAxKTtcblxuICAgICAgICBpZiAoIHBvaW50c0xpc3QuY2FwdHVyZUNvdW50ID09PSAwICkge1xuICAgICAgICAgICAgaWYgKCAkLkJyb3dzZXIudmVuZG9yID09PSAkLkJST1dTRVJTLklFICYmICQuQnJvd3Nlci52ZXJzaW9uIDwgOSApIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLmVsZW1lbnQucmVsZWFzZUNhcHR1cmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMgPSBnZXRDYXB0dXJlRXZlbnRQYXJhbXMoIHRyYWNrZXIsICQuTW91c2VUcmFja2VyLmhhdmVQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJldmVudCcgOiBwb2ludGVyVHlwZSApO1xuICAgICAgICAgICAgICAgIC8vIFdlIGVtdWxhdGUgbW91c2UgY2FwdHVyZSBieSBoYW5naW5nIGxpc3RlbmVycyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgICAgICAgICAgICAgIC8vICAgIChOb3RlIHdlIGxpc3RlbiBvbiB0aGUgY2FwdHVyZSBwaGFzZSBzbyB0aGUgY2FwdHVyZWQgaGFuZGxlcnMgd2lsbCBnZXQgY2FsbGVkIGZpcnN0KVxuICAgICAgICAgICAgICAgIGlmIChpc0luSWZyYW1lICYmIGNhbkFjY2Vzc0V2ZW50cyh3aW5kb3cudG9wKSkge1xuICAgICAgICAgICAgICAgICAgICAkLnJlbW92ZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLnVwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLnVwSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudChcbiAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLm1vdmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudFBhcmFtcy5tb3ZlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudChcbiAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLnVwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIFczQyBQb2ludGVyIEV2ZW50cyBtb2RlbCBjb21wYXRpYmxlIHBvaW50ZXIgdHlwZSBzdHJpbmcgZnJvbSBhIERPTSBwb2ludGVyIGV2ZW50LlxuICAgICAqIElFMTAgdXNlZCBhIGxvbmcgaW50ZWdlciB2YWx1ZSwgYnV0IHRoZSBXM0Mgc3BlY2lmaWNhdGlvbiAoYW5kIElFMTErKSB1c2UgYSBzdHJpbmcgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBvaW50ZXJUeXBlKCBldmVudCApIHtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlU3RyO1xuICAgICAgICBpZiAoICQuTW91c2VUcmFja2VyLnVucHJlZml4ZWRQb2ludGVyRXZlbnRzICkge1xuICAgICAgICAgICAgcG9pbnRlclR5cGVTdHIgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElFMTBcbiAgICAgICAgICAgIC8vICBNU1BPSU5URVJfVFlQRV9UT1VDSDogMHgwMDAwMDAwMlxuICAgICAgICAgICAgLy8gIE1TUE9JTlRFUl9UWVBFX1BFTjogICAweDAwMDAwMDAzXG4gICAgICAgICAgICAvLyAgTVNQT0lOVEVSX1RZUEVfTU9VU0U6IDB4MDAwMDAwMDRcbiAgICAgICAgICAgIHN3aXRjaCggZXZlbnQucG9pbnRlclR5cGUgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwMDAwMDAwMjpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGVTdHIgPSAndG91Y2gnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4MDAwMDAwMDM6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlU3RyID0gJ3Blbic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwMDAwMDAwNDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGVTdHIgPSAnbW91c2UnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZVN0ciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludGVyVHlwZVN0cjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQgKSB7XG4gICAgICAgIHJldHVybiAkLmdldE1vdXNlUG9zaXRpb24oIGV2ZW50ICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNb3VzZVJlbGF0aXZlKCBldmVudCwgZWxlbWVudCApIHtcbiAgICAgICAgcmV0dXJuIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLCBlbGVtZW50ICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggcG9pbnQsIGVsZW1lbnQgKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAkLmdldEVsZW1lbnRPZmZzZXQoIGVsZW1lbnQgKTtcbiAgICAgICAgcmV0dXJuIHBvaW50Lm1pbnVzKCBvZmZzZXQgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENlbnRlclBvaW50KCBwb2ludDEsIHBvaW50MiApIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KCAoIHBvaW50MS54ICsgcG9pbnQyLnggKSAvIDIsICggcG9pbnQxLnkgKyBwb2ludDIueSApIC8gMiApO1xuICAgIH1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEZXZpY2Utc3BlY2lmaWMgRE9NIGV2ZW50IGhhbmRsZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQ2xpY2soIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBpZiAoIHRyYWNrZXIuY2xpY2tIYW5kbGVyICkge1xuICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkRibENsaWNrKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaWYgKCB0cmFja2VyLmRibENsaWNrSGFuZGxlciApIHtcbiAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25LZXlEb3duKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgLy8kLmNvbnNvbGUubG9nKCBcImtleWRvd24gJXMgJXMgJXMgJXMgJXNcIiwgZXZlbnQua2V5Q29kZSwgZXZlbnQuY2hhckNvZGUsIGV2ZW50LmN0cmxLZXksIGV2ZW50LnNoaWZ0S2V5LCBldmVudC5hbHRLZXkgKTtcbiAgICAgICAgdmFyIHByb3BhZ2F0ZTtcbiAgICAgICAgaWYgKCB0cmFja2VyLmtleURvd25IYW5kbGVyICkge1xuICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5rZXlEb3duSGFuZGxlcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICBrZXlDb2RlOiAgICAgICAgICAgICAgZXZlbnQua2V5Q29kZSA/IGV2ZW50LmtleUNvZGUgOiBldmVudC5jaGFyQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgY3RybDogICAgICAgICAgICAgICAgIGV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0OiAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiAgICAgICAgICAgICAgICAgIGV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogICAgICAgICAgICAgICAgIGV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoICFwcm9wYWdhdGUgKSB7XG4gICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleVVwKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgLy8kLmNvbnNvbGUubG9nKCBcImtleXVwICVzICVzICVzICVzICVzXCIsIGV2ZW50LmtleUNvZGUsIGV2ZW50LmNoYXJDb2RlLCBldmVudC5jdHJsS2V5LCBldmVudC5zaGlmdEtleSwgZXZlbnQuYWx0S2V5ICk7XG4gICAgICAgIHZhciBwcm9wYWdhdGU7XG4gICAgICAgIGlmICggdHJhY2tlci5rZXlVcEhhbmRsZXIgKSB7XG4gICAgICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmtleVVwSGFuZGxlcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICBrZXlDb2RlOiAgICAgICAgICAgICAgZXZlbnQua2V5Q29kZSA/IGV2ZW50LmtleUNvZGUgOiBldmVudC5jaGFyQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgY3RybDogICAgICAgICAgICAgICAgIGV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0OiAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiAgICAgICAgICAgICAgICAgIGV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogICAgICAgICAgICAgICAgIGV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoICFwcm9wYWdhdGUgKSB7XG4gICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleVByZXNzKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgLy8kLmNvbnNvbGUubG9nKCBcImtleXByZXNzICVzICVzICVzICVzICVzXCIsIGV2ZW50LmtleUNvZGUsIGV2ZW50LmNoYXJDb2RlLCBldmVudC5jdHJsS2V5LCBldmVudC5zaGlmdEtleSwgZXZlbnQuYWx0S2V5ICk7XG4gICAgICAgIHZhciBwcm9wYWdhdGU7XG4gICAgICAgIGlmICggdHJhY2tlci5rZXlIYW5kbGVyICkge1xuICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5rZXlIYW5kbGVyKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleUNvZGU6ICAgICAgICAgICAgICBldmVudC5rZXlDb2RlID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjdHJsOiAgICAgICAgICAgICAgICAgZXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICBhbHQ6ICAgICAgICAgICAgICAgICAgZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiAgICAgICAgICAgICAgICAgZXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICggIXByb3BhZ2F0ZSApIHtcbiAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRm9jdXMoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCBcImZvY3VzICVzXCIsIGV2ZW50ICk7XG4gICAgICAgIHZhciBwcm9wYWdhdGU7XG4gICAgICAgIGlmICggdHJhY2tlci5mb2N1c0hhbmRsZXIgKSB7XG4gICAgICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmZvY3VzSGFuZGxlcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25CbHVyKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyggXCJibHVyICVzXCIsIGV2ZW50ICk7XG4gICAgICAgIHZhciBwcm9wYWdhdGU7XG4gICAgICAgIGlmICggdHJhY2tlci5ibHVySGFuZGxlciApIHtcbiAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIuYmx1ckhhbmRsZXIoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnd2hlZWwnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbldoZWVsKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaGFuZGxlV2hlZWxFdmVudCggdHJhY2tlciwgZXZlbnQsIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsIGFuZCAnTW96TW91c2VQaXhlbFNjcm9sbCcgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhICd3aGVlbCcgZXZlbnRcbiAgICAgICAgdmFyIHNpbXVsYXRlZEV2ZW50ID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiAgICAgZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgICAgICB0eXBlOiAgICAgICBcIndoZWVsXCIsXG4gICAgICAgICAgICBzaGlmdEtleTogICBldmVudC5zaGlmdEtleSB8fCBmYWxzZSxcbiAgICAgICAgICAgIGNsaWVudFg6ICAgIGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZOiAgICBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgcGFnZVg6ICAgICAgZXZlbnQucGFnZVggPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBwYWdlWTogICAgICBldmVudC5wYWdlWSA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgIGRlbHRhTW9kZTogIGV2ZW50LnR5cGUgPT0gXCJNb3pNb3VzZVBpeGVsU2Nyb2xsXCIgPyAwIDogMSwgLy8gMD1waXhlbCwgMT1saW5lLCAyPXBhZ2VcbiAgICAgICAgICAgIGRlbHRhWDogICAgIDAsXG4gICAgICAgICAgICBkZWx0YVo6ICAgICAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRlbHRhWVxuICAgICAgICBpZiAoICQuTW91c2VUcmFja2VyLndoZWVsRXZlbnROYW1lID09IFwibW91c2V3aGVlbFwiICkge1xuICAgICAgICAgICAgc2ltdWxhdGVkRXZlbnQuZGVsdGFZID0gLSAxIC8gJC5ERUZBVUxUX1NFVFRJTkdTLnBpeGVsc1BlcldoZWVsTGluZSAqIGV2ZW50LndoZWVsRGVsdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaW11bGF0ZWRFdmVudC5kZWx0YVkgPSBldmVudC5kZXRhaWw7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVXaGVlbEV2ZW50KCB0cmFja2VyLCBzaW11bGF0ZWRFdmVudCwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgJ3doZWVsJyBldmVudHMuXG4gICAgICogVGhlIGV2ZW50IG1heSBiZSBzaW11bGF0ZWQgYnkgdGhlIGxlZ2FjeSBtb3VzZSB3aGVlbCBldmVudCBoYW5kbGVyIChvbk1vdXNlV2hlZWwoKSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVdoZWVsRXZlbnQoIHRyYWNrZXIsIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkge1xuICAgICAgICB2YXIgbkRlbHRhID0gMCxcbiAgICAgICAgICAgIHByb3BhZ2F0ZTtcblxuICAgICAgICAvLyBUaGUgbkRlbHRhIHZhcmlhYmxlIGlzIGdhdGVkIHRvIHByb3ZpZGUgc21vb3RoIHotaW5kZXggc2Nyb2xsaW5nXG4gICAgICAgIC8vICAgc2luY2UgdGhlIG1vdXNlIHdoZWVsIGFsbG93cyBmb3Igc3Vic3RhbnRpYWwgZGVsdGFzIG1lYW50IGZvciByYXBpZFxuICAgICAgICAvLyAgIHktaW5kZXggc2Nyb2xsaW5nLlxuICAgICAgICAvLyBldmVudC5kZWx0YU1vZGU6IDA9cGl4ZWwsIDE9bGluZSwgMj1wYWdlXG4gICAgICAgIC8vIFRPRE86IERlbHRhcyBpbiBwaXhlbCBtb2RlIHNob3VsZCBiZSBhY2N1bXVsYXRlZCB0aGVuIGEgc2Nyb2xsIHZhbHVlIGNvbXB1dGVkIGFmdGVyICQuREVGQVVMVF9TRVRUSU5HUy5waXhlbHNQZXJXaGVlbExpbmUgdGhyZXNob2xkIHJlYWNoZWRcbiAgICAgICAgbkRlbHRhID0gZXZlbnQuZGVsdGFZIDwgMCA/IDEgOiAtMTtcblxuICAgICAgICBpZiAoIHRyYWNrZXIuc2Nyb2xsSGFuZGxlciApIHtcbiAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIuc2Nyb2xsSGFuZGxlcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgJ21vdXNlJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldE1vdXNlUmVsYXRpdmUoIGV2ZW50LCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsOiAgICAgICAgICAgICAgIG5EZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQYXJlbnRDaGlsZCggcGFyZW50LCBjaGlsZCApXG4gICAge1xuICAgICAgIGlmICggcGFyZW50ID09PSBjaGlsZCApIHtcbiAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgICB3aGlsZSAoIGNoaWxkICYmIGNoaWxkICE9PSBwYXJlbnQgKSB7XG4gICAgICAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGNoaWxkID09PSBwYXJlbnQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBPbmx5IHVzZWQgb24gSUUgOFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG5cbiAgICAgICAgaGFuZGxlTW91c2VFbnRlciggdHJhY2tlciwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Nb3VzZU92ZXIoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG5cbiAgICAgICAgaWYgKCBldmVudC5jdXJyZW50VGFyZ2V0ID09PSBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGlzUGFyZW50Q2hpbGQoIGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50LnJlbGF0ZWRUYXJnZXQgKSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZU1vdXNlRW50ZXIoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6ICQuTW91c2VUcmFja2VyLm1vdXNlUG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIGlzUHJpbWFyeTogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJzRW50ZXIoIHRyYWNrZXIsIGV2ZW50LCBbIGdQb2ludCBdICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBPbmx5IHVzZWQgb24gSUUgOFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG5cbiAgICAgICAgaGFuZGxlTW91c2VFeGl0KCB0cmFja2VyLCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlT3V0KCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuXG4gICAgICAgIGlmICggZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBpc1BhcmVudENoaWxkKCBldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudC5yZWxhdGVkVGFyZ2V0ICkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVNb3VzZUV4aXQoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRXhpdCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogJC5Nb3VzZVRyYWNrZXIubW91c2VQb2ludGVySWQsXG4gICAgICAgICAgICB0eXBlOiAnbW91c2UnLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiB0cnVlLFxuICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQgKSxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiAkLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgdXBkYXRlUG9pbnRlcnNFeGl0KCB0cmFja2VyLCBldmVudCwgWyBnUG9pbnQgXSApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFczQyBET00gbGV2ZWwgMyBzdGFuZGFyZCBidXR0b24gdmFsdWUgZ2l2ZW4gYW4gZXZlbnQuYnV0dG9uIHByb3BlcnR5OlxuICAgICAqICAgLTEgPT0gbm9uZSwgMCA9PSBwcmltYXJ5L2xlZnQsIDEgPT0gbWlkZGxlLCAyID09IHNlY29uZGFyeS9yaWdodCwgMyA9PSBYMS9iYWNrLCA0ID09IFgyL2ZvcndhcmQsIDUgPT0gZXJhc2VyIChwZW4pXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdGFuZGFyZGl6ZWRCdXR0b24oIGJ1dHRvbiApIHtcbiAgICAgICAgaWYgKCAkLkJyb3dzZXIudmVuZG9yID09PSAkLkJST1dTRVJTLklFICYmICQuQnJvd3Nlci52ZXJzaW9uIDwgOSApIHtcbiAgICAgICAgICAgIC8vIE9uIElFIDgsIDAgPT0gbm9uZSwgMSA9PSBsZWZ0LCAyID09IHJpZ2h0LCAzID09IGxlZnQgYW5kIHJpZ2h0LCA0ID09IG1pZGRsZSwgNSA9PSBsZWZ0IGFuZCBtaWRkbGUsIDYgPT0gcmlnaHQgYW5kIG1pZGRsZSwgNyA9PSBhbGwgdGhyZWVcbiAgICAgICAgICAgIC8vIFRPRE86IFN1cHBvcnQgY2hvcmRlZCAobXVsdGlwbGUpIGJ1dHRvbiBwcmVzc2VzIG9uIElFIDg/XG4gICAgICAgICAgICBpZiAoIGJ1dHRvbiA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbiA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbiA9PT0gNCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93biggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQ7XG5cbiAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuXG4gICAgICAgIGdQb2ludCA9IHtcbiAgICAgICAgICAgIGlkOiAkLk1vdXNlVHJhY2tlci5tb3VzZVBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZScsXG4gICAgICAgICAgICBpc1ByaW1hcnk6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6ICQubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIHVwZGF0ZVBvaW50ZXJzRG93biggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0sIGdldFN0YW5kYXJkaXplZEJ1dHRvbiggZXZlbnQuYnV0dG9uICkgKSApIHtcbiAgICAgICAgICAgICQuc3RvcEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgY2FwdHVyZVBvaW50ZXIoIHRyYWNrZXIsICdtb3VzZScgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHJhY2tlci5jbGlja0hhbmRsZXIgfHwgdHJhY2tlci5kYmxDbGlja0hhbmRsZXIgfHwgdHJhY2tlci5wcmVzc0hhbmRsZXIgfHwgdHJhY2tlci5kcmFnSGFuZGxlciB8fCB0cmFja2VyLmRyYWdFbmRIYW5kbGVyICkge1xuICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBoYW5kbGVNb3VzZVVwKCB0cmFja2VyLCBldmVudCApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGFuZGxlciBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93IG9iamVjdCAob24gdGhlIGNhcHR1cmUgcGhhc2UpIHRvIGVtdWxhdGUgbW91c2UgY2FwdHVyZS5cbiAgICAgKiBvbk1vdXNlVXAgaXMgc3RpbGwgYXR0YWNoZWQgdG8gdGhlIHRyYWNrZWQgZWxlbWVudCwgc28gc3RvcCBwcm9wYWdhdGlvbiB0byBhdm9pZCBwcm9jZXNzaW5nIHR3aWNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXBDYXB0dXJlZCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZU1vdXNlVXAoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgICAgICQuc3RvcEV2ZW50KCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGdQb2ludDtcblxuICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG5cbiAgICAgICAgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6ICQuTW91c2VUcmFja2VyLm1vdXNlUG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIGlzUHJpbWFyeTogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggdXBkYXRlUG9pbnRlcnNVcCggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0sIGdldFN0YW5kYXJkaXplZEJ1dHRvbiggZXZlbnQuYnV0dG9uICkgKSApIHtcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyKCB0cmFja2VyLCAnbW91c2UnICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBoYW5kbGVNb3VzZU1vdmUoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGFuZGxlciBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93IG9iamVjdCAob24gdGhlIGNhcHR1cmUgcGhhc2UpIHRvIGVtdWxhdGUgbW91c2UgY2FwdHVyZS5cbiAgICAgKiBvbk1vdXNlTW92ZSBpcyBzdGlsbCBhdHRhY2hlZCB0byB0aGUgdHJhY2tlZCBlbGVtZW50LCBzbyBzdG9wIHByb3BhZ2F0aW9uIHRvIGF2b2lkIHByb2Nlc3NpbmcgdHdpY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlQ2FwdHVyZWQoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBoYW5kbGVNb3VzZU1vdmUoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgICAgICQuc3RvcEV2ZW50KCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgZ1BvaW50O1xuXG4gICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogJC5Nb3VzZVRyYWNrZXIubW91c2VQb2ludGVySWQsXG4gICAgICAgICAgICB0eXBlOiAnbW91c2UnLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiB0cnVlLFxuICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQgKSxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiAkLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgdXBkYXRlUG9pbnRlcnNNb3ZlKCB0cmFja2VyLCBldmVudCwgWyBnUG9pbnQgXSApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYm9ydFRvdWNoQ29udGFjdHMoIHRyYWNrZXIsIGV2ZW50LCBwb2ludHNMaXN0ICkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGdQb2ludENvdW50ID0gcG9pbnRzTGlzdC5nZXRMZW5ndGgoKSxcbiAgICAgICAgICAgIGFib3J0R1BvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZ1BvaW50Q291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgIGFib3J0R1BvaW50cy5wdXNoKCBwb2ludHNMaXN0LmdldEJ5SW5kZXgoIGkgKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBhYm9ydEdQb2ludHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIC8vIHNpbXVsYXRlIHRvdWNoZW5kXG4gICAgICAgICAgICB1cGRhdGVQb2ludGVyc1VwKCB0cmFja2VyLCBldmVudCwgYWJvcnRHUG9pbnRzLCAwICk7IC8vIDAgbWVhbnMgcHJpbWFyeSBidXR0b24gcHJlc3MvcmVsZWFzZSBvciB0b3VjaCBjb250YWN0XG4gICAgICAgICAgICAvLyByZWxlYXNlIHBvaW50ZXIgY2FwdHVyZVxuICAgICAgICAgICAgcG9pbnRzTGlzdC5jYXB0dXJlQ291bnQgPSAxO1xuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXIoIHRyYWNrZXIsICd0b3VjaCcgKTtcbiAgICAgICAgICAgIC8vIHNpbXVsYXRlIHRvdWNobGVhdmVcbiAgICAgICAgICAgIHVwZGF0ZVBvaW50ZXJzRXhpdCggdHJhY2tlciwgZXZlbnQsIGFib3J0R1BvaW50cyApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciB0aW1lLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICB0b3VjaENvdW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgZ1BvaW50cyA9IFtdLFxuICAgICAgICAgICAgcGFyZW50R1BvaW50cyxcbiAgICAgICAgICAgIHBvaW50c0xpc3QgPSB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggJ3RvdWNoJyApO1xuXG4gICAgICAgIHRpbWUgPSAkLm5vdygpO1xuXG4gICAgICAgIGlmICggcG9pbnRzTGlzdC5nZXRMZW5ndGgoKSA+IGV2ZW50LnRvdWNoZXMubGVuZ3RoIC0gdG91Y2hDb3VudCApIHtcbiAgICAgICAgICAgICQuY29uc29sZS53YXJuKCdUcmFja2VkIHRvdWNoIGNvbnRhY3QgY291bnQgZG9lc25cXCd0IG1hdGNoIGV2ZW50LnRvdWNoZXMubGVuZ3RoLiBSZW1vdmluZyBhbGwgdHJhY2tlZCB0b3VjaCBwb2ludGVycy4nKTtcbiAgICAgICAgICAgIGFib3J0VG91Y2hDb250YWN0cyggdHJhY2tlciwgZXZlbnQsIHBvaW50c0xpc3QgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdG91Y2hDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgZ1BvaW50cy5wdXNoKCB7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWyBpIF0uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2gnLFxuICAgICAgICAgICAgICAgIC8vIGlzUHJpbWFyeSBub3Qgc2V0IC0gbGV0IHRoZSB1cGRhdGVQb2ludGVycyBmdW5jdGlvbnMgZGV0ZXJtaW5lIGl0XG4gICAgICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQuY2hhbmdlZFRvdWNoZXNbIGkgXSApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiB0aW1lXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW11bGF0ZSB0b3VjaGVudGVyIG9uIG91ciB0cmFja2VkIGVsZW1lbnRcbiAgICAgICAgdXBkYXRlUG9pbnRlcnNFbnRlciggdHJhY2tlciwgZXZlbnQsIGdQb2ludHMgKTtcblxuICAgICAgICAvLyBzaW11bGF0ZSB0b3VjaGVudGVyIG9uIG91ciB0cmFja2VkIGVsZW1lbnQncyB0cmFja2VkIGFuY2VzdG9yIGVsZW1lbnRzXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgTU9VU0VUUkFDS0VSUy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggTU9VU0VUUkFDS0VSU1sgaSBdICE9PSB0cmFja2VyICYmIE1PVVNFVFJBQ0tFUlNbIGkgXS5pc1RyYWNraW5nKCkgJiYgaXNQYXJlbnRDaGlsZCggTU9VU0VUUkFDS0VSU1sgaSBdLmVsZW1lbnQsIHRyYWNrZXIuZWxlbWVudCApICkge1xuICAgICAgICAgICAgICAgIHBhcmVudEdQb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHRvdWNoQ291bnQ7IGorKyApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50R1BvaW50cy5wdXNoKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbIGogXS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzUHJpbWFyeSBub3Qgc2V0IC0gbGV0IHRoZSB1cGRhdGVQb2ludGVycyBmdW5jdGlvbnMgZGV0ZXJtaW5lIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudC5jaGFuZ2VkVG91Y2hlc1sgaiBdICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZTogdGltZVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvaW50ZXJzRW50ZXIoIE1PVVNFVFJBQ0tFUlNbIGkgXSwgZXZlbnQsIHBhcmVudEdQb2ludHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdXBkYXRlUG9pbnRlcnNEb3duKCB0cmFja2VyLCBldmVudCwgZ1BvaW50cywgMCApICkgeyAvLyAwIG1lYW5zIHByaW1hcnkgYnV0dG9uIHByZXNzL3JlbGVhc2Ugb3IgdG91Y2ggY29udGFjdFxuICAgICAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBjYXB0dXJlUG9pbnRlciggdHJhY2tlciwgJ3RvdWNoJywgdG91Y2hDb3VudCApO1xuICAgICAgICB9XG5cbiAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZVRvdWNoRW5kKCB0cmFja2VyLCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cgb2JqZWN0IChvbiB0aGUgY2FwdHVyZSBwaGFzZSkgdG8gZW11bGF0ZSBwb2ludGVyIGNhcHR1cmUuXG4gICAgICogb25Ub3VjaEVuZCBpcyBzdGlsbCBhdHRhY2hlZCB0byB0aGUgdHJhY2tlZCBlbGVtZW50LCBzbyBzdG9wIHByb3BhZ2F0aW9uIHRvIGF2b2lkIHByb2Nlc3NpbmcgdHdpY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmRDYXB0dXJlZCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZVRvdWNoRW5kKCB0cmFja2VyLCBldmVudCApO1xuICAgICAgICAkLnN0b3BFdmVudCggZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgdGltZSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgdG91Y2hDb3VudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGdQb2ludHMgPSBbXSxcbiAgICAgICAgICAgIHBhcmVudEdQb2ludHM7XG5cbiAgICAgICAgdGltZSA9ICQubm93KCk7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCB0b3VjaENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBnUG9pbnRzLnB1c2goIHtcbiAgICAgICAgICAgICAgICBpZDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbIGkgXS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgLy8gaXNQcmltYXJ5IG5vdCBzZXQgLSBsZXQgdGhlIHVwZGF0ZVBvaW50ZXJzIGZ1bmN0aW9ucyBkZXRlcm1pbmUgaXRcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudC5jaGFuZ2VkVG91Y2hlc1sgaSBdICksXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6IHRpbWVcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdXBkYXRlUG9pbnRlcnNVcCggdHJhY2tlciwgZXZlbnQsIGdQb2ludHMsIDAgKSApIHtcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyKCB0cmFja2VyLCAndG91Y2gnLCB0b3VjaENvdW50ICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW11bGF0ZSB0b3VjaGxlYXZlIG9uIG91ciB0cmFja2VkIGVsZW1lbnRcbiAgICAgICAgdXBkYXRlUG9pbnRlcnNFeGl0KCB0cmFja2VyLCBldmVudCwgZ1BvaW50cyApO1xuXG4gICAgICAgIC8vIHNpbXVsYXRlIHRvdWNobGVhdmUgb24gb3VyIHRyYWNrZWQgZWxlbWVudCdzIHRyYWNrZWQgYW5jZXN0b3IgZWxlbWVudHNcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBNT1VTRVRSQUNLRVJTLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCBNT1VTRVRSQUNLRVJTWyBpIF0gIT09IHRyYWNrZXIgJiYgTU9VU0VUUkFDS0VSU1sgaSBdLmlzVHJhY2tpbmcoKSAmJiBpc1BhcmVudENoaWxkKCBNT1VTRVRSQUNLRVJTWyBpIF0uZWxlbWVudCwgdHJhY2tlci5lbGVtZW50ICkgKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50R1BvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgdG91Y2hDb3VudDsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRHUG9pbnRzLnB1c2goIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBldmVudC5jaGFuZ2VkVG91Y2hlc1sgaiBdLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNQcmltYXJ5IG5vdCBzZXQgLSBsZXQgdGhlIHVwZGF0ZVBvaW50ZXJzIGZ1bmN0aW9ucyBkZXRlcm1pbmUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50LmNoYW5nZWRUb3VjaGVzWyBqIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiB0aW1lXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlUG9pbnRlcnNFeGl0KCBNT1VTRVRSQUNLRVJTWyBpIF0sIGV2ZW50LCBwYXJlbnRHUG9pbnRzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZSggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZSggdHJhY2tlciwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGFuZGxlciBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93IG9iamVjdCAob24gdGhlIGNhcHR1cmUgcGhhc2UpIHRvIGVtdWxhdGUgcG9pbnRlciBjYXB0dXJlLlxuICAgICAqIG9uVG91Y2hNb3ZlIGlzIHN0aWxsIGF0dGFjaGVkIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQsIHNvIHN0b3AgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvY2Vzc2luZyB0d2ljZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Ub3VjaE1vdmVDYXB0dXJlZCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZSggdHJhY2tlciwgZXZlbnQgKTtcbiAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZSggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdG91Y2hDb3VudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGdQb2ludHMgPSBbXTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHRvdWNoQ291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgIGdQb2ludHMucHVzaCgge1xuICAgICAgICAgICAgICAgIGlkOiBldmVudC5jaGFuZ2VkVG91Y2hlc1sgaSBdLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAvLyBpc1ByaW1hcnkgbm90IHNldCAtIGxldCB0aGUgdXBkYXRlUG9pbnRlcnMgZnVuY3Rpb25zIGRldGVybWluZSBpdFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50LmNoYW5nZWRUb3VjaGVzWyBpIF0gKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlUG9pbnRlcnNNb3ZlKCB0cmFja2VyLCBldmVudCwgZ1BvaW50cyApO1xuXG4gICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uVG91Y2hDYW5jZWwoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHRvdWNoQ291bnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgsXG4gICAgICAgICAgICBnUG9pbnRzID0gW10sXG4gICAgICAgICAgICBwb2ludHNMaXN0ID0gdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoICd0b3VjaCcgKTtcbiAgICAgICAgXG4gICAgICAgIGFib3J0VG91Y2hDb250YWN0cyggdHJhY2tlciwgZXZlbnQsIHBvaW50c0xpc3QgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25HZXN0dXJlU3RhcnQoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkdlc3R1cmVDaGFuZ2UoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJPdmVyKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGdQb2ludDtcblxuICAgICAgICBpZiAoIGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgaXNQYXJlbnRDaGlsZCggZXZlbnQuY3VycmVudFRhcmdldCwgZXZlbnQucmVsYXRlZFRhcmdldCApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6IGV2ZW50LnBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6IGdldFBvaW50ZXJUeXBlKCBldmVudCApLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiBldmVudC5pc1ByaW1hcnksXG4gICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6ICQubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICB1cGRhdGVQb2ludGVyc0VudGVyKCB0cmFja2VyLCBldmVudCwgWyBnUG9pbnQgXSApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJPdXQoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgZ1BvaW50O1xuXG4gICAgICAgIGlmICggZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBpc1BhcmVudENoaWxkKCBldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudC5yZWxhdGVkVGFyZ2V0ICkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogZXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogZ2V0UG9pbnRlclR5cGUoIGV2ZW50ICksXG4gICAgICAgICAgICBpc1ByaW1hcnk6IGV2ZW50LmlzUHJpbWFyeSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJzRXhpdCggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0gKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93biggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQ7XG5cbiAgICAgICAgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6IGV2ZW50LnBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6IGdldFBvaW50ZXJUeXBlKCBldmVudCApLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiBldmVudC5pc1ByaW1hcnksXG4gICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6ICQubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIHVwZGF0ZVBvaW50ZXJzRG93biggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0sIGV2ZW50LmJ1dHRvbiApICkge1xuICAgICAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBjYXB0dXJlUG9pbnRlciggdHJhY2tlciwgZ1BvaW50LnR5cGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHJhY2tlci5jbGlja0hhbmRsZXIgfHwgdHJhY2tlci5kYmxDbGlja0hhbmRsZXIgfHwgdHJhY2tlci5wcmVzc0hhbmRsZXIgfHwgdHJhY2tlci5kcmFnSGFuZGxlciB8fCB0cmFja2VyLmRyYWdFbmRIYW5kbGVyIHx8IHRyYWNrZXIucGluY2hIYW5kbGVyICkge1xuICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZVBvaW50ZXJVcCggdHJhY2tlciwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGFuZGxlciBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93IG9iamVjdCAob24gdGhlIGNhcHR1cmUgcGhhc2UpIHRvIGVtdWxhdGUgbW91c2UgY2FwdHVyZS5cbiAgICAgKiBvblBvaW50ZXJVcCBpcyBzdGlsbCBhdHRhY2hlZCB0byB0aGUgdHJhY2tlZCBlbGVtZW50LCBzbyBzdG9wIHByb3BhZ2F0aW9uIHRvIGF2b2lkIHByb2Nlc3NpbmcgdHdpY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwQ2FwdHVyZWQoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCBnZXRQb2ludGVyVHlwZSggZXZlbnQgKSApO1xuICAgICAgICBpZiAoIHBvaW50c0xpc3QuZ2V0QnlJZCggZXZlbnQucG9pbnRlcklkICkgKSB7XG4gICAgICAgICAgICBoYW5kbGVQb2ludGVyVXAoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgICAgIH1cbiAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJVcCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQ7XG5cbiAgICAgICAgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6IGV2ZW50LnBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6IGdldFBvaW50ZXJUeXBlKCBldmVudCApLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiBldmVudC5pc1ByaW1hcnksXG4gICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6ICQubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIHVwZGF0ZVBvaW50ZXJzVXAoIHRyYWNrZXIsIGV2ZW50LCBbIGdQb2ludCBdLCBldmVudC5idXR0b24gKSApIHtcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyKCB0cmFja2VyLCBnUG9pbnQudHlwZSApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBoYW5kbGVQb2ludGVyTW92ZSggdHJhY2tlciwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGFuZGxlciBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93IG9iamVjdCAob24gdGhlIGNhcHR1cmUgcGhhc2UpIHRvIGVtdWxhdGUgbW91c2UgY2FwdHVyZS5cbiAgICAgKiBvblBvaW50ZXJNb3ZlIGlzIHN0aWxsIGF0dGFjaGVkIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQsIHNvIHN0b3AgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvY2Vzc2luZyB0d2ljZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZUNhcHR1cmVkKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIHBvaW50c0xpc3QgPSB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggZ2V0UG9pbnRlclR5cGUoIGV2ZW50ICkgKTtcbiAgICAgICAgaWYgKCBwb2ludHNMaXN0LmdldEJ5SWQoIGV2ZW50LnBvaW50ZXJJZCApICkge1xuICAgICAgICAgICAgaGFuZGxlUG9pbnRlck1vdmUoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgICAgIH1cbiAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgLy8gUG9pbnRlciBjaGFuZ2VkIGNvb3JkaW5hdGVzLCBidXR0b24gc3RhdGUsIHByZXNzdXJlLCB0aWx0LCBvciBjb250YWN0IGdlb21ldHJ5IChlLmcuIHdpZHRoIGFuZCBoZWlnaHQpXG4gICAgICAgIHZhciBnUG9pbnQ7XG5cbiAgICAgICAgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6IGV2ZW50LnBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6IGdldFBvaW50ZXJUeXBlKCBldmVudCApLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiBldmVudC5pc1ByaW1hcnksXG4gICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6ICQubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICB1cGRhdGVQb2ludGVyc01vdmUoIHRyYWNrZXIsIGV2ZW50LCBbIGdQb2ludCBdICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckNhbmNlbCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQ7XG5cbiAgICAgICAgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6IGV2ZW50LnBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6IGdldFBvaW50ZXJUeXBlKCBldmVudCApXG4gICAgICAgIH07XG5cbiAgICAgICAgdXBkYXRlUG9pbnRlcnNDYW5jZWwoIHRyYWNrZXIsIGV2ZW50LCBbIGdQb2ludCBdICk7XG4gICAgfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERldmljZS1hZ25vc3RpYyBET00gZXZlbnQgaGFuZGxlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0fSBwb2ludHNMaXN0XG4gICAgICogICAgIFRoZSBHZXN0dXJlUG9pbnRMaXN0IHRvIHRyYWNrIHRoZSBwb2ludGVyIGluLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50fSBnUG9pbnRcbiAgICAgKiAgICAgIEdlc3R1cmUgcG9pbnQgdG8gdHJhY2suXG4gICAgICogQHJldHVybnMge051bWJlcn0gTnVtYmVyIG9mIGdlc3R1cmUgcG9pbnRzIGluIHBvaW50c0xpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRUcmFja2luZ1BvaW50ZXIoIHBvaW50c0xpc3QsIGdQb2ludCApIHtcblxuICAgICAgICAvLyBJZiBpc1ByaW1hcnkgaXMgbm90IGtub3duIGZvciB0aGUgcG9pbnRlciB0aGVuIHNldCBpdCBhY2NvcmRpbmcgdG8gb3VyIHJ1bGVzOlxuICAgICAgICAvLyAgICB0cnVlIGlmIHRoZSBmaXJzdCBwb2ludGVyIGluIHRoZSBnZXN0dXJlLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgaWYgKCAhZ1BvaW50Lmhhc093blByb3BlcnR5KCAnaXNQcmltYXJ5JyApICkge1xuICAgICAgICAgICAgaWYgKCBwb2ludHNMaXN0LmdldExlbmd0aCgpID09PSAwICkge1xuICAgICAgICAgICAgICAgIGdQb2ludC5pc1ByaW1hcnkgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnUG9pbnQuaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ1BvaW50LnNwZWVkID0gMDtcbiAgICAgICAgZ1BvaW50LmRpcmVjdGlvbiA9IDA7XG4gICAgICAgIGdQb2ludC5jb250YWN0UG9zID0gZ1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgIGdQb2ludC5jb250YWN0VGltZSA9IGdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgZ1BvaW50Lmxhc3RQb3MgPSBnUG9pbnQuY3VycmVudFBvcztcbiAgICAgICAgZ1BvaW50Lmxhc3RUaW1lID0gZ1BvaW50LmN1cnJlbnRUaW1lO1xuXG4gICAgICAgIHJldHVybiBwb2ludHNMaXN0LmFkZCggZ1BvaW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdH0gcG9pbnRzTGlzdFxuICAgICAqICAgICBUaGUgR2VzdHVyZVBvaW50TGlzdCB0byBzdG9wIHRyYWNraW5nIHRoZSBwb2ludGVyIG9uLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50fSBnUG9pbnRcbiAgICAgKiAgICAgIEdlc3R1cmUgcG9pbnQgdG8gc3RvcCB0cmFja2luZy5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2YgZ2VzdHVyZSBwb2ludHMgaW4gcG9pbnRzTGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9wVHJhY2tpbmdQb2ludGVyKCBwb2ludHNMaXN0LCBnUG9pbnQgKSB7XG4gICAgICAgIHZhciBsaXN0TGVuZ3RoLFxuICAgICAgICAgICAgcHJpbWFyeVBvaW50O1xuXG4gICAgICAgIGlmICggcG9pbnRzTGlzdC5nZXRCeUlkKCBnUG9pbnQuaWQgKSApIHtcbiAgICAgICAgICAgIGxpc3RMZW5ndGggPSBwb2ludHNMaXN0LnJlbW92ZUJ5SWQoIGdQb2ludC5pZCApO1xuXG4gICAgICAgICAgICAvLyBJZiBpc1ByaW1hcnkgaXMgbm90IGtub3duIGZvciB0aGUgcG9pbnRlciBhbmQgd2UganVzdCByZW1vdmVkIHRoZSBwcmltYXJ5IHBvaW50ZXIgZnJvbSB0aGUgbGlzdCB0aGVuIHdlIG5lZWQgdG8gc2V0IGFub3RoZXIgcG9pbnRlciBhcyBwcmltYXJ5XG4gICAgICAgICAgICBpZiAoICFnUG9pbnQuaGFzT3duUHJvcGVydHkoICdpc1ByaW1hcnknICkgKSB7XG4gICAgICAgICAgICAgICAgcHJpbWFyeVBvaW50ID0gcG9pbnRzTGlzdC5nZXRQcmltYXJ5KCk7XG4gICAgICAgICAgICAgICAgaWYgKCAhcHJpbWFyeVBvaW50ICkge1xuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5UG9pbnQgPSBwb2ludHNMaXN0LmdldEJ5SW5kZXgoIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwcmltYXJ5UG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5UG9pbnQuaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RMZW5ndGggPSBwb2ludHNMaXN0LmdldExlbmd0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3RMZW5ndGg7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXJcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmF0aW5nIERPTSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnQ+fSBnUG9pbnRzXG4gICAgICogICAgICBHZXN0dXJlIHBvaW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJzRW50ZXIoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzICkge1xuICAgICAgICB2YXIgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCBnUG9pbnRzWyAwIF0udHlwZSApLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGdQb2ludENvdW50ID0gZ1BvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjdXJHUG9pbnQsXG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQsXG4gICAgICAgICAgICBwcm9wYWdhdGU7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBnUG9pbnRDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgY3VyR1BvaW50ID0gZ1BvaW50c1sgaSBdO1xuICAgICAgICAgICAgdXBkYXRlR1BvaW50ID0gcG9pbnRzTGlzdC5nZXRCeUlkKCBjdXJHUG9pbnQuaWQgKTtcblxuICAgICAgICAgICAgaWYgKCB1cGRhdGVHUG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSB0cmFja2luZyB0aGUgcG9pbnRlci4uLnVwZGF0ZSBpdFxuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQubGFzdFBvcyA9IHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0VGltZSA9IHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuY3VycmVudFBvcyA9IGN1ckdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZSA9IGN1ckdQb2ludC5jdXJyZW50VGltZTtcblxuICAgICAgICAgICAgICAgIGN1ckdQb2ludCA9IHVwZGF0ZUdQb2ludDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBmb3IgdHJhY2tpbmcgYW5kIGFkZCB0byB0aGUgdHJhY2tpbmcgbGlzdFxuICAgICAgICAgICAgICAgIGN1ckdQb2ludC5jYXB0dXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGN1ckdQb2ludC5pbnNpZGVFbGVtZW50UHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGN1ckdQb2ludC5pbnNpZGVFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFydFRyYWNraW5nUG9pbnRlciggcG9pbnRzTGlzdCwgY3VyR1BvaW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVudGVyXG4gICAgICAgICAgICBpZiAoIHRyYWNrZXIuZW50ZXJIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIuZW50ZXJIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICBjdXJHUG9pbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggY3VyR1BvaW50LmN1cnJlbnRQb3MsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJzOiAgICAgICAgICAgICB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJDb3VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlRWxlbWVudFByZXNzZWQ6IGN1ckdQb2ludC5pbnNpZGVFbGVtZW50UHJlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkRvd25Bbnk6ICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgIT09IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgY3VyR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXJcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmF0aW5nIERPTSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnQ+fSBnUG9pbnRzXG4gICAgICogICAgICBHZXN0dXJlIHBvaW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJzRXhpdCggdHJhY2tlciwgZXZlbnQsIGdQb2ludHMgKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IFRISVNbIHRyYWNrZXIuaGFzaCBdLFxuICAgICAgICAgICAgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCBnUG9pbnRzWyAwIF0udHlwZSApLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGdQb2ludENvdW50ID0gZ1BvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjdXJHUG9pbnQsXG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQsXG4gICAgICAgICAgICBwcm9wYWdhdGU7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBnUG9pbnRDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgY3VyR1BvaW50ID0gZ1BvaW50c1sgaSBdO1xuICAgICAgICAgICAgdXBkYXRlR1BvaW50ID0gcG9pbnRzTGlzdC5nZXRCeUlkKCBjdXJHUG9pbnQuaWQgKTtcblxuICAgICAgICAgICAgaWYgKCB1cGRhdGVHUG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSB0cmFja2luZyB0aGUgcG9pbnRlci4gSWYgY2FwdHVyZWQgdGhlbiB1cGRhdGUgaXQsIGVsc2Ugc3RvcCB0cmFja2luZyBpdFxuICAgICAgICAgICAgICAgIGlmICggdXBkYXRlR1BvaW50LmNhcHR1cmVkICkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQubGFzdFBvcyA9IHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQubGFzdFRpbWUgPSB1cGRhdGVHUG9pbnQuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zID0gY3VyR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZSA9IGN1ckdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wVHJhY2tpbmdQb2ludGVyKCBwb2ludHNMaXN0LCB1cGRhdGVHUG9pbnQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJHUG9pbnQgPSB1cGRhdGVHUG9pbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4aXRcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5leGl0SGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmV4aXRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICBjdXJHUG9pbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggY3VyR1BvaW50LmN1cnJlbnRQb3MsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJzOiAgICAgICAgICAgICB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJDb3VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlRWxlbWVudFByZXNzZWQ6IHVwZGF0ZUdQb2ludCA/IHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50UHJlc3NlZCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRG93bkFueTogICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyAhPT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICBjdXJHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyXG4gICAgICogICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hdGluZyBET00gZXZlbnQuXG4gICAgICogQHBhcmFtIHtBcnJheS48T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50Pn0gZ1BvaW50c1xuICAgICAqICAgICAgR2VzdHVyZSBwb2ludHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYnV0dG9uQ2hhbmdlZFxuICAgICAqICAgICAgVGhlIGJ1dHRvbiBpbnZvbHZlZCBpbiB0aGUgZXZlbnQ6IC0xOiBub25lLCAwOiBwcmltYXJ5L2xlZnQsIDE6IGF1eC9taWRkbGUsIDI6IHNlY29uZGFyeS9yaWdodCwgMzogWDEvYmFjaywgNDogWDIvZm9yd2FyZCwgNTogcGVuIGVyYXNlci5cbiAgICAgKiAgICAgIE5vdGUgb24gY2hvcmRlZCBidXR0b24gcHJlc3NlcyAoYSBidXR0b24gcHJlc3NlZCB3aGVuIGFub3RoZXIgYnV0dG9uIGlzIGFscmVhZHkgcHJlc3NlZCk6IEluIHRoZSBXM0MgUG9pbnRlciBFdmVudHMgbW9kZWwsXG4gICAgICogICAgICBvbmx5IG9uZSBwb2ludGVyZG93bi9wb2ludGVydXAgZXZlbnQgY29tYm8gaXMgZmlyZWQuIENob3JkZWQgYnV0dG9uIHN0YXRlIGNoYW5nZXMgaW5zdGVhZCBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHBvaW50ZXJzIHNob3VsZCBiZSBjYXB0dXJlZCB0byB0aGUgdHJhY2tlZCBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlcnNEb3duKCB0cmFja2VyLCBldmVudCwgZ1BvaW50cywgYnV0dG9uQ2hhbmdlZCApIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdHJhY2tlci5oYXNoIF0sXG4gICAgICAgICAgICBwcm9wYWdhdGUsXG4gICAgICAgICAgICBwb2ludHNMaXN0ID0gdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoIGdQb2ludHNbIDAgXS50eXBlICksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgZ1BvaW50Q291bnQgPSBnUG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1ckdQb2ludCxcbiAgICAgICAgICAgIHVwZGF0ZUdQb2ludDtcblxuICAgICAgICBpZiAoIHR5cGVvZiBldmVudC5idXR0b25zICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoICQuQnJvd3Nlci52ZW5kb3IgPT09ICQuQlJPV1NFUlMuSUUgJiYgJC5Ccm93c2VyLnZlcnNpb24gPCA5ICkge1xuICAgICAgICAgICAgICAgIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWFyeVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdXhcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zICs9IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kYXJ5XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyArPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFgxIChCYWNrKVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgKz0gODtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBYMiAoRm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zICs9IDE2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlbiBFcmFzZXJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zICs9IDMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCBidXR0b25DaGFuZ2VkID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltYXJ5XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyB8PSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1eFxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgfD0gNDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmRhcnlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIHw9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWDEgKEJhY2spXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyB8PSA4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFgyIChGb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgfD0gMTY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gNSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVuIEVyYXNlclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgfD0gMzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjYXB0dXJlIGFuZCB0cmFjayBwcmltYXJ5IGJ1dHRvbiwgcGVuLCBhbmQgdG91Y2ggY29udGFjdHNcbiAgICAgICAgaWYgKCBidXR0b25DaGFuZ2VkICE9PSAwICkge1xuICAgICAgICAgICAgLy8gQXV4IFByZXNzXG4gICAgICAgICAgICBpZiAoIHRyYWNrZXIubm9uUHJpbWFyeVByZXNzSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLm5vblByaW1hcnlQcmVzc0hhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgIGdQb2ludHNbIDAgXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCBnUG9pbnRzWyAwIF0uY3VycmVudFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246ICAgICAgICAgICAgICAgYnV0dG9uQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgZ1BvaW50c1sgMCBdLnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGdQb2ludENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBjdXJHUG9pbnQgPSBnUG9pbnRzWyBpIF07XG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQgPSBwb2ludHNMaXN0LmdldEJ5SWQoIGN1ckdQb2ludC5pZCApO1xuXG4gICAgICAgICAgICBpZiAoIHVwZGF0ZUdQb2ludCApIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHRyYWNraW5nIHRoZSBwb2ludGVyLi4udXBkYXRlIGl0XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmNhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuY29udGFjdFBvcyA9IGN1ckdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jb250YWN0VGltZSA9IGN1ckdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQubGFzdFBvcyA9IHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0VGltZSA9IHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuY3VycmVudFBvcyA9IGN1ckdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZSA9IGN1ckdQb2ludC5jdXJyZW50VGltZTtcblxuICAgICAgICAgICAgICAgIGN1ckdQb2ludCA9IHVwZGF0ZUdQb2ludDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBmb3IgdHJhY2tpbmcgYW5kIGFkZCB0byB0aGUgdHJhY2tpbmcgbGlzdCAobm8gcG9pbnRlcm92ZXIgb3IgcG9pbnRlcm1vdmUgZXZlbnQgb2NjdXJyZWQgYmVmb3JlIHRoaXMpXG4gICAgICAgICAgICAgICAgY3VyR1BvaW50LmNhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJHUG9pbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN1ckdQb2ludC5pbnNpZGVFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFydFRyYWNraW5nUG9pbnRlciggcG9pbnRzTGlzdCwgY3VyR1BvaW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvaW50c0xpc3QuY29udGFjdHMrKztcbiAgICAgICAgICAgIC8vJC5jb25zb2xlLmxvZygnY29udGFjdHMrKyAnLCBwb2ludHNMaXN0LmNvbnRhY3RzKTtcblxuICAgICAgICAgICAgaWYgKCB0cmFja2VyLmRyYWdIYW5kbGVyIHx8IHRyYWNrZXIuZHJhZ0VuZEhhbmRsZXIgfHwgdHJhY2tlci5waW5jaEhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuZ2VzdHVyZVBvaW50VmVsb2NpdHlUcmFja2VyLmFkZFBvaW50KCB0cmFja2VyLCBjdXJHUG9pbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBwb2ludHNMaXN0LmNvbnRhY3RzID09PSAxICkge1xuICAgICAgICAgICAgICAgIC8vIFByZXNzXG4gICAgICAgICAgICAgICAgaWYgKCB0cmFja2VyLnByZXNzSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5wcmVzc0hhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgIGN1ckdQb2ludC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggY3VyR1BvaW50LmNvbnRhY3RQb3MsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiAgICAgICAgIGN1ckdQb2ludC50eXBlID09PSAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHBvaW50c0xpc3QuY29udGFjdHMgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0cmFja2VyLnBpbmNoSGFuZGxlciAmJiBjdXJHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBmb3IgcGluY2hcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUucGluY2hHUG9pbnRzID0gcG9pbnRzTGlzdC5hc0FycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmxhc3RQaW5jaERpc3QgPSBkZWxlZ2F0ZS5jdXJyZW50UGluY2hEaXN0ID0gZGVsZWdhdGUucGluY2hHUG9pbnRzWyAwIF0uY3VycmVudFBvcy5kaXN0YW5jZVRvKCBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDEgXS5jdXJyZW50UG9zICk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmxhc3RQaW5jaENlbnRlciA9IGRlbGVnYXRlLmN1cnJlbnRQaW5jaENlbnRlciA9IGdldENlbnRlclBvaW50KCBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDAgXS5jdXJyZW50UG9zLCBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDEgXS5jdXJyZW50UG9zICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXJcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmF0aW5nIERPTSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnQ+fSBnUG9pbnRzXG4gICAgICogICAgICBHZXN0dXJlIHBvaW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBidXR0b25DaGFuZ2VkXG4gICAgICogICAgICBUaGUgYnV0dG9uIGludm9sdmVkIGluIHRoZSBldmVudDogLTE6IG5vbmUsIDA6IHByaW1hcnkvbGVmdCwgMTogYXV4L21pZGRsZSwgMjogc2Vjb25kYXJ5L3JpZ2h0LCAzOiBYMS9iYWNrLCA0OiBYMi9mb3J3YXJkLCA1OiBwZW4gZXJhc2VyLlxuICAgICAqICAgICAgTm90ZSBvbiBjaG9yZGVkIGJ1dHRvbiBwcmVzc2VzIChhIGJ1dHRvbiBwcmVzc2VkIHdoZW4gYW5vdGhlciBidXR0b24gaXMgYWxyZWFkeSBwcmVzc2VkKTogSW4gdGhlIFczQyBQb2ludGVyIEV2ZW50cyBtb2RlbCxcbiAgICAgKiAgICAgIG9ubHkgb25lIHBvaW50ZXJkb3duL3BvaW50ZXJ1cCBldmVudCBjb21ibyBpcyBmaXJlZC4gQ2hvcmRlZCBidXR0b24gc3RhdGUgY2hhbmdlcyBpbnN0ZWFkIGZpcmUgcG9pbnRlcm1vdmUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgcG9pbnRlciBjYXB0dXJlIHNob3VsZCBiZSByZWxlYXNlZCBmcm9tIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyc1VwKCB0cmFja2VyLCBldmVudCwgZ1BvaW50cywgYnV0dG9uQ2hhbmdlZCApIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdHJhY2tlci5oYXNoIF0sXG4gICAgICAgICAgICBwb2ludHNMaXN0ID0gdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoIGdQb2ludHNbIDAgXS50eXBlICksXG4gICAgICAgICAgICBwcm9wYWdhdGUsXG4gICAgICAgICAgICBpbnNpZGVFbGVtZW50UmVsZWFzZWQsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnQsXG4gICAgICAgICAgICByZWxlYXNlVGltZSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBnUG9pbnRDb3VudCA9IGdQb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgY3VyR1BvaW50LFxuICAgICAgICAgICAgdXBkYXRlR1BvaW50LFxuICAgICAgICAgICAgcmVsZWFzZUNhcHR1cmUgPSBmYWxzZSxcbiAgICAgICAgICAgIHdhc0NhcHR1cmVkID0gZmFsc2UsXG4gICAgICAgICAgICBxdWljaztcblxuICAgICAgICBpZiAoIHR5cGVvZiBldmVudC5idXR0b25zICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoICQuQnJvd3Nlci52ZW5kb3IgPT09ICQuQlJPV1NFUlMuSUUgJiYgJC5Ccm93c2VyLnZlcnNpb24gPCA5ICkge1xuICAgICAgICAgICAgICAgIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWFyeVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdXhcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIC09IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kYXJ5XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyAtPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFgxIChCYWNrKVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgLT0gODtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBYMiAoRm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIC09IDE2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlbiBFcmFzZXJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIC09IDMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCBidXR0b25DaGFuZ2VkID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltYXJ5XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyBePSB+MTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdXhcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIF49IH40O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlY29uZGFyeVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgXj0gfjI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWDEgKEJhY2spXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyBePSB+ODtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBYMiAoRm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIF49IH4xNjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSA1ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQZW4gRXJhc2VyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyBePSB+MzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjYXB0dXJlIGFuZCB0cmFjayBwcmltYXJ5IGJ1dHRvbiwgcGVuLCBhbmQgdG91Y2ggY29udGFjdHNcbiAgICAgICAgaWYgKCBidXR0b25DaGFuZ2VkICE9PSAwICkge1xuICAgICAgICAgICAgLy8gQXV4IFJlbGVhc2VcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5ub25QcmltYXJ5UmVsZWFzZUhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5ub25QcmltYXJ5UmVsZWFzZUhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICAgZ1BvaW50c1sgMCBdLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCAgZ1BvaW50c1sgMCBdLmN1cnJlbnRQb3MsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiAgICAgICAgICAgICAgICBidXR0b25DaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgIGdQb2ludHNbIDAgXS50eXBlID09PSAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBnUG9pbnRDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgY3VyR1BvaW50ID0gZ1BvaW50c1sgaSBdO1xuICAgICAgICAgICAgdXBkYXRlR1BvaW50ID0gcG9pbnRzTGlzdC5nZXRCeUlkKCBjdXJHUG9pbnQuaWQgKTtcblxuICAgICAgICAgICAgaWYgKCB1cGRhdGVHUG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwb2ludGVyLCBzdG9wIHRyYWNraW5nIGl0IGlmIG5vdCBzdGlsbCBpbiB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoIHVwZGF0ZUdQb2ludC5jYXB0dXJlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmNhcHR1cmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VDYXB0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2FzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQubGFzdFBvcyA9IHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0VGltZSA9IHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuY3VycmVudFBvcyA9IGN1ckdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZSA9IGN1ckdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICBpZiAoICF1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcFRyYWNraW5nUG9pbnRlciggcG9pbnRzTGlzdCwgdXBkYXRlR1BvaW50ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVsZWFzZVBvaW50ID0gdXBkYXRlR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgcmVsZWFzZVRpbWUgPSB1cGRhdGVHUG9pbnQuY3VycmVudFRpbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHdhc0NhcHR1cmVkICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQb2ludGVyIHdhcyBhY3RpdmF0ZWQgaW4gb3VyIGVsZW1lbnQgYnV0IGNvdWxkIGhhdmUgYmVlbiByZW1vdmVkIGluIGFueSBlbGVtZW50IHNpbmNlIGV2ZW50cyBhcmUgY2FwdHVyZWQgdG8gb3VyIGVsZW1lbnRcblxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmNvbnRhY3RzLS07XG4gICAgICAgICAgICAgICAgICAgIC8vJC5jb25zb2xlLmxvZygnY29udGFjdHMtLSAnLCBwb2ludHNMaXN0LmNvbnRhY3RzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIuZHJhZ0hhbmRsZXIgfHwgdHJhY2tlci5kcmFnRW5kSGFuZGxlciB8fCB0cmFja2VyLnBpbmNoSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmdlc3R1cmVQb2ludFZlbG9jaXR5VHJhY2tlci5yZW1vdmVQb2ludCggdHJhY2tlciwgdXBkYXRlR1BvaW50ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBvaW50c0xpc3QuY29udGFjdHMgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2UgKHByZXNzZWQgaW4gb3VyIGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIucmVsZWFzZUhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5yZWxlYXNlSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIHJlbGVhc2VQb2ludCwgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZUVsZW1lbnRQcmVzc2VkOiAgdXBkYXRlR1BvaW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlRWxlbWVudFJlbGVhc2VkOiB1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246ICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEcmFnIEVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0cmFja2VyLmRyYWdFbmRIYW5kbGVyICYmICF1cGRhdGVHUG9pbnQuY3VycmVudFBvcy5lcXVhbHMoIHVwZGF0ZUdQb2ludC5jb250YWN0UG9zICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5kcmFnRW5kSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkOiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuc3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICAgICAgICAgICAgdXBkYXRlR1BvaW50LmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0OiAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsaWNrIC8gRG91YmxlLUNsaWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggdHJhY2tlci5jbGlja0hhbmRsZXIgfHwgdHJhY2tlci5kYmxDbGlja0hhbmRsZXIgKSAmJiB1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWljayA9IHJlbGVhc2VUaW1lIC0gdXBkYXRlR1BvaW50LmNvbnRhY3RUaW1lIDw9IHRyYWNrZXIuY2xpY2tUaW1lVGhyZXNob2xkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jb250YWN0UG9zLmRpc3RhbmNlVG8oIHJlbGVhc2VQb2ludCApIDw9IHRyYWNrZXIuY2xpY2tEaXN0VGhyZXNob2xkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIuY2xpY2tIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmNsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCB1cGRhdGVHUG9pbnQuY3VycmVudFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVpY2s6ICAgICAgICAgICAgICAgIHF1aWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0OiAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG91YmxlLUNsaWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0cmFja2VyLmRibENsaWNrSGFuZGxlciAmJiBxdWljayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5jbGlja3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwb2ludHNMaXN0LmNsaWNrcyA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmxhc3RDbGlja1BvcyA9IHJlbGVhc2VQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGxvb3BmdW5jOnRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuZGJsQ2xpY2tUaW1lT3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5jbGlja3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJhY2tlci5kYmxDbGlja1RpbWVUaHJlc2hvbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGxvb3BmdW5jOmZhbHNlKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggcG9pbnRzTGlzdC5jbGlja3MgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoIGRlbGVnYXRlLmRibENsaWNrVGltZU91dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5jbGlja3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWxlZ2F0ZS5sYXN0Q2xpY2tQb3MuZGlzdGFuY2VUbyggcmVsZWFzZVBvaW50ICkgPD0gdHJhY2tlci5kYmxDbGlja0Rpc3RUaHJlc2hvbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5kYmxDbGlja0hhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgIHVwZGF0ZUdQb2ludC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCB1cGRhdGVHUG9pbnQuY3VycmVudFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdDogICAgICAgICAgICAgICAgZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubGFzdENsaWNrUG9zID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggcG9pbnRzTGlzdC5jb250YWN0cyA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHJhY2tlci5waW5jaEhhbmRsZXIgJiYgdXBkYXRlR1BvaW50LnR5cGUgPT09ICd0b3VjaCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgZm9yIHBpbmNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUucGluY2hHUG9pbnRzID0gcG9pbnRzTGlzdC5hc0FycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubGFzdFBpbmNoRGlzdCA9IGRlbGVnYXRlLmN1cnJlbnRQaW5jaERpc3QgPSBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDAgXS5jdXJyZW50UG9zLmRpc3RhbmNlVG8oIGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMSBdLmN1cnJlbnRQb3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5sYXN0UGluY2hDZW50ZXIgPSBkZWxlZ2F0ZS5jdXJyZW50UGluY2hDZW50ZXIgPSBnZXRDZW50ZXJQb2ludCggZGVsZWdhdGUucGluY2hHUG9pbnRzWyAwIF0uY3VycmVudFBvcywgZGVsZWdhdGUucGluY2hHUG9pbnRzWyAxIF0uY3VycmVudFBvcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9pbnRlciB3YXMgYWN0aXZhdGVkIGluIGFub3RoZXIgZWxlbWVudCBidXQgcmVtb3ZlZCBpbiBvdXIgZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2UgKHByZXNzZWQgaW4gYW5vdGhlciBlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIucmVsZWFzZUhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLnJlbGVhc2VIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgIHVwZGF0ZUdQb2ludC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCByZWxlYXNlUG9pbnQsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlRWxlbWVudFByZXNzZWQ6ICB1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudFByZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZUVsZW1lbnRSZWxlYXNlZDogdXBkYXRlR1BvaW50Lmluc2lkZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWxlYXNlQ2FwdHVyZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgd2hlbiBwb2ludGVyKHMpIGNoYW5nZSBjb29yZGluYXRlcywgYnV0dG9uIHN0YXRlLCBwcmVzc3VyZSwgdGlsdCwgb3IgY29udGFjdCBnZW9tZXRyeSAoZS5nLiB3aWR0aCBhbmQgaGVpZ2h0KVxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyXG4gICAgICogICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hdGluZyBET00gZXZlbnQuXG4gICAgICogQHBhcmFtIHtBcnJheS48T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50Pn0gZ1BvaW50c1xuICAgICAqICAgICAgR2VzdHVyZSBwb2ludHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyc01vdmUoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzICkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0cmFja2VyLmhhc2ggXSxcbiAgICAgICAgICAgIHBvaW50c0xpc3QgPSB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggZ1BvaW50c1sgMCBdLnR5cGUgKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBnUG9pbnRDb3VudCA9IGdQb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgY3VyR1BvaW50LFxuICAgICAgICAgICAgdXBkYXRlR1BvaW50LFxuICAgICAgICAgICAgZ1BvaW50QXJyYXksXG4gICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgIHByb3BhZ2F0ZTtcblxuICAgICAgICBpZiAoIHR5cGVvZiBldmVudC5idXR0b25zICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGdQb2ludENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBjdXJHUG9pbnQgPSBnUG9pbnRzWyBpIF07XG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQgPSBwb2ludHNMaXN0LmdldEJ5SWQoIGN1ckdQb2ludC5pZCApO1xuXG4gICAgICAgICAgICBpZiAoIHVwZGF0ZUdQb2ludCApIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHRyYWNraW5nIHRoZSBwb2ludGVyLi4udXBkYXRlIGl0XG4gICAgICAgICAgICAgICAgaWYgKCBjdXJHUG9pbnQuaGFzT3duUHJvcGVydHkoICdpc1ByaW1hcnknICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5pc1ByaW1hcnkgPSBjdXJHUG9pbnQuaXNQcmltYXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQubGFzdFBvcyA9IHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0VGltZSA9IHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuY3VycmVudFBvcyA9IGN1ckdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZSA9IGN1ckdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBmb3IgdHJhY2tpbmcgYW5kIGFkZCB0byB0aGUgdHJhY2tpbmcgbGlzdCAobm8gcG9pbnRlcm92ZXIgb3IgcG9pbnRlcmRvd24gZXZlbnQgb2NjdXJyZWQgYmVmb3JlIHRoaXMpXG4gICAgICAgICAgICAgICAgY3VyR1BvaW50LmNhcHR1cmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VyR1BvaW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VyR1BvaW50Lmluc2lkZUVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXJ0VHJhY2tpbmdQb2ludGVyKCBwb2ludHNMaXN0LCBjdXJHUG9pbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3AgKG1vdXNlIG9ubHkpXG4gICAgICAgIGlmICggdHJhY2tlci5zdG9wSGFuZGxlciAmJiBnUG9pbnRzWyAwIF0udHlwZSA9PT0gJ21vdXNlJyApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCggdHJhY2tlci5zdG9wVGltZU91dCApO1xuICAgICAgICAgICAgdHJhY2tlci5zdG9wVGltZU91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVBvaW50ZXJTdG9wKCB0cmFja2VyLCBldmVudCwgZ1BvaW50c1sgMCBdLnR5cGUgKTtcbiAgICAgICAgICAgIH0sIHRyYWNrZXIuc3RvcERlbGF5ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHBvaW50c0xpc3QuY29udGFjdHMgPT09IDAgKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIChubyBjb250YWN0czogaG92ZXJpbmcgbW91c2Ugb3Igb3RoZXIgaG92ZXItY2FwYWJsZSBkZXZpY2UpXG4gICAgICAgICAgICBpZiAoIHRyYWNrZXIubW92ZUhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5tb3ZlSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgZ1BvaW50c1sgMCBdLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIGdQb2ludHNbIDAgXS5jdXJyZW50UG9zLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgZ1BvaW50c1sgMCBdLnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCBwb2ludHNMaXN0LmNvbnRhY3RzID09PSAxICkge1xuICAgICAgICAgICAgLy8gTW92ZSAoMSBjb250YWN0KVxuICAgICAgICAgICAgaWYgKCB0cmFja2VyLm1vdmVIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludCA9IHBvaW50c0xpc3QuYXNBcnJheSgpWyAwIF07XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5tb3ZlSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmFnXG4gICAgICAgICAgICBpZiAoIHRyYWNrZXIuZHJhZ0hhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50ID0gcG9pbnRzTGlzdC5hc0FycmF5KClbIDAgXTtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zLm1pbnVzKCB1cGRhdGVHUG9pbnQubGFzdFBvcyApO1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIuZHJhZ0hhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgIHVwZGF0ZUdQb2ludC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCB1cGRhdGVHUG9pbnQuY3VycmVudFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGE6ICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWQ6ICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5zcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogICAgICAgICAgICB1cGRhdGVHUG9pbnQuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiAgICAgICAgIHVwZGF0ZUdQb2ludC50eXBlID09PSAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggcG9pbnRzTGlzdC5jb250YWN0cyA9PT0gMiApIHtcbiAgICAgICAgICAgIC8vIE1vdmUgKDIgY29udGFjdHMsIHVzZSBjZW50ZXIpXG4gICAgICAgICAgICBpZiAoIHRyYWNrZXIubW92ZUhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgZ1BvaW50QXJyYXkgPSBwb2ludHNMaXN0LmFzQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLm1vdmVIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICBnUG9pbnRBcnJheVsgMCBdLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIGdldENlbnRlclBvaW50KCBnUG9pbnRBcnJheVsgMCBdLmN1cnJlbnRQb3MsIGdQb2ludEFycmF5WyAxIF0uY3VycmVudFBvcyApLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgZ1BvaW50QXJyYXlbIDAgXS50eXBlID09PSAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGluY2hcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5waW5jaEhhbmRsZXIgJiYgZ1BvaW50c1sgMCBdLnR5cGUgPT09ICd0b3VjaCcgKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDAgXS5jdXJyZW50UG9zLmRpc3RhbmNlVG8oIGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMSBdLmN1cnJlbnRQb3MgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGRlbHRhICE9IGRlbGVnYXRlLmN1cnJlbnRQaW5jaERpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmxhc3RQaW5jaERpc3QgPSBkZWxlZ2F0ZS5jdXJyZW50UGluY2hEaXN0O1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5jdXJyZW50UGluY2hEaXN0ID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmxhc3RQaW5jaENlbnRlciA9IGRlbGVnYXRlLmN1cnJlbnRQaW5jaENlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuY3VycmVudFBpbmNoQ2VudGVyID0gZ2V0Q2VudGVyUG9pbnQoIGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMCBdLmN1cnJlbnRQb3MsIGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMSBdLmN1cnJlbnRQb3MgKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5waW5jaEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VzdHVyZVBvaW50czogICAgICAgIGRlbGVnYXRlLnBpbmNoR1BvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2VudGVyOiAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIGRlbGVnYXRlLmxhc3RQaW5jaENlbnRlciwgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiAgICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCBkZWxlZ2F0ZS5jdXJyZW50UGluY2hDZW50ZXIsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3REaXN0YW5jZTogICAgICAgICBkZWxlZ2F0ZS5sYXN0UGluY2hEaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAgICAgICAgICAgICBkZWxlZ2F0ZS5jdXJyZW50UGluY2hEaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0OiAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlclxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYXRpbmcgRE9NIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludD59IGdQb2ludHNcbiAgICAgKiAgICAgIEdlc3R1cmUgcG9pbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlcnNDYW5jZWwoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzICkge1xuICAgICAgICB1cGRhdGVQb2ludGVyc1VwKCB0cmFja2VyLCBldmVudCwgZ1BvaW50cywgMCApO1xuICAgICAgICB1cGRhdGVQb2ludGVyc0V4aXQoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJTdG9wKCB0cmFja2VyLCBvcmlnaW5hbE1vdmVFdmVudCwgcG9pbnRlclR5cGUgKSB7XG4gICAgICAgIGlmICggdHJhY2tlci5zdG9wSGFuZGxlciApIHtcbiAgICAgICAgICAgIHRyYWNrZXIuc3RvcEhhbmRsZXIoIHtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgcG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldE1vdXNlUmVsYXRpdmUoIG9yaWdpbmFsTW92ZUV2ZW50LCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgICAgdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoIHBvaW50ZXJUeXBlICkuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgcG9pbnRlclR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIG9yaWdpbmFsTW92ZUV2ZW50LFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFRydWUgaWYgaW5zaWRlIGFuIGlmcmFtZSwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIC8vIEBtZW1iZXIge0Jvb2xlYW59IGlzSW5JZnJhbWVcbiAgICAvLyBAcHJpdmF0ZVxuICAgIC8vIEBpbm5lclxuICAgIHZhciBpc0luSWZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZWxmICE9PSB3aW5kb3cudG9wO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gXG4gICAgLy8gQGZ1bmN0aW9uXG4gICAgLy8gQHByaXZhdGVcbiAgICAvLyBAaW5uZXJcbiAgICAvLyBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdGFyZ2V0IGhhcyBhY2Nlc3MgcmlnaHRzIHRvIGV2ZW50cywgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIGZ1bmN0aW9uIGNhbkFjY2Vzc0V2ZW50cyAodGFyZ2V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgJiYgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxufSAoIE9wZW5TZWFkcmFnb24gKSApO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIENvbnRyb2xcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2Ygc3VwcG9ydGVkIGxvY2F0aW9ucyB3aGVyZSBjb250cm9scyBjYW4gYmUgYW5jaG9yZWQuXG4gKiBUaGUgYW5jaG9yaW5nIGlzIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyLlxuICogQG1lbWJlciBDb250cm9sQW5jaG9yXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQHN0YXRpY1xuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBOT05FXG4gKiBAcHJvcGVydHkge051bWJlcn0gVE9QX0xFRlRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBUT1BfUklHSFRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1RUT01fTEVGVFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPVFRPTV9SSUdIVFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFCU09MVVRFXG4gKi9cbiQuQ29udHJvbEFuY2hvciA9IHtcbiAgICBOT05FOiAwLFxuICAgIFRPUF9MRUZUOiAxLFxuICAgIFRPUF9SSUdIVDogMixcbiAgICBCT1RUT01fUklHSFQ6IDMsXG4gICAgQk9UVE9NX0xFRlQ6IDQsXG4gICAgQUJTT0xVVEU6IDVcbn07XG5cbi8qKlxuICogQGNsYXNzIENvbnRyb2xcbiAqIEBjbGFzc2Rlc2MgQSBDb250cm9sIHJlcHJlc2VudHMgYW55IGludGVyZmFjZSBlbGVtZW50IHdoaWNoIGlzIG1lYW50IHRvIGFsbG93IHRoZSB1c2VyXG4gKiB0byBpbnRlcmFjdCB3aXRoIHRoZSB6b29tYWJsZSBpbnRlcmZhY2UuIEFueSBjb250cm9sIGNhbiBiZSBhbmNob3JlZCB0byBhbnlcbiAqIGVsZW1lbnQuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBjb250cm9sIGVsZW1lbnQgdG8gYmUgYW5jaG9yZWQgaW4gdGhlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0IH0gb3B0aW9ucyAtIEFsbCByZXF1aXJlZCBhbmQgb3B0aW9uYWwgc2V0dGluZ3MgZm9yIGNvbmZpZ3VyaW5nIGEgY29udHJvbCBlbGVtZW50LlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkNvbnRyb2xBbmNob3J9IFtvcHRpb25zLmFuY2hvcj1PcGVuU2VhZHJhZ29uLkNvbnRyb2xBbmNob3IuTk9ORV0gLSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2xcbiAqICByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdHRhY2hUb1ZpZXdlcj10cnVlXSAtIFdoZXRoZXIgdGhlIGNvbnRyb2wgc2hvdWxkIGJlIGFkZGVkIGRpcmVjdGx5IHRvIHRoZSB2aWV3ZXIsIG9yXG4gKiAgZGlyZWN0bHkgdG8gdGhlIGNvbnRhaW5lclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvRmFkZT10cnVlXSAtIFdoZXRoZXIgdGhlIGNvbnRyb2wgc2hvdWxkIGhhdmUgdGhlIGF1dG9mYWRlIGJlaGF2aW9yXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAtIHRoZSBlbGVtZW50IHRvIGNvbnRyb2wgd2lsbCBiZSBhbmNob3JlZCB0b28uXG4gKi9cbiQuQ29udHJvbCA9IGZ1bmN0aW9uICggZWxlbWVudCwgb3B0aW9ucywgY29udGFpbmVyICkge1xuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJylcbiAgICB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcIlBhc3NpbmcgYW4gYW5jaG9yIGRpcmVjdGx5IGludG8gdGhlIE9wZW5TZWFkcmFnb24uQ29udHJvbCBjb25zdHJ1Y3RvciBpcyBkZXByZWNhdGVkOyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBsZWFzZSB1c2UgYW4gb3B0aW9ucyBvYmplY3QgaW5zdGVhZC4gIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiU3VwcG9ydCBmb3IgdGhpcyBkZXByZWNhdGVkIHZhcmlhbnQgaXMgc2NoZWR1bGVkIGZvciByZW1vdmFsIGluIERlY2VtYmVyIDIwMTNcIik7XG4gICAgICAgICBvcHRpb25zID0ge2FuY2hvcjogb3B0aW9uc307XG4gICAgfVxuICAgIG9wdGlvbnMuYXR0YWNoVG9WaWV3ZXIgPSAodHlwZW9mIG9wdGlvbnMuYXR0YWNoVG9WaWV3ZXIgPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBvcHRpb25zLmF0dGFjaFRvVmlld2VyO1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGNvbnRyb2wgc2hvdWxkIGhhdmUgYXV0b2ZhZGUgYmVoYXZpb3IuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0ZhZGVcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Db250cm9sI1xuICAgICAqL1xuICAgIHRoaXMuYXV0b0ZhZGUgPSAodHlwZW9mIG9wdGlvbnMuYXV0b0ZhZGUgPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBvcHRpb25zLmF1dG9GYWRlO1xuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHByb3ZpZGluZyB0aGUgdXNlciBpbnRlcmZhY2Ugd2l0aCBzb21lIHR5cGUgb2YgY29udHJvbCAoZS5nLiBhIHpvb20taW4gYnV0dG9uKS5cbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQ29udHJvbCNcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnQgICAgPSBlbGVtZW50O1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgQ29udHJvbCByZWxhdGl2ZSB0byBpdHMgY29udGFpbmVyLlxuICAgICAqIEBtZW1iZXIge09wZW5TZWFkcmFnb24uQ29udHJvbEFuY2hvcn0gYW5jaG9yXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQ29udHJvbCNcbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvciAgICAgPSBvcHRpb25zLmFuY2hvcjtcbiAgICAvKipcbiAgICAgKiBUaGUgQ29udHJvbCdzIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBjb250YWluZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Db250cm9sI1xuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyICA9IGNvbnRhaW5lcjtcbiAgICAvKipcbiAgICAgKiBBIG5ldXRyYWwgZWxlbWVudCBzdXJyb3VuZGluZyB0aGUgY29udHJvbCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IHdyYXBwZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Db250cm9sI1xuICAgICAqL1xuICAgIGlmICggdGhpcy5hbmNob3IgPT0gJC5Db250cm9sQW5jaG9yLkFCU09MVVRFICkge1xuICAgICAgICB0aGlzLndyYXBwZXIgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSB0eXBlb2YgKCBvcHRpb25zLnRvcCApICA9PSBcIm51bWJlclwiID8gKCBvcHRpb25zLnRvcCArICdweCcgKSA6IG9wdGlvbnMudG9wO1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCAgPSB0eXBlb2YgKCBvcHRpb25zLmxlZnQgKSAgPT0gXCJudW1iZXJcIiA/ICAob3B0aW9ucy5sZWZ0ICsgJ3B4JyApIDogb3B0aW9ucy5sZWZ0O1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gdHlwZW9mICggb3B0aW9ucy5oZWlnaHQgKSAgPT0gXCJudW1iZXJcIiA/ICggb3B0aW9ucy5oZWlnaHQgKyAncHgnICkgOiBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLndpZHRoICA9IHR5cGVvZiAoIG9wdGlvbnMud2lkdGggKSAgPT0gXCJudW1iZXJcIiA/ICggb3B0aW9ucy53aWR0aCArICdweCcgKSA6IG9wdGlvbnMud2lkdGg7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUucGFkZGluZyA9IFwiMHB4XCI7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud3JhcHBlciAgICA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgaWYgKCB0aGlzLmFuY2hvciA9PSAkLkNvbnRyb2xBbmNob3IuTk9ORSApIHtcbiAgICAgICAgICAgIC8vIElFNiBmaXhcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS53aWR0aCA9IHRoaXMud3JhcHBlci5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuXG4gICAgaWYgKG9wdGlvbnMuYXR0YWNoVG9WaWV3ZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5hbmNob3IgPT0gJC5Db250cm9sQW5jaG9yLlRPUF9SSUdIVCB8fFxuICAgICAgICAgICAgIHRoaXMuYW5jaG9yID09ICQuQ29udHJvbEFuY2hvci5CT1RUT01fUklHSFQgKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLFxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy53cmFwcGVyICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoIHRoaXMud3JhcHBlciApO1xuICAgIH1cbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5Db250cm9sLnByb3RvdHlwZSAqL1xuJC5Db250cm9sLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgY29udGFpbmVyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCggdGhpcy53cmFwcGVyICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGNvbnRyb2wgaXMgY3VycmVudGx5IHZpc2libGUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjdXJyZW5seSB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlci5zdHlsZS5kaXNwbGF5ICE9IFwibm9uZVwiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBjb250cm9sLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSAtIHRydWUgdG8gbWFrZSB2aXNpYmxlLCBmYWxzZSB0byBoaWRlLlxuICAgICAqL1xuICAgIHNldFZpc2libGU6IGZ1bmN0aW9uKCB2aXNpYmxlICkge1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgP1xuICAgICAgICAgICAgKCB0aGlzLmFuY2hvciA9PSAkLkNvbnRyb2xBbmNob3IuQUJTT0xVVEUgPyAnYmxvY2snIDogJ2lubGluZS1ibG9jaycgKSA6XG4gICAgICAgICAgICBcIm5vbmVcIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3BhY2l0eSBsZXZlbCBmb3IgdGhlIGNvbnRyb2wuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wYWN0aXkgLSBhIHZhbHVlIGJldHdlZW4gMSBhbmQgMCBpbmNsdXNpdmVseS5cbiAgICAgKi9cbiAgICBzZXRPcGFjaXR5OiBmdW5jdGlvbiggb3BhY2l0eSApIHtcbiAgICAgICAgaWYgKCB0aGlzLmVsZW1lbnRbICQuU0lHTkFMIF0gJiYgJC5Ccm93c2VyLnZlbmRvciA9PSAkLkJST1dTRVJTLklFICkge1xuICAgICAgICAgICAgJC5zZXRFbGVtZW50T3BhY2l0eSggdGhpcy5lbGVtZW50LCBvcGFjaXR5LCB0cnVlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLnNldEVsZW1lbnRPcGFjaXR5KCB0aGlzLndyYXBwZXIsIG9wYWNpdHksIHRydWUgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gQ29udHJvbERvY2tcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG4gICAgLyoqXG4gICAgICogQGNsYXNzIENvbnRyb2xEb2NrXG4gICAgICogQGNsYXNzZGVzYyBQcm92aWRlcyBhIGNvbnRhaW5lciBlbGVtZW50IChhICZsdDtmb3JtJmd0OyBlbGVtZW50KSB3aXRoIHN1cHBvcnQgZm9yIHRoZSBsYXlvdXQgb2YgY29udHJvbCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICovXG4gICAgJC5Db250cm9sRG9jayA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICAgIHZhciBsYXlvdXRzID0gWyAndG9wbGVmdCcsICd0b3ByaWdodCcsICdib3R0b21yaWdodCcsICdib3R0b21sZWZ0J10sXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgICQuZXh0ZW5kKCB0cnVlLCB0aGlzLCB7XG4gICAgICAgICAgICBpZDogJ2NvbnRyb2xkb2NrLScrJC5ub3coKSsnLScrTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjEwMDAwMDApLFxuICAgICAgICAgICAgY29udGFpbmVyOiAkLm1ha2VOZXV0cmFsRWxlbWVudCggJ2RpdicgKSxcbiAgICAgICAgICAgIGNvbnRyb2xzOiBbXVxuICAgICAgICB9LCBvcHRpb25zICk7XG5cbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgZm9ybSdzIHN1Ym1pdDsgb3RoZXJ3aXNlIGJ1dHRvbiBjbGlja3MgYW5kIHJldHVybiBrZXlzXG4gICAgICAgIC8vIGNhbiB0cmlnZ2VyIGl0LlxuICAgICAgICB0aGlzLmNvbnRhaW5lci5vbnN1Ym1pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCB0aGlzLmVsZW1lbnQgKXtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggdGhpcy5lbGVtZW50ICk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuY29udGFpbmVyICk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIGkgPSAwOyBpIDwgbGF5b3V0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgbGF5b3V0ID0gbGF5b3V0c1sgaSBdO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sc1sgbGF5b3V0IF0gPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sc1sgbGF5b3V0IF0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgaWYgKCBsYXlvdXQubWF0Y2goICdsZWZ0JyApICl7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1sgbGF5b3V0IF0uc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBsYXlvdXQubWF0Y2goICdyaWdodCcgKSApe1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbIGxheW91dCBdLnN0eWxlLnJpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGxheW91dC5tYXRjaCggJ3RvcCcgKSApe1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbIGxheW91dCBdLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBsYXlvdXQubWF0Y2goICdib3R0b20nICkgKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzWyBsYXlvdXQgXS5zdHlsZS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLmNvbnRyb2xzLnRvcGxlZnQgKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuY29udHJvbHMudG9wcmlnaHQgKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuY29udHJvbHMuYm90dG9tcmlnaHQgKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuY29udHJvbHMuYm90dG9tbGVmdCApO1xuICAgIH07XG5cbiAgICAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uQ29udHJvbERvY2sucHJvdG90eXBlICovXG4gICAgJC5Db250cm9sRG9jay5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ29udHJvbDogZnVuY3Rpb24gKCBlbGVtZW50LCBjb250cm9sT3B0aW9ucyApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgIHZhciBkaXYgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIGdldENvbnRyb2xJbmRleCggdGhpcywgZWxlbWVudCApID49IDAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgICAgLy8gdGhleSdyZSB0cnlpbmcgdG8gYWRkIGEgZHVwbGljYXRlIGNvbnRyb2xcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICggY29udHJvbE9wdGlvbnMuYW5jaG9yICkge1xuICAgICAgICAgICAgICAgIGNhc2UgJC5Db250cm9sQW5jaG9yLlRPUF9SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5jb250cm9scy50b3ByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdUb3AgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICQuQ29udHJvbEFuY2hvci5CT1RUT01fUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuY29udHJvbHMuYm90dG9tcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nQm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAkLkNvbnRyb2xBbmNob3IuQk9UVE9NX0xFRlQ6XG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuY29udHJvbHMuYm90dG9tbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJC5Db250cm9sQW5jaG9yLlRPUF9MRUZUOlxuICAgICAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmNvbnRyb2xzLnRvcGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdUb3AgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICQuQ29udHJvbEFuY2hvci5BQlNPTFVURTpcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjYXNlICQuQ29udHJvbEFuY2hvci5OT05FOlxuICAgICAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb250cm9scy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyAkLkNvbnRyb2woIGVsZW1lbnQsIGNvbnRyb2xPcHRpb25zLCBkaXYgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uQ29udHJvbERvY2t9IENoYWluYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uICggZWxlbWVudCApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgIHZhciBpID0gZ2V0Q29udHJvbEluZGV4KCB0aGlzLCBlbGVtZW50ICk7XG5cbiAgICAgICAgICAgIGlmICggaSA+PSAwICkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbIGkgXS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLkNvbnRyb2xEb2NrfSBDaGFpbmFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckNvbnRyb2xzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aGlsZSAoIHRoaXMuY29udHJvbHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnBvcCgpLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhcmVDb250cm9sc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gdGhpcy5jb250cm9scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY29udHJvbHNbIGkgXS5pc1Zpc2libGUoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uQ29udHJvbERvY2t9IENoYWluYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldENvbnRyb2xzRW5hYmxlZDogZnVuY3Rpb24oIGVuYWJsZWQgKSB7XG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgZm9yICggaSA9IHRoaXMuY29udHJvbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1sgaSBdLnNldFZpc2libGUoIGVuYWJsZWQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgZnVuY3Rpb24gZ2V0Q29udHJvbEluZGV4KCBkb2NrLCBlbGVtZW50ICkge1xuICAgICAgICB2YXIgY29udHJvbHMgPSBkb2NrLmNvbnRyb2xzLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKCBpID0gY29udHJvbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgICAgICBpZiAoIGNvbnRyb2xzWyBpIF0uZWxlbWVudCA9PSBlbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBQbGFjZW1lbnRcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNiBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oJCkge1xuXG4gICAgLyoqXG4gICAgICogQW4gZW51bWVyYXRpb24gb2YgcG9zaXRpb25zIHRvIGFuY2hvciBhbiBlbGVtZW50LlxuICAgICAqIEBtZW1iZXIgUGxhY2VtZW50XG4gICAgICogQG1lbWJlck9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gQ0VOVEVSXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gVE9QX0xFRlRcbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBUT1BcbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBUT1BfUklHSFRcbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBSSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IEJPVFRPTV9SSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IEJPVFRPTVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IEJPVFRPTV9MRUZUXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gTEVGVFxuICAgICAqL1xuICAgICQuUGxhY2VtZW50ID0gJC5mcmVlemVPYmplY3Qoe1xuICAgICAgICBDRU5URVI6ICAgICAgIDAsXG4gICAgICAgIFRPUF9MRUZUOiAgICAgMSxcbiAgICAgICAgVE9QOiAgICAgICAgICAyLFxuICAgICAgICBUT1BfUklHSFQ6ICAgIDMsXG4gICAgICAgIFJJR0hUOiAgICAgICAgNCxcbiAgICAgICAgQk9UVE9NX1JJR0hUOiA1LFxuICAgICAgICBCT1RUT006ICAgICAgIDYsXG4gICAgICAgIEJPVFRPTV9MRUZUOiAgNyxcbiAgICAgICAgTEVGVDogICAgICAgICA4LFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAwOiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxseUNlbnRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsbHlDZW50ZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxOiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyOiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxseUNlbnRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAzOiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA0OiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsbHlDZW50ZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA1OiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsbHlDZW50ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNCb3R0b206IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA2OiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxseUNlbnRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsbHlDZW50ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNCb3R0b206IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3OiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsbHlDZW50ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNCb3R0b206IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA4OiB7XG4gICAgICAgICAgICAgICAgaXNMZWZ0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsbHlDZW50ZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KE9wZW5TZWFkcmFnb24pKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBWaWV3ZXJcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8vIGRpY3Rpb25hcnkgZnJvbSBoYXNoIHRvIHByaXZhdGUgcHJvcGVydGllc1xudmFyIFRISVMgPSB7fTtcbnZhciBuZXh0SGFzaCA9IDE7XG5cbi8qKlxuICpcbiAqIFRoZSBtYWluIHBvaW50IG9mIGVudHJ5IGludG8gY3JlYXRpbmcgYSB6b29tYWJsZSBpbWFnZSBvbiB0aGUgcGFnZS48YnI+XG4gKiA8YnI+XG4gKiBXZSBoYXZlIHByb3ZpZGVkIGFuIGlkaW9tYXRpYyBqYXZhc2NyaXB0IGNvbnN0cnVjdG9yIHdoaWNoIHRha2VzXG4gKiBhIHNpbmdsZSBvYmplY3QsIGJ1dCBzdGlsbCBzdXBwb3J0IHRoZSBsZWdhY3kgcG9zaXRpb25hbCBhcmd1bWVudHMuPGJyPlxuICogPGJyPlxuICogVGhlIG9wdGlvbnMgYmVsb3cgYXJlIGdpdmVuIGluIG9yZGVyIHRoYXQgdGhleSBhcHBlYXJlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAqIGFzIGFyZ3VtZW50cyBhbmQgd2UgdHJhbnNsYXRlIGEgcG9zaXRpb25hbCBjYWxsIGludG8gYW4gaWRpb21hdGljIGNhbGwuPGJyPlxuICogPGJyPlxuICogVG8gY3JlYXRlIGEgdmlld2VyLCB5b3UgY2FuIHVzZSBlaXRoZXIgb2YgdGhpcyBtZXRob2RzOjxicj5cbiAqIDx1bD5cbiAqIDxsaT48Y29kZT52YXIgdmlld2VyID0gbmV3IE9wZW5TZWFkcmFnb24uVmlld2VyKG9wdGlvbnMpOzwvY29kZT48L2xpPlxuICogPGxpPjxjb2RlPnZhciB2aWV3ZXIgPSBPcGVuU2VhZHJhZ29uKG9wdGlvbnMpOzwvY29kZT48L2xpPlxuICogPC91bD5cbiAqIEBjbGFzcyBWaWV3ZXJcbiAqIEBjbGFzc2Rlc2MgVGhlIG1haW4gT3BlblNlYWRyYWdvbiB2aWV3ZXIgY2xhc3MuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uRXZlbnRTb3VyY2VcbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uQ29udHJvbERvY2tcbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5PcHRpb25zfSBvcHRpb25zIC0gVmlld2VyIG9wdGlvbnMuXG4gKlxuICoqL1xuJC5WaWV3ZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgIHZhciBhcmdzICA9IGFyZ3VtZW50cyxcbiAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICBpO1xuXG5cbiAgICAvL2JhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHBvc2l0aW9uYWwgYXJncyB3aGlsZSBwcmVmZXJpbmcgbW9yZVxuICAgIC8vaWRpb21hdGljIGphdmFzY3JpcHQgb3B0aW9ucyBvYmplY3QgYXMgdGhlIG9ubHkgYXJndW1lbnRcbiAgICBpZiggISQuaXNQbGFpbk9iamVjdCggb3B0aW9ucyApICl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpZDogICAgICAgICAgICAgICAgIGFyZ3NbIDAgXSxcbiAgICAgICAgICAgIHhtbFBhdGg6ICAgICAgICAgICAgYXJncy5sZW5ndGggPiAxID8gYXJnc1sgMSBdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJlZml4VXJsOiAgICAgICAgICBhcmdzLmxlbmd0aCA+IDIgPyBhcmdzWyAyIF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb250cm9sczogICAgICAgICAgIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbIDMgXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG92ZXJsYXlzOiAgICAgICAgICAgYXJncy5sZW5ndGggPiA0ID8gYXJnc1sgNCBdIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9vcHRpb25zLmNvbmZpZyBhbmQgdGhlIGdlbmVyYWwgY29uZmlnIGFyZ3VtZW50IGFyZSBkZXByZWNhdGVkXG4gICAgLy9pbiBmYXZvciBvZiB0aGUgbW9yZSBkaXJlY3Qgc3BlY2lmaWNhdGlvbiBvZiBvcHRpb25hbCBzZXR0aW5nc1xuICAgIC8vYmVpbmcgcGFzcyBkaXJlY3RseSBvbiB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICBpZiAoIG9wdGlvbnMuY29uZmlnICl7XG4gICAgICAgICQuZXh0ZW5kKCB0cnVlLCBvcHRpb25zLCBvcHRpb25zLmNvbmZpZyApO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jb25maWc7XG4gICAgfVxuXG4gICAgLy9QdWJsaWMgcHJvcGVydGllc1xuICAgIC8vQWxsb3cgdGhlIG9wdGlvbnMgb2JqZWN0IHRvIG92ZXJyaWRlIGdsb2JhbCBkZWZhdWx0c1xuICAgICQuZXh0ZW5kKCB0cnVlLCB0aGlzLCB7XG5cbiAgICAgICAgLy9pbnRlcm5hbCBzdGF0ZSBhbmQgZG9tIGlkZW50aWZpZXJzXG4gICAgICAgIGlkOiAgICAgICAgICAgICBvcHRpb25zLmlkLFxuICAgICAgICBoYXNoOiAgICAgICAgICAgb3B0aW9ucy5oYXNoIHx8IG5leHRIYXNoKyssXG5cbiAgICAgICAgLy9kb20gbm9kZXNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGlzIFZpZXdlciBpbnN0YW5jZSwgcGFzc2VkIGluIHdoZW4gdGhlIFZpZXdlciB3YXMgY3JlYXRlZC5cbiAgICAgICAgICogQG1lbWJlciB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXIjXG4gICAgICAgICAqL1xuICAgICAgICBlbGVtZW50OiAgICAgICAgbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgJmx0O2RpdiZndDsgZWxlbWVudCAocHJvdmlkZWQgYnkge0BsaW5rIE9wZW5TZWFkcmFnb24uQ29udHJvbERvY2t9KSwgdGhlIGJhc2UgZWxlbWVudCBvZiB0aGlzIFZpZXdlciBpbnN0YW5jZS48YnI+PGJyPlxuICAgICAgICAgKiBDaGlsZCBlbGVtZW50IG9mIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNlbGVtZW50fS5cbiAgICAgICAgICogQG1lbWJlciB7RWxlbWVudH0gY29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlciNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lcjogICAgICBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSAmbHQ7ZGl2Jmd0OyBlbGVtZW50LCB0aGUgZWxlbWVudCB3aGVyZSB1c2VyLWlucHV0IGV2ZW50cyBhcmUgaGFuZGxlZCBmb3IgcGFubmluZyBhbmQgem9vbWluZy48YnI+PGJyPlxuICAgICAgICAgKiBDaGlsZCBlbGVtZW50IG9mIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjb250YWluZXJ9LFxuICAgICAgICAgKiBwb3NpdGlvbmVkIG9uIHRvcCBvZiB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIja2V5Ym9hcmRDb21tYW5kQXJlYX0uPGJyPjxicj5cbiAgICAgICAgICogVGhlIHBhcmVudCBvZiB7QGxpbmsgT3BlblNlYWRyYWdvbi5EcmF3ZXIjY2FudmFzfSBpbnN0YW5jZXMuXG4gICAgICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGNhbnZhc1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXIjXG4gICAgICAgICAqL1xuICAgICAgICBjYW52YXM6ICAgICAgICAgbnVsbCxcblxuICAgICAgICAvLyBPdmVybGF5cyBsaXN0LiBBbiBvdmVybGF5IGFsbG93cyB0byBhZGQgaHRtbCBvbiB0b3Agb2YgdGhlIHZpZXdlci5cbiAgICAgICAgb3ZlcmxheXM6ICAgICAgICAgICBbXSxcbiAgICAgICAgLy8gQ29udGFpbmVyIGluc2lkZSB0aGUgY2FudmFzIHdoZXJlIG92ZXJsYXlzIGFyZSBkcmF3bi5cbiAgICAgICAgb3ZlcmxheXNDb250YWluZXI6ICBudWxsLFxuXG4gICAgICAgIC8vcHJpdmF0ZSBzdGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHByZXZpb3VzQm9keTogICBbXSxcblxuICAgICAgICAvL1RoaXMgd2FzIG9yaWdpbmFsbHkgaW5pdGlhbGl6ZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGFuZCBzbyBjb3VsZCBuZXZlclxuICAgICAgICAvL2hhdmUgYW55dGhpbmcgaW4gaXQuICBub3cgaXQgY2FuIGJlY2F1c2Ugd2UgYWxsb3cgaXQgdG8gYmUgc3BlY2lmaWVkXG4gICAgICAgIC8vaW4gdGhlIG9wdGlvbnMgYW5kIGlzIG9ubHkgZW1wdHkgYnkgZGVmYXVsdCBpZiBub3Qgc3BlY2lmaWVkLiBBbHNvXG4gICAgICAgIC8vdGhpcyBhcnJheSB3YXMgcmV0dXJuZWQgZnJvbSBnZXRfY29udHJvbHMgd2hpY2ggSSBmaW5kIGNvbmZ1c2luZ1xuICAgICAgICAvL3NpbmNlIHRoaXMgb2JqZWN0IGhhcyBhIGNvbnRyb2xzIHByb3BlcnR5IHdoaWNoIGlzIHRyZWF0ZWQgaW4gb3RoZXJcbiAgICAgICAgLy9mdW5jdGlvbnMgbGlrZSBjbGVhckNvbnRyb2xzLiAgSSdtIHJlbW92aW5nIHRoZSBhY2Nlc3NvcnMuXG4gICAgICAgIGN1c3RvbUNvbnRyb2xzOiBbXSxcblxuICAgICAgICAvL1RoZXNlIGFyZSBvcmlnaW5hbGx5IG5vdCBwYXJ0IG9wdGlvbnMgYnV0IGRlY2xhcmVkIGFzIG1lbWJlcnNcbiAgICAgICAgLy9pbiBpbml0aWFsaXplLiAgSXQncyBzdGlsbCBjb25zaWRlcmVkIGlkaW9tYXRpYyB0byBwdXQgdGhlbSBoZXJlXG4gICAgICAgIHNvdXJjZTogICAgICAgICBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyByZW5kZXJpbmcgb2YgdGlsZXMgaW4gdGhlIHZpZXdlci4gQ3JlYXRlZCBmb3IgZWFjaCBUaWxlU291cmNlIG9wZW5lZC5cbiAgICAgICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5EcmF3ZXJ9IGRyYXdlclxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXIjXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3ZXI6ICAgICAgICAgICAgIG51bGwsXG4gICAgICAgIHdvcmxkOiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgY29vcmRpbmF0ZS1yZWxhdGVkIGZ1bmN0aW9uYWxpdHkgLSB6b29tLCBwYW4sIHJvdGF0aW9uLCBldGMuIENyZWF0ZWQgZm9yIGVhY2ggVGlsZVNvdXJjZSBvcGVuZWQuXG4gICAgICAgICAqIEBtZW1iZXIge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IHZpZXdwb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlciNcbiAgICAgICAgICovXG4gICAgICAgIHZpZXdwb3J0OiAgICAgICBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5OYXZpZ2F0b3J9IG5hdmlnYXRvclxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXIjXG4gICAgICAgICAqL1xuICAgICAgICBuYXZpZ2F0b3I6ICAgICAgbnVsbCxcblxuICAgICAgICAvL0EgY29sbGVjdGlvbiB2aWV3cG9ydCBpcyBhIHNlcGFyYXRlIHZpZXdwb3J0IHVzZWQgdG8gcHJvdmlkZVxuICAgICAgICAvL3NpbXVsdGFuZW91cyByZW5kZXJpbmcgb2Ygc2V0cyBvZiB0aWxlc1xuICAgICAgICBjb2xsZWN0aW9uVmlld3BvcnQ6ICAgICBudWxsLFxuICAgICAgICBjb2xsZWN0aW9uRHJhd2VyOiAgICAgICBudWxsLFxuXG4gICAgICAgIC8vVUkgaW1hZ2UgcmVzb3VyY2VzXG4gICAgICAgIC8vVE9ETzogcmVuYW1lIG5hdkltYWdlcyB0byB1aUltYWdlc1xuICAgICAgICBuYXZJbWFnZXM6ICAgICAgbnVsbCxcblxuICAgICAgICAvL2ludGVyZmFjZSBidXR0b24gY29udHJvbHNcbiAgICAgICAgYnV0dG9uczogICAgICAgIG51bGwsXG5cbiAgICAgICAgLy9UT0RPOiB0aGlzIGlzIGRlZnVuY3Qgc28gc2FmZWx5IHJlbW92ZSBpdFxuICAgICAgICBwcm9maWxlcjogICAgICAgbnVsbFxuXG4gICAgfSwgJC5ERUZBVUxUX1NFVFRJTkdTLCBvcHRpb25zICk7XG5cbiAgICBpZiAoIHR5cGVvZiggdGhpcy5oYXNoKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBoYXNoIG11c3QgYmUgZGVmaW5lZCwgZWl0aGVyIGJ5IHNwZWNpZnlpbmcgb3B0aW9ucy5pZCBvciBvcHRpb25zLmhhc2guXCIpO1xuICAgIH1cbiAgICBpZiAoIHR5cGVvZiggVEhJU1sgdGhpcy5oYXNoIF0gKSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0aHJvdyBhbiBlcnJvciBoZXJlLCBhcyB0aGUgdXNlciBtaWdodCBoYXZlIGRpc2NhcmRlZFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgdmlld2VyIHdpdGggdGhlIHNhbWUgaGFzaCBhbmQgbm93IHdhbnQgdG8gcmVjcmVhdGUgaXQuXG4gICAgICAgICQuY29uc29sZS53YXJuKFwiSGFzaCBcIiArIHRoaXMuaGFzaCArIFwiIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgfVxuXG4gICAgLy9Qcml2YXRlIHN0YXRlIHByb3BlcnRpZXNcbiAgICBUSElTWyB0aGlzLmhhc2ggXSA9IHtcbiAgICAgICAgXCJmc0JvdW5kc0RlbHRhXCI6ICAgICBuZXcgJC5Qb2ludCggMSwgMSApLFxuICAgICAgICBcInByZXZDb250YWluZXJTaXplXCI6IG51bGwsXG4gICAgICAgIFwiYW5pbWF0aW5nXCI6ICAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiZm9yY2VSZWRyYXdcIjogICAgICAgZmFsc2UsXG4gICAgICAgIFwibW91c2VJbnNpZGVcIjogICAgICAgZmFsc2UsXG4gICAgICAgIFwiZ3JvdXBcIjogICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gd2hldGhlciB3ZSBzaG91bGQgYmUgY29udGludW91c2x5IHpvb21pbmdcbiAgICAgICAgXCJ6b29taW5nXCI6ICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgLy8gaG93IG11Y2ggd2Ugc2hvdWxkIGJlIGNvbnRpbnVvdXNseSB6b29taW5nIGJ5XG4gICAgICAgIFwiem9vbUZhY3RvclwiOiAgICAgICAgbnVsbCxcbiAgICAgICAgXCJsYXN0Wm9vbVRpbWVcIjogICAgICBudWxsLFxuICAgICAgICBcImZ1bGxQYWdlXCI6ICAgICAgICAgIGZhbHNlLFxuICAgICAgICBcIm9uZnVsbHNjcmVlbmNoYW5nZVwiOiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuX3NlcXVlbmNlSW5kZXggPSAwO1xuICAgIHRoaXMuX2ZpcnN0T3BlbiA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlUmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkUXVldWUgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRPdmVybGF5cyA9IFtdO1xuXG4gICAgdGhpcy5fbGFzdFNjcm9sbFRpbWUgPSAkLm5vdygpOyAvLyB2YXJpYWJsZSB1c2VkIHRvIGhlbHAgbm9ybWFsaXplIHRoZSBzY3JvbGwgZXZlbnQgc3BlZWQgb2YgZGlmZmVyZW50IGRldmljZXNcblxuICAgIC8vSW5oZXJpdCBzb21lIGJlaGF2aW9ycyBhbmQgcHJvcGVydGllc1xuICAgICQuRXZlbnRTb3VyY2UuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5hZGRIYW5kbGVyKCAnb3Blbi1mYWlsZWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICB2YXIgbXNnID0gJC5nZXRTdHJpbmcoIFwiRXJyb3JzLk9wZW5GYWlsZWRcIiwgZXZlbnQuZXZlbnRTb3VyY2UsIGV2ZW50Lm1lc3NhZ2UpO1xuICAgICAgICBfdGhpcy5fc2hvd01lc3NhZ2UoIG1zZyApO1xuICAgIH0pO1xuXG4gICAgJC5Db250cm9sRG9jay5jYWxsKCB0aGlzLCBvcHRpb25zICk7XG5cbiAgICAvL0RlYWwgd2l0aCB0aWxlIHNvdXJjZXNcbiAgICBpZiAoIHRoaXMueG1sUGF0aCAgKXtcbiAgICAgICAgLy9EZXByZWNhdGVkIG9wdGlvbi4gIE5vdyBpdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSB0aWxlU291cmNlcyBvcHRpb25cbiAgICAgICAgdGhpcy50aWxlU291cmNlcyA9IFsgdGhpcy54bWxQYXRoIF07XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50ICAgICAgICAgICAgICA9IHRoaXMuZWxlbWVudCB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggdGhpcy5pZCApO1xuICAgIHRoaXMuY2FudmFzICAgICAgICAgICAgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuXG4gICAgdGhpcy5jYW52YXMuY2xhc3NOYW1lID0gXCJvcGVuc2VhZHJhZ29uLWNhbnZhc1wiO1xuICAgIChmdW5jdGlvbiggc3R5bGUgKXtcbiAgICAgICAgc3R5bGUud2lkdGggICAgPSBcIjEwMCVcIjtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ICAgPSBcIjEwMCVcIjtcbiAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgc3R5bGUudG9wICAgICAgPSBcIjBweFwiO1xuICAgICAgICBzdHlsZS5sZWZ0ICAgICA9IFwiMHB4XCI7XG4gICAgfSh0aGlzLmNhbnZhcy5zdHlsZSkpO1xuICAgICQuc2V0RWxlbWVudFRvdWNoQWN0aW9uTm9uZSggdGhpcy5jYW52YXMgKTtcbiAgICBpZiAob3B0aW9ucy50YWJJbmRleCAhPT0gXCJcIikge1xuICAgICAgICB0aGlzLmNhbnZhcy50YWJJbmRleCA9IChvcHRpb25zLnRhYkluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy50YWJJbmRleCk7XG4gICAgfVxuXG4gICAgLy90aGUgY29udGFpbmVyIGlzIGNyZWF0ZWQgdGhyb3VnaCBhcHBseWluZyB0aGUgQ29udHJvbERvY2sgY29uc3RydWN0b3IgYWJvdmVcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcIm9wZW5zZWFkcmFnb24tY29udGFpbmVyXCI7XG4gICAgKGZ1bmN0aW9uKCBzdHlsZSApe1xuICAgICAgICBzdHlsZS53aWR0aCAgICAgPSBcIjEwMCVcIjtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ICAgID0gXCIxMDAlXCI7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uICA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgc3R5bGUub3ZlcmZsb3cgID0gXCJoaWRkZW5cIjtcbiAgICAgICAgc3R5bGUubGVmdCAgICAgID0gXCIwcHhcIjtcbiAgICAgICAgc3R5bGUudG9wICAgICAgID0gXCIwcHhcIjtcbiAgICAgICAgc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7ICAvLyBuZWVkZWQgdG8gcHJvdGVjdCBhZ2FpbnN0XG4gICAgfSggdGhpcy5jb250YWluZXIuc3R5bGUgKSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoIHRoaXMuY2FudmFzLCB0aGlzLmNvbnRhaW5lci5maXJzdENoaWxkICk7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLmNvbnRhaW5lciApO1xuXG4gICAgLy9Vc2VkIGZvciB0b2dnbGluZyBiZXR3ZWVuIGZ1bGxzY3JlZW4gYW5kIGRlZmF1bHQgY29udGFpbmVyIHNpemVcbiAgICAvL1RPRE86IHRoZXNlIGNhbiBiZSBjbG9zdXJlIHByaXZhdGUgYW5kIHNoYXJlZCBhY3Jvc3MgVmlld2VyXG4gICAgLy8gICAgICBpbnN0YW5jZXMuXG4gICAgdGhpcy5ib2R5V2lkdGggICAgICA9IGRvY3VtZW50LmJvZHkuc3R5bGUud2lkdGg7XG4gICAgdGhpcy5ib2R5SGVpZ2h0ICAgICA9IGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0O1xuICAgIHRoaXMuYm9keU92ZXJmbG93ICAgPSBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgIHRoaXMuZG9jT3ZlcmZsb3cgICAgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICB0aGlzLmlubmVyVHJhY2tlciA9IG5ldyAkLk1vdXNlVHJhY2tlcih7XG4gICAgICAgIGVsZW1lbnQ6ICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMsXG4gICAgICAgIHN0YXJ0RGlzYWJsZWQ6ICAgICAgICAgICAgdGhpcy5tb3VzZU5hdkVuYWJsZWQgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogICAgICAgdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogICAgICAgdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgIGRibENsaWNrVGltZVRocmVzaG9sZDogICAgdGhpcy5kYmxDbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgIGRibENsaWNrRGlzdFRocmVzaG9sZDogICAgdGhpcy5kYmxDbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgIGtleURvd25IYW5kbGVyOiAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNLZXlEb3duICksXG4gICAgICAgIGtleUhhbmRsZXI6ICAgICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNLZXlQcmVzcyApLFxuICAgICAgICBjbGlja0hhbmRsZXI6ICAgICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzQ2xpY2sgKSxcbiAgICAgICAgZGJsQ2xpY2tIYW5kbGVyOiAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0RibENsaWNrICksXG4gICAgICAgIGRyYWdIYW5kbGVyOiAgICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNEcmFnICksXG4gICAgICAgIGRyYWdFbmRIYW5kbGVyOiAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNEcmFnRW5kICksXG4gICAgICAgIGVudGVySGFuZGxlcjogICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNFbnRlciApLFxuICAgICAgICBleGl0SGFuZGxlcjogICAgICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzRXhpdCApLFxuICAgICAgICBwcmVzc0hhbmRsZXI6ICAgICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzUHJlc3MgKSxcbiAgICAgICAgcmVsZWFzZUhhbmRsZXI6ICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc1JlbGVhc2UgKSxcbiAgICAgICAgbm9uUHJpbWFyeVByZXNzSGFuZGxlcjogICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc05vblByaW1hcnlQcmVzcyApLFxuICAgICAgICBub25QcmltYXJ5UmVsZWFzZUhhbmRsZXI6ICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzTm9uUHJpbWFyeVJlbGVhc2UgKSxcbiAgICAgICAgc2Nyb2xsSGFuZGxlcjogICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc1Njcm9sbCApLFxuICAgICAgICBwaW5jaEhhbmRsZXI6ICAgICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzUGluY2ggKVxuICAgIH0pO1xuXG4gICAgdGhpcy5vdXRlclRyYWNrZXIgPSBuZXcgJC5Nb3VzZVRyYWNrZXIoe1xuICAgICAgICBlbGVtZW50OiAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLFxuICAgICAgICBzdGFydERpc2FibGVkOiAgICAgICAgIHRoaXMubW91c2VOYXZFbmFibGVkID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6ICAgIHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6ICAgIHRoaXMuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICBkYmxDbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuZGJsQ2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICBkYmxDbGlja0Rpc3RUaHJlc2hvbGQ6IHRoaXMuZGJsQ2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICBlbnRlckhhbmRsZXI6ICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ29udGFpbmVyRW50ZXIgKSxcbiAgICAgICAgZXhpdEhhbmRsZXI6ICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNvbnRhaW5lckV4aXQgKVxuICAgIH0pO1xuXG4gICAgaWYoIHRoaXMudG9vbGJhciApe1xuICAgICAgICB0aGlzLnRvb2xiYXIgPSBuZXcgJC5Db250cm9sRG9jayh7IGVsZW1lbnQ6IHRoaXMudG9vbGJhciB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRTdGFuZGFyZENvbnRyb2xzKCk7XG5cbiAgICBUSElTWyB0aGlzLmhhc2ggXS5wcmV2Q29udGFpbmVyU2l6ZSA9IF9nZXRTYWZlRWxlbVNpemUoIHRoaXMuY29udGFpbmVyICk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHdvcmxkXG4gICAgdGhpcy53b3JsZCA9IG5ldyAkLldvcmxkKHtcbiAgICAgICAgdmlld2VyOiB0aGlzXG4gICAgfSk7XG5cbiAgICB0aGlzLndvcmxkLmFkZEhhbmRsZXIoJ2FkZC1pdGVtJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBtYWludGFpbiB0aGUgc291cmNlIHByb3BlcnR5XG4gICAgICAgIF90aGlzLnNvdXJjZSA9IF90aGlzLndvcmxkLmdldEl0ZW1BdCgwKS5zb3VyY2U7XG5cbiAgICAgICAgVEhJU1sgX3RoaXMuaGFzaCBdLmZvcmNlUmVkcmF3ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIV90aGlzLl91cGRhdGVSZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVSZXF1ZXN0SWQgPSBzY2hlZHVsZVVwZGF0ZSggX3RoaXMsIHVwZGF0ZU11bHRpICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMud29ybGQuYWRkSGFuZGxlcigncmVtb3ZlLWl0ZW0nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdlIG1haW50YWluIHRoZSBzb3VyY2UgcHJvcGVydHlcbiAgICAgICAgaWYgKF90aGlzLndvcmxkLmdldEl0ZW1Db3VudCgpKSB7XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2UgPSBfdGhpcy53b3JsZC5nZXRJdGVtQXQoMCkuc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIFRISVNbIF90aGlzLmhhc2ggXS5mb3JjZVJlZHJhdyA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLndvcmxkLmFkZEhhbmRsZXIoJ21ldHJpY3MtY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICBfdGhpcy52aWV3cG9ydC5fc2V0Q29udGVudEJvdW5kcyhfdGhpcy53b3JsZC5nZXRIb21lQm91bmRzKCksIF90aGlzLndvcmxkLmdldENvbnRlbnRGYWN0b3IoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMud29ybGQuYWRkSGFuZGxlcignaXRlbS1pbmRleC1jaGFuZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdlIG1haW50YWluIHRoZSBzb3VyY2UgcHJvcGVydHlcbiAgICAgICAgX3RoaXMuc291cmNlID0gX3RoaXMud29ybGQuZ2V0SXRlbUF0KDApLnNvdXJjZTtcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0aGUgdmlld3BvcnRcbiAgICB0aGlzLnZpZXdwb3J0ID0gbmV3ICQuVmlld3BvcnQoe1xuICAgICAgICBjb250YWluZXJTaXplOiAgICAgIFRISVNbIHRoaXMuaGFzaCBdLnByZXZDb250YWluZXJTaXplLFxuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6ICAgIHRoaXMuc3ByaW5nU3RpZmZuZXNzLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAgICAgIHRoaXMuYW5pbWF0aW9uVGltZSxcbiAgICAgICAgbWluWm9vbUltYWdlUmF0aW86ICB0aGlzLm1pblpvb21JbWFnZVJhdGlvLFxuICAgICAgICBtYXhab29tUGl4ZWxSYXRpbzogIHRoaXMubWF4Wm9vbVBpeGVsUmF0aW8sXG4gICAgICAgIHZpc2liaWxpdHlSYXRpbzogICAgdGhpcy52aXNpYmlsaXR5UmF0aW8sXG4gICAgICAgIHdyYXBIb3Jpem9udGFsOiAgICAgdGhpcy53cmFwSG9yaXpvbnRhbCxcbiAgICAgICAgd3JhcFZlcnRpY2FsOiAgICAgICB0aGlzLndyYXBWZXJ0aWNhbCxcbiAgICAgICAgZGVmYXVsdFpvb21MZXZlbDogICB0aGlzLmRlZmF1bHRab29tTGV2ZWwsXG4gICAgICAgIG1pblpvb21MZXZlbDogICAgICAgdGhpcy5taW5ab29tTGV2ZWwsXG4gICAgICAgIG1heFpvb21MZXZlbDogICAgICAgdGhpcy5tYXhab29tTGV2ZWwsXG4gICAgICAgIHZpZXdlcjogICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgZGVncmVlczogICAgICAgICAgICB0aGlzLmRlZ3JlZXMsXG4gICAgICAgIG5hdmlnYXRvclJvdGF0ZTogICAgdGhpcy5uYXZpZ2F0b3JSb3RhdGUsXG4gICAgICAgIGhvbWVGaWxsc1ZpZXdlcjogICAgdGhpcy5ob21lRmlsbHNWaWV3ZXIsXG4gICAgICAgIG1hcmdpbnM6ICAgICAgICAgICAgdGhpcy52aWV3cG9ydE1hcmdpbnNcbiAgICB9KTtcblxuICAgIHRoaXMudmlld3BvcnQuX3NldENvbnRlbnRCb3VuZHModGhpcy53b3JsZC5nZXRIb21lQm91bmRzKCksIHRoaXMud29ybGQuZ2V0Q29udGVudEZhY3RvcigpKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgaW1hZ2UgbG9hZGVyXG4gICAgdGhpcy5pbWFnZUxvYWRlciA9IG5ldyAkLkltYWdlTG9hZGVyKHtcbiAgICAgICAgam9iTGltaXQ6IHRoaXMuaW1hZ2VMb2FkZXJMaW1pdFxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSB0aWxlIGNhY2hlXG4gICAgdGhpcy50aWxlQ2FjaGUgPSBuZXcgJC5UaWxlQ2FjaGUoe1xuICAgICAgICBtYXhJbWFnZUNhY2hlQ291bnQ6IHRoaXMubWF4SW1hZ2VDYWNoZUNvdW50XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGRyYXdlclxuICAgIHRoaXMuZHJhd2VyID0gbmV3ICQuRHJhd2VyKHtcbiAgICAgICAgdmlld2VyOiAgICAgICAgICAgICB0aGlzLFxuICAgICAgICB2aWV3cG9ydDogICAgICAgICAgIHRoaXMudmlld3BvcnQsXG4gICAgICAgIGVsZW1lbnQ6ICAgICAgICAgICAgdGhpcy5jYW52YXMsXG4gICAgICAgIGRlYnVnR3JpZENvbG9yOiAgICAgdGhpcy5kZWJ1Z0dyaWRDb2xvclxuICAgIH0pO1xuXG4gICAgLy8gT3ZlcmxheSBjb250YWluZXJcbiAgICB0aGlzLm92ZXJsYXlzQ29udGFpbmVyICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiZGl2XCIgKTtcbiAgICB0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCggdGhpcy5vdmVybGF5c0NvbnRhaW5lciApO1xuXG4gICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBhIGRyYXdlciwgc2VlIGlmIGl0IHN1cHBvcnRzIHJvdGF0ZS4gSWYgbm90IHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByb3RhdGUgYnV0dG9uc1xuICAgIGlmICghdGhpcy5kcmF3ZXIuY2FuUm90YXRlKCkpIHtcbiAgICAgICAgLy8gRGlzYWJsZS9yZW1vdmUgdGhlIHJvdGF0ZSBsZWZ0L3JpZ2h0IGJ1dHRvbnMgc2luY2UgdGhleSBhcmVuJ3Qgc3VwcG9ydGVkXG4gICAgICAgIGlmICh0aGlzLnJvdGF0ZUxlZnQpIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLmJ1dHRvbnMuYnV0dG9ucy5pbmRleE9mKHRoaXMucm90YXRlTGVmdCk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuYnV0dG9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnJvdGF0ZUxlZnQuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm90YXRlUmlnaHQpIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLmJ1dHRvbnMuYnV0dG9ucy5pbmRleE9mKHRoaXMucm90YXRlUmlnaHQpO1xuICAgICAgICAgICAgdGhpcy5idXR0b25zLmJ1dHRvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdGhpcy5idXR0b25zLmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5yb3RhdGVSaWdodC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vSW5zdGFudGlhdGUgYSBuYXZpZ2F0b3IgaWYgY29uZmlndXJlZFxuICAgIGlmICggdGhpcy5zaG93TmF2aWdhdG9yKXtcbiAgICAgICAgdGhpcy5uYXZpZ2F0b3IgPSBuZXcgJC5OYXZpZ2F0b3Ioe1xuICAgICAgICAgICAgaWQ6ICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdG9ySWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgdGhpcy5uYXZpZ2F0b3JQb3NpdGlvbixcbiAgICAgICAgICAgIHNpemVSYXRpbzogICAgICAgICB0aGlzLm5hdmlnYXRvclNpemVSYXRpbyxcbiAgICAgICAgICAgIG1haW50YWluU2l6ZVJhdGlvOiB0aGlzLm5hdmlnYXRvck1haW50YWluU2l6ZVJhdGlvLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yVG9wLFxuICAgICAgICAgICAgbGVmdDogICAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yTGVmdCxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICB0aGlzLm5hdmlnYXRvcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiAgICAgICAgICAgIHRoaXMubmF2aWdhdG9ySGVpZ2h0LFxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogICAgICAgIHRoaXMubmF2aWdhdG9yQXV0b1Jlc2l6ZSxcbiAgICAgICAgICAgIGF1dG9GYWRlOiAgICAgICAgICB0aGlzLm5hdmlnYXRvckF1dG9GYWRlLFxuICAgICAgICAgICAgcHJlZml4VXJsOiAgICAgICAgIHRoaXMucHJlZml4VXJsLFxuICAgICAgICAgICAgdmlld2VyOiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBuYXZpZ2F0b3JSb3RhdGU6ICAgdGhpcy5uYXZpZ2F0b3JSb3RhdGUsXG4gICAgICAgICAgICBjcm9zc09yaWdpblBvbGljeTogdGhpcy5jcm9zc09yaWdpblBvbGljeVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXF1ZW5jZSBtb2RlXG4gICAgaWYgKHRoaXMuc2VxdWVuY2VNb2RlKSB7XG4gICAgICAgIHRoaXMuYmluZFNlcXVlbmNlQ29udHJvbHMoKTtcbiAgICB9XG5cbiAgICAvLyBPcGVuIGluaXRpYWwgdGlsZXNvdXJjZXNcbiAgICBpZiAodGhpcy50aWxlU291cmNlcykge1xuICAgICAgICB0aGlzLm9wZW4oIHRoaXMudGlsZVNvdXJjZXMgKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY3VzdG9tIGNvbnRyb2xzXG4gICAgZm9yICggaSA9IDA7IGkgPCB0aGlzLmN1c3RvbUNvbnRyb2xzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICB0aGlzLmFkZENvbnRyb2woXG4gICAgICAgICAgICB0aGlzLmN1c3RvbUNvbnRyb2xzWyBpIF0uaWQsXG4gICAgICAgICAgICB7YW5jaG9yOiB0aGlzLmN1c3RvbUNvbnRyb2xzWyBpIF0uYW5jaG9yfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWwgZmFkZSBvdXRcbiAgICAkLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnVuY3Rpb24oKXtcbiAgICAgICAgYmVnaW5Db250cm9sc0F1dG9IaWRlKCBfdGhpcyApO1xuICAgIH0gKTtcbn07XG5cbiQuZXh0ZW5kKCAkLlZpZXdlci5wcm90b3R5cGUsICQuRXZlbnRTb3VyY2UucHJvdG90eXBlLCAkLkNvbnRyb2xEb2NrLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5wcm90b3R5cGUgKi97XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMud29ybGQuZ2V0SXRlbUNvdW50KCk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBvcGVuRHppOiBmdW5jdGlvbiAoIGR6aSApIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKCBcIltWaWV3ZXIub3BlbkR6aV0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgVmlld2VyLm9wZW4oKSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW4oIGR6aSApO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgb3BlblRpbGVTb3VyY2U6IGZ1bmN0aW9uICggdGlsZVNvdXJjZSApIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKCBcIltWaWV3ZXIub3BlblRpbGVTb3VyY2VdIHRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIFZpZXdlci5vcGVuKCkgaW5zdGVhZC5cIiApO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuKCB0aWxlU291cmNlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGlsZWQgaW1hZ2VzIGludG8gdGhlIHZpZXdlciwgY2xvc2luZyBhbnkgb3RoZXJzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gdGlsZVNvdXJjZXMgLSBUaGlzIGNhbiBiZSBhIFRpbGVkSW1hZ2VcbiAgICAgKiBzcGVjaWZpZXIsIGEgVGlsZVNvdXJjZSBzcGVjaWZpZXIsIG9yIGFuIGFycmF5IG9mIGVpdGhlci4gQSBUaWxlZEltYWdlIHNwZWNpZmllclxuICAgICAqIGlzIHRoZSBzYW1lIGFzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZFRpbGVkSW1hZ2V9LFxuICAgICAqIGV4Y2VwdCBmb3IgdGhlIGluZGV4IHByb3BlcnR5OyBpbWFnZXMgYXJlIGFkZGVkIGluIHNlcXVlbmNlLlxuICAgICAqIEEgVGlsZVNvdXJjZSBzcGVjaWZpZXIgaXMgYW55dGhpbmcgeW91IGNvdWxkIHBhc3MgYXMgdGhlIHRpbGVTb3VyY2UgcHJvcGVydHlcbiAgICAgKiBvZiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNhZGRUaWxlZEltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpvcGVuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50Om9wZW4tZmFpbGVkXG4gICAgICovXG4gICAgb3BlbjogZnVuY3Rpb24gKHRpbGVTb3VyY2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgIGlmICghdGlsZVNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcXVlbmNlTW9kZSAmJiAkLmlzQXJyYXkodGlsZVNvdXJjZXMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VTdHJpcCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RyaXAuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RyaXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRpbGVTb3VyY2VzID0gdGlsZVNvdXJjZXM7XG4gICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZUluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy50aWxlU291cmNlcy5sZW5ndGggLSAxLCB0aGlzLmluaXRpYWxQYWdlKSk7XG4gICAgICAgICAgICBpZiAodGhpcy50aWxlU291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4odGhpcy50aWxlU291cmNlc1t0aGlzLl9zZXF1ZW5jZUluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc2hvd1JlZmVyZW5jZVN0cmlwICl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RyaXAgPSBuZXcgJC5SZWZlcmVuY2VTdHJpcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdHJpcEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgdGhpcy5yZWZlcmVuY2VTdHJpcFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZVJhdGlvOiAgIHRoaXMucmVmZXJlbmNlU3RyaXBTaXplUmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGw6ICAgICAgdGhpcy5yZWZlcmVuY2VTdHJpcFNjcm9sbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogICAgICB0aGlzLnJlZmVyZW5jZVN0cmlwSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICAgICAgIHRoaXMucmVmZXJlbmNlU3RyaXBXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVTb3VyY2VzOiB0aGlzLnRpbGVTb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4VXJsOiAgIHRoaXMucHJlZml4VXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyOiAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXF1ZW5jZUJ1dHRvbnMoIHRoaXMuX3NlcXVlbmNlSW5kZXggKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghJC5pc0FycmF5KHRpbGVTb3VyY2VzKSkge1xuICAgICAgICAgICAgdGlsZVNvdXJjZXMgPSBbdGlsZVNvdXJjZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aWxlU291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29wZW5pbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciBleHBlY3RlZCA9IHRpbGVTb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN1Y2Nlc3NlcyA9IDA7XG4gICAgICAgIHZhciBmYWlsdXJlcyA9IDA7XG4gICAgICAgIHZhciBmYWlsRXZlbnQ7XG5cbiAgICAgICAgdmFyIGNoZWNrQ29tcGxldGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID09PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9maXJzdE9wZW4gfHwgIV90aGlzLnByZXNlcnZlVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0LmdvSG9tZSggdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3BvcnQudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZmlyc3RPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRpbGVTb3VyY2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnRpbGVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS50aWxlU291cmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2xvYmFsIG92ZXJsYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmKCBfdGhpcy5vdmVybGF5cyAmJiAhX3RoaXMucHJlc2VydmVPdmVybGF5cyApe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMub3ZlcmxheXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudE92ZXJsYXlzWyBpIF0gPSBnZXRPdmVybGF5T2JqZWN0KCBfdGhpcywgX3RoaXMub3ZlcmxheXNbIGkgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RyYXdPdmVybGF5cygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgdmlld2VyIGhhcyBvcGVuZWQgYW5kIGxvYWRlZCBvbmUgb3IgbW9yZSBUaWxlU291cmNlcy5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IG9wZW5cbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZVNvdXJjZX0gc291cmNlIC0gVGhlIHRpbGUgc291cmNlIHRoYXQgd2FzIG9wZW5lZC5cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgc291cmNlcz9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggJ29wZW4nLCB7IHNvdXJjZTogc291cmNlIH0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgbG9hZGluZyBhIFRpbGVTb3VyY2UuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBldmVudCBvcGVuLWZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlIC0gSW5mb3JtYXRpb24gYWJvdXQgd2hhdCBmYWlsZWQuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgdGlsZSBzb3VyY2UgdGhhdCBmYWlsZWQuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoICdvcGVuLWZhaWxlZCcsIGZhaWxFdmVudCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZG9PbmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoISQuaXNQbGFpbk9iamVjdChvcHRpb25zKSB8fCAhb3B0aW9ucy50aWxlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNvdXJjZTogb3B0aW9uc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAkLmNvbnNvbGUuZXJyb3IoJ1tWaWV3ZXIub3Blbl0gc2V0dGluZyBpbmRleGVzIGhlcmUgaXMgbm90IHN1cHBvcnRlZDsgdXNlIGFkZFRpbGVkSW1hZ2UgaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uSW1tZWRpYXRlbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sbGVjdGlvbkltbWVkaWF0ZWx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc2VzKys7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBub3cgdGhhdCBvcHRpb25zIGhhcyBvdGhlciB0aGluZ3MgYmVzaWRlcyB0aWxlU291cmNlLCB0aGUgb3ZlcmxheXNcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgcHJvYmFibHkgYmUgYXQgdGhlIG9wdGlvbnMgbGV2ZWwsIG5vdCB0aGUgdGlsZVNvdXJjZSBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aWxlU291cmNlLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy50aWxlU291cmNlLm92ZXJsYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRPdmVybGF5KG9wdGlvbnMudGlsZVNvdXJjZS5vdmVybGF5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxTdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3VjY2VzcyhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wbGV0aW9uKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlcysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFmYWlsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvcihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wbGV0aW9uKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfdGhpcy5hZGRUaWxlZEltYWdlKG9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRpbGVTb3VyY2VzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZVNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRvT25lKHRpbGVTb3VyY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmNsb3NlXG4gICAgICovXG4gICAgY2xvc2U6IGZ1bmN0aW9uICggKSB7XG4gICAgICAgIGlmICggIVRISVNbIHRoaXMuaGFzaCBdICkge1xuICAgICAgICAgICAgLy90aGlzIHZpZXdlciBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZDogcmV0dXJuaW5nIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29wZW5pbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIHRoaXMubmF2aWdhdG9yICkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0b3IuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhIHRoaXMucHJlc2VydmVPdmVybGF5cykge1xuICAgICAgICAgICAgdGhpcy5jbGVhck92ZXJsYXlzKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlzQ29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53b3JsZC5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5pbWFnZUxvYWRlci5jbGVhcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgdmlld2VyIGlzIGNsb3NlZCAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjbG9zZX0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgY2xvc2VcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdjbG9zZScgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBkZXN0cm95IHRoZSB2aWV3ZXIgYW5kIGNsZWFuIHVwIGV2ZXJ5dGhpbmcgY3JlYXRlZCBieSBPcGVuU2VhZHJhZ29uLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiB2YXIgdmlld2VyID0gT3BlblNlYWRyYWdvbih7XG4gICAgICogICBbLi4uXVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy93aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoZSB2aWV3ZXI6XG4gICAgICogdmlld2VyLmRlc3Ryb3koKTtcbiAgICAgKiB2aWV3ZXIgPSBudWxsOyAvL2ltcG9ydGFudFxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oICkge1xuICAgICAgICBpZiAoICFUSElTWyB0aGlzLmhhc2ggXSApIHtcbiAgICAgICAgICAgIC8vdGhpcyB2aWV3ZXIgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQ6IHJldHVybmluZyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgIHRoaXMuY2xlYXJPdmVybGF5cygpO1xuICAgICAgICB0aGlzLm92ZXJsYXlzQ29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAgICAgLy9UT0RPOiBpbXBsZW1lbnQgdGhpcy4uLlxuICAgICAgICAvL3RoaXMudW5iaW5kU2VxdWVuY2VDb250cm9scygpXG4gICAgICAgIC8vdGhpcy51bmJpbmRTdGFuZGFyZENvbnRyb2xzKClcblxuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VTdHJpcCkge1xuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdHJpcC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZVN0cmlwID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5fdXBkYXRlUmVxdWVzdElkICE9PSBudWxsICkge1xuICAgICAgICAgICAgJC5jYW5jZWxBbmltYXRpb25GcmFtZSggdGhpcy5fdXBkYXRlUmVxdWVzdElkICk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLmRyYXdlciApIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsSGFuZGxlcnMoKTtcblxuICAgICAgICAvLyBHbyB0aHJvdWdoIHRvcCBlbGVtZW50IChwYXNzZWQgdG8gdXMpIGFuZCByZW1vdmUgYWxsIGNoaWxkcmVuXG4gICAgICAgIC8vIFVzZSByZW1vdmVDaGlsZCB0byBtYWtlIHN1cmUgaXQgaGFuZGxlcyBTVkcgb3IgYW55IG5vbi1odG1sXG4gICAgICAgIC8vIGFsc28gaXQgcGVyZm9ybXMgYmV0dGVyIC0gaHR0cDovL2pzcGVyZi5jb20vaW5uZXJodG1sLXZzLXJlbW92ZWNoaWxkLzE1XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpe1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgdGhlIG1vdXNlIHRyYWNrZXJzXG4gICAgICAgIGlmICh0aGlzLmlubmVyVHJhY2tlcil7XG4gICAgICAgICAgICB0aGlzLmlubmVyVHJhY2tlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0ZXJUcmFja2VyKXtcbiAgICAgICAgICAgIHRoaXMub3V0ZXJUcmFja2VyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIFRISVNbIHRoaXMuaGFzaCBdO1xuXG4gICAgICAgIC8vIGNsZWFyIGFsbCBvdXIgcmVmZXJlbmNlcyB0byBkb20gb2JqZWN0c1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICAvLyBjbGVhciBvdXIgcmVmZXJlbmNlIHRvIHRoZSBtYWluIGVsZW1lbnQgLSB0aGV5IHdpbGwgbmVlZCB0byBwYXNzIGl0IGluIGFnYWluLCBjcmVhdGluZyBhIG5ldyB2aWV3ZXJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc01vdXNlTmF2RW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm5lclRyYWNrZXIuaXNUcmFja2luZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWQgLSB0cnVlIHRvIGVuYWJsZSwgZmFsc2UgdG8gZGlzYWJsZVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50Om1vdXNlLWVuYWJsZWRcbiAgICAgKi9cbiAgICBzZXRNb3VzZU5hdkVuYWJsZWQ6IGZ1bmN0aW9uKCBlbmFibGVkICl7XG4gICAgICAgIHRoaXMuaW5uZXJUcmFja2VyLnNldFRyYWNraW5nKCBlbmFibGVkICk7XG4gICAgICAgIHRoaXMub3V0ZXJUcmFja2VyLnNldFRyYWNraW5nKCBlbmFibGVkICk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiBtb3VzZS90b3VjaCBuYXZpZ2F0aW9uIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjc2V0TW91c2VOYXZFbmFibGVkfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBtb3VzZS1lbmFibGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCggJ21vdXNlLWVuYWJsZWQnLCB7IGVuYWJsZWQ6IGVuYWJsZWQgfSApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGFyZUNvbnRyb2xzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW5hYmxlZCA9IHRoaXMuY29udHJvbHMubGVuZ3RoLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yKCBpID0gMDsgaSA8IHRoaXMuY29udHJvbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGVuYWJsZWQgPSBlbmFibGVkICYmIHRoaXMuY29udHJvbHNbIGkgXS5pc1Zpc2liaWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuYWJsZWQ7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogU2hvd3Mgb3IgaGlkZXMgdGhlIGNvbnRyb2xzIChlLmcuIHRoZSBkZWZhdWx0IG5hdmlnYXRpb24gYnV0dG9ucykuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUgdG8gc2hvdywgZmFsc2UgdG8gaGlkZS5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpjb250cm9scy1lbmFibGVkXG4gICAgICovXG4gICAgc2V0Q29udHJvbHNFbmFibGVkOiBmdW5jdGlvbiggZW5hYmxlZCApIHtcbiAgICAgICAgaWYoIGVuYWJsZWQgKXtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbHNBdXRvSGlkZSggdGhpcyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmVnaW5Db250cm9sc0F1dG9IaWRlKCB0aGlzICk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIGFyZSBzaG93biBvciBoaWRkZW4gKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjc2V0Q29udHJvbHNFbmFibGVkfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBjb250cm9scy1lbmFibGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCggJ2NvbnRyb2xzLWVuYWJsZWQnLCB7IGVuYWJsZWQ6IGVuYWJsZWQgfSApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Z1bGxQYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBUSElTWyB0aGlzLmhhc2ggXS5mdWxsUGFnZTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgZnVsbCBwYWdlIG1vZGUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsUGFnZVxuICAgICAqICAgICAgSWYgdHJ1ZSwgZW50ZXIgZnVsbCBwYWdlIG1vZGUuICBJZiBmYWxzZSwgZXhpdCBmdWxsIHBhZ2UgbW9kZS5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpwcmUtZnVsbC1wYWdlXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmZ1bGwtcGFnZVxuICAgICAqL1xuICAgIHNldEZ1bGxQYWdlOiBmdW5jdGlvbiggZnVsbFBhZ2UgKSB7XG5cbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgYm9keVN0eWxlID0gYm9keS5zdHlsZSxcbiAgICAgICAgICAgIGRvY1N0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvL2RvbnQgYm90aGVyIG1vZGlmeWluZyB0aGUgRE9NIGlmIHdlIGFyZSBhbHJlYWR5IGluIGZ1bGwgcGFnZSBtb2RlLlxuICAgICAgICBpZiAoIGZ1bGxQYWdlID09IHRoaXMuaXNGdWxsUGFnZSgpICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnVsbFBhZ2VFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBmdWxsUGFnZTogZnVsbFBhZ2UsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIgaXMgYWJvdXQgdG8gY2hhbmdlIHRvL2Zyb20gZnVsbC1wYWdlIG1vZGUgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjc2V0RnVsbFBhZ2V9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IHByZS1mdWxsLXBhZ2VcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGZ1bGxQYWdlIC0gVHJ1ZSBpZiBlbnRlcmluZyBmdWxsLXBhZ2UgbW9kZSwgZmFsc2UgaWYgZXhpdGluZyBmdWxsLXBhZ2UgbW9kZS5cbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBwcmV2ZW50RGVmYXVsdEFjdGlvbiAtIFNldCB0byB0cnVlIHRvIHByZXZlbnQgZnVsbC1wYWdlIG1vZGUgY2hhbmdlLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAncHJlLWZ1bGwtcGFnZScsIGZ1bGxQYWdlRXZlbnRBcmdzICk7XG4gICAgICAgIGlmICggZnVsbFBhZ2VFdmVudEFyZ3MucHJldmVudERlZmF1bHRBY3Rpb24gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZnVsbFBhZ2UgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFNpemUgPSAkLmdldEVsZW1lbnRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgICAgICAgICAgIHRoaXMucGFnZVNjcm9sbCA9ICQuZ2V0UGFnZVNjcm9sbCgpO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRNYXJnaW4gPSB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbiA9IFwiMFwiO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50UGFkZGluZyA9IHRoaXMuZWxlbWVudC5zdHlsZS5wYWRkaW5nO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjBcIjtcblxuICAgICAgICAgICAgdGhpcy5ib2R5TWFyZ2luID0gYm9keVN0eWxlLm1hcmdpbjtcbiAgICAgICAgICAgIHRoaXMuZG9jTWFyZ2luID0gZG9jU3R5bGUubWFyZ2luO1xuICAgICAgICAgICAgYm9keVN0eWxlLm1hcmdpbiA9IFwiMFwiO1xuICAgICAgICAgICAgZG9jU3R5bGUubWFyZ2luID0gXCIwXCI7XG5cbiAgICAgICAgICAgIHRoaXMuYm9keVBhZGRpbmcgPSBib2R5U3R5bGUucGFkZGluZztcbiAgICAgICAgICAgIHRoaXMuZG9jUGFkZGluZyA9IGRvY1N0eWxlLnBhZGRpbmc7XG4gICAgICAgICAgICBib2R5U3R5bGUucGFkZGluZyA9IFwiMFwiO1xuICAgICAgICAgICAgZG9jU3R5bGUucGFkZGluZyA9IFwiMFwiO1xuXG4gICAgICAgICAgICB0aGlzLmJvZHlXaWR0aCA9IGJvZHlTdHlsZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZG9jV2lkdGggPSBkb2NTdHlsZS53aWR0aDtcbiAgICAgICAgICAgIGJvZHlTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgZG9jU3R5bGUud2lkdGggPSBcIjEwMCVcIjtcblxuICAgICAgICAgICAgdGhpcy5ib2R5SGVpZ2h0ID0gYm9keVN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZG9jSGVpZ2h0ID0gZG9jU3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgYm9keVN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgZG9jU3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG5cbiAgICAgICAgICAgIC8vd2hlbiBlbnRlcmluZyBmdWxsIHNjcmVlbiBvbiB0aGUgaXBhZCBpdCB3YXNudCBzdWZmaWNpZW50IHRvIGxlYXZlXG4gICAgICAgICAgICAvL3RoZSBib2R5IGludGFjdCBhcyBvbmx5IG9ubHkgdGhlIHRvcCBoYWxmIG9mIHRoZSBzY3JlZW4gd291bGRcbiAgICAgICAgICAgIC8vcmVzcG9uZCB0byB0b3VjaCBldmVudHMgb24gdGhlIGNhbnZhcywgd2hpbGUgdGhlIGJvdHRvbSBoYWxmIHRyZWF0ZWRcbiAgICAgICAgICAgIC8vdGhlbSBhcyB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IGJvZHkuICBUaHVzIHdlIHJlbW92ZSBhbmQgc3RvcmVcbiAgICAgICAgICAgIC8vdGhlIGJvZGllcyBlbGVtZW50cyBhbmQgcmVwbGFjZSB0aGVtIHdoZW4gd2UgbGVhdmUgZnVsbCBzY3JlZW4uXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzQm9keSA9IFtdO1xuICAgICAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ucHJldkVsZW1lbnRQYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLnByZXZOZXh0U2libGluZyA9IHRoaXMuZWxlbWVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLnByZXZFbGVtZW50V2lkdGggPSB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5wcmV2RWxlbWVudEhlaWdodCA9IHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICBub2RlcyA9IGJvZHkuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5vZGVzOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0JvZHkucHVzaCggYm9keS5jaGlsZE5vZGVzWyAwIF0gKTtcbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKCBib2R5LmNoaWxkTm9kZXNbIDAgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0lmIHdlJ3ZlIGdvdCBhIHRvb2xiYXIsIHdlIG5lZWQgdG8gZW5hYmxlIHRoZSB1c2VyIHRvIHVzZSBjc3MgdG9cbiAgICAgICAgICAgIC8vcHJlc2VydmUgaXQgaW4gZnVsbHBhZ2UgbW9kZVxuICAgICAgICAgICAgaWYgKCB0aGlzLnRvb2xiYXIgJiYgdGhpcy50b29sYmFyLmVsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgLy9zYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc28gd2UgY2FuIHB1dCBpdCBiYWNrXG4gICAgICAgICAgICAgICAgLy9pbiB0aGUgbG9uZyBydW4gd2UgbmVlZCBhIGJldHRlciBzdHJhdGVneVxuICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci5wYXJlbnROb2RlID0gdGhpcy50b29sYmFyLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIubmV4dFNpYmxpbmcgPSB0aGlzLnRvb2xiYXIuZWxlbWVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKCB0aGlzLnRvb2xiYXIuZWxlbWVudCApO1xuXG4gICAgICAgICAgICAgICAgLy9NYWtlIHN1cmUgdGhlIHVzZXIgaGFzIHNvbWUgYWJpbGl0eSB0byBzdHlsZSB0aGUgdG9vbGJhciBiYXNlZFxuICAgICAgICAgICAgICAgIC8vb24gdGhlIG1vZGVcbiAgICAgICAgICAgICAgICAkLmFkZENsYXNzKCB0aGlzLnRvb2xiYXIuZWxlbWVudCwgJ2Z1bGxwYWdlJyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkLmFkZENsYXNzKCB0aGlzLmVsZW1lbnQsICdmdWxscGFnZScgKTtcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJC5nZXRXaW5kb3dTaXplKCkueSArICdweCc7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAkLmdldFdpbmRvd1NpemUoKS54ICsgJ3B4JztcblxuICAgICAgICAgICAgaWYgKCB0aGlzLnRvb2xiYXIgJiYgdGhpcy50b29sYmFyLmVsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChcbiAgICAgICAgICAgICAgICAgICAgJC5nZXRFbGVtZW50U2l6ZSggdGhpcy5lbGVtZW50ICkueSAtICQuZ2V0RWxlbWVudFNpemUoIHRoaXMudG9vbGJhci5lbGVtZW50ICkueVxuICAgICAgICAgICAgICAgICkgKyAncHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5mdWxsUGFnZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIG1vdXNlIHdpbGwgYmUgaW5zaWRlIGNvbnRhaW5lciBub3dcbiAgICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ29udGFpbmVyRW50ZXIgKSgge30gKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luID0gdGhpcy5lbGVtZW50TWFyZ2luO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBhZGRpbmcgPSB0aGlzLmVsZW1lbnRQYWRkaW5nO1xuXG4gICAgICAgICAgICBib2R5U3R5bGUubWFyZ2luID0gdGhpcy5ib2R5TWFyZ2luO1xuICAgICAgICAgICAgZG9jU3R5bGUubWFyZ2luID0gdGhpcy5kb2NNYXJnaW47XG5cbiAgICAgICAgICAgIGJvZHlTdHlsZS5wYWRkaW5nID0gdGhpcy5ib2R5UGFkZGluZztcbiAgICAgICAgICAgIGRvY1N0eWxlLnBhZGRpbmcgPSB0aGlzLmRvY1BhZGRpbmc7XG5cbiAgICAgICAgICAgIGJvZHlTdHlsZS53aWR0aCA9IHRoaXMuYm9keVdpZHRoO1xuICAgICAgICAgICAgZG9jU3R5bGUud2lkdGggPSB0aGlzLmRvY1dpZHRoO1xuXG4gICAgICAgICAgICBib2R5U3R5bGUuaGVpZ2h0ID0gdGhpcy5ib2R5SGVpZ2h0O1xuICAgICAgICAgICAgZG9jU3R5bGUuaGVpZ2h0ID0gdGhpcy5kb2NIZWlnaHQ7XG5cbiAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuICAgICAgICAgICAgbm9kZXMgPSB0aGlzLnByZXZpb3VzQm9keS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5vZGVzOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZCggdGhpcy5wcmV2aW91c0JvZHkuc2hpZnQoKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkLnJlbW92ZUNsYXNzKCB0aGlzLmVsZW1lbnQsICdmdWxscGFnZScgKTtcbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLnByZXZFbGVtZW50UGFyZW50Lmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ucHJldk5leHRTaWJsaW5nXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvL0lmIHdlJ3ZlIGdvdCBhIHRvb2xiYXIsIHdlIG5lZWQgdG8gZW5hYmxlIHRoZSB1c2VyIHRvIHVzZSBjc3MgdG9cbiAgICAgICAgICAgIC8vcmVzZXQgaXQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG4gICAgICAgICAgICBpZiAoIHRoaXMudG9vbGJhciAmJiB0aGlzLnRvb2xiYXIuZWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKCB0aGlzLnRvb2xiYXIuZWxlbWVudCApO1xuXG4gICAgICAgICAgICAgICAgLy9NYWtlIHN1cmUgdGhlIHVzZXIgaGFzIHNvbWUgYWJpbGl0eSB0byBzdHlsZSB0aGUgdG9vbGJhciBiYXNlZFxuICAgICAgICAgICAgICAgIC8vb24gdGhlIG1vZGVcbiAgICAgICAgICAgICAgICAkLnJlbW92ZUNsYXNzKCB0aGlzLnRvb2xiYXIuZWxlbWVudCwgJ2Z1bGxwYWdlJyApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy50b29sYmFyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sYmFyLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50b29sYmFyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudG9vbGJhci5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gVEhJU1sgdGhpcy5oYXNoIF0ucHJldkVsZW1lbnRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBUSElTWyB0aGlzLmhhc2ggXS5wcmV2RWxlbWVudEhlaWdodDtcblxuICAgICAgICAgICAgLy8gQWZ0ZXIgZXhpdGluZyBmdWxsUGFnZSBvciBmdWxsU2NyZWVuLCBpdCBjYW4gdGFrZSBzb21lIHRpbWVcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgYnJvd3NlciBjYW4gYWN0dWFsbHkgc2V0IHRoZSBzY3JvbGwuXG4gICAgICAgICAgICB2YXIgcmVzdG9yZVNjcm9sbENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIHJlc3RvcmVTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkLnNldFBhZ2VTY3JvbGwoIF90aGlzLnBhZ2VTY3JvbGwgKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVNjcm9sbCA9ICQuZ2V0UGFnZVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIHJlc3RvcmVTY3JvbGxDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgaWYgKCByZXN0b3JlU2Nyb2xsQ291bnRlciA8IDEwICYmXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VTY3JvbGwueCAhPT0gX3RoaXMucGFnZVNjcm9sbC54IHx8XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VTY3JvbGwueSAhPT0gX3RoaXMucGFnZVNjcm9sbC55ICkge1xuICAgICAgICAgICAgICAgICAgICAkLnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVzdG9yZVNjcm9sbCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkLnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVzdG9yZVNjcm9sbCApO1xuXG4gICAgICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5mdWxsUGFnZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBtb3VzZSB3aWxsIGxpa2VseSBiZSBvdXRzaWRlIG5vd1xuICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25Db250YWluZXJFeGl0ICkoIHsgfSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMubmF2aWdhdG9yICYmIHRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRvci51cGRhdGUoIHRoaXMudmlld3BvcnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgdmlld2VyIGhhcyBjaGFuZ2VkIHRvL2Zyb20gZnVsbC1wYWdlIG1vZGUgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjc2V0RnVsbFBhZ2V9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGZ1bGwtcGFnZVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZnVsbFBhZ2UgLSBUcnVlIGlmIGNoYW5nZWQgdG8gZnVsbC1wYWdlIG1vZGUsIGZhbHNlIGlmIGV4aXRlZCBmdWxsLXBhZ2UgbW9kZS5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAnZnVsbC1wYWdlJywgeyBmdWxsUGFnZTogZnVsbFBhZ2UgfSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgZnVsbCBzY3JlZW4gbW9kZSBpZiBzdXBwb3J0ZWQuIFRvZ2dsZSBmdWxsIHBhZ2UgbW9kZSBvdGhlcndpc2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsU2NyZWVuXG4gICAgICogICAgICBJZiB0cnVlLCBlbnRlciBmdWxsIHNjcmVlbiBtb2RlLiAgSWYgZmFsc2UsIGV4aXQgZnVsbCBzY3JlZW4gbW9kZS5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpwcmUtZnVsbC1zY3JlZW5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6ZnVsbC1zY3JlZW5cbiAgICAgKi9cbiAgICBzZXRGdWxsU2NyZWVuOiBmdW5jdGlvbiggZnVsbFNjcmVlbiApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoICEkLnN1cHBvcnRzRnVsbFNjcmVlbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEZ1bGxQYWdlKCBmdWxsU2NyZWVuICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICQuaXNGdWxsU2NyZWVuKCkgPT09IGZ1bGxTY3JlZW4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmdWxsU2NyZWVFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBmdWxsU2NyZWVuOiBmdWxsU2NyZWVuLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgdmlld2VyIGlzIGFib3V0IHRvIGNoYW5nZSB0by9mcm9tIGZ1bGwtc2NyZWVuIG1vZGUgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjc2V0RnVsbFNjcmVlbn0pLlxuICAgICAgICAgKiBOb3RlOiB0aGUgcHJlLWZ1bGwtc2NyZWVuIGV2ZW50IGlzIG5vdCByYWlzZWQgd2hlbiB0aGUgdXNlciBpcyBleGl0aW5nXG4gICAgICAgICAqIGZ1bGwtc2NyZWVuIG1vZGUgYnkgcHJlc3NpbmcgdGhlIEVzYyBrZXkuIEluIHRoYXQgY2FzZSwgY29uc2lkZXIgdXNpbmdcbiAgICAgICAgICogdGhlIGZ1bGwtc2NyZWVuLCBwcmUtZnVsbC1wYWdlIG9yIGZ1bGwtcGFnZSBldmVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBwcmUtZnVsbC1zY3JlZW5cbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGZ1bGxTY3JlZW4gLSBUcnVlIGlmIGVudGVyaW5nIGZ1bGwtc2NyZWVuIG1vZGUsIGZhbHNlIGlmIGV4aXRpbmcgZnVsbC1zY3JlZW4gbW9kZS5cbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBwcmV2ZW50RGVmYXVsdEFjdGlvbiAtIFNldCB0byB0cnVlIHRvIHByZXZlbnQgZnVsbC1zY3JlZW4gbW9kZSBjaGFuZ2UuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdwcmUtZnVsbC1zY3JlZW4nLCBmdWxsU2NyZWVFdmVudEFyZ3MgKTtcbiAgICAgICAgaWYgKCBmdWxsU2NyZWVFdmVudEFyZ3MucHJldmVudERlZmF1bHRBY3Rpb24gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZnVsbFNjcmVlbiApIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRGdWxsUGFnZSggdHJ1ZSApO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZ1bGwgcGFnZSBtb2RlIGlzIG5vdCBhY3R1YWxseSBlbnRlcmVkLCB3ZSBuZWVkIHRvIHByZXZlbnRcbiAgICAgICAgICAgIC8vIHRoZSBmdWxsIHNjcmVlbiBtb2RlLlxuICAgICAgICAgICAgaWYgKCAhdGhpcy5pc0Z1bGxQYWdlKCkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZnVsbFBhZ2VTdHlsZVdpZHRoID0gdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5mdWxsUGFnZVN0eWxlSGVpZ2h0ID0gdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICAgICAgICAgIHZhciBvbkZ1bGxTY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGdWxsU2NyZWVuID0gJC5pc0Z1bGxTY3JlZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoICFpc0Z1bGxTY3JlZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoIGRvY3VtZW50LCAkLmZ1bGxTY3JlZW5FdmVudE5hbWUsIG9uRnVsbFNjcmVlbkNoYW5nZSApO1xuICAgICAgICAgICAgICAgICAgICAkLnJlbW92ZUV2ZW50KCBkb2N1bWVudCwgJC5mdWxsU2NyZWVuRXJyb3JFdmVudE5hbWUsIG9uRnVsbFNjcmVlbkNoYW5nZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEZ1bGxQYWdlKCBmYWxzZSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIF90aGlzLmlzRnVsbFBhZ2UoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBfdGhpcy5mdWxsUGFnZVN0eWxlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IF90aGlzLmZ1bGxQYWdlU3R5bGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBfdGhpcy5uYXZpZ2F0b3IgJiYgX3RoaXMudmlld3BvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdmlnYXRvci51cGRhdGUoIF90aGlzLnZpZXdwb3J0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIgaGFzIGNoYW5nZWQgdG8vZnJvbSBmdWxsLXNjcmVlbiBtb2RlIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI3NldEZ1bGxTY3JlZW59KS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBmdWxsLXNjcmVlblxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmdWxsU2NyZWVuIC0gVHJ1ZSBpZiBjaGFuZ2VkIHRvIGZ1bGwtc2NyZWVuIG1vZGUsIGZhbHNlIGlmIGV4aXRlZCBmdWxsLXNjcmVlbiBtb2RlLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCAnZnVsbC1zY3JlZW4nLCB7IGZ1bGxTY3JlZW46IGlzRnVsbFNjcmVlbiB9ICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJC5hZGRFdmVudCggZG9jdW1lbnQsICQuZnVsbFNjcmVlbkV2ZW50TmFtZSwgb25GdWxsU2NyZWVuQ2hhbmdlICk7XG4gICAgICAgICAgICAkLmFkZEV2ZW50KCBkb2N1bWVudCwgJC5mdWxsU2NyZWVuRXJyb3JFdmVudE5hbWUsIG9uRnVsbFNjcmVlbkNoYW5nZSApO1xuXG4gICAgICAgICAgICAkLnJlcXVlc3RGdWxsU2NyZWVuKCBkb2N1bWVudC5ib2R5ICk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuZXhpdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgIT0gXCJoaWRkZW5cIjtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGVcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDp2aXNpYmxlXG4gICAgICovXG4gICAgc2V0VmlzaWJsZTogZnVuY3Rpb24oIHZpc2libGUgKXtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IHZpc2libGUgPyBcIlwiIDogXCJoaWRkZW5cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIgaXMgc2hvd24gb3IgaGlkZGVuIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI3NldFZpc2libGV9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IHZpc2libGVcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHZpc2libGVcbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAndmlzaWJsZScsIHsgdmlzaWJsZTogdmlzaWJsZSB9ICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0aWxlZCBpbWFnZSB0byB0aGUgdmlld2VyLlxuICAgICAqIG9wdGlvbnMudGlsZVNvdXJjZSBjYW4gYmUgYW55dGhpbmcgdGhhdCB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjb3Blbn1cbiAgICAgKiAgc3VwcG9ydHMgZXhjZXB0IGFycmF5cyBvZiBpbWFnZXMuXG4gICAgICogTm90ZSB0aGF0IHlvdSBjYW4gc3BlY2lmeSBvcHRpb25zLndpZHRoIG9yIG9wdGlvbnMuaGVpZ2h0LCBidXQgbm90IGJvdGguXG4gICAgICogVGhlIG90aGVyIGRpbWVuc2lvbiB3aWxsIGJlIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBpdGVtJ3MgYXNwZWN0IHJhdGlvLlxuICAgICAqIElmIGNvbGxlY3Rpb25Nb2RlIGlzIG9uIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30pLCB0aGUgbmV3IGltYWdlIGlzXG4gICAgICogYXV0b21hdGljYWxseSBhcnJhbmdlZCB3aXRoIHRoZSBvdGhlcnMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IG9wdGlvbnMudGlsZVNvdXJjZSAtIFRoZSBUaWxlU291cmNlIHNwZWNpZmllci5cbiAgICAgKiBBIFN0cmluZyBpbXBsaWVzIGEgdXJsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB0aWxlU291cmNlIGltcGxlbWVudGF0aW9uXG4gICAgICogICAgICBiYXNlZCBvbiB0aGUgZmlsZSBleHRlbnNpb24gb2YgdXJsLiBKU09OUCBpcyBpbXBsaWVkIGJ5ICouanMsXG4gICAgICogICAgICBvdGhlcndpc2UgdGhlIHVybCBpcyByZXRyaWV2ZWQgYXMgdGV4dCBhbmQgdGhlIHJlc3VsdGluZyB0ZXh0IGlzXG4gICAgICogICAgICBpbnRyb3NwZWN0ZWQgdG8gZGV0ZXJtaW5lIGlmIGl0cyBqc29uLCB4bWwsIG9yIHRleHQgYW5kIHBhcnNlZC5cbiAgICAgKiBBbiBPYmplY3QgaW1wbGllcyBhbiBpbmxpbmUgY29uZmlndXJhdGlvbiB3aGljaCBoYXMgYSBzaW5nbGVcbiAgICAgKiAgICAgIHByb3BlcnR5IHN1ZmZpY2llbnQgZm9yIGJlaW5nIGFibGUgdG8gZGV0ZXJtaW5lIHRpbGVTb3VyY2VcbiAgICAgKiAgICAgIGltcGxlbWVudGF0aW9uLiBJZiB0aGUgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHdoaWNoIGlzIGEgZnVuY3Rpb25cbiAgICAgKiAgICAgIG5hbWVkICdnZXRUaWxlVXJsJywgaXQgaXMgdHJlYXRlZCBhcyBhIGN1c3RvbSBUaWxlU291cmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbmRleF0gVGhlIGluZGV4IG9mIHRoZSBpdGVtLiBBZGRlZCBvbiB0b3Agb2ZcbiAgICAgKiBhbGwgb3RoZXIgaXRlbXMgaWYgbm90IHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlcGxhY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBpdGVtIGF0IG9wdGlvbnMuaW5kZXggd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYW5kIHRoZSBuZXcgaXRlbSBpcyBhZGRlZCBpbiBpdHMgcGxhY2UuIG9wdGlvbnMudGlsZVNvdXJjZSB3aWxsIGJlXG4gICAgICogaW50ZXJwcmV0ZWQgYW5kIGZldGNoZWQgaWYgbmVjZXNzYXJ5IGJlZm9yZSB0aGUgb2xkIGl0ZW0gaXMgcmVtb3ZlZCB0byBhdm9pZCBsZWF2aW5nXG4gICAgICogYSBnYXAgaW4gdGhlIHdvcmxkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy54PTBdIFRoZSBYIHBvc2l0aW9uIGZvciB0aGUgaW1hZ2UgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnk9MF0gVGhlIFkgcG9zaXRpb24gZm9yIHRoZSBpbWFnZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MV0gVGhlIHdpZHRoIGZvciB0aGUgaW1hZ2UgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gVGhlIGhlaWdodCBmb3IgdGhlIGltYWdlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSBbb3B0aW9ucy5maXRCb3VuZHNdIFRoZSBib3VuZHMgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXNcbiAgICAgKiB0byBmaXQgdGhlIGltYWdlIGludG8uIElmIHNwZWNpZmllZCwgeCwgeSwgd2lkdGggYW5kIGhlaWdodCBnZXQgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBbb3B0aW9ucy5maXRCb3VuZHNQbGFjZW1lbnQ9T3BlblNlYWRyYWdvbi5QbGFjZW1lbnQuQ0VOVEVSXVxuICAgICAqIEhvdyB0byBhbmNob3IgdGhlIGltYWdlIGluIHRoZSBib3VuZHMgaWYgb3B0aW9ucy5maXRCb3VuZHMgaXMgc2V0LlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSBbb3B0aW9ucy5jbGlwXSAtIEFuIGFyZWEsIGluIGltYWdlIHBpeGVscywgdG8gY2xpcCB0b1xuICAgICAqIChwb3J0aW9ucyBvZiB0aGUgaW1hZ2Ugb3V0c2lkZSBvZiB0aGlzIGFyZWEgd2lsbCBub3QgYmUgdmlzaWJsZSkuIE9ubHkgd29ya3Mgb25cbiAgICAgKiBicm93c2VycyB0aGF0IHN1cHBvcnQgdGhlIEhUTUw1IGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub3BhY2l0eV0gT3BhY2l0eSB0aGUgdGlsZWQgaW1hZ2Ugc2hvdWxkIGJlIGRyYXduIGF0IGJ5IGRlZmF1bHQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbXBvc2l0ZU9wZXJhdGlvbl0gSG93IHRoZSBpbWFnZSBpcyBjb21wb3NpdGVkIG9udG8gb3RoZXIgaW1hZ2VzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnN1Y2Nlc3NdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBpbWFnZSBpc1xuICAgICAqIHN1Y2Nlc3NmdWxseSBhZGRlZC4gSXQncyBwYXNzZWQgdGhlIGV2ZW50IG9iamVjdCB3aGljaCBjb250YWlucyBhIHNpbmdsZSBwcm9wZXJ0eTpcbiAgICAgKiBcIml0ZW1cIiwgdGhlIHJlc3VsdGluZyBUaWxlZEltYWdlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVycm9yXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgaWYgdGhlIGltYWdlIGlzXG4gICAgICogdW5hYmxlIHRvIGJlIGFkZGVkLiBJdCdzIHBhc3NlZCB0aGUgZXJyb3IgZXZlbnQgb2JqZWN0LCB3aGljaCBjb250YWlucyBcIm1lc3NhZ2VcIlxuICAgICAqIGFuZCBcInNvdXJjZVwiIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb2xsZWN0aW9uSW1tZWRpYXRlbHk9ZmFsc2VdIElmIGNvbGxlY3Rpb25Nb2RlIGlzIG9uLFxuICAgICAqIHNwZWNpZmllcyB3aGV0aGVyIHRvIHNuYXAgdG8gdGhlIG5ldyBhcnJhbmdlbWVudCBpbW1lZGlhdGVseSBvciB0byBhbmltYXRlIHRvIGl0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm58RnVuY3Rpb259IFtvcHRpb25zLnBsYWNlaG9sZGVyRmlsbFN0eWxlXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5Xb3JsZC5ldmVudDphZGQtaXRlbVxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDphZGQtaXRlbS1mYWlsZWRcbiAgICAgKi9cbiAgICBhZGRUaWxlZEltYWdlOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChvcHRpb25zLCBcIltWaWV3ZXIuYWRkVGlsZWRJbWFnZV0gb3B0aW9ucyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChvcHRpb25zLnRpbGVTb3VyY2UsIFwiW1ZpZXdlci5hZGRUaWxlZEltYWdlXSBvcHRpb25zLnRpbGVTb3VyY2UgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoIW9wdGlvbnMucmVwbGFjZSB8fCAob3B0aW9ucy5pbmRleCA+IC0xICYmIG9wdGlvbnMuaW5kZXggPCB0aGlzLndvcmxkLmdldEl0ZW1Db3VudCgpKSxcbiAgICAgICAgICAgIFwiW1ZpZXdlci5hZGRUaWxlZEltYWdlXSBpZiBvcHRpb25zLnJlcGxhY2UgaXMgdXNlZCwgb3B0aW9ucy5pbmRleCBtdXN0IGJlIGEgdmFsaWQgaW5kZXggaW4gVmlld2VyLndvcmxkXCIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXBsYWNlSXRlbSA9IF90aGlzLndvcmxkLmdldEl0ZW1BdChvcHRpb25zLmluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hpZGVNZXNzYWdlKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXJGaWxsU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5wbGFjZWhvbGRlckZpbGxTdHlsZSA9IHRoaXMucGxhY2Vob2xkZXJGaWxsU3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcG9zaXRlT3BlcmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbXlRdWV1ZUl0ZW0gPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcmFpc2VBZGRJdGVtRmFpbGVkKCBldmVudCApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuX2xvYWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fbG9hZFF1ZXVlW2ldID09PSBteVF1ZXVlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZFF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2xvYWRRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWZyZXNoV29ybGQobXlRdWV1ZUl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgaXRlbS5cbiAgICAgICAgICAgICAqIEBldmVudCBhZGQtaXRlbS1mYWlsZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzb3VyY2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgYWRkVGlsZWRJbWFnZSBtZXRob2QuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoICdhZGQtaXRlbS1mYWlsZWQnLCBldmVudCApO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFdvcmxkKHRoZUl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb2xsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndvcmxkLmFycmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseTogdGhlSXRlbS5vcHRpb25zLmNvbGxlY3Rpb25JbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAgICAgcm93czogX3RoaXMuY29sbGVjdGlvblJvd3MsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IF90aGlzLmNvbGxlY3Rpb25Db2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IF90aGlzLmNvbGxlY3Rpb25MYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgIHRpbGVTaXplOiBfdGhpcy5jb2xsZWN0aW9uVGlsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgIHRpbGVNYXJnaW46IF90aGlzLmNvbGxlY3Rpb25UaWxlTWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMud29ybGQuc2V0QXV0b1JlZmlndXJlU2l6ZXModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJC5pc0FycmF5KG9wdGlvbnMudGlsZVNvdXJjZSkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmFpc2VBZGRJdGVtRmFpbGVkKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJbVmlld2VyLmFkZFRpbGVkSW1hZ2VdIFNlcXVlbmNlcyBjYW4gbm90IGJlIGFkZGVkOyBhZGQgdGhlbSBvbmUgYXQgYSB0aW1lIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogb3B0aW9ucy50aWxlU291cmNlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5wdXNoKG15UXVldWVJdGVtKTtcblxuICAgICAgICBnZXRUaWxlU291cmNlSW1wbGVtZW50YXRpb24oIHRoaXMsIG9wdGlvbnMudGlsZVNvdXJjZSwgZnVuY3Rpb24oIHRpbGVTb3VyY2UgKSB7XG5cbiAgICAgICAgICAgIG15UXVldWVJdGVtLnRpbGVTb3VyY2UgPSB0aWxlU291cmNlO1xuXG4gICAgICAgICAgICAvLyBhZGQgZXZlcnlib2R5IGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWUgdGhhdCdzIHJlYWR5IHRvIGdvXG4gICAgICAgICAgICB2YXIgcXVldWVJdGVtLCB0aWxlZEltYWdlLCBvcHRpb25zQ2xvbmU7XG4gICAgICAgICAgICB3aGlsZSAoX3RoaXMuX2xvYWRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0gPSBfdGhpcy5fbG9hZFF1ZXVlWzBdO1xuICAgICAgICAgICAgICAgIGlmICghcXVldWVJdGVtLnRpbGVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRRdWV1ZS5zcGxpY2UoMCwgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocXVldWVJdGVtLm9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SW5kZXggPSBfdGhpcy53b3JsZC5nZXRJbmRleE9mSXRlbShxdWV1ZUl0ZW0ub3B0aW9ucy5yZXBsYWNlSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVJdGVtLm9wdGlvbnMuaW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy53b3JsZC5yZW1vdmVJdGVtKHF1ZXVlSXRlbS5vcHRpb25zLnJlcGxhY2VJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aWxlZEltYWdlID0gbmV3ICQuVGlsZWRJbWFnZSh7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlcjogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogcXVldWVJdGVtLnRpbGVTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiBfdGhpcy52aWV3cG9ydCxcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyOiBfdGhpcy5kcmF3ZXIsXG4gICAgICAgICAgICAgICAgICAgIHRpbGVDYWNoZTogX3RoaXMudGlsZUNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZUxvYWRlcjogX3RoaXMuaW1hZ2VMb2FkZXIsXG4gICAgICAgICAgICAgICAgICAgIHg6IHF1ZXVlSXRlbS5vcHRpb25zLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHF1ZXVlSXRlbS5vcHRpb25zLnksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBxdWV1ZUl0ZW0ub3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBxdWV1ZUl0ZW0ub3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGZpdEJvdW5kczogcXVldWVJdGVtLm9wdGlvbnMuZml0Qm91bmRzLFxuICAgICAgICAgICAgICAgICAgICBmaXRCb3VuZHNQbGFjZW1lbnQ6IHF1ZXVlSXRlbS5vcHRpb25zLmZpdEJvdW5kc1BsYWNlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgY2xpcDogcXVldWVJdGVtLm9wdGlvbnMuY2xpcCxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJGaWxsU3R5bGU6IHF1ZXVlSXRlbS5vcHRpb25zLnBsYWNlaG9sZGVyRmlsbFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBxdWV1ZUl0ZW0ub3B0aW9ucy5vcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVPcGVyYXRpb246IHF1ZXVlSXRlbS5vcHRpb25zLmNvbXBvc2l0ZU9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiBfdGhpcy5zcHJpbmdTdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblRpbWU6IF90aGlzLmFuaW1hdGlvblRpbWUsXG4gICAgICAgICAgICAgICAgICAgIG1pblpvb21JbWFnZVJhdGlvOiBfdGhpcy5taW5ab29tSW1hZ2VSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgd3JhcEhvcml6b250YWw6IF90aGlzLndyYXBIb3Jpem9udGFsLFxuICAgICAgICAgICAgICAgICAgICB3cmFwVmVydGljYWw6IF90aGlzLndyYXBWZXJ0aWNhbCxcbiAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBfdGhpcy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kVGltZTogX3RoaXMuYmxlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNCbGVuZDogX3RoaXMuYWx3YXlzQmxlbmQsXG4gICAgICAgICAgICAgICAgICAgIG1pblBpeGVsUmF0aW86IF90aGlzLm1pblBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgICAgIHNtb290aFRpbGVFZGdlc01pblpvb206IF90aGlzLnNtb290aFRpbGVFZGdlc01pblpvb20sXG4gICAgICAgICAgICAgICAgICAgIGlPU0RldmljZTogX3RoaXMuaU9TRGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpblBvbGljeTogX3RoaXMuY3Jvc3NPcmlnaW5Qb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTW9kZTogX3RoaXMuZGVidWdNb2RlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29sbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud29ybGQuc2V0QXV0b1JlZmlndXJlU2l6ZXMoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy53b3JsZC5hZGRJdGVtKCB0aWxlZEltYWdlLCB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBxdWV1ZUl0ZW0ub3B0aW9ucy5pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9sb2FkUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcyByZXN0b3JlcyB0aGUgYXV0b1JlZmlndXJlU2l6ZXMgZmxhZyB0byB0cnVlLlxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoV29ybGQocXVldWVJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMud29ybGQuZ2V0SXRlbUNvdW50KCkgPT09IDEgJiYgIV90aGlzLnByZXNlcnZlVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3BvcnQuZ29Ib21lKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5uYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0Nsb25lID0gJC5leHRlbmQoe30sIHF1ZXVlSXRlbS5vcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlOiBmYWxzZSwgLy8gbmF2aWdhdG9yIGFscmVhZHkgcmVtb3ZlZCB0aGUgbGF5ZXIsIG5vdGhpbmcgdG8gcmVwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxUaWxlZEltYWdlOiB0aWxlZEltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVNvdXJjZTogcXVldWVJdGVtLnRpbGVTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdG9yLmFkZFRpbGVkSW1hZ2Uob3B0aW9uc0Nsb25lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocXVldWVJdGVtLm9wdGlvbnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0ub3B0aW9ucy5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IHRpbGVkSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICBldmVudC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHJhaXNlQWRkSXRlbUZhaWxlZChldmVudCk7XG4gICAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgc2ltcGxlIGltYWdlIHRvIHRoZSB2aWV3ZXIuXG4gICAgICogVGhlIG9wdGlvbnMgYXJlIHRoZSBzYW1lIGFzIHRoZSBvbmVzIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNhZGRUaWxlZEltYWdlfVxuICAgICAqIGV4Y2VwdCBmb3Igb3B0aW9ucy50aWxlU291cmNlIHdoaWNoIGlzIHJlcGxhY2VkIGJ5IG9wdGlvbnMudXJsLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNhZGRUaWxlZEltYWdlfVxuICAgICAqIGZvciBhbGwgdGhlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgLSBUaGUgVVJMIG9mIHRoZSBpbWFnZSB0byBhZGQuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6YWRkLWl0ZW1cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6YWRkLWl0ZW0tZmFpbGVkXG4gICAgICovXG4gICAgYWRkU2ltcGxlSW1hZ2U6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChvcHRpb25zLCBcIltWaWV3ZXIuYWRkU2ltcGxlSW1hZ2VdIG9wdGlvbnMgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQob3B0aW9ucy51cmwsIFwiW1ZpZXdlci5hZGRTaW1wbGVJbWFnZV0gb3B0aW9ucy51cmwgaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgICAgdmFyIG9wdHMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgdGlsZVNvdXJjZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgdXJsOiAgb3B0aW9ucy51cmxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBvcHRzLnVybDtcbiAgICAgICAgdGhpcy5hZGRUaWxlZEltYWdlKG9wdHMpO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbVmlld2VyLmFkZExheWVyXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBWaWV3ZXIuYWRkVGlsZWRJbWFnZSgpIGluc3RlYWQuXCIgKTtcblxuICAgICAgICB2YXIgb3B0aW9uc0Nsb25lID0gJC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudChcImFkZC1sYXllclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRyYXdlcjogZXZlbnQuaXRlbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoXCJhZGQtbGF5ZXItZmFpbGVkXCIsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRUaWxlZEltYWdlKG9wdGlvbnNDbG9uZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZ2V0TGF5ZXJBdExldmVsOiBmdW5jdGlvbiggbGV2ZWwgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbVmlld2VyLmdldExheWVyQXRMZXZlbF0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgV29ybGQuZ2V0SXRlbUF0KCkgaW5zdGVhZC5cIiApO1xuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5nZXRJdGVtQXQobGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZ2V0TGV2ZWxPZkxheWVyOiBmdW5jdGlvbiggZHJhd2VyICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW1ZpZXdlci5nZXRMZXZlbE9mTGF5ZXJdIHRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIFdvcmxkLmdldEluZGV4T2ZJdGVtKCkgaW5zdGVhZC5cIiApO1xuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5nZXRJbmRleE9mSXRlbShkcmF3ZXIpO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZ2V0TGF5ZXJzQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW1ZpZXdlci5nZXRMYXllcnNDb3VudF0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgV29ybGQuZ2V0SXRlbUNvdW50KCkgaW5zdGVhZC5cIiApO1xuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIHNldExheWVyTGV2ZWw6IGZ1bmN0aW9uKCBkcmF3ZXIsIGxldmVsICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW1ZpZXdlci5zZXRMYXllckxldmVsXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBXb3JsZC5zZXRJdGVtSW5kZXgoKSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLnNldEl0ZW1JbmRleChkcmF3ZXIsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIHJlbW92ZUxheWVyOiBmdW5jdGlvbiggZHJhd2VyICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW1ZpZXdlci5yZW1vdmVMYXllcl0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgV29ybGQucmVtb3ZlSXRlbSgpIGluc3RlYWQuXCIgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGQucmVtb3ZlSXRlbShkcmF3ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSB0aGUgdmlld2VyIHRvIHJlZHJhdyBpdHMgY29udGVudHMuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgZm9yY2VSZWRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5mb3JjZVJlZHJhdyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqL1xuICAgIGJpbmRTZXF1ZW5jZUNvbnRyb2xzOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIEltYWdlIFNlcXVlbmNlIENvbnRyb2xzXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIHZhciBvbkZvY3VzSGFuZGxlciAgICAgICAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIG9uRm9jdXMgKSxcbiAgICAgICAgICAgIG9uQmx1ckhhbmRsZXIgICAgICAgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgb25CbHVyICksXG4gICAgICAgICAgICBvbk5leHRIYW5kbGVyICAgICAgICAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIG9uTmV4dCApLFxuICAgICAgICAgICAgb25QcmV2aW91c0hhbmRsZXIgICAgICAgPSAkLmRlbGVnYXRlKCB0aGlzLCBvblByZXZpb3VzICksXG4gICAgICAgICAgICBuYXZJbWFnZXMgICAgICAgICAgICAgICA9IHRoaXMubmF2SW1hZ2VzLFxuICAgICAgICAgICAgdXNlR3JvdXAgICAgICAgICAgICAgICAgPSB0cnVlIDtcblxuICAgICAgICBpZiggdGhpcy5zaG93U2VxdWVuY2VDb250cm9sICl7XG5cbiAgICAgICAgICAgIGlmKCB0aGlzLnByZXZpb3VzQnV0dG9uIHx8IHRoaXMubmV4dEJ1dHRvbiApe1xuICAgICAgICAgICAgICAgIC8vaWYgd2UgYXJlIGJpbmRpbmcgdG8gY3VzdG9tIGJ1dHRvbnMgdGhlbiBsYXlvdXQgYW5kXG4gICAgICAgICAgICAgICAgLy9ncm91cGluZyBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHBhZ2UgYXV0aG9yXG4gICAgICAgICAgICAgICAgdXNlR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0J1dHRvbiA9IG5ldyAkLkJ1dHRvbih7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogICAgdGhpcy5wcmV2aW91c0J1dHRvbiA/ICQuZ2V0RWxlbWVudCggdGhpcy5wcmV2aW91c0J1dHRvbiApIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogICAgJC5nZXRTdHJpbmcoIFwiVG9vbHRpcHMuUHJldmlvdXNQYWdlXCIgKSxcbiAgICAgICAgICAgICAgICBzcmNSZXN0OiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnByZXZpb3VzLlJFU1QgKSxcbiAgICAgICAgICAgICAgICBzcmNHcm91cDogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnByZXZpb3VzLkdST1VQICksXG4gICAgICAgICAgICAgICAgc3JjSG92ZXI6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5wcmV2aW91cy5IT1ZFUiApLFxuICAgICAgICAgICAgICAgIHNyY0Rvd246ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMucHJldmlvdXMuRE9XTiApLFxuICAgICAgICAgICAgICAgIG9uUmVsZWFzZTogIG9uUHJldmlvdXNIYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6ICAgIG9uRm9jdXNIYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uQmx1cjogICAgIG9uQmx1ckhhbmRsZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm5leHRCdXR0b24gPSBuZXcgJC5CdXR0b24oe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgIHRoaXMubmV4dEJ1dHRvbiA/ICQuZ2V0RWxlbWVudCggdGhpcy5uZXh0QnV0dG9uICkgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiAgICAkLmdldFN0cmluZyggXCJUb29sdGlwcy5OZXh0UGFnZVwiICksXG4gICAgICAgICAgICAgICAgc3JjUmVzdDogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5uZXh0LlJFU1QgKSxcbiAgICAgICAgICAgICAgICBzcmNHcm91cDogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLm5leHQuR1JPVVAgKSxcbiAgICAgICAgICAgICAgICBzcmNIb3ZlcjogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLm5leHQuSE9WRVIgKSxcbiAgICAgICAgICAgICAgICBzcmNEb3duOiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLm5leHQuRE9XTiApLFxuICAgICAgICAgICAgICAgIG9uUmVsZWFzZTogIG9uTmV4dEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25Gb2N1czogICAgb25Gb2N1c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25CbHVyOiAgICAgb25CbHVySGFuZGxlclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmKCAhdGhpcy5uYXZQcmV2TmV4dFdyYXAgKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbGVTb3VyY2VzIHx8ICF0aGlzLnRpbGVTb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dEJ1dHRvbi5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCB1c2VHcm91cCApe1xuICAgICAgICAgICAgICAgIHRoaXMucGFnaW5nID0gbmV3ICQuQnV0dG9uR3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucGFnaW5nQ29udHJvbCA9IHRoaXMucGFnaW5nLmVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiggdGhpcy50b29sYmFyICl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci5hZGRDb250cm9sKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdpbmdDb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAge2FuY2hvcjogJC5Db250cm9sQW5jaG9yLkJPVFRPTV9SSUdIVH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb250cm9sKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdpbmdDb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAge2FuY2hvcjogdGhpcy5zZXF1ZW5jZUNvbnRyb2xBbmNob3IgfHwgJC5Db250cm9sQW5jaG9yLlRPUF9MRUZUfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqL1xuICAgIGJpbmRTdGFuZGFyZENvbnRyb2xzOiBmdW5jdGlvbigpe1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAvLyBOYXZpZ2F0aW9uIENvbnRyb2xzXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIHZhciBiZWdpblpvb21pbmdJbkhhbmRsZXIgICA9ICQuZGVsZWdhdGUoIHRoaXMsIGJlZ2luWm9vbWluZ0luICksXG4gICAgICAgICAgICBlbmRab29taW5nSGFuZGxlciAgICAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIGVuZFpvb21pbmcgKSxcbiAgICAgICAgICAgIGRvU2luZ2xlWm9vbUluSGFuZGxlciAgID0gJC5kZWxlZ2F0ZSggdGhpcywgZG9TaW5nbGVab29tSW4gKSxcbiAgICAgICAgICAgIGJlZ2luWm9vbWluZ091dEhhbmRsZXIgID0gJC5kZWxlZ2F0ZSggdGhpcywgYmVnaW5ab29taW5nT3V0ICksXG4gICAgICAgICAgICBkb1NpbmdsZVpvb21PdXRIYW5kbGVyICA9ICQuZGVsZWdhdGUoIHRoaXMsIGRvU2luZ2xlWm9vbU91dCApLFxuICAgICAgICAgICAgb25Ib21lSGFuZGxlciAgICAgICAgICAgPSAkLmRlbGVnYXRlKCB0aGlzLCBvbkhvbWUgKSxcbiAgICAgICAgICAgIG9uRnVsbFNjcmVlbkhhbmRsZXIgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgb25GdWxsU2NyZWVuICksXG4gICAgICAgICAgICBvblJvdGF0ZUxlZnRIYW5kbGVyICAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIG9uUm90YXRlTGVmdCApLFxuICAgICAgICAgICAgb25Sb3RhdGVSaWdodEhhbmRsZXIgICAgPSAkLmRlbGVnYXRlKCB0aGlzLCBvblJvdGF0ZVJpZ2h0ICksXG4gICAgICAgICAgICBvbkZvY3VzSGFuZGxlciAgICAgICAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIG9uRm9jdXMgKSxcbiAgICAgICAgICAgIG9uQmx1ckhhbmRsZXIgICAgICAgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgb25CbHVyICksXG4gICAgICAgICAgICBuYXZJbWFnZXMgICAgICAgICAgICAgICA9IHRoaXMubmF2SW1hZ2VzLFxuICAgICAgICAgICAgYnV0dG9ucyAgICAgICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHVzZUdyb3VwICAgICAgICAgICAgICAgID0gdHJ1ZSA7XG5cblxuICAgICAgICBpZiAoIHRoaXMuc2hvd05hdmlnYXRpb25Db250cm9sICkge1xuXG4gICAgICAgICAgICBpZiggdGhpcy56b29tSW5CdXR0b24gfHwgdGhpcy56b29tT3V0QnV0dG9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5ob21lQnV0dG9uIHx8IHRoaXMuZnVsbFBhZ2VCdXR0b24gfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZUxlZnRCdXR0b24gfHwgdGhpcy5yb3RhdGVSaWdodEJ1dHRvbiApIHtcbiAgICAgICAgICAgICAgICAvL2lmIHdlIGFyZSBiaW5kaW5nIHRvIGN1c3RvbSBidXR0b25zIHRoZW4gbGF5b3V0IGFuZFxuICAgICAgICAgICAgICAgIC8vZ3JvdXBpbmcgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBwYWdlIGF1dGhvclxuICAgICAgICAgICAgICAgIHVzZUdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5zaG93Wm9vbUNvbnRyb2wgKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9ucy5wdXNoKCB0aGlzLnpvb21JbkJ1dHRvbiA9IG5ldyAkLkJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgIHRoaXMuem9vbUluQnV0dG9uID8gJC5nZXRFbGVtZW50KCB0aGlzLnpvb21JbkJ1dHRvbiApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogICAgJC5nZXRTdHJpbmcoIFwiVG9vbHRpcHMuWm9vbUluXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjUmVzdDogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy56b29tSW4uUkVTVCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNHcm91cDogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnpvb21Jbi5HUk9VUCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNIb3ZlcjogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnpvb21Jbi5IT1ZFUiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNEb3duOiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnpvb21Jbi5ET1dOICksXG4gICAgICAgICAgICAgICAgICAgIG9uUHJlc3M6ICAgIGJlZ2luWm9vbWluZ0luSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25SZWxlYXNlOiAgZW5kWm9vbWluZ0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICAgIGRvU2luZ2xlWm9vbUluSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcjogICAgYmVnaW5ab29taW5nSW5IYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQ6ICAgICBlbmRab29taW5nSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1czogICAgb25Gb2N1c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cjogICAgIG9uQmx1ckhhbmRsZXJcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goIHRoaXMuem9vbU91dEJ1dHRvbiA9IG5ldyAkLkJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgIHRoaXMuem9vbU91dEJ1dHRvbiA/ICQuZ2V0RWxlbWVudCggdGhpcy56b29tT3V0QnV0dG9uICkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6IHRoaXMuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAgICAkLmdldFN0cmluZyggXCJUb29sdGlwcy5ab29tT3V0XCIgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjUmVzdDogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy56b29tT3V0LlJFU1QgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjR3JvdXA6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy56b29tT3V0LkdST1VQICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0hvdmVyOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuem9vbU91dC5IT1ZFUiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNEb3duOiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnpvb21PdXQuRE9XTiApLFxuICAgICAgICAgICAgICAgICAgICBvblByZXNzOiAgICBiZWdpblpvb21pbmdPdXRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvblJlbGVhc2U6ICBlbmRab29taW5nSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogICAgZG9TaW5nbGVab29tT3V0SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcjogICAgYmVnaW5ab29taW5nT3V0SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25FeGl0OiAgICAgZW5kWm9vbWluZ0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM6ICAgIG9uRm9jdXNIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI6ICAgICBvbkJsdXJIYW5kbGVyXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXMuc2hvd0hvbWVDb250cm9sICkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCggdGhpcy5ob21lQnV0dG9uID0gbmV3ICQuQnV0dG9uKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogICAgdGhpcy5ob21lQnV0dG9uID8gJC5nZXRFbGVtZW50KCB0aGlzLmhvbWVCdXR0b24gKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICAgICQuZ2V0U3RyaW5nKCBcIlRvb2x0aXBzLkhvbWVcIiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNSZXN0OiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLmhvbWUuUkVTVCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNHcm91cDogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLmhvbWUuR1JPVVAgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjSG92ZXI6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5ob21lLkhPVkVSICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0Rvd246ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuaG9tZS5ET1dOICksXG4gICAgICAgICAgICAgICAgICAgIG9uUmVsZWFzZTogIG9uSG9tZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM6ICAgIG9uRm9jdXNIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI6ICAgICBvbkJsdXJIYW5kbGVyXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXMuc2hvd0Z1bGxQYWdlQ29udHJvbCApIHtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goIHRoaXMuZnVsbFBhZ2VCdXR0b24gPSBuZXcgJC5CdXR0b24oe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAgICB0aGlzLmZ1bGxQYWdlQnV0dG9uID8gJC5nZXRFbGVtZW50KCB0aGlzLmZ1bGxQYWdlQnV0dG9uICkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6IHRoaXMuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAgICAkLmdldFN0cmluZyggXCJUb29sdGlwcy5GdWxsUGFnZVwiICksXG4gICAgICAgICAgICAgICAgICAgIHNyY1Jlc3Q6ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuZnVsbHBhZ2UuUkVTVCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNHcm91cDogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLmZ1bGxwYWdlLkdST1VQICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0hvdmVyOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuZnVsbHBhZ2UuSE9WRVIgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjRG93bjogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5mdWxscGFnZS5ET1dOICksXG4gICAgICAgICAgICAgICAgICAgIG9uUmVsZWFzZTogIG9uRnVsbFNjcmVlbkhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM6ICAgIG9uRm9jdXNIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI6ICAgICBvbkJsdXJIYW5kbGVyXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXMuc2hvd1JvdGF0aW9uQ29udHJvbCApIHtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goIHRoaXMucm90YXRlTGVmdEJ1dHRvbiA9IG5ldyAkLkJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgIHRoaXMucm90YXRlTGVmdEJ1dHRvbiA/ICQuZ2V0RWxlbWVudCggdGhpcy5yb3RhdGVMZWZ0QnV0dG9uICkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6IHRoaXMuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAgICAkLmdldFN0cmluZyggXCJUb29sdGlwcy5Sb3RhdGVMZWZ0XCIgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjUmVzdDogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5yb3RhdGVsZWZ0LlJFU1QgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjR3JvdXA6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5yb3RhdGVsZWZ0LkdST1VQICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0hvdmVyOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMucm90YXRlbGVmdC5IT1ZFUiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNEb3duOiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnJvdGF0ZWxlZnQuRE9XTiApLFxuICAgICAgICAgICAgICAgICAgICBvblJlbGVhc2U6ICBvblJvdGF0ZUxlZnRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzOiAgICBvbkZvY3VzSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25CbHVyOiAgICAgb25CbHVySGFuZGxlclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCggdGhpcy5yb3RhdGVSaWdodEJ1dHRvbiA9IG5ldyAkLkJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgIHRoaXMucm90YXRlUmlnaHRCdXR0b24gPyAkLmdldEVsZW1lbnQoIHRoaXMucm90YXRlUmlnaHRCdXR0b24gKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICAgICQuZ2V0U3RyaW5nKCBcIlRvb2x0aXBzLlJvdGF0ZVJpZ2h0XCIgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjUmVzdDogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5yb3RhdGVyaWdodC5SRVNUICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0dyb3VwOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMucm90YXRlcmlnaHQuR1JPVVAgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjSG92ZXI6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5yb3RhdGVyaWdodC5IT1ZFUiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNEb3duOiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnJvdGF0ZXJpZ2h0LkRPV04gKSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWxlYXNlOiAgb25Sb3RhdGVSaWdodEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM6ICAgIG9uRm9jdXNIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI6ICAgICBvbkJsdXJIYW5kbGVyXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdXNlR3JvdXAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25zID0gbmV3ICQuQnV0dG9uR3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgIGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMubmF2Q29udHJvbCAgPSB0aGlzLmJ1dHRvbnMuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhhbmRsZXIoICdvcGVuJywgJC5kZWxlZ2F0ZSggdGhpcywgbGlnaHRVcCApICk7XG5cbiAgICAgICAgICAgICAgICBpZiggdGhpcy50b29sYmFyICl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci5hZGRDb250cm9sKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZDb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAge2FuY2hvcjogJC5Db250cm9sQW5jaG9yLlRPUF9MRUZUfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29udHJvbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF2Q29udHJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHthbmNob3I6IHRoaXMubmF2aWdhdGlvbkNvbnRyb2xBbmNob3IgfHwgJC5Db250cm9sQW5jaG9yLlRPUF9MRUZUfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhY3RpdmUgcGFnZSBvZiBhIHNlcXVlbmNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGN1cnJlbnRQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcXVlbmNlSW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnBhZ2VcbiAgICAgKi9cbiAgICBnb1RvUGFnZTogZnVuY3Rpb24oIHBhZ2UgKXtcbiAgICAgICAgaWYoIHRoaXMudGlsZVNvdXJjZXMgJiYgcGFnZSA+PSAwICYmIHBhZ2UgPCB0aGlzLnRpbGVTb3VyY2VzLmxlbmd0aCApe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgcGFnZSBpcyBjaGFuZ2VkIG9uIGEgdmlld2VyIGNvbmZpZ3VyZWQgd2l0aCBtdWx0aXBsZSBpbWFnZSBzb3VyY2VzIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2dvVG9QYWdlfSkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IHBhZ2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHBhZ2UgLSBUaGUgcGFnZSBpbmRleC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAncGFnZScsIHsgcGFnZTogcGFnZSB9ICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlSW5kZXggPSBwYWdlO1xuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXF1ZW5jZUJ1dHRvbnMoIHBhZ2UgKTtcblxuICAgICAgICAgICAgdGhpcy5vcGVuKCB0aGlzLnRpbGVTb3VyY2VzWyBwYWdlIF0gKTtcblxuICAgICAgICAgICAgaWYoIHRoaXMucmVmZXJlbmNlU3RyaXAgKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZVN0cmlwLnNldEZvY3VzKCBwYWdlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAvKipcbiAgICAgKiBBZGRzIGFuIGh0bWwgZWxlbWVudCBhcyBhbiBvdmVybGF5IHRvIHRoZSBjdXJyZW50IHZpZXdwb3J0LiAgVXNlZnVsIGZvclxuICAgICAqIGhpZ2hsaWdodGluZyB3b3JkcyBvciBhcmVhcyBvZiBpbnRlcmVzdCBvbiBhbiBpbWFnZSBvciBvdGhlciB6b29tYWJsZVxuICAgICAqIGludGVyZmFjZS4gVGhlIG92ZXJsYXlzIGFkZGVkIHZpYSB0aGlzIG1ldGhvZCBhcmUgcmVtb3ZlZCB3aGVuIHRoZSB2aWV3cG9ydFxuICAgICAqIGlzIGNsb3NlZCB3aGljaCBpbmNsdWRlIHdoZW4gY2hhbmdpbmcgcGFnZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ3xPYmplY3R9IGVsZW1lbnQgLSBBIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50IG9yIGFuIGlkIGZvclxuICAgICAqICAgICAgdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBvdmVybGF5ZWQuIE9yIGFuIE9iamVjdCBzcGVjaWZ5aW5nIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgb3ZlcmxheS5cbiAgICAgKiAgICAgIElmIHVzaW5nIGFuIG9iamVjdCwgc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk92ZXJsYXl9IGZvciBhIGxpc3Qgb2ZcbiAgICAgKiAgICAgIGFsbCBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR8T3BlblNlYWRyYWdvbi5SZWN0fSBsb2NhdGlvbiAtIFRoZSBwb2ludCBvclxuICAgICAqICAgICAgcmVjdGFuZ2xlIHdoaWNoIHdpbGwgYmUgb3ZlcmxheWVkLiBUaGlzIGlzIGEgdmlld3BvcnQgcmVsYXRpdmUgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gcGxhY2VtZW50IC0gVGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgICAqICAgICAgdmlld3BvcnQgd2hpY2ggdGhlIGxvY2F0aW9uIGNvb3JkaW5hdGVzIHdpbGwgYmUgdHJlYXRlZCBhcyByZWxhdGl2ZVxuICAgICAqICAgICAgdG8uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25EcmF3IC0gSWYgc3VwcGxpZWQgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBvdmVybGF5XG4gICAgICogICAgICBuZWVkcyB0byBiZSBkcmF3bi4gSXQgaXQgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsYmFjayB0byBkbyBhbnkgZHJhd2luZy9wb3NpdGlvbmluZy5cbiAgICAgKiAgICAgIEl0IGlzIHBhc3NlZCBwb3NpdGlvbiwgc2l6ZSBhbmQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDphZGQtb3ZlcmxheVxuICAgICAqL1xuICAgIGFkZE92ZXJsYXk6IGZ1bmN0aW9uKCBlbGVtZW50LCBsb2NhdGlvbiwgcGxhY2VtZW50LCBvbkRyYXcgKSB7XG4gICAgICAgIHZhciBvcHRpb25zO1xuICAgICAgICBpZiggJC5pc1BsYWluT2JqZWN0KCBlbGVtZW50ICkgKXtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICBvbkRyYXc6IG9uRHJhd1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIG9wdGlvbnMuZWxlbWVudCApO1xuXG4gICAgICAgIGlmICggZ2V0T3ZlcmxheUluZGV4KCB0aGlzLmN1cnJlbnRPdmVybGF5cywgZWxlbWVudCApID49IDAgKSB7XG4gICAgICAgICAgICAvLyB0aGV5J3JlIHRyeWluZyB0byBhZGQgYSBkdXBsaWNhdGUgb3ZlcmxheVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3ZlcmxheSA9IGdldE92ZXJsYXlPYmplY3QoIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5cy5wdXNoKG92ZXJsYXkpO1xuICAgICAgICBvdmVybGF5LmRyYXdIVE1MKCB0aGlzLm92ZXJsYXlzQ29udGFpbmVyLCB0aGlzLnZpZXdwb3J0ICk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIG92ZXJsYXkgaXMgYWRkZWQgdG8gdGhlIHZpZXdlciAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNhZGRPdmVybGF5fSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBhZGQtb3ZlcmxheVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBvdmVybGF5IGVsZW1lbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludHxPcGVuU2VhZHJhZ29uLlJlY3R9IGxvY2F0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IHBsYWNlbWVudFxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdhZGQtb3ZlcmxheScsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBsb2NhdGlvbjogb3B0aW9ucy5sb2NhdGlvbixcbiAgICAgICAgICAgIHBsYWNlbWVudDogb3B0aW9ucy5wbGFjZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBvdmVybGF5IHJlcHJlc2VudGVkIGJ5IHRoZSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgb3JcbiAgICAgKiBlbGVtZW50IGlkIG1vdmluZyBpdCB0byB0aGUgbmV3IGxvY2F0aW9uLCByZWxhdGl2ZSB0byB0aGUgbmV3IHBsYWNlbWVudC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudCAtIEEgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQgb3IgYW4gaWQgZm9yXG4gICAgICogICAgICB0aGUgZWxlbWVudCB3aGljaCBpcyBvdmVybGF5ZWQuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fE9wZW5TZWFkcmFnb24uUmVjdH0gbG9jYXRpb24gLSBUaGUgcG9pbnQgb3JcbiAgICAgKiAgICAgIHJlY3RhbmdsZSB3aGljaCB3aWxsIGJlIG92ZXJsYXllZC4gVGhpcyBpcyBhIHZpZXdwb3J0IHJlbGF0aXZlIGxvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IHBsYWNlbWVudCAtIFRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICAgKiAgICAgIHZpZXdwb3J0IHdoaWNoIHRoZSBsb2NhdGlvbiBjb29yZGluYXRlcyB3aWxsIGJlIHRyZWF0ZWQgYXMgcmVsYXRpdmVcbiAgICAgKiAgICAgIHRvLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnVwZGF0ZS1vdmVybGF5XG4gICAgICovXG4gICAgdXBkYXRlT3ZlcmxheTogZnVuY3Rpb24oIGVsZW1lbnQsIGxvY2F0aW9uLCBwbGFjZW1lbnQgKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgaSA9IGdldE92ZXJsYXlJbmRleCggdGhpcy5jdXJyZW50T3ZlcmxheXMsIGVsZW1lbnQgKTtcblxuICAgICAgICBpZiAoIGkgPj0gMCApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXlzWyBpIF0udXBkYXRlKCBsb2NhdGlvbiwgcGxhY2VtZW50ICk7XG4gICAgICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5mb3JjZVJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIG92ZXJsYXkncyBsb2NhdGlvbiBvciBwbGFjZW1lbnQgY2hhbmdlc1xuICAgICAgICAgICAgICogKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjdXBkYXRlT3ZlcmxheX0pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCB1cGRhdGUtb3ZlcmxheVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICAgICAqIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR8T3BlblNlYWRyYWdvbi5SZWN0fSBsb2NhdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gcGxhY2VtZW50XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmFpc2VFdmVudCggJ3VwZGF0ZS1vdmVybGF5Jywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBvdmVybGF5IGlkZW50aWZpZWQgYnkgdGhlIHJlZmVyZW5jZSBlbGVtZW50IG9yIGVsZW1lbnQgaWRcbiAgICAgKiBhbmQgc2NoZWR1bGVzIGFuIHVwZGF0ZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IG9yIGFuXG4gICAgICogICAgICBlbGVtZW50IGlkIHdoaWNoIHJlcHJlc2VudCB0aGUgb3ZlbGF5IGNvbnRlbnQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpyZW1vdmUtb3ZlcmxheVxuICAgICAqL1xuICAgIHJlbW92ZU92ZXJsYXk6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgIGkgPSBnZXRPdmVybGF5SW5kZXgoIHRoaXMuY3VycmVudE92ZXJsYXlzLCBlbGVtZW50ICk7XG5cbiAgICAgICAgaWYgKCBpID49IDAgKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5c1sgaSBdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXlzLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0uZm9yY2VSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbiBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSB0aGUgdmlld2VyXG4gICAgICAgICAgICAgKiAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNyZW1vdmVPdmVybGF5fSkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IHJlbW92ZS1vdmVybGF5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAgICAgICogVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgb3ZlcmxheSBlbGVtZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdyZW1vdmUtb3ZlcmxheScsIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgY3VycmVudGx5IGNvbmZpZ3VyZWQgT3ZlcmxheXMgZnJvbSB0aGlzIFZpZXdlciBhbmQgc2NoZWR1bGVzXG4gICAgICogYW4gdXBkYXRlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpjbGVhci1vdmVybGF5XG4gICAgICovXG4gICAgY2xlYXJPdmVybGF5czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlICggdGhpcy5jdXJyZW50T3ZlcmxheXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXlzLnBvcCgpLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5mb3JjZVJlZHJhdyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbGwgb3ZlcmxheXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgdmlld2VyIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uRHJhd2VyI2NsZWFyT3ZlcmxheXN9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGNsZWFyLW92ZXJsYXlcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdjbGVhci1vdmVybGF5Jywge30gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgICAvKipcbiAgICAgKiBGaW5kcyBhbiBvdmVybGF5IGlkZW50aWZpZWQgYnkgdGhlIHJlZmVyZW5jZSBlbGVtZW50IG9yIGVsZW1lbnQgaWRcbiAgICAgKiBhbmQgcmV0dXJucyBpdCBhcyBhbiBvYmplY3QsIHJldHVybiBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IG9yIGFuXG4gICAgICogICAgICBlbGVtZW50IGlkIHdoaWNoIHJlcHJlc2VudHMgdGhlIG92ZXJsYXkgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLk92ZXJsYXl9IHRoZSBtYXRjaGluZyBvdmVybGF5IG9yIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXRPdmVybGF5QnlJZDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgaSA9IGdldE92ZXJsYXlJbmRleCggdGhpcy5jdXJyZW50T3ZlcmxheXMsIGVsZW1lbnQgKTtcblxuICAgICAgICBpZiAoaT49MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE92ZXJsYXlzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc2VxdWVuY2UgYnV0dG9ucy5cbiAgICAgKiBAZnVuY3Rpb24gT3BlblNlYWRyYWdvbi5WaWV3ZXIucHJvdG90eXBlLl91cGRhdGVTZXF1ZW5jZUJ1dHRvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBTZXF1ZW5jZSBWYWx1ZVxuICAgICAqL1xuICAgIF91cGRhdGVTZXF1ZW5jZUJ1dHRvbnM6IGZ1bmN0aW9uKCBwYWdlICkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMubmV4dEJ1dHRvbiApIHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy50aWxlU291cmNlcyB8fCB0aGlzLnRpbGVTb3VyY2VzLmxlbmd0aCAtIDEgPT09IHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9EaXNhYmxlIG5leHQgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXRoaXMubmF2UHJldk5leHRXcmFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0QnV0dG9uLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dEJ1dHRvbi5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHRoaXMucHJldmlvdXNCdXR0b24gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBwYWdlID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmFibGUgcHJldmlvdXMgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24uZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhdGhpcy5uYXZQcmV2TmV4dFdyYXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGEgbWVzc2FnZSBpbiB0aGUgdmlld3BvcnRcbiAgICAgKiBAZnVuY3Rpb24gT3BlblNlYWRyYWdvbi5WaWV3ZXIucHJvdG90eXBlLl9zaG93TWVzc2FnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgbWVzc2FnZVxuICAgICAqL1xuICAgIF9zaG93TWVzc2FnZTogZnVuY3Rpb24gKCBtZXNzYWdlICkge1xuICAgICAgICB0aGlzLl9oaWRlTWVzc2FnZSgpO1xuXG4gICAgICAgIHZhciBkaXYgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBtZXNzYWdlICkgKTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2VEaXYgPSAkLm1ha2VDZW50ZXJlZE5vZGUoIGRpdiApO1xuXG4gICAgICAgICQuYWRkQ2xhc3ModGhpcy5tZXNzYWdlRGl2LCBcIm9wZW5zZWFkcmFnb24tbWVzc2FnZVwiKTtcblxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5tZXNzYWdlRGl2ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgYW55IGN1cnJlbnRseSBkaXNwbGF5ZWQgdmlld3BvcnQgbWVzc2FnZVxuICAgICAqIEBmdW5jdGlvbiBPcGVuU2VhZHJhZ29uLlZpZXdlci5wcm90b3R5cGUuX2hpZGVNZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZU1lc3NhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdiA9IHRoaXMubWVzc2FnZURpdjtcbiAgICAgICAgaWYgKGRpdikge1xuICAgICAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1lc3NhZ2VEaXY7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGlzIHZpZXdlcidzIGdlc3R1cmUgc2V0dGluZ3MgZm9yIHRoZSBnaXZlbiBwb2ludGVyIGRldmljZSB0eXBlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBwb2ludGVyIGRldmljZSB0eXBlIHRvIGdldCB0aGUgZ2VzdHVyZSBzZXR0aW5ncyBmb3IgKFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuKS5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLkdlc3R1cmVTZXR0aW5nc31cbiAgICAgKi9cbiAgICBnZXN0dXJlU2V0dGluZ3NCeURldmljZVR5cGU6IGZ1bmN0aW9uICggdHlwZSApIHtcbiAgICAgICAgc3dpdGNoICggdHlwZSApIHtcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXN0dXJlU2V0dGluZ3NNb3VzZTtcbiAgICAgICAgICAgIGNhc2UgJ3RvdWNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXN0dXJlU2V0dGluZ3NUb3VjaDtcbiAgICAgICAgICAgIGNhc2UgJ3Blbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VzdHVyZVNldHRpbmdzUGVuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXN0dXJlU2V0dGluZ3NVbmtub3duO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfZHJhd092ZXJsYXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmN1cnJlbnRPdmVybGF5cy5sZW5ndGg7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPdmVybGF5c1sgaSBdLmRyYXdIVE1MKCB0aGlzLm92ZXJsYXlzQ29udGFpbmVyLCB0aGlzLnZpZXdwb3J0ICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSBcImluIGZsaWdodFwiIGltYWdlcy5cbiAgICAgKi9cbiAgICBfY2FuY2VsUGVuZGluZ0ltYWdlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xvYWRRdWV1ZSA9IFtdO1xuICAgIH1cbn0pO1xuXG5cbi8qKlxuICogX2dldFNhZmVFbGVtU2l6ZSBpcyBsaWtlIGdldEVsZW1lbnRTaXplKCksIGJ1dCByZWZ1c2VzIHRvIHJldHVybiAwIGZvciB4IG9yIHksXG4gKiB3aGljaCB3YXMgY2F1c2luZyBzb21lIGNhbGxpbmcgb3BlcmF0aW9ucyB0byByZXR1cm4gTmFOLlxuICogQHJldHVybnMge1BvaW50fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFNhZmVFbGVtU2l6ZSAob0VsZW1lbnQpIHtcbiAgICBvRWxlbWVudCA9ICQuZ2V0RWxlbWVudCggb0VsZW1lbnQgKTtcblxuICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgKG9FbGVtZW50LmNsaWVudFdpZHRoID09PSAwID8gMSA6IG9FbGVtZW50LmNsaWVudFdpZHRoKSxcbiAgICAgICAgKG9FbGVtZW50LmNsaWVudEhlaWdodCA9PT0gMCA/IDEgOiBvRWxlbWVudC5jbGllbnRIZWlnaHQpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFRpbGVTb3VyY2VJbXBsZW1lbnRhdGlvbiggdmlld2VyLCB0aWxlU291cmNlLCBzdWNjZXNzQ2FsbGJhY2ssXG4gICAgZmFpbENhbGxiYWNrICkge1xuICAgIHZhciBfdGhpcyA9IHZpZXdlcjtcblxuICAgIC8vYWxsb3cgcGxhaW4geG1sIHN0cmluZ3Mgb3IganNvbiBzdHJpbmdzIHRvIGJlIHBhcnNlZCBoZXJlXG4gICAgaWYgKCAkLnR5cGUoIHRpbGVTb3VyY2UgKSA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgaWYgKCB0aWxlU291cmNlLm1hdGNoKCAvXFxzKjwuKi8gKSApIHtcbiAgICAgICAgICAgIHRpbGVTb3VyY2UgPSAkLnBhcnNlWG1sKCB0aWxlU291cmNlICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHRpbGVTb3VyY2UubWF0Y2goIC9cXHMqW1xce1xcW10uKi8gKSApIHtcbiAgICAgICAgICAgIHRpbGVTb3VyY2UgPSAkLnBhcnNlSlNPTih0aWxlU291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhaXRVbnRpbFJlYWR5KHRpbGVTb3VyY2UsIG9yaWdpbmFsVGlsZVNvdXJjZSkge1xuICAgICAgICBpZiAodGlsZVNvdXJjZS5yZWFkeSkge1xuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRpbGVTb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlsZVNvdXJjZS5hZGRIYW5kbGVyKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodGlsZVNvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbGVTb3VyY2UuYWRkSGFuZGxlcignb3Blbi1mYWlsZWQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmYWlsQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsVGlsZVNvdXJjZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAkLnR5cGUoIHRpbGVTb3VyY2UgKSA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIC8vSWYgaXRzIHN0aWxsIGEgc3RyaW5nIGl0IG1lYW5zIGl0IG11c3QgYmUgYSB1cmwgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgdGlsZVNvdXJjZSA9IG5ldyAkLlRpbGVTb3VyY2Uoe1xuICAgICAgICAgICAgICAgIHVybDogdGlsZVNvdXJjZSxcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpblBvbGljeTogdmlld2VyLmNyb3NzT3JpZ2luUG9saWN5LFxuICAgICAgICAgICAgICAgIGFqYXhXaXRoQ3JlZGVudGlhbHM6IHZpZXdlci5hamF4V2l0aENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgICAgIHVzZUNhbnZhczogdmlld2VyLnVzZUNhbnZhcyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayggZXZlbnQudGlsZVNvdXJjZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGlsZVNvdXJjZS5hZGRIYW5kbGVyKCAnb3Blbi1mYWlsZWQnLCBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgZmFpbENhbGxiYWNrKCBldmVudCApO1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHRpbGVTb3VyY2UpIHx8IHRpbGVTb3VyY2Uubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGlmICghdGlsZVNvdXJjZS5jcm9zc09yaWdpblBvbGljeSAmJiB2aWV3ZXIuY3Jvc3NPcmlnaW5Qb2xpY3kpIHtcbiAgICAgICAgICAgICAgICB0aWxlU291cmNlLmNyb3NzT3JpZ2luUG9saWN5ID0gdmlld2VyLmNyb3NzT3JpZ2luUG9saWN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbGVTb3VyY2UuYWpheFdpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGlsZVNvdXJjZS5hamF4V2l0aENyZWRlbnRpYWxzID0gdmlld2VyLmFqYXhXaXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGlsZVNvdXJjZS51c2VDYW52YXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRpbGVTb3VyY2UudXNlQ2FudmFzID0gdmlld2VyLnVzZUNhbnZhcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIHRpbGVTb3VyY2UuZ2V0VGlsZVVybCApICkge1xuICAgICAgICAgICAgICAgIC8vQ3VzdG9tIHRpbGUgc291cmNlXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbVRpbGVTb3VyY2UgPSBuZXcgJC5UaWxlU291cmNlKCB0aWxlU291cmNlICk7XG4gICAgICAgICAgICAgICAgY3VzdG9tVGlsZVNvdXJjZS5nZXRUaWxlVXJsID0gdGlsZVNvdXJjZS5nZXRUaWxlVXJsO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayggY3VzdG9tVGlsZVNvdXJjZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2lubGluZSBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgICAgdmFyICRUaWxlU291cmNlID0gJC5UaWxlU291cmNlLmRldGVybWluZVR5cGUoIF90aGlzLCB0aWxlU291cmNlICk7XG4gICAgICAgICAgICAgICAgaWYgKCAhJFRpbGVTb3VyY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxDYWxsYmFjaygge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJVbmFibGUgdG8gbG9hZCBUaWxlU291cmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRpbGVTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAkVGlsZVNvdXJjZS5wcm90b3R5cGUuY29uZmlndXJlLmFwcGx5KCBfdGhpcywgWyB0aWxlU291cmNlIF0gKTtcbiAgICAgICAgICAgICAgICB3YWl0VW50aWxSZWFkeShuZXcgJFRpbGVTb3VyY2Uob3B0aW9ucyksIHRpbGVTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9jYW4gYXNzdW1lIGl0J3MgYWxyZWFkeSBhIHRpbGUgc291cmNlIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICB3YWl0VW50aWxSZWFkeSh0aWxlU291cmNlLCB0aWxlU291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRPdmVybGF5T2JqZWN0KCB2aWV3ZXIsIG92ZXJsYXkgKSB7XG4gICAgaWYgKCBvdmVybGF5IGluc3RhbmNlb2YgJC5PdmVybGF5ICkge1xuICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XG4gICAgaWYgKCBvdmVybGF5LmVsZW1lbnQgKSB7XG4gICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIG92ZXJsYXkuZWxlbWVudCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZCA9IG92ZXJsYXkuaWQgP1xuICAgICAgICAgICAgb3ZlcmxheS5pZCA6XG4gICAgICAgICAgICBcIm9wZW5zZWFkcmFnb24tb3ZlcmxheS1cIiArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCApO1xuXG4gICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIG92ZXJsYXkuaWQgKTtcbiAgICAgICAgaWYgKCAhZWxlbWVudCApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG4gICAgICAgICAgICBlbGVtZW50LmhyZWYgICAgPSBcIiMvb3ZlcmxheS9cIiArIGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuaWQgPSBpZDtcbiAgICAgICAgJC5hZGRDbGFzcyggZWxlbWVudCwgb3ZlcmxheS5jbGFzc05hbWUgP1xuICAgICAgICAgICAgb3ZlcmxheS5jbGFzc05hbWUgOlxuICAgICAgICAgICAgXCJvcGVuc2VhZHJhZ29uLW92ZXJsYXlcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IG92ZXJsYXkubG9jYXRpb247XG4gICAgdmFyIHdpZHRoID0gb3ZlcmxheS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gb3ZlcmxheS5oZWlnaHQ7XG4gICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICB2YXIgeCA9IG92ZXJsYXkueDtcbiAgICAgICAgdmFyIHkgPSBvdmVybGF5Lnk7XG4gICAgICAgIGlmIChvdmVybGF5LnB4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdmlld2VyLnZpZXdwb3J0LmltYWdlVG9WaWV3cG9ydFJlY3RhbmdsZShuZXcgJC5SZWN0KFxuICAgICAgICAgICAgICAgIG92ZXJsYXkucHgsXG4gICAgICAgICAgICAgICAgb3ZlcmxheS5weSxcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAwLFxuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAwKSk7XG4gICAgICAgICAgICB4ID0gcmVjdC54O1xuICAgICAgICAgICAgeSA9IHJlY3QueTtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHJlY3Qud2lkdGggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IHJlY3QuaGVpZ2h0IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxvY2F0aW9uID0gbmV3ICQuUG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgdmFyIHBsYWNlbWVudCA9IG92ZXJsYXkucGxhY2VtZW50O1xuICAgIGlmIChwbGFjZW1lbnQgJiYgJC50eXBlKHBsYWNlbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gJC5QbGFjZW1lbnRbb3ZlcmxheS5wbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAkLk92ZXJsYXkoe1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICBvbkRyYXc6IG92ZXJsYXkub25EcmF3LFxuICAgICAgICBjaGVja1Jlc2l6ZTogb3ZlcmxheS5jaGVja1Jlc2l6ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcm90YXRpb25Nb2RlOiBvdmVybGF5LnJvdGF0aW9uTW9kZVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIERldGVybWluZXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBvdmVybGF5IGluIHRoZSBnaXZlbiBvdmVybGF5cyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ2V0T3ZlcmxheUluZGV4KCBvdmVybGF5cywgZWxlbWVudCApIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKCBpID0gb3ZlcmxheXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgIGlmICggb3ZlcmxheXNbIGkgXS5lbGVtZW50ID09PSBlbGVtZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNjaGVkdWxlcnMgcHJvdmlkZSB0aGUgZ2VuZXJhbCBlbmdpbmUgZm9yIGFuaW1hdGlvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGUoIHZpZXdlciwgdXBkYXRlRnVuYyApe1xuICAgIHJldHVybiAkLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnVuY3Rpb24oKXtcbiAgICAgICAgdXBkYXRlRnVuYyggdmlld2VyICk7XG4gICAgfSApO1xufVxuXG5cbi8vcHJvdmlkZXMgYSBzZXF1ZW5jZSBpbiB0aGUgZmFkZSBhbmltYXRpb25cbmZ1bmN0aW9uIHNjaGVkdWxlQ29udHJvbHNGYWRlKCB2aWV3ZXIgKSB7XG4gICAgJC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZ1bmN0aW9uKCl7XG4gICAgICAgIHVwZGF0ZUNvbnRyb2xzRmFkZSggdmlld2VyICk7XG4gICAgfSk7XG59XG5cblxuLy9pbml0aWF0ZXMgYW4gYW5pbWF0aW9uIHRvIGhpZGUgdGhlIGNvbnRyb2xzXG5mdW5jdGlvbiBiZWdpbkNvbnRyb2xzQXV0b0hpZGUoIHZpZXdlciApIHtcbiAgICBpZiAoICF2aWV3ZXIuYXV0b0hpZGVDb250cm9scyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aWV3ZXIuY29udHJvbHNTaG91bGRGYWRlID0gdHJ1ZTtcbiAgICB2aWV3ZXIuY29udHJvbHNGYWRlQmVnaW5UaW1lID1cbiAgICAgICAgJC5ub3coKSArXG4gICAgICAgIHZpZXdlci5jb250cm9sc0ZhZGVEZWxheTtcblxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgICBzY2hlZHVsZUNvbnRyb2xzRmFkZSggdmlld2VyICk7XG4gICAgfSwgdmlld2VyLmNvbnRyb2xzRmFkZURlbGF5ICk7XG59XG5cblxuLy9kZXRlcm1pbmVzIGlmIGZhZGUgYW5pbWF0aW9uIGlzIGRvbmUgb3IgY29udGludWVzIHRoZSBhbmltYXRpb25cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xzRmFkZSggdmlld2VyICkge1xuICAgIHZhciBjdXJyZW50VGltZSxcbiAgICAgICAgZGVsdGFUaW1lLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBpO1xuICAgIGlmICggdmlld2VyLmNvbnRyb2xzU2hvdWxkRmFkZSApIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSAkLm5vdygpO1xuICAgICAgICBkZWx0YVRpbWUgPSBjdXJyZW50VGltZSAtIHZpZXdlci5jb250cm9sc0ZhZGVCZWdpblRpbWU7XG4gICAgICAgIG9wYWNpdHkgPSAxLjAgLSBkZWx0YVRpbWUgLyB2aWV3ZXIuY29udHJvbHNGYWRlTGVuZ3RoO1xuXG4gICAgICAgIG9wYWNpdHkgPSBNYXRoLm1pbiggMS4wLCBvcGFjaXR5ICk7XG4gICAgICAgIG9wYWNpdHkgPSBNYXRoLm1heCggMC4wLCBvcGFjaXR5ICk7XG5cbiAgICAgICAgZm9yICggaSA9IHZpZXdlci5jb250cm9scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHZpZXdlci5jb250cm9sc1sgaSBdLmF1dG9GYWRlKSB7XG4gICAgICAgICAgICAgICAgdmlld2VyLmNvbnRyb2xzWyBpIF0uc2V0T3BhY2l0eSggb3BhY2l0eSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvcGFjaXR5ID4gMCApIHtcbiAgICAgICAgICAgIC8vIGZhZGUgYWdhaW5cbiAgICAgICAgICAgIHNjaGVkdWxlQ29udHJvbHNGYWRlKCB2aWV3ZXIgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vL3N0b3AgdGhlIGZhZGUgYW5pbWF0aW9uIG9uIHRoZSBjb250cm9scyBhbmQgc2hvdyB0aGVtXG5mdW5jdGlvbiBhYm9ydENvbnRyb2xzQXV0b0hpZGUoIHZpZXdlciApIHtcbiAgICB2YXIgaTtcbiAgICB2aWV3ZXIuY29udHJvbHNTaG91bGRGYWRlID0gZmFsc2U7XG4gICAgZm9yICggaSA9IHZpZXdlci5jb250cm9scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgdmlld2VyLmNvbnRyb2xzWyBpIF0uc2V0T3BhY2l0eSggMS4wICk7XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGVmYXVsdCB2aWV3IGV2ZW50IGhhbmRsZXJzLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gb25Gb2N1cygpe1xuICAgIGFib3J0Q29udHJvbHNBdXRvSGlkZSggdGhpcyApO1xufVxuXG5mdW5jdGlvbiBvbkJsdXIoKXtcbiAgICBiZWdpbkNvbnRyb2xzQXV0b0hpZGUoIHRoaXMgKTtcblxufVxuXG5mdW5jdGlvbiBvbkNhbnZhc0tleURvd24oIGV2ZW50ICkge1xuICAgIGlmICggIWV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uICYmICFldmVudC5jdHJsICYmICFldmVudC5hbHQgJiYgIWV2ZW50Lm1ldGEgKSB7XG4gICAgICAgIHN3aXRjaCggZXZlbnQua2V5Q29kZSApe1xuICAgICAgICAgICAgY2FzZSAzODovL3VwIGFycm93XG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC5zaGlmdCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoMS4xKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKG5ldyAkLlBvaW50KDAsIC00MCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSA0MDovL2Rvd24gYXJyb3dcbiAgICAgICAgICAgICAgICBpZiAoIGV2ZW50LnNoaWZ0ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeSgwLjkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucGFuQnkodGhpcy52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMobmV3ICQuUG9pbnQoMCwgNDApKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMzc6Ly9sZWZ0IGFycm93XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wYW5CeSh0aGlzLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhuZXcgJC5Qb2ludCgtNDAsIDApKSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAzOTovL3JpZ2h0IGFycm93XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wYW5CeSh0aGlzLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhuZXcgJC5Qb2ludCg0MCwgMCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coICduYXZpZ2F0b3Iga2V5Y29kZSAlcycsIGV2ZW50LmtleUNvZGUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25DYW52YXNLZXlQcmVzcyggZXZlbnQgKSB7XG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgIWV2ZW50LmN0cmwgJiYgIWV2ZW50LmFsdCAmJiAhZXZlbnQubWV0YSApIHtcbiAgICAgICAgc3dpdGNoKCBldmVudC5rZXlDb2RlICl7XG4gICAgICAgICAgICBjYXNlIDQzOi8vPXwrXG4gICAgICAgICAgICBjYXNlIDYxOi8vPXwrXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoMS4xKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDQ1Oi8vLXxfXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoMC45KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDQ4Oi8vMHwpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5nb0hvbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDExOTovL3dcbiAgICAgICAgICAgIGNhc2UgODc6Ly9XXG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC5zaGlmdCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoMS4xKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKG5ldyAkLlBvaW50KDAsIC00MCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxMTU6Ly9zXG4gICAgICAgICAgICBjYXNlIDgzOi8vU1xuICAgICAgICAgICAgICAgIGlmICggZXZlbnQuc2hpZnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuem9vbUJ5KDAuOSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wYW5CeSh0aGlzLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhuZXcgJC5Qb2ludCgwLCA0MCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSA5NzovL2FcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKG5ldyAkLlBvaW50KC00MCwgMCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDEwMDovL2RcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKG5ldyAkLlBvaW50KDQwLCAwKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ25hdmlnYXRvciBrZXljb2RlICVzJywgZXZlbnQua2V5Q29kZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvbkNhbnZhc0NsaWNrKCBldmVudCApIHtcbiAgICB2YXIgZ2VzdHVyZVNldHRpbmdzO1xuXG4gICAgdmFyIGhhdmVLZXlib2FyZEZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNhbnZhcztcblxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUga2V5Ym9hcmQgZm9jdXMsIHJlcXVlc3QgaXQuXG4gICAgaWYgKCAhaGF2ZUtleWJvYXJkRm9jdXMgKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgdGhpcy52aWV3cG9ydCAmJiBldmVudC5xdWljayApIHtcbiAgICAgICAgZ2VzdHVyZVNldHRpbmdzID0gdGhpcy5nZXN0dXJlU2V0dGluZ3NCeURldmljZVR5cGUoIGV2ZW50LnBvaW50ZXJUeXBlICk7XG4gICAgICAgIGlmICggZ2VzdHVyZVNldHRpbmdzLmNsaWNrVG9ab29tICkge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoXG4gICAgICAgICAgICAgICAgZXZlbnQuc2hpZnQgPyAxLjAgLyB0aGlzLnpvb21QZXJDbGljayA6IHRoaXMuem9vbVBlckNsaWNrLFxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucG9pbnRGcm9tUGl4ZWwoIGV2ZW50LnBvc2l0aW9uLCB0cnVlIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiBhIG1vdXNlIHByZXNzL3JlbGVhc2Ugb3IgdG91Y2gvcmVtb3ZlIG9jY3VycyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtY2xpY2tcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHF1aWNrIC0gVHJ1ZSBvbmx5IGlmIHRoZSBjbGlja0Rpc3RUaHJlc2hvbGQgYW5kIGNsaWNrVGltZVRocmVzaG9sZCBhcmUgYm90aCBwYXNzZWQuIFVzZWZ1bCBmb3IgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gY2xpY2tzIGFuZCBkcmFncy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNoaWZ0IC0gVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLWNsaWNrJywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBxdWljazogZXZlbnQucXVpY2ssXG4gICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvbkNhbnZhc0RibENsaWNrKCBldmVudCApIHtcbiAgICB2YXIgZ2VzdHVyZVNldHRpbmdzO1xuXG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgZ2VzdHVyZVNldHRpbmdzID0gdGhpcy5nZXN0dXJlU2V0dGluZ3NCeURldmljZVR5cGUoIGV2ZW50LnBvaW50ZXJUeXBlICk7XG4gICAgICAgIGlmICggZ2VzdHVyZVNldHRpbmdzLmRibENsaWNrVG9ab29tICkge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoXG4gICAgICAgICAgICAgICAgZXZlbnQuc2hpZnQgPyAxLjAgLyB0aGlzLnpvb21QZXJDbGljayA6IHRoaXMuem9vbVBlckNsaWNrLFxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucG9pbnRGcm9tUGl4ZWwoIGV2ZW50LnBvc2l0aW9uLCB0cnVlIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiBhIGRvdWJsZSBtb3VzZSBwcmVzcy9yZWxlYXNlIG9yIHRvdWNoL3JlbW92ZSBvY2N1cnMgb24gdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjYW52YXN9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLWRvdWJsZS1jbGlja1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hpZnQgLSBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjYW52YXMtZG91YmxlLWNsaWNrJywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnQsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNEcmFnKCBldmVudCApIHtcbiAgICB2YXIgZ2VzdHVyZVNldHRpbmdzO1xuXG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgZ2VzdHVyZVNldHRpbmdzID0gdGhpcy5nZXN0dXJlU2V0dGluZ3NCeURldmljZVR5cGUoIGV2ZW50LnBvaW50ZXJUeXBlICk7XG4gICAgICAgIGlmKCAhdGhpcy5wYW5Ib3Jpem9udGFsICl7XG4gICAgICAgICAgICBldmVudC5kZWx0YS54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiggIXRoaXMucGFuVmVydGljYWwgKXtcbiAgICAgICAgICAgIGV2ZW50LmRlbHRhLnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnQucGFuQnkoIHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKCBldmVudC5kZWx0YS5uZWdhdGUoKSApLCBnZXN0dXJlU2V0dGluZ3MuZmxpY2tFbmFibGVkICk7XG4gICAgICAgIGlmKCB0aGlzLmNvbnN0cmFpbkR1cmluZ1BhbiApe1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gYSBtb3VzZSBvciB0b3VjaCBkcmFnIG9wZXJhdGlvbiBvY2N1cnMgb24gdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjYW52YXN9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLWRyYWdcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IGRlbHRhIC0gVGhlIHgseSBjb21wb25lbnRzIG9mIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc3RhcnQgZHJhZyBhbmQgZW5kIGRyYWcuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNwZWVkIC0gQ3VycmVudCBjb21wdXRlZCBzcGVlZCwgaW4gcGl4ZWxzIHBlciBzZWNvbmQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRpcmVjdGlvbiAtIEN1cnJlbnQgY29tcHV0ZWQgZGlyZWN0aW9uLCBleHByZXNzZWQgYXMgYW4gYW5nbGUgY291bnRlcmNsb2Nrd2lzZSByZWxhdGl2ZSB0byB0aGUgcG9zaXRpdmUgWCBheGlzICgtcGkgdG8gcGksIGluIHJhZGlhbnMpLiBPbmx5IHZhbGlkIGlmIHNwZWVkID4gMC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNoaWZ0IC0gVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLWRyYWcnLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIGRlbHRhOiBldmVudC5kZWx0YSxcbiAgICAgICAgc3BlZWQ6IGV2ZW50LnNwZWVkLFxuICAgICAgICBkaXJlY3Rpb246IGV2ZW50LmRpcmVjdGlvbixcbiAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzRHJhZ0VuZCggZXZlbnQgKSB7XG4gICAgaWYgKCFldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvbiAmJiB0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgIHZhciBnZXN0dXJlU2V0dGluZ3MgPSB0aGlzLmdlc3R1cmVTZXR0aW5nc0J5RGV2aWNlVHlwZShldmVudC5wb2ludGVyVHlwZSk7XG4gICAgICAgIGlmIChnZXN0dXJlU2V0dGluZ3MuZmxpY2tFbmFibGVkICYmXG4gICAgICAgICAgICBldmVudC5zcGVlZCA+PSBnZXN0dXJlU2V0dGluZ3MuZmxpY2tNaW5TcGVlZCkge1xuICAgICAgICAgICAgdmFyIGFtcGxpdHVkZVggPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFuSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGFtcGxpdHVkZVggPSBnZXN0dXJlU2V0dGluZ3MuZmxpY2tNb21lbnR1bSAqIGV2ZW50LnNwZWVkICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3MoZXZlbnQuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhbXBsaXR1ZGVZID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhblZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgYW1wbGl0dWRlWSA9IGdlc3R1cmVTZXR0aW5ncy5mbGlja01vbWVudHVtICogZXZlbnQuc3BlZWQgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbihldmVudC5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMudmlld3BvcnQucGl4ZWxGcm9tUG9pbnQoXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIodHJ1ZSkpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudmlld3BvcnQucG9pbnRGcm9tUGl4ZWwoXG4gICAgICAgICAgICAgICAgbmV3ICQuUG9pbnQoY2VudGVyLnggLSBhbXBsaXR1ZGVYLCBjZW50ZXIueSAtIGFtcGxpdHVkZVkpKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQucGFuVG8odGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGEgbW91c2Ugb3IgdG91Y2ggZHJhZyBvcGVyYXRpb24gZW5kcyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtZHJhZy1lbmRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3BlZWQgLSBTcGVlZCBhdCB0aGUgZW5kIG9mIGEgZHJhZyBnZXN0dXJlLCBpbiBwaXhlbHMgcGVyIHNlY29uZC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZGlyZWN0aW9uIC0gRGlyZWN0aW9uIGF0IHRoZSBlbmQgb2YgYSBkcmFnIGdlc3R1cmUsIGV4cHJlc3NlZCBhcyBhbiBhbmdsZSBjb3VudGVyY2xvY2t3aXNlIHJlbGF0aXZlIHRvIHRoZSBwb3NpdGl2ZSBYIGF4aXMgKC1waSB0byBwaSwgaW4gcmFkaWFucykuIE9ubHkgdmFsaWQgaWYgc3BlZWQgPiAwLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hpZnQgLSBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoJ2NhbnZhcy1kcmFnLWVuZCcsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgc3BlZWQ6IGV2ZW50LnNwZWVkLFxuICAgICAgICBkaXJlY3Rpb246IGV2ZW50LmRpcmVjdGlvbixcbiAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzRW50ZXIoIGV2ZW50ICkge1xuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGEgcG9pbnRlciBlbnRlcnMgdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjYW52YXN9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLWVudGVyXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgd2hpY2ggb3JpZ2luYXRlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwb2ludGVyVHlwZSAtIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYnV0dG9ucyAtIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLiBBIGNvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHBvaW50ZXJzIC0gTnVtYmVyIG9mIHBvaW50ZXJzIChhbGwgdHlwZXMpIGFjdGl2ZSBpbiB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW5zaWRlRWxlbWVudFByZXNzZWQgLSBUcnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgd2FzIGluaXRpYXRlZCBpbnNpZGUgdGhlIHRyYWNrZWQgZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYnV0dG9uRG93bkFueSAtIFdhcyB0aGUgYnV0dG9uIGRvd24gYW55d2hlcmUgaW4gdGhlIHNjcmVlbiBkdXJpbmcgdGhlIGV2ZW50LiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgYnV0dG9ucyBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCggJ2NhbnZhcy1lbnRlcicsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBidXR0b25zOiBldmVudC5idXR0b25zLFxuICAgICAgICBwb2ludGVyczogZXZlbnQucG9pbnRlcnMsXG4gICAgICAgIGluc2lkZUVsZW1lbnRQcmVzc2VkOiBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCxcbiAgICAgICAgYnV0dG9uRG93bkFueTogZXZlbnQuYnV0dG9uRG93bkFueSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvbkNhbnZhc0V4aXQoIGV2ZW50ICkge1xuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGEgcG9pbnRlciBsZWF2ZXMgdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjYW52YXN9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLWV4aXRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBvaW50ZXJUeXBlIC0gXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBidXR0b25zIC0gQ3VycmVudCBidXR0b25zIHByZXNzZWQuIEEgY29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcG9pbnRlcnMgLSBOdW1iZXIgb2YgcG9pbnRlcnMgKGFsbCB0eXBlcykgYWN0aXZlIGluIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbnNpZGVFbGVtZW50UHJlc3NlZCAtIFRydWUgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB3YXMgaW5pdGlhdGVkIGluc2lkZSB0aGUgdHJhY2tlZCBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBidXR0b25Eb3duQW55IC0gV2FzIHRoZSBidXR0b24gZG93biBhbnl3aGVyZSBpbiB0aGUgc2NyZWVuIGR1cmluZyB0aGUgZXZlbnQuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBidXR0b25zIGluc3RlYWQuPC9zcGFuPlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLWV4aXQnLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb2ludGVyVHlwZTogZXZlbnQucG9pbnRlclR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgYnV0dG9uczogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgcG9pbnRlcnM6IGV2ZW50LnBvaW50ZXJzLFxuICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQsXG4gICAgICAgIGJ1dHRvbkRvd25Bbnk6IGV2ZW50LmJ1dHRvbkRvd25BbnksXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNQcmVzcyggZXZlbnQgKSB7XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gdGhlIHByaW1hcnkgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgb3IgdG91Y2ggc3RhcnRzIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY2FudmFzfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy1wcmVzc1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcG9pbnRlclR5cGUgLSBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbnNpZGVFbGVtZW50UHJlc3NlZCAtIFRydWUgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB3YXMgaW5pdGlhdGVkIGluc2lkZSB0aGUgdHJhY2tlZCBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbnNpZGVFbGVtZW50UmVsZWFzZWQgLSBUcnVlIGlmIHRoZSBjdXJzb3Igc3RpbGwgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQgd2hlbiB0aGUgYnV0dG9uIHdhcyByZWxlYXNlZC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCggJ2NhbnZhcy1wcmVzcycsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQsXG4gICAgICAgIGluc2lkZUVsZW1lbnRSZWxlYXNlZDogZXZlbnQuaW5zaWRlRWxlbWVudFJlbGVhc2VkLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzUmVsZWFzZSggZXZlbnQgKSB7XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gdGhlIHByaW1hcnkgbW91c2UgYnV0dG9uIGlzIHJlbGVhc2VkIG9yIHRvdWNoIGVuZHMgb24gdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjYW52YXN9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLXJlbGVhc2VcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBvaW50ZXJUeXBlIC0gXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW5zaWRlRWxlbWVudFByZXNzZWQgLSBUcnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgd2FzIGluaXRpYXRlZCBpbnNpZGUgdGhlIHRyYWNrZWQgZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW5zaWRlRWxlbWVudFJlbGVhc2VkIC0gVHJ1ZSBpZiB0aGUgY3Vyc29yIHN0aWxsIGluc2lkZSB0aGUgdHJhY2tlZCBlbGVtZW50IHdoZW4gdGhlIGJ1dHRvbiB3YXMgcmVsZWFzZWQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjYW52YXMtcmVsZWFzZScsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQsXG4gICAgICAgIGluc2lkZUVsZW1lbnRSZWxlYXNlZDogZXZlbnQuaW5zaWRlRWxlbWVudFJlbGVhc2VkLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzTm9uUHJpbWFyeVByZXNzKCBldmVudCApIHtcbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiBhbnkgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gaXMgcHJlc3NlZCBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtbm9ucHJpbWFyeS1wcmVzc1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwb2ludGVyVHlwZSAtIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJ1dHRvbiAtIEJ1dHRvbiB3aGljaCBjYXVzZWQgdGhlIGV2ZW50LlxuICAgICAqICAgICAgLTE6IG5vbmUsIDA6IHByaW1hcnkvbGVmdCwgMTogYXV4L21pZGRsZSwgMjogc2Vjb25kYXJ5L3JpZ2h0LCAzOiBYMS9iYWNrLCA0OiBYMi9mb3J3YXJkLCA1OiBwZW4gZXJhc2VyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBidXR0b25zIC0gQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLW5vbnByaW1hcnktcHJlc3MnLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICAgIGJ1dHRvbnM6IGV2ZW50LmJ1dHRvbnMsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNOb25QcmltYXJ5UmVsZWFzZSggZXZlbnQgKSB7XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gYW55IG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uIGlzIHJlbGVhc2VkIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY2FudmFzfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy1ub25wcmltYXJ5LXJlbGVhc2VcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcG9pbnRlclR5cGUgLSBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBidXR0b24gLSBCdXR0b24gd2hpY2ggY2F1c2VkIHRoZSBldmVudC5cbiAgICAgKiAgICAgIC0xOiBub25lLCAwOiBwcmltYXJ5L2xlZnQsIDE6IGF1eC9taWRkbGUsIDI6IHNlY29uZGFyeS9yaWdodCwgMzogWDEvYmFjaywgNDogWDIvZm9yd2FyZCwgNTogcGVuIGVyYXNlci5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYnV0dG9ucyAtIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLlxuICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCggJ2NhbnZhcy1ub25wcmltYXJ5LXJlbGVhc2UnLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICAgIGJ1dHRvbnM6IGV2ZW50LmJ1dHRvbnMsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNQaW5jaCggZXZlbnQgKSB7XG4gICAgdmFyIGdlc3R1cmVTZXR0aW5ncyxcbiAgICAgICAgY2VudGVyUHQsXG4gICAgICAgIGxhc3RDZW50ZXJQdCxcbiAgICAgICAgcGFuQnlQdDtcblxuICAgIGlmICggIWV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uICYmIHRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgIGdlc3R1cmVTZXR0aW5ncyA9IHRoaXMuZ2VzdHVyZVNldHRpbmdzQnlEZXZpY2VUeXBlKCBldmVudC5wb2ludGVyVHlwZSApO1xuICAgICAgICBpZiAoIGdlc3R1cmVTZXR0aW5ncy5waW5jaFRvWm9vbSApIHtcbiAgICAgICAgICAgIGNlbnRlclB0ID0gdGhpcy52aWV3cG9ydC5wb2ludEZyb21QaXhlbCggZXZlbnQuY2VudGVyLCB0cnVlICk7XG4gICAgICAgICAgICBsYXN0Q2VudGVyUHQgPSB0aGlzLnZpZXdwb3J0LnBvaW50RnJvbVBpeGVsKCBldmVudC5sYXN0Q2VudGVyLCB0cnVlICk7XG4gICAgICAgICAgICBwYW5CeVB0ID0gbGFzdENlbnRlclB0Lm1pbnVzKCBjZW50ZXJQdCApO1xuICAgICAgICAgICAgaWYoICF0aGlzLnBhbkhvcml6b250YWwgKSB7XG4gICAgICAgICAgICAgICAgcGFuQnlQdC54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCAhdGhpcy5wYW5WZXJ0aWNhbCApIHtcbiAgICAgICAgICAgICAgICBwYW5CeVB0LnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoIGV2ZW50LmRpc3RhbmNlIC8gZXZlbnQubGFzdERpc3RhbmNlLCBjZW50ZXJQdCwgdHJ1ZSApO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wYW5CeSggcGFuQnlQdCwgdHJ1ZSApO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBnZXN0dXJlU2V0dGluZ3MucGluY2hSb3RhdGUgKSB7XG4gICAgICAgICAgICAvLyBQaW5jaCByb3RhdGVcbiAgICAgICAgICAgIHZhciBhbmdsZTEgPSBNYXRoLmF0YW4yKGV2ZW50Lmdlc3R1cmVQb2ludHNbMF0uY3VycmVudFBvcy55IC0gZXZlbnQuZ2VzdHVyZVBvaW50c1sxXS5jdXJyZW50UG9zLnksXG4gICAgICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZVBvaW50c1swXS5jdXJyZW50UG9zLnggLSBldmVudC5nZXN0dXJlUG9pbnRzWzFdLmN1cnJlbnRQb3MueCk7XG4gICAgICAgICAgICB2YXIgYW5nbGUyID0gTWF0aC5hdGFuMihldmVudC5nZXN0dXJlUG9pbnRzWzBdLmxhc3RQb3MueSAtIGV2ZW50Lmdlc3R1cmVQb2ludHNbMV0ubGFzdFBvcy55LFxuICAgICAgICAgICAgICAgIGV2ZW50Lmdlc3R1cmVQb2ludHNbMF0ubGFzdFBvcy54IC0gZXZlbnQuZ2VzdHVyZVBvaW50c1sxXS5sYXN0UG9zLngpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRSb3RhdGlvbih0aGlzLnZpZXdwb3J0LmdldFJvdGF0aW9uKCkgKyAoKGFuZ2xlMSAtIGFuZ2xlMikgKiAoMTgwIC8gTWF0aC5QSSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiBhIHBpbmNoIGV2ZW50IG9jY3VycyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtcGluY2hcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50Pn0gZ2VzdHVyZVBvaW50cyAtIEdlc3R1cmUgcG9pbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2VzdHVyZS4gVmVsb2NpdHkgZGF0YSBjYW4gYmUgZm91bmQgaGVyZS5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IGxhc3RDZW50ZXIgLSBUaGUgcHJldmlvdXMgY2VudGVyIHBvaW50IG9mIHRoZSB0d28gcGluY2ggY29udGFjdCBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IGNlbnRlciAtIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIHR3byBwaW5jaCBjb250YWN0IHBvaW50cyByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXN0RGlzdGFuY2UgLSBUaGUgcHJldmlvdXMgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBpbmNoIGNvbnRhY3QgcG9pbnRzIGluIENTUyBwaXhlbHMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRpc3RhbmNlIC0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwaW5jaCBjb250YWN0IHBvaW50cyBpbiBDU1MgcGl4ZWxzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hpZnQgLSBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoJ2NhbnZhcy1waW5jaCcsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIGdlc3R1cmVQb2ludHM6IGV2ZW50Lmdlc3R1cmVQb2ludHMsXG4gICAgICAgIGxhc3RDZW50ZXI6IGV2ZW50Lmxhc3RDZW50ZXIsXG4gICAgICAgIGNlbnRlcjogZXZlbnQuY2VudGVyLFxuICAgICAgICBsYXN0RGlzdGFuY2U6IGV2ZW50Lmxhc3REaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2U6IGV2ZW50LmRpc3RhbmNlLFxuICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnQsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbiAgICAvL2NhbmNlbHMgZXZlbnRcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzU2Nyb2xsKCBldmVudCApIHtcbiAgICB2YXIgZ2VzdHVyZVNldHRpbmdzLFxuICAgICAgICBmYWN0b3IsXG4gICAgICAgIHRoaXNTY3JvbGxUaW1lLFxuICAgICAgICBkZWx0YVNjcm9sbFRpbWU7XG5cbiAgICAvKiBDZXJ0YWluIHNjcm9sbCBkZXZpY2VzIGZpcmUgdGhlIHNjcm9sbCBldmVudCB3YXkgdG9vIGZhc3Qgc28gd2UgYXJlIGluamVjdGluZyBhIHNpbXBsZSBhZGp1c3RtZW50IHRvIGtlZXAgdGhpbmdzXG4gICAgICogcGFydGlhbGx5IG5vcm1hbGl6ZWQuIElmIHdlIGhhdmUgYWxyZWFkeSBmaXJlZCBhbiBldmVudCB3aXRoaW4gdGhlIGxhc3QgJ21pblNjcm9sbERlbHRhJyBtaWxsaXNlY29uZHMgd2Ugc2tpcFxuICAgICAqIHRoaXMgb25lIGFuZCB3YWl0IGZvciB0aGUgbmV4dCBldmVudC4gKi9cbiAgICB0aGlzU2Nyb2xsVGltZSA9ICQubm93KCk7XG4gICAgZGVsdGFTY3JvbGxUaW1lID0gdGhpc1Njcm9sbFRpbWUgLSB0aGlzLl9sYXN0U2Nyb2xsVGltZTtcbiAgICBpZiAoZGVsdGFTY3JvbGxUaW1lID4gdGhpcy5taW5TY3JvbGxEZWx0YVRpbWUpIHtcbiAgICAgICAgdGhpcy5fbGFzdFNjcm9sbFRpbWUgPSB0aGlzU2Nyb2xsVGltZTtcblxuICAgICAgICBpZiAoICFldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvbiAmJiB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICAgICAgZ2VzdHVyZVNldHRpbmdzID0gdGhpcy5nZXN0dXJlU2V0dGluZ3NCeURldmljZVR5cGUoIGV2ZW50LnBvaW50ZXJUeXBlICk7XG4gICAgICAgICAgICBpZiAoIGdlc3R1cmVTZXR0aW5ncy5zY3JvbGxUb1pvb20gKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID0gTWF0aC5wb3coIHRoaXMuem9vbVBlclNjcm9sbCwgZXZlbnQuc2Nyb2xsICk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wb2ludEZyb21QaXhlbCggZXZlbnQucG9zaXRpb24sIHRydWUgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIGEgc2Nyb2xsIGV2ZW50IG9jY3VycyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudCAobW91c2Ugd2hlZWwpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgY2FudmFzLXNjcm9sbFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGwgLSBUaGUgc2Nyb2xsIGRlbHRhIGZvciB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hpZnQgLSBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLXNjcm9sbCcsIHtcbiAgICAgICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICAgICAgc2Nyb2xsOiBldmVudC5zY3JvbGwsXG4gICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnQsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZ2VzdHVyZVNldHRpbmdzICYmIGdlc3R1cmVTZXR0aW5ncy5zY3JvbGxUb1pvb20pIHtcbiAgICAgICAgICAgIC8vY2FuY2VscyBldmVudFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXN0dXJlU2V0dGluZ3MgPSB0aGlzLmdlc3R1cmVTZXR0aW5nc0J5RGV2aWNlVHlwZSggZXZlbnQucG9pbnRlclR5cGUgKTtcbiAgICAgICAgaWYgKGdlc3R1cmVTZXR0aW5ncyAmJiBnZXN0dXJlU2V0dGluZ3Muc2Nyb2xsVG9ab29tKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7ICAgLy8gV2UgYXJlIHN3YWxsb3dpbmcgdGhpcyBldmVudFxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbnRhaW5lckVudGVyKCBldmVudCApIHtcbiAgICBUSElTWyB0aGlzLmhhc2ggXS5tb3VzZUluc2lkZSA9IHRydWU7XG4gICAgYWJvcnRDb250cm9sc0F1dG9IaWRlKCB0aGlzICk7XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gdGhlIGN1cnNvciBlbnRlcnMgdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjb250YWluZXJ9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY29udGFpbmVyLWVudGVyXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgd2hpY2ggb3JpZ2luYXRlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJ1dHRvbnMgLSBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC4gQSBjb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwb2ludGVycyAtIE51bWJlciBvZiBwb2ludGVycyAoYWxsIHR5cGVzKSBhY3RpdmUgaW4gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGluc2lkZUVsZW1lbnRQcmVzc2VkIC0gVHJ1ZSBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYW5kIHdhcyBpbml0aWF0ZWQgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ1dHRvbkRvd25BbnkgLSBXYXMgdGhlIGJ1dHRvbiBkb3duIGFueXdoZXJlIGluIHRoZSBzY3JlZW4gZHVyaW5nIHRoZSBldmVudC4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIGJ1dHRvbnMgaW5zdGVhZC48L3NwYW4+XG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjb250YWluZXItZW50ZXInLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIGJ1dHRvbnM6IGV2ZW50LmJ1dHRvbnMsXG4gICAgICAgIHBvaW50ZXJzOiBldmVudC5wb2ludGVycyxcbiAgICAgICAgaW5zaWRlRWxlbWVudFByZXNzZWQ6IGV2ZW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkLFxuICAgICAgICBidXR0b25Eb3duQW55OiBldmVudC5idXR0b25Eb3duQW55LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ29udGFpbmVyRXhpdCggZXZlbnQgKSB7XG4gICAgaWYgKCBldmVudC5wb2ludGVycyA8IDEgKSB7XG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLm1vdXNlSW5zaWRlID0gZmFsc2U7XG4gICAgICAgIGlmICggIVRISVNbIHRoaXMuaGFzaCBdLmFuaW1hdGluZyApIHtcbiAgICAgICAgICAgIGJlZ2luQ29udHJvbHNBdXRvSGlkZSggdGhpcyApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIHRoZSBjdXJzb3IgbGVhdmVzIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY29udGFpbmVyfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNvbnRhaW5lci1leGl0XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgd2hpY2ggb3JpZ2luYXRlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJ1dHRvbnMgLSBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC4gQSBjb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwb2ludGVycyAtIE51bWJlciBvZiBwb2ludGVycyAoYWxsIHR5cGVzKSBhY3RpdmUgaW4gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGluc2lkZUVsZW1lbnRQcmVzc2VkIC0gVHJ1ZSBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYW5kIHdhcyBpbml0aWF0ZWQgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ1dHRvbkRvd25BbnkgLSBXYXMgdGhlIGJ1dHRvbiBkb3duIGFueXdoZXJlIGluIHRoZSBzY3JlZW4gZHVyaW5nIHRoZSBldmVudC4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIGJ1dHRvbnMgaW5zdGVhZC48L3NwYW4+XG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjb250YWluZXItZXhpdCcsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgYnV0dG9uczogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgcG9pbnRlcnM6IGV2ZW50LnBvaW50ZXJzLFxuICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQsXG4gICAgICAgIGJ1dHRvbkRvd25Bbnk6IGV2ZW50LmJ1dHRvbkRvd25BbnksXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQYWdlIHVwZGF0ZSByb3V0aW5lcyAoIGFrYSBWaWV3cyAtIGZvciBmdXR1cmUgcmVmZXJlbmNlIClcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gdXBkYXRlTXVsdGkoIHZpZXdlciApIHtcbiAgICB1cGRhdGVPbmNlKCB2aWV3ZXIgKTtcblxuICAgIC8vIFJlcXVlc3QgdGhlIG5leHQgZnJhbWUsIHVubGVzcyB3ZSd2ZSBiZWVuIGNsb3NlZFxuICAgIGlmICggdmlld2VyLmlzT3BlbigpICkge1xuICAgICAgICB2aWV3ZXIuX3VwZGF0ZVJlcXVlc3RJZCA9IHNjaGVkdWxlVXBkYXRlKCB2aWV3ZXIsIHVwZGF0ZU11bHRpICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmlld2VyLl91cGRhdGVSZXF1ZXN0SWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9uY2UoIHZpZXdlciApIHtcblxuICAgIC8vdmlld2VyLnByb2ZpbGVyLmJlZ2luVXBkYXRlKCk7XG5cbiAgICBpZiAodmlld2VyLl9vcGVuaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmlld2VyLmF1dG9SZXNpemUpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclNpemUgPSBfZ2V0U2FmZUVsZW1TaXplKHZpZXdlci5jb250YWluZXIpO1xuICAgICAgICB2YXIgcHJldkNvbnRhaW5lclNpemUgPSBUSElTW3ZpZXdlci5oYXNoXS5wcmV2Q29udGFpbmVyU2l6ZTtcbiAgICAgICAgaWYgKCFjb250YWluZXJTaXplLmVxdWFscyhwcmV2Q29udGFpbmVyU2l6ZSkpIHtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydCA9IHZpZXdlci52aWV3cG9ydDtcbiAgICAgICAgICAgIGlmICh2aWV3ZXIucHJlc2VydmVJbWFnZVNpemVPblJlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXNpemVSYXRpbyA9IHByZXZDb250YWluZXJTaXplLnggLyBjb250YWluZXJTaXplLng7XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSB2aWV3cG9ydC5nZXRab29tKCkgKiByZXNpemVSYXRpbztcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gdmlld3BvcnQuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQucmVzaXplKGNvbnRhaW5lclNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC56b29tVG8oem9vbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQucGFuVG8oY2VudGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbWFpbnRhaW4gaW1hZ2UgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgb2xkQm91bmRzID0gdmlld3BvcnQuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQucmVzaXplKGNvbnRhaW5lclNpemUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmZpdEJvdW5kc1dpdGhDb25zdHJhaW50cyhvbGRCb3VuZHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVEhJU1t2aWV3ZXIuaGFzaF0ucHJldkNvbnRhaW5lclNpemUgPSBjb250YWluZXJTaXplO1xuICAgICAgICAgICAgVEhJU1t2aWV3ZXIuaGFzaF0uZm9yY2VSZWRyYXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZXdwb3J0Q2hhbmdlID0gdmlld2VyLnZpZXdwb3J0LnVwZGF0ZSgpO1xuICAgIHZhciBhbmltYXRlZCA9IHZpZXdlci53b3JsZC51cGRhdGUoKSB8fCB2aWV3cG9ydENoYW5nZTtcblxuICAgIGlmICh2aWV3cG9ydENoYW5nZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gYW55IHNwcmluZyBhbmltYXRpb24gdXBkYXRlIG9jY3VycyAoem9vbSwgcGFuLCBldGMuKSxcbiAgICAgICAgICogYmVmb3JlIHRoZSB2aWV3ZXIgaGFzIGRyYXduIHRoZSBuZXcgbG9jYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCB2aWV3cG9ydC1jaGFuZ2VcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmlld2VyLnJhaXNlRXZlbnQoJ3ZpZXdwb3J0LWNoYW5nZScpO1xuICAgIH1cblxuICAgIGlmKCB2aWV3ZXIucmVmZXJlbmNlU3RyaXAgKXtcbiAgICAgICAgYW5pbWF0ZWQgPSB2aWV3ZXIucmVmZXJlbmNlU3RyaXAudXBkYXRlKCB2aWV3ZXIudmlld3BvcnQgKSB8fCBhbmltYXRlZDtcbiAgICB9XG5cbiAgICBpZiAoICFUSElTWyB2aWV3ZXIuaGFzaCBdLmFuaW1hdGluZyAmJiBhbmltYXRlZCApIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIGFueSBzcHJpbmcgYW5pbWF0aW9uIHN0YXJ0cyAoem9vbSwgcGFuLCBldGMuKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGFuaW1hdGlvbi1zdGFydFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB2aWV3ZXIucmFpc2VFdmVudCggXCJhbmltYXRpb24tc3RhcnRcIiApO1xuICAgICAgICBhYm9ydENvbnRyb2xzQXV0b0hpZGUoIHZpZXdlciApO1xuICAgIH1cblxuICAgIGlmICggYW5pbWF0ZWQgfHwgVEhJU1sgdmlld2VyLmhhc2ggXS5mb3JjZVJlZHJhdyB8fCB2aWV3ZXIud29ybGQubmVlZHNEcmF3KCkgKSB7XG4gICAgICAgIGRyYXdXb3JsZCggdmlld2VyICk7XG4gICAgICAgIHZpZXdlci5fZHJhd092ZXJsYXlzKCk7XG4gICAgICAgIGlmKCB2aWV3ZXIubmF2aWdhdG9yICl7XG4gICAgICAgICAgICB2aWV3ZXIubmF2aWdhdG9yLnVwZGF0ZSggdmlld2VyLnZpZXdwb3J0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBUSElTWyB2aWV3ZXIuaGFzaCBdLmZvcmNlUmVkcmF3ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGFuaW1hdGVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGFueSBzcHJpbmcgYW5pbWF0aW9uIHVwZGF0ZSBvY2N1cnMgKHpvb20sIHBhbiwgZXRjLiksXG4gICAgICAgICAgICAgKiBhZnRlciB0aGUgdmlld2VyIGhhcyBkcmF3biB0aGUgbmV3IGxvY2F0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBhbmltYXRpb25cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlld2VyLnJhaXNlRXZlbnQoIFwiYW5pbWF0aW9uXCIgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICggVEhJU1sgdmlld2VyLmhhc2ggXS5hbmltYXRpbmcgJiYgIWFuaW1hdGVkICkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gYW55IHNwcmluZyBhbmltYXRpb24gZW5kcyAoem9vbSwgcGFuLCBldGMuKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGFuaW1hdGlvbi1maW5pc2hcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmlld2VyLnJhaXNlRXZlbnQoIFwiYW5pbWF0aW9uLWZpbmlzaFwiICk7XG5cbiAgICAgICAgaWYgKCAhVEhJU1sgdmlld2VyLmhhc2ggXS5tb3VzZUluc2lkZSApIHtcbiAgICAgICAgICAgIGJlZ2luQ29udHJvbHNBdXRvSGlkZSggdmlld2VyICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBUSElTWyB2aWV3ZXIuaGFzaCBdLmFuaW1hdGluZyA9IGFuaW1hdGVkO1xuXG4gICAgLy92aWV3ZXIucHJvZmlsZXIuZW5kVXBkYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdXb3JsZCggdmlld2VyICkge1xuICAgIHZpZXdlci5pbWFnZUxvYWRlci5jbGVhcigpO1xuICAgIHZpZXdlci5kcmF3ZXIuY2xlYXIoKTtcbiAgICB2aWV3ZXIud29ybGQuZHJhdygpO1xuXG4gICAgLyoqXG4gICAgICogPGVtPi0gTmVlZHMgZG9jdW1lbnRhdGlvbiAtPC9lbT5cbiAgICAgKlxuICAgICAqIEBldmVudCB1cGRhdGUtdmlld3BvcnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB2aWV3ZXIucmFpc2VFdmVudCggJ3VwZGF0ZS12aWV3cG9ydCcsIHt9ICk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE5hdmlnYXRpb24gQ29udHJvbHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIHJlc29sdmVVcmwoIHByZWZpeCwgdXJsICkge1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyB1cmwgOiB1cmw7XG59XG5cblxuXG5mdW5jdGlvbiBiZWdpblpvb21pbmdJbigpIHtcbiAgICBUSElTWyB0aGlzLmhhc2ggXS5sYXN0Wm9vbVRpbWUgPSAkLm5vdygpO1xuICAgIFRISVNbIHRoaXMuaGFzaCBdLnpvb21GYWN0b3IgPSB0aGlzLnpvb21QZXJTZWNvbmQ7XG4gICAgVEhJU1sgdGhpcy5oYXNoIF0uem9vbWluZyA9IHRydWU7XG4gICAgc2NoZWR1bGVab29tKCB0aGlzICk7XG59XG5cblxuZnVuY3Rpb24gYmVnaW5ab29taW5nT3V0KCkge1xuICAgIFRISVNbIHRoaXMuaGFzaCBdLmxhc3Rab29tVGltZSA9ICQubm93KCk7XG4gICAgVEhJU1sgdGhpcy5oYXNoIF0uem9vbUZhY3RvciA9IDEuMCAvIHRoaXMuem9vbVBlclNlY29uZDtcbiAgICBUSElTWyB0aGlzLmhhc2ggXS56b29taW5nID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVpvb20oIHRoaXMgKTtcbn1cblxuXG5mdW5jdGlvbiBlbmRab29taW5nKCkge1xuICAgIFRISVNbIHRoaXMuaGFzaCBdLnpvb21pbmcgPSBmYWxzZTtcbn1cblxuXG5mdW5jdGlvbiBzY2hlZHVsZVpvb20oIHZpZXdlciApIHtcbiAgICAkLnJlcXVlc3RBbmltYXRpb25GcmFtZSggJC5kZWxlZ2F0ZSggdmlld2VyLCBkb1pvb20gKSApO1xufVxuXG5cbmZ1bmN0aW9uIGRvWm9vbSgpIHtcbiAgICB2YXIgY3VycmVudFRpbWUsXG4gICAgICAgIGRlbHRhVGltZSxcbiAgICAgICAgYWRqdXN0ZWRGYWN0b3I7XG5cbiAgICBpZiAoIFRISVNbIHRoaXMuaGFzaCBdLnpvb21pbmcgJiYgdGhpcy52aWV3cG9ydCkge1xuICAgICAgICBjdXJyZW50VGltZSAgICAgPSAkLm5vdygpO1xuICAgICAgICBkZWx0YVRpbWUgICAgICAgPSBjdXJyZW50VGltZSAtIFRISVNbIHRoaXMuaGFzaCBdLmxhc3Rab29tVGltZTtcbiAgICAgICAgYWRqdXN0ZWRGYWN0b3IgID0gTWF0aC5wb3coIFRISVNbIHRoaXMuaGFzaCBdLnpvb21GYWN0b3IsIGRlbHRhVGltZSAvIDEwMDAgKTtcblxuICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeSggYWRqdXN0ZWRGYWN0b3IgKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLmxhc3Rab29tVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICBzY2hlZHVsZVpvb20oIHRoaXMgKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZG9TaW5nbGVab29tSW4oKSB7XG4gICAgaWYgKCB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS56b29taW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQuem9vbUJ5KFxuICAgICAgICAgICAgdGhpcy56b29tUGVyQ2xpY2sgLyAxLjBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGRvU2luZ2xlWm9vbU91dCgpIHtcbiAgICBpZiAoIHRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoXG4gICAgICAgICAgICAxLjAgLyB0aGlzLnpvb21QZXJDbGlja1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gbGlnaHRVcCgpIHtcbiAgICB0aGlzLmJ1dHRvbnMuZW11bGF0ZUVudGVyKCk7XG4gICAgdGhpcy5idXR0b25zLmVtdWxhdGVFeGl0KCk7XG59XG5cblxuZnVuY3Rpb24gb25Ib21lKCkge1xuICAgIGlmICggdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5nb0hvbWUoKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gb25GdWxsU2NyZWVuKCkge1xuICAgIGlmICggdGhpcy5pc0Z1bGxQYWdlKCkgJiYgISQuaXNGdWxsU2NyZWVuKCkgKSB7XG4gICAgICAgIC8vIElzIGZ1bGxQYWdlIGJ1dCBub3QgZnVsbFNjcmVlblxuICAgICAgICB0aGlzLnNldEZ1bGxQYWdlKCBmYWxzZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RnVsbFNjcmVlbiggIXRoaXMuaXNGdWxsUGFnZSgpICk7XG4gICAgfVxuICAgIC8vIGNvcnJlY3QgZm9yIG5vIG1vdXNlb3V0IGV2ZW50IG9uIGNoYW5nZVxuICAgIGlmICggdGhpcy5idXR0b25zICkge1xuICAgICAgICB0aGlzLmJ1dHRvbnMuZW11bGF0ZUV4aXQoKTtcbiAgICB9XG4gICAgdGhpcy5mdWxsUGFnZUJ1dHRvbi5lbGVtZW50LmZvY3VzKCk7XG4gICAgaWYgKCB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICB9XG59XG5cbi8qKlxuICogTm90ZTogVGhlIGN1cnJlbnQgcm90YXRpb24gZmVhdHVyZSBpcyBsaW1pdGVkIHRvIDkwIGRlZ3JlZSB0dXJucy5cbiAqL1xuZnVuY3Rpb24gb25Sb3RhdGVMZWZ0KCkge1xuICAgIGlmICggdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgdmFyIGN1cnJSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQuZ2V0Um90YXRpb24oKTtcbiAgICAgICAgaWYgKGN1cnJSb3RhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgY3VyclJvdGF0aW9uID0gMjcwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyclJvdGF0aW9uIC09IDkwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Um90YXRpb24oY3VyclJvdGF0aW9uKTtcbiAgICB9XG59XG5cbi8qKlxuICogTm90ZTogVGhlIGN1cnJlbnQgcm90YXRpb24gZmVhdHVyZSBpcyBsaW1pdGVkIHRvIDkwIGRlZ3JlZSB0dXJucy5cbiAqL1xuZnVuY3Rpb24gb25Sb3RhdGVSaWdodCgpIHtcbiAgICBpZiAoIHRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgIHZhciBjdXJyUm90YXRpb24gPSB0aGlzLnZpZXdwb3J0LmdldFJvdGF0aW9uKCk7XG4gICAgICAgIGlmIChjdXJyUm90YXRpb24gPT09IDI3MCkge1xuICAgICAgICAgICAgY3VyclJvdGF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJSb3RhdGlvbiArPSA5MDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldFJvdGF0aW9uKGN1cnJSb3RhdGlvbik7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIG9uUHJldmlvdXMoKXtcbiAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9zZXF1ZW5jZUluZGV4IC0gMTtcbiAgICBpZih0aGlzLm5hdlByZXZOZXh0V3JhcCAmJiBwcmV2aW91cyA8IDApe1xuICAgICAgICBwcmV2aW91cyArPSB0aGlzLnRpbGVTb3VyY2VzLmxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5nb1RvUGFnZSggcHJldmlvdXMgKTtcbn1cblxuXG5mdW5jdGlvbiBvbk5leHQoKXtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX3NlcXVlbmNlSW5kZXggKyAxO1xuICAgIGlmKHRoaXMubmF2UHJldk5leHRXcmFwICYmIG5leHQgPj0gdGhpcy50aWxlU291cmNlcy5sZW5ndGgpe1xuICAgICAgICBuZXh0ID0gMDtcbiAgICB9XG4gICAgdGhpcy5nb1RvUGFnZSggbmV4dCApO1xufVxuXG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gTmF2aWdhdG9yXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBOYXZpZ2F0b3JcbiAqIEBjbGFzc2Rlc2MgVGhlIE5hdmlnYXRvciBwcm92aWRlcyBhIHNtYWxsIHZpZXcgb2YgdGhlIGN1cnJlbnQgaW1hZ2UgYXMgZml4ZWRcbiAqIHdoaWxlIHJlcHJlc2VudGluZyB0aGUgdmlld3BvcnQgYXMgYSBtb3ZpbmcgYm94IHNlcnZpbmcgYXMgYSBmcmFtZVxuICogb2YgcmVmZXJlbmNlIGluIHRoZSBsYXJnZXIgdmlld3BvcnQgYXMgdG8gd2hpY2ggcG9ydGlvbiBvZiB0aGUgaW1hZ2VcbiAqIGlzIGN1cnJlbnRseSBiZWluZyBleGFtaW5lZC4gIFRoZSBuYXZpZ2F0b3IncyB2aWV3cG9ydCBjYW4gYmUgaW50ZXJhY3RlZFxuICogd2l0aCB1c2luZyB0aGUga2V5Ym9hcmQgb3IgdGhlIG1vdXNlLlxuICpcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5FdmVudFNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuJC5OYXZpZ2F0b3IgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuXG4gICAgdmFyIHZpZXdlciAgICAgID0gb3B0aW9ucy52aWV3ZXIsXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgdmlld2VyU2l6ZSxcbiAgICAgICAgbmF2aWdhdG9yU2l6ZTtcblxuICAgIC8vV2UgbWF5IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGlkIGlmIHRoZXkgZGlkIG5vdFxuICAgIC8vcHJvdmlkZSB0aGUgaWQgZm9yIHRoZSBleGlzdGluZyBlbGVtZW50XG4gICAgaWYoICFvcHRpb25zLmlkICl7XG4gICAgICAgIG9wdGlvbnMuaWQgICAgICAgICAgICAgID0gJ25hdmlnYXRvci0nICsgJC5ub3coKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ICAgICAgICAgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zICA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogICAgICAgICAgICQuQ29udHJvbEFuY2hvci5UT1BfUklHSFQsXG4gICAgICAgICAgICBhdHRhY2hUb1ZpZXdlcjogICB0cnVlLFxuICAgICAgICAgICAgYXV0b0ZhZGU6ICAgICAgICAgb3B0aW9ucy5hdXRvRmFkZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBvcHRpb25zLnBvc2l0aW9uICl7XG4gICAgICAgICAgICBpZiggJ0JPVFRPTV9SSUdIVCcgPT0gb3B0aW9ucy5wb3NpdGlvbiApe1xuICAgICAgICAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucy5hbmNob3IgPSAkLkNvbnRyb2xBbmNob3IuQk9UVE9NX1JJR0hUO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCAnQk9UVE9NX0xFRlQnID09IG9wdGlvbnMucG9zaXRpb24gKXtcbiAgICAgICAgICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnMuYW5jaG9yID0gJC5Db250cm9sQW5jaG9yLkJPVFRPTV9MRUZUO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCAnVE9QX1JJR0hUJyA9PSBvcHRpb25zLnBvc2l0aW9uICl7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmFuY2hvciA9ICQuQ29udHJvbEFuY2hvci5UT1BfUklHSFQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYoICdUT1BfTEVGVCcgPT0gb3B0aW9ucy5wb3NpdGlvbiApe1xuICAgICAgICAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucy5hbmNob3IgPSAkLkNvbnRyb2xBbmNob3IuVE9QX0xFRlQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYoICdBQlNPTFVURScgPT0gb3B0aW9ucy5wb3NpdGlvbiApe1xuICAgICAgICAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucy5hbmNob3IgPSAkLkNvbnRyb2xBbmNob3IuQUJTT0xVVEU7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLnRvcCA9IG9wdGlvbnMudG9wO1xuICAgICAgICAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5sZWZ0O1xuICAgICAgICAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnMud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsZW1lbnQgICAgICAgICAgICA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBvcHRpb25zLmlkICk7XG4gICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnMgID0ge1xuICAgICAgICAgICAgYW5jaG9yOiAgICAgICAgICAgJC5Db250cm9sQW5jaG9yLk5PTkUsXG4gICAgICAgICAgICBhdHRhY2hUb1ZpZXdlcjogICBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9GYWRlOiAgICAgICAgIGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5pZCAgICAgICAgID0gb3B0aW9ucy5pZDtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lICArPSAnIG5hdmlnYXRvcic7XG5cbiAgICBvcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHtcbiAgICAgICAgc2l6ZVJhdGlvOiAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLm5hdmlnYXRvclNpemVSYXRpb1xuICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgZWxlbWVudDogICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICB0YWJJbmRleDogICAgICAgICAgICAgICAtMSwgLy8gTm8ga2V5Ym9hcmQgbmF2aWdhdGlvbiwgb21pdCBmcm9tIHRhYiBvcmRlclxuICAgICAgICAvL1RoZXNlIG5lZWQgdG8gYmUgb3ZlcnJpZGRlbiB0byBwcmV2ZW50IHJlY3Vyc2lvbiBzaW5jZVxuICAgICAgICAvL3RoZSBuYXZpZ2F0b3IgaXMgYSB2aWV3ZXIgYW5kIGEgdmlld2VyIGhhcyBhIG5hdmlnYXRvclxuICAgICAgICBzaG93TmF2aWdhdG9yOiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgbW91c2VOYXZFbmFibGVkOiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNob3dOYXZpZ2F0aW9uQ29udHJvbDogIGZhbHNlLFxuICAgICAgICBzaG93U2VxdWVuY2VDb250cm9sOiAgICBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiAgICAgICAgdHJ1ZSxcbiAgICAgICAgYmxlbmRUaW1lOiAgICAgICAgICAgICAgMCxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogICAgICAgICAgMCxcbiAgICAgICAgYXV0b1Jlc2l6ZTogICAgICAgICAgICAgb3B0aW9ucy5hdXRvUmVzaXplLFxuICAgICAgICAvLyBwcmV2ZW50IHJlc2l6aW5nIHRoZSBuYXZpZ2F0b3IgZnJvbSBhZGRpbmcgdW53YW50ZWQgc3BhY2UgYXJvdW5kIHRoZSBpbWFnZVxuICAgICAgICBtaW5ab29tSW1hZ2VSYXRpbzogICAgICAxLjBcbiAgICB9KTtcblxuICAgIG9wdGlvbnMubWluUGl4ZWxSYXRpbyA9IHRoaXMubWluUGl4ZWxSYXRpbyA9IHZpZXdlci5taW5QaXhlbFJhdGlvO1xuXG4gICAgJC5zZXRFbGVtZW50VG91Y2hBY3Rpb25Ob25lKCB0aGlzLmVsZW1lbnQgKTtcblxuICAgIHRoaXMuYm9yZGVyV2lkdGggPSAyO1xuICAgIC8vQXQgc29tZSBicm93c2VyIG1hZ25pZmljYXRpb24gbGV2ZWxzIHRoZSBkaXNwbGF5IHJlZ2lvbnMgbGluZXMgdXAgY29ycmVjdGx5LCBidXQgYXQgc29tZSB0aGVyZSBhcHBlYXJzIHRvXG4gICAgLy9iZSBhIG9uZSBwaXhlbCBnYXAuXG4gICAgdGhpcy5mdWRnZSA9IG5ldyAkLlBvaW50KDEsIDEpO1xuICAgIHRoaXMudG90YWxCb3JkZXJXaWR0aHMgPSBuZXcgJC5Qb2ludCh0aGlzLmJvcmRlcldpZHRoKjIsIHRoaXMuYm9yZGVyV2lkdGgqMikubWludXModGhpcy5mdWRnZSk7XG5cblxuICAgIGlmICggb3B0aW9ucy5jb250cm9sT3B0aW9ucy5hbmNob3IgIT0gJC5Db250cm9sQW5jaG9yLk5PTkUgKSB7XG4gICAgICAgIChmdW5jdGlvbiggc3R5bGUsIGJvcmRlcldpZHRoICl7XG4gICAgICAgICAgICBzdHlsZS5tYXJnaW4gICAgICAgID0gJzBweCc7XG4gICAgICAgICAgICBzdHlsZS5ib3JkZXIgICAgICAgID0gYm9yZGVyV2lkdGggKyAncHggc29saWQgIzU1NSc7XG4gICAgICAgICAgICBzdHlsZS5wYWRkaW5nICAgICAgID0gJzBweCc7XG4gICAgICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kICAgID0gJyMwMDAnO1xuICAgICAgICAgICAgc3R5bGUub3BhY2l0eSAgICAgICA9IDAuODtcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ICAgICAgPSAnaGlkZGVuJztcbiAgICAgICAgfSggdGhpcy5lbGVtZW50LnN0eWxlLCB0aGlzLmJvcmRlcldpZHRoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uICAgICAgICAgICA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uLmlkICAgICAgICA9IHRoaXMuZWxlbWVudC5pZCArICctZGlzcGxheXJlZ2lvbic7XG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uLmNsYXNzTmFtZSA9ICdkaXNwbGF5cmVnaW9uJztcblxuICAgIChmdW5jdGlvbiggc3R5bGUsIGJvcmRlcldpZHRoICl7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uICAgICAgPSAncmVsYXRpdmUnO1xuICAgICAgICBzdHlsZS50b3AgICAgICAgICAgID0gJzBweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgICAgICAgICAgPSAnMHB4JztcbiAgICAgICAgc3R5bGUuZm9udFNpemUgICAgICA9ICcwcHgnO1xuICAgICAgICBzdHlsZS5vdmVyZmxvdyAgICAgID0gJ2hpZGRlbic7XG4gICAgICAgIHN0eWxlLmJvcmRlciAgICAgICAgPSBib3JkZXJXaWR0aCArICdweCBzb2xpZCAjOTAwJztcbiAgICAgICAgc3R5bGUubWFyZ2luICAgICAgICA9ICcwcHgnO1xuICAgICAgICBzdHlsZS5wYWRkaW5nICAgICAgID0gJzBweCc7XG4gICAgICAgIC8vVE9ETzogSUUgZG9lc250IGxpa2UgdGhpcyBwcm9wZXJ0eSBiZWluZyBzZXRcbiAgICAgICAgLy90cnl7IHN0eWxlLm91dGxpbmUgID0gJzJweCBhdXRvICM5MDknOyB9Y2F0Y2goZSl7LyppZ25vcmUqL31cblxuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kICAgID0gJ3RyYW5zcGFyZW50JztcblxuICAgICAgICAvLyBXZSB1c2Ugc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gb24gdGhlIHN0YXRlbWVudCBiZWxvdywgYmVjYXVzZSBmbG9hdCBpcyBhIGtleXdvcmQuXG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciB0aGUgR29vZ2xlIENsb3N1cmUgY29tcGlsZXIsIGlmIG5vdGhpbmcgZWxzZS5cbiAgICAgICAgLypqc2hpbnQgc3ViOnRydWUgKi9cbiAgICAgICAgc3R5bGVbJ2Zsb2F0J10gICAgICA9ICdsZWZ0JzsgLy9XZWJraXRcblxuICAgICAgICBzdHlsZS5jc3NGbG9hdCAgICAgID0gJ2xlZnQnOyAvL0ZpcmVmb3hcbiAgICAgICAgc3R5bGUuc3R5bGVGbG9hdCAgICA9ICdsZWZ0JzsgLy9JRVxuICAgICAgICBzdHlsZS56SW5kZXggICAgICAgID0gOTk5OTk5OTk5O1xuICAgICAgICBzdHlsZS5jdXJzb3IgICAgICAgID0gJ2RlZmF1bHQnO1xuICAgIH0oIHRoaXMuZGlzcGxheVJlZ2lvbi5zdHlsZSwgdGhpcy5ib3JkZXJXaWR0aCApKTtcblxuICAgIHRoaXMuZGlzcGxheVJlZ2lvbkNvbnRhaW5lciA9ICQubWFrZU5ldXRyYWxFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZGlzcGxheVJlZ2lvbkNvbnRhaW5lci5pZCA9IHRoaXMuZWxlbWVudC5pZCArICctZGlzcGxheXJlZ2lvbmNvbnRhaW5lcic7XG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwiZGlzcGxheXJlZ2lvbmNvbnRhaW5lclwiO1xuICAgIHRoaXMuZGlzcGxheVJlZ2lvbkNvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHRoaXMuZGlzcGxheVJlZ2lvbkNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcblxuICAgIHZpZXdlci5hZGRDb250cm9sKFxuICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnNcbiAgICApO1xuXG4gICAgdGhpcy5fcmVzaXplV2l0aFZpZXdlciA9IG9wdGlvbnMuY29udHJvbE9wdGlvbnMuYW5jaG9yICE9ICQuQ29udHJvbEFuY2hvci5BQlNPTFVURSAmJlxuICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmFuY2hvciAhPSAkLkNvbnRyb2xBbmNob3IuTk9ORTtcblxuICAgIGlmICggdGhpcy5fcmVzaXplV2l0aFZpZXdlciApIHtcbiAgICAgICAgaWYgKCBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0ICkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IHR5cGVvZiAoIG9wdGlvbnMuaGVpZ2h0ICkgID09IFwibnVtYmVyXCIgPyAoIG9wdGlvbnMuaGVpZ2h0ICsgJ3B4JyApIDogb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggID0gdHlwZW9mICggb3B0aW9ucy53aWR0aCApICA9PSBcIm51bWJlclwiID8gKCBvcHRpb25zLndpZHRoICsgJ3B4JyApIDogb3B0aW9ucy53aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdlclNpemUgPSAkLmdldEVsZW1lbnRTaXplKCB2aWV3ZXIuZWxlbWVudCApO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IE1hdGgucm91bmQoIHZpZXdlclNpemUueSAqIG9wdGlvbnMuc2l6ZVJhdGlvICkgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoICA9IE1hdGgucm91bmQoIHZpZXdlclNpemUueCAqIG9wdGlvbnMuc2l6ZVJhdGlvICkgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5vbGRWaWV3ZXJTaXplID0gdmlld2VyU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBuYXZpZ2F0b3JTaXplID0gJC5nZXRFbGVtZW50U2l6ZSggdGhpcy5lbGVtZW50ICk7XG4gICAgICAgIHRoaXMuZWxlbWVudEFyZWEgPSBuYXZpZ2F0b3JTaXplLnggKiBuYXZpZ2F0b3JTaXplLnk7XG4gICAgfVxuXG4gICAgdGhpcy5vbGRDb250YWluZXJTaXplID0gbmV3ICQuUG9pbnQoIDAsIDAgKTtcblxuICAgICQuVmlld2VyLmFwcGx5KCB0aGlzLCBbIG9wdGlvbnMgXSApO1xuXG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZGlzcGxheVJlZ2lvbik7XG4gICAgdGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKVswXS5hcHBlbmRDaGlsZCh0aGlzLmRpc3BsYXlSZWdpb25Db250YWluZXIpO1xuXG4gICAgZnVuY3Rpb24gcm90YXRlKGRlZ3JlZXMpIHtcbiAgICAgICAgX3NldFRyYW5zZm9ybVJvdGF0ZShfdGhpcy5kaXNwbGF5UmVnaW9uQ29udGFpbmVyLCBkZWdyZWVzKTtcbiAgICAgICAgX3NldFRyYW5zZm9ybVJvdGF0ZShfdGhpcy5kaXNwbGF5UmVnaW9uLCAtZGVncmVlcyk7XG4gICAgICAgIF90aGlzLnZpZXdwb3J0LnNldFJvdGF0aW9uKGRlZ3JlZXMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uYXZpZ2F0b3JSb3RhdGUpIHtcbiAgICAgICAgdmFyIGRlZ3JlZXMgPSBvcHRpb25zLnZpZXdlci52aWV3cG9ydCA/XG4gICAgICAgICAgICBvcHRpb25zLnZpZXdlci52aWV3cG9ydC5nZXRSb3RhdGlvbigpIDpcbiAgICAgICAgICAgIG9wdGlvbnMudmlld2VyLmRlZ3JlZXMgfHwgMDtcbiAgICAgICAgcm90YXRlKGRlZ3JlZXMpO1xuICAgICAgICBvcHRpb25zLnZpZXdlci5hZGRIYW5kbGVyKFwicm90YXRlXCIsIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByb3RhdGUoYXJncy5kZWdyZWVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBiYXNlIGNsYXNzJyAoVmlld2VyJ3MpIGlubmVyVHJhY2tlciBhbmQgcmVwbGFjZSBpdCB3aXRoIG91ciBvd25cbiAgICB0aGlzLmlubmVyVHJhY2tlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbm5lclRyYWNrZXIgPSBuZXcgJC5Nb3VzZVRyYWNrZXIoe1xuICAgICAgICBlbGVtZW50OiAgICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgZHJhZ0hhbmRsZXI6ICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0RyYWcgKSxcbiAgICAgICAgY2xpY2tIYW5kbGVyOiAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0NsaWNrICksXG4gICAgICAgIHJlbGVhc2VIYW5kbGVyOiAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNSZWxlYXNlICksXG4gICAgICAgIHNjcm9sbEhhbmRsZXI6ICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNTY3JvbGwgKVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRIYW5kbGVyKFwicmVzZXQtc2l6ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF90aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICBfdGhpcy52aWV3cG9ydC5nb0hvbWUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZpZXdlci53b3JsZC5hZGRIYW5kbGVyKFwiaXRlbS1pbmRleC1jaGFuZ2VcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfdGhpcy53b3JsZC5nZXRJdGVtQXQoZXZlbnQucHJldmlvdXNJbmRleCk7XG4gICAgICAgIF90aGlzLndvcmxkLnNldEl0ZW1JbmRleChpdGVtLCBldmVudC5uZXdJbmRleCk7XG4gICAgfSk7XG5cbiAgICB2aWV3ZXIud29ybGQuYWRkSGFuZGxlcihcInJlbW92ZS1pdGVtXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB0aGVpckl0ZW0gPSBldmVudC5pdGVtO1xuICAgICAgICB2YXIgbXlJdGVtID0gX3RoaXMuX2dldE1hdGNoaW5nSXRlbSh0aGVpckl0ZW0pO1xuICAgICAgICBpZiAobXlJdGVtKSB7XG4gICAgICAgICAgICBfdGhpcy53b3JsZC5yZW1vdmVJdGVtKG15SXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMudXBkYXRlKHZpZXdlci52aWV3cG9ydCk7XG59O1xuXG4kLmV4dGVuZCggJC5OYXZpZ2F0b3IucHJvdG90eXBlLCAkLkV2ZW50U291cmNlLnByb3RvdHlwZSwgJC5WaWV3ZXIucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uTmF2aWdhdG9yLnByb3RvdHlwZSAqL3tcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbm90aWZ5IHRoZSBuYXZpZ2F0b3Igd2hlbiBpdHMgc2l6ZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9Lm5hdmlnYXRvckF1dG9SZXNpemUgaXMgc2V0IHRvIGZhbHNlIGFuZCB0aGUgbmF2aWdhdG9yIGlzIHJlc2l6YWJsZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1cGRhdGVTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICggdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJTaXplID0gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCA9PT0gMCA/IDEgOiB0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQgPT09IDAgPyAxIDogdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICggIWNvbnRhaW5lclNpemUuZXF1YWxzKCB0aGlzLm9sZENvbnRhaW5lclNpemUgKSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnJlc2l6ZSggY29udGFpbmVyU2l6ZSwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuZ29Ib21lKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMub2xkQ29udGFpbmVyU2l6ZSA9IGNvbnRhaW5lclNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkLmRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHVwZGF0ZSB0aGUgbmF2aWdhdG9yIG1pbmltYXAncyB2aWV3cG9ydCByZWN0YW5nbGUgd2hlbiBhIGNoYW5nZSBpbiB0aGUgdmlld2VyJ3Mgdmlld3BvcnQgb2NjdXJzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gVGhlIHZpZXdwb3J0IHRoaXMgbmF2aWdhdG9yIGlzIHRyYWNraW5nLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oIHZpZXdwb3J0ICkge1xuXG4gICAgICAgIHZhciB2aWV3ZXJTaXplLFxuICAgICAgICAgICAgbmV3V2lkdGgsXG4gICAgICAgICAgICBuZXdIZWlnaHQsXG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICB0b3BsZWZ0LFxuICAgICAgICAgICAgYm90dG9tcmlnaHQ7XG5cbiAgICAgICAgdmlld2VyU2l6ZSA9ICQuZ2V0RWxlbWVudFNpemUoIHRoaXMudmlld2VyLmVsZW1lbnQgKTtcbiAgICAgICAgaWYgKCB0aGlzLl9yZXNpemVXaXRoVmlld2VyICYmIHZpZXdlclNpemUueCAmJiB2aWV3ZXJTaXplLnkgJiYgIXZpZXdlclNpemUuZXF1YWxzKCB0aGlzLm9sZFZpZXdlclNpemUgKSApIHtcbiAgICAgICAgICAgIHRoaXMub2xkVmlld2VyU2l6ZSA9IHZpZXdlclNpemU7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5tYWludGFpblNpemVSYXRpbyB8fCAhdGhpcy5lbGVtZW50QXJlYSkge1xuICAgICAgICAgICAgICAgIG5ld1dpZHRoICA9IHZpZXdlclNpemUueCAqIHRoaXMuc2l6ZVJhdGlvO1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHZpZXdlclNpemUueSAqIHRoaXMuc2l6ZVJhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9IE1hdGguc3FydCh0aGlzLmVsZW1lbnRBcmVhICogKHZpZXdlclNpemUueCAvIHZpZXdlclNpemUueSkpO1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHRoaXMuZWxlbWVudEFyZWEgLyBuZXdXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoICA9IE1hdGgucm91bmQoIG5ld1dpZHRoICkgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IE1hdGgucm91bmQoIG5ld0hlaWdodCApICsgJ3B4JztcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnRBcmVhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50QXJlYSA9IG5ld1dpZHRoICogbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWV3cG9ydCAmJiB0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICBib3VuZHMgICAgICA9IHZpZXdwb3J0LmdldEJvdW5kc05vUm90YXRlKHRydWUpO1xuICAgICAgICAgICAgdG9wbGVmdCAgICAgPSB0aGlzLnZpZXdwb3J0LnBpeGVsRnJvbVBvaW50Tm9Sb3RhdGUoYm91bmRzLmdldFRvcExlZnQoKSwgZmFsc2UpO1xuICAgICAgICAgICAgYm90dG9tcmlnaHQgPSB0aGlzLnZpZXdwb3J0LnBpeGVsRnJvbVBvaW50Tm9Sb3RhdGUoYm91bmRzLmdldEJvdHRvbVJpZ2h0KCksIGZhbHNlKVxuICAgICAgICAgICAgICAgIC5taW51cyggdGhpcy50b3RhbEJvcmRlcldpZHRocyApO1xuXG4gICAgICAgICAgICAvL3VwZGF0ZSBzdHlsZSBmb3IgbmF2aWdhdG9yLWJveFxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5kaXNwbGF5UmVnaW9uLnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IHRoaXMud29ybGQuZ2V0SXRlbUNvdW50KCkgPyAnYmxvY2snIDogJ25vbmUnO1xuXG4gICAgICAgICAgICBzdHlsZS50b3AgICAgPSBNYXRoLnJvdW5kKCB0b3BsZWZ0LnkgKSArICdweCc7XG4gICAgICAgICAgICBzdHlsZS5sZWZ0ICAgPSBNYXRoLnJvdW5kKCB0b3BsZWZ0LnggKSArICdweCc7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKCB0b3BsZWZ0LnggLSBib3R0b21yaWdodC54ICk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoIHRvcGxlZnQueSAtIGJvdHRvbXJpZ2h0LnkgKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub24tbmVnYXRpdmUgc28gSUUgZG9lc24ndCB0aHJvd1xuICAgICAgICAgICAgc3R5bGUud2lkdGggID0gTWF0aC5yb3VuZCggTWF0aC5tYXgoIHdpZHRoLCAwICkgKSArICdweCc7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBNYXRoLnJvdW5kKCBNYXRoLm1heCggaGVpZ2h0LCAwICkgKSArICdweCc7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBvdmVycmlkZXMgVmlld2VyLmFkZFRpbGVkSW1hZ2VcbiAgICBhZGRUaWxlZEltYWdlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gb3B0aW9ucy5vcmlnaW5hbFRpbGVkSW1hZ2U7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLm9yaWdpbmFsO1xuXG4gICAgICAgIHZhciBvcHRpb25zQ2xvbmUgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlJdGVtID0gZXZlbnQuaXRlbTtcbiAgICAgICAgICAgICAgICBteUl0ZW0uX29yaWdpbmFsRm9yTmF2aWdhdG9yID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21hdGNoQm91bmRzKG15SXRlbSwgb3JpZ2luYWwsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgb3JpZ2luYWwuYWRkSGFuZGxlcignYm91bmRzLWNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbWF0Y2hCb3VuZHMobXlJdGVtLCBvcmlnaW5hbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkLlZpZXdlci5wcm90b3R5cGUuYWRkVGlsZWRJbWFnZS5hcHBseSh0aGlzLCBbb3B0aW9uc0Nsb25lXSk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfZ2V0TWF0Y2hpbmdJdGVtOiBmdW5jdGlvbih0aGVpckl0ZW0pIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMud29ybGQuZ2V0SXRlbUF0KGkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uX29yaWdpbmFsRm9yTmF2aWdhdG9yID09PSB0aGVpckl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX21hdGNoQm91bmRzOiBmdW5jdGlvbihteUl0ZW0sIHRoZWlySXRlbSwgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoZWlySXRlbS5nZXRCb3VuZHMoKTtcbiAgICAgICAgbXlJdGVtLnNldFBvc2l0aW9uKGJvdW5kcy5nZXRUb3BMZWZ0KCksIGltbWVkaWF0ZWx5KTtcbiAgICAgICAgbXlJdGVtLnNldFdpZHRoKGJvdW5kcy53aWR0aCwgaW1tZWRpYXRlbHkpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvbkNhbnZhc0NsaWNrKCBldmVudCApIHtcbiAgICBpZiAoIGV2ZW50LnF1aWNrICYmIHRoaXMudmlld2VyLnZpZXdwb3J0ICkge1xuICAgICAgICB0aGlzLnZpZXdlci52aWV3cG9ydC5wYW5Ubyh0aGlzLnZpZXdwb3J0LnBvaW50RnJvbVBpeGVsKGV2ZW50LnBvc2l0aW9uKSk7XG4gICAgICAgIHRoaXMudmlld2VyLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uQ2FudmFzRHJhZyggZXZlbnQgKSB7XG4gICAgaWYgKCB0aGlzLnZpZXdlci52aWV3cG9ydCApIHtcbiAgICAgICAgaWYoICF0aGlzLnBhbkhvcml6b250YWwgKXtcbiAgICAgICAgICAgIGV2ZW50LmRlbHRhLnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhdGhpcy5wYW5WZXJ0aWNhbCApe1xuICAgICAgICAgICAgZXZlbnQuZGVsdGEueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3ZXIudmlld3BvcnQucGFuQnkoXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhcbiAgICAgICAgICAgICAgICBldmVudC5kZWx0YVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvbkNhbnZhc1JlbGVhc2UoIGV2ZW50ICkge1xuICAgIGlmICggZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgJiYgdGhpcy52aWV3ZXIudmlld3BvcnQgKSB7XG4gICAgICAgIHRoaXMudmlld2VyLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gb25DYW52YXNTY3JvbGwoIGV2ZW50ICkge1xuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGEgc2Nyb2xsIGV2ZW50IG9jY3VycyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI25hdmlnYXRvcn0gZWxlbWVudCAobW91c2Ugd2hlZWwsIHRvdWNoIHBpbmNoLCBldGMuKS5cbiAgICAgKlxuICAgICAqIEBldmVudCBuYXZpZ2F0b3Itc2Nyb2xsXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgd2hpY2ggb3JpZ2luYXRlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbCAtIFRoZSBzY3JvbGwgZGVsdGEgZm9yIHRoZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNoaWZ0IC0gVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy52aWV3ZXIucmFpc2VFdmVudCggJ25hdmlnYXRvci1zY3JvbGwnLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIHNjcm9sbDogZXZlbnQuc2Nyb2xsLFxuICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnQsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcblxuICAgIC8vZG9udCBzY3JvbGwgdGhlIHBhZ2UgdXAgYW5kIGRvd24gaWYgdGhlIHVzZXIgaXMgc2Nyb2xsaW5nXG4gICAgLy9pbiB0aGUgbmF2aWdhdG9yXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlc1xuICAgICovXG5mdW5jdGlvbiBfc2V0VHJhbnNmb3JtUm90YXRlIChlbGVtZW50LCBkZWdyZWVzKSB7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGRlZ3JlZXMgKyBcImRlZylcIjtcbiAgICBlbGVtZW50LnN0eWxlLm1velRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgZGVncmVlcyArIFwiZGVnKVwiO1xuICAgIGVsZW1lbnQuc3R5bGUubXNUcmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGRlZ3JlZXMgKyBcImRlZylcIjtcbiAgICBlbGVtZW50LnN0eWxlLm9UcmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGRlZ3JlZXMgKyBcImRlZylcIjtcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgZGVncmVlcyArIFwiZGVnKVwiO1xufVxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIGdldFN0cmluZy9zZXRTdHJpbmdcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8vVE9ETzogSSBndWVzcyB0aGlzIGlzIHdoZXJlIHRoZSBpMThuIG5lZWRzIHRvIGJlIHJlaW1wbGVtZW50ZWQuICBJJ2xsIGxvb2tcbi8vICAgICAgaW50byBleGlzdGluZyBwYXR0ZXJucyBmb3IgaTE4biBpbiBqYXZhc2NyaXB0IGJ1dCBpIHRoaW5rIHRoYXQgbWltaWNraW5nXG4vLyAgICAgIHB5dGhvbnMgZ2V0dGV4dCBtaWdodCBiZSBhIHJlYXNvbmFibGUgYXBwcm9hY2guXG52YXIgSTE4TiA9IHtcbiAgICBFcnJvcnM6IHtcbiAgICAgICAgRHpjOiAgICAgICAgICAgIFwiU29ycnksIHdlIGRvbid0IHN1cHBvcnQgRGVlcCBab29tIENvbGxlY3Rpb25zIVwiLFxuICAgICAgICBEemk6ICAgICAgICAgICAgXCJIbW0sIHRoaXMgZG9lc24ndCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBEZWVwIFpvb20gSW1hZ2UuXCIsXG4gICAgICAgIFhtbDogICAgICAgICAgICBcIkhtbSwgdGhpcyBkb2Vzbid0IGFwcGVhciB0byBiZSBhIHZhbGlkIERlZXAgWm9vbSBJbWFnZS5cIixcbiAgICAgICAgSW1hZ2VGb3JtYXQ6ICAgIFwiU29ycnksIHdlIGRvbid0IHN1cHBvcnQgezB9LWJhc2VkIERlZXAgWm9vbSBJbWFnZXMuXCIsXG4gICAgICAgIFNlY3VyaXR5OiAgICAgICBcIkl0IGxvb2tzIGxpa2UgYSBzZWN1cml0eSByZXN0cmljdGlvbiBzdG9wcGVkIHVzIGZyb20gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJsb2FkaW5nIHRoaXMgRGVlcCBab29tIEltYWdlLlwiLFxuICAgICAgICBTdGF0dXM6ICAgICAgICAgXCJUaGlzIHNwYWNlIHVuaW50ZW50aW9uYWxseSBsZWZ0IGJsYW5rICh7MH0gezF9KS5cIixcbiAgICAgICAgT3BlbkZhaWxlZDogICAgIFwiVW5hYmxlIHRvIG9wZW4gezB9OiB7MX1cIlxuICAgIH0sXG5cbiAgICBUb29sdGlwczoge1xuICAgICAgICBGdWxsUGFnZTogICAgICAgXCJUb2dnbGUgZnVsbCBwYWdlXCIsXG4gICAgICAgIEhvbWU6ICAgICAgICAgICBcIkdvIGhvbWVcIixcbiAgICAgICAgWm9vbUluOiAgICAgICAgIFwiWm9vbSBpblwiLFxuICAgICAgICBab29tT3V0OiAgICAgICAgXCJab29tIG91dFwiLFxuICAgICAgICBOZXh0UGFnZTogICAgICAgXCJOZXh0IHBhZ2VcIixcbiAgICAgICAgUHJldmlvdXNQYWdlOiAgIFwiUHJldmlvdXMgcGFnZVwiLFxuICAgICAgICBSb3RhdGVMZWZ0OiAgICAgXCJSb3RhdGUgbGVmdFwiLFxuICAgICAgICBSb3RhdGVSaWdodDogICAgXCJSb3RhdGUgcmlnaHRcIlxuICAgIH1cbn07XG5cbiQuZXh0ZW5kKCAkLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24gKi97XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICAgKi9cbiAgICBnZXRTdHJpbmc6IGZ1bmN0aW9uKCBwcm9wICkge1xuXG4gICAgICAgIHZhciBwcm9wcyAgID0gcHJvcC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgc3RyaW5nICA9IG51bGwsXG4gICAgICAgICAgICBhcmdzICAgID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgY29udGFpbmVyID0gSTE4TixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGgtMTsgaSsrICkge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBub3QgYSBzdWJwcm9wZXJ0eVxuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyWyBwcm9wc1sgaSBdIF0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nID0gY29udGFpbmVyWyBwcm9wc1sgaSBdIF07XG5cbiAgICAgICAgaWYgKCB0eXBlb2YoIHN0cmluZyApICE9IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAkLmNvbnNvbGUuZGVidWcoIFwiVW50cmFuc2xhdGVkIHNvdXJjZSBzdHJpbmc6XCIsIHByb3AgKTtcbiAgICAgICAgICAgIHN0cmluZyA9IFwiXCI7IC8vIEZJWE1FOiB0aGlzIGJyZWFrcyBnZXR0ZXh0KCktc3R5bGUgY29udmVudGlvbiwgd2hpY2ggd291bGQgcmV0dXJuIHNvdXJjZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXHtcXGQrXFx9L2csIGZ1bmN0aW9uKGNhcHR1cmUpIHtcbiAgICAgICAgICAgIHZhciBpID0gcGFyc2VJbnQoIGNhcHR1cmUubWF0Y2goIC9cXGQrLyApLCAxMCApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBpIDwgYXJncy5sZW5ndGggP1xuICAgICAgICAgICAgICAgIGFyZ3NbIGkgXSA6XG4gICAgICAgICAgICAgICAgXCJcIjtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRTdHJpbmc6IGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblxuICAgICAgICB2YXIgcHJvcHMgICAgID0gcHJvcC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgY29udGFpbmVyID0gSTE4TixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGggLSAxOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoICFjb250YWluZXJbIHByb3BzWyBpIF0gXSApIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJbIHByb3BzWyBpIF0gXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyWyBwcm9wc1sgaSBdIF07XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXJbIHByb3BzWyBpIF0gXSA9IHZhbHVlO1xuICAgIH1cblxufSk7XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogQGNsYXNzIFBvaW50XG4gKiBAY2xhc3NkZXNjIEEgUG9pbnQgaXMgcmVhbGx5IHVzZWQgYXMgYSAyLWRpbWVuc2lvbmFsIHZlY3RvciwgZXF1YWxseSB1c2VmdWwgZm9yXG4gKiByZXByZXNlbnRpbmcgYSBwb2ludCBvbiBhIHBsYW5lLCBvciB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiBhIHBsYW5lXG4gKiBub3QgcmVxdWlyaW5nIGFueSBvdGhlciBmcmFtZSBvZiByZWZlcmVuY2UuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbeF0gVGhlIHZlY3RvciBjb21wb25lbnQgJ3gnLiBEZWZhdWx0cyB0byB0aGUgb3JpZ2luIGF0IDAuXG4gKiBAcGFyYW0ge051bWJlcn0gW3ldIFRoZSB2ZWN0b3IgY29tcG9uZW50ICd5Jy4gRGVmYXVsdHMgdG8gdGhlIG9yaWdpbiBhdCAwLlxuICovXG4kLlBvaW50ID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZlY3RvciBjb21wb25lbnQgJ3gnLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0geFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlBvaW50I1xuICAgICAqL1xuICAgIHRoaXMueCA9IHR5cGVvZiAoIHggKSA9PSBcIm51bWJlclwiID8geCA6IDA7XG4gICAgLyoqXG4gICAgICogVGhlIHZlY3RvciBjb21wb25lbnQgJ3knLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0geVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlBvaW50I1xuICAgICAqL1xuICAgIHRoaXMueSA9IHR5cGVvZiAoIHkgKSA9PSBcIm51bWJlclwiID8geSA6IDA7XG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uUG9pbnQucHJvdG90eXBlICovXG4kLlBvaW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gYSBkdXBsaWNhdGUgb2YgdGhpcyBQb2ludFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFub3RoZXIgUG9pbnQgdG8gdGhpcyBwb2ludCBhbmQgcmV0dXJuIGEgbmV3IFBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIGFkZCB2ZWN0b3IgY29tcG9uZW50cy5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gQSBuZXcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBzdW0gb2YgdGhlXG4gICAgICogIHZlY3RvciBjb21wb25lbnRzXG4gICAgICovXG4gICAgcGx1czogZnVuY3Rpb24oIHBvaW50ICkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggKyBwb2ludC54LFxuICAgICAgICAgICAgdGhpcy55ICsgcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJzdHJhY3QgYW5vdGhlciBQb2ludCB0byB0aGlzIHBvaW50IGFuZCByZXR1cm4gYSBuZXcgUG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gc3Vic3RyYWN0IHZlY3RvciBjb21wb25lbnRzLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBBIG5ldyBwb2ludCByZXByZXNlbnRpbmcgdGhlIHN1YnN0cmFjdGlvbiBvZiB0aGVcbiAgICAgKiAgdmVjdG9yIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBtaW51czogZnVuY3Rpb24oIHBvaW50ICkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggLSBwb2ludC54LFxuICAgICAgICAgICAgdGhpcy55IC0gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aGlzIHBvaW50IGJ5IGEgZmFjdG9yIGFuZCByZXR1cm4gYSBuZXcgUG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZhY3RvciBUaGUgZmFjdG9yIHRvIG11bHRpcGx5IHZlY3RvciBjb21wb25lbnRzLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBBIG5ldyBwb2ludCByZXByZXNlbnRpbmcgdGhlIG11bHRpcGxpY2F0aW9uXG4gICAgICogIG9mIHRoZSB2ZWN0b3IgY29tcG9uZW50cyBieSB0aGUgZmFjdG9yXG4gICAgICovXG4gICAgdGltZXM6IGZ1bmN0aW9uKCBmYWN0b3IgKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIHRoaXMueCAqIGZhY3RvcixcbiAgICAgICAgICAgIHRoaXMueSAqIGZhY3RvclxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdGhpcyBwb2ludCBieSBhIGZhY3RvciBhbmQgcmV0dXJuIGEgbmV3IFBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3IgVGhlIGZhY3RvciB0byBkaXZpZGUgdmVjdG9yIGNvbXBvbmVudHMuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IEEgbmV3IHBvaW50IHJlcHJlc2VudGluZyB0aGUgZGl2aXNpb24gb2YgdGhlXG4gICAgICogIHZlY3RvciBjb21wb25lbnRzIGJ5IHRoZSBmYWN0b3JcbiAgICAgKi9cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKCBmYWN0b3IgKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIHRoaXMueCAvIGZhY3RvcixcbiAgICAgICAgICAgIHRoaXMueSAvIGZhY3RvclxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBvcHBvc2l0ZSBvZiB0aGlzIHBvaW50IGFuZCByZXR1cm4gYSBuZXcgUG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IEEgbmV3IHBvaW50IHJlcHJlc2VudGluZyB0aGUgb3Bwb3NpdGUgb2YgdGhlXG4gICAgICogIHZlY3RvciBjb21wb25lbnRzXG4gICAgICovXG4gICAgbmVnYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KCAtdGhpcy54LCAtdGhpcy55ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSAyIHBvaW50c1xuICAgICAqL1xuICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKCBwb2ludCApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KCB0aGlzLnggLSBwb2ludC54LCAyICkgK1xuICAgICAgICAgICAgTWF0aC5wb3coIHRoaXMueSAtIHBvaW50LnksIDIgKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGlzIHBvaW50IGFuZCByZXR1cm4gYSBuZXcgcG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBBIG5ldyBwb2ludCB3aXRoIHRoZSBjb29yZGluYXRlcyBjb21wdXRlZFxuICAgICAqIGJ5IHRoZSBzcGVjaWZpZWQgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24oIGZ1bmMgKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCggZnVuYyggdGhpcy54ICksIGZ1bmMoIHRoaXMueSApICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgcG9pbnQgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gY29tcGFyZSB0aGlzIHBvaW50IHdpdGguXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhleSBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCBwb2ludCApIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvaW50IGluc3RhbmNlb2YgJC5Qb2ludFxuICAgICAgICApICYmIChcbiAgICAgICAgICAgIHRoaXMueCA9PT0gcG9pbnQueFxuICAgICAgICApICYmIChcbiAgICAgICAgICAgIHRoaXMueSA9PT0gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBwb2ludCBhcm91bmQgdGhlIHNwZWNpZmllZCBwaXZvdFxuICAgICAqIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NDY1OTMxL3JvdGF0ZS1yZWN0YW5nbGUtYXJvdW5kLWEtcG9pbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVzcyB0byByb3RhdGUgYXJvdW5kIHRoZSBwaXZvdC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IFtwaXZvdD0oMCwwKV0gUG9pbnQgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZS5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgb3JpZ2luLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fS4gQSBuZXcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBwb2ludCByb3RhdGVkIGFyb3VuZCB0aGUgc3BlY2lmaWVkIHBpdm90XG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcywgcGl2b3QpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdCB8fCBuZXcgJC5Qb2ludCgwLCAwKTtcbiAgICAgICAgdmFyIGNvcztcbiAgICAgICAgdmFyIHNpbjtcbiAgICAgICAgLy8gQXZvaWQgZmxvYXQgY29tcHV0YXRpb25zIHdoZW4gcG9zc2libGVcbiAgICAgICAgaWYgKGRlZ3JlZXMgJSA5MCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGQgPSBkZWdyZWVzICUgMzYwO1xuICAgICAgICAgICAgaWYgKGQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZCArPSAzNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHNpbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNpbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgICAgICAgICBjb3MgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgc2luID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNpbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSBjb3MgKiAodGhpcy54IC0gcGl2b3QueCkgLSBzaW4gKiAodGhpcy55IC0gcGl2b3QueSkgKyBwaXZvdC54O1xuICAgICAgICB2YXIgeSA9IHNpbiAqICh0aGlzLnggLSBwaXZvdC54KSArIGNvcyAqICh0aGlzLnkgLSBwaXZvdC55KSArIHBpdm90Lnk7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGlzIHBvaW50IHRvIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQgKHgseSkgd2hlcmUgeCBhbmQgeSBhcmVcbiAgICAgKiByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwb2ludC5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIChNYXRoLnJvdW5kKHRoaXMueCAqIDEwMCkgLyAxMDApICsgXCIsXCIgKyAoTWF0aC5yb3VuZCh0aGlzLnkgKiAxMDApIC8gMTAwKSArIFwiKVwiO1xuICAgIH1cbn07XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gVGlsZVNvdXJjZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuXG4vKipcbiAqIEBjbGFzcyBUaWxlU291cmNlXG4gKiBAY2xhc3NkZXNjIFRoZSBUaWxlU291cmNlIGNvbnRhaW5zIHRoZSBtb3N0IGJhc2ljIGltcGxlbWVudGF0aW9uIHJlcXVpcmVkIHRvIGNyZWF0ZSBhXG4gKiBzbW9vdGggdHJhbnNpdGlvbiBiZXR3ZWVuIGxheWVycyBpbiBhbiBpbWFnZSBweXJhbWlkLiBJdCBoYXMgb25seSBhIHNpbmdsZSBrZXlcbiAqIGludGVyZmFjZSB0aGF0IG11c3QgYmUgaW1wbGVtZW50ZWQgdG8gY29tcGxldGUgaXRzIGtleSBmdW5jdGlvbmFsaXR5OlxuICogJ2dldFRpbGVVcmwnLiAgSXQgYWxzbyBoYXMgc2V2ZXJhbCBvcHRpb25hbCBpbnRlcmZhY2VzIHRoYXQgY2FuIGJlXG4gKiBpbXBsZW1lbnRlZCBpZiBhIG5ldyBUaWxlU291cmNlIHdpc2hlcyB0byBzdXBwb3J0IGNvbmZpZ3VyYXRpb24gdmlhIGEgc2ltcGxlXG4gKiBvYmplY3Qgb3IgYXJyYXkgKCdjb25maWd1cmUnKSBhbmQgaWYgdGhlIHRpbGUgc291cmNlIHN1cHBvcnRzIG9yIHJlcXVpcmVzXG4gKiBjb25maWd1cmF0aW9uIHZpYSByZXRyaWV2YWwgb2YgYSBkb2N1bWVudCBvbiB0aGUgbmV0d29yayBhbGEgQUpBWCBvciBKU09OUCxcbiAqICgnZ2V0SW1hZ2VJbmZvJykuXG4gKiA8YnIvPlxuICogQnkgZGVmYXVsdCB0aGUgaW1hZ2UgcHlyYW1pZCBpcyBzcGxpdCBpbnRvIE4gbGF5ZXJzIHdoZXJlIHRoZSBpbWFnZSdzIGxvbmdlc3RcbiAqIHNpZGUgaW4gTSAoaW4gcGl4ZWxzKSwgd2hlcmUgTiBpcyB0aGUgc21hbGxlc3QgaW50ZWdlciB3aGljaCBzYXRpc2ZpZXNcbiAqICAgICAgPHN0cm9uZz4yXihOKzEpID49IE08L3N0cm9uZz4uXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uRXZlbnRTb3VyY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgIFlvdSBjYW4gZWl0aGVyIHNwZWNpZnkgYSBVUkwsIG9yIGxpdGVyYWxseSBkZWZpbmUgdGhlIFRpbGVTb3VyY2UgKGJ5IHNwZWNpZnlpbmdcbiAqICAgICAgd2lkdGgsIGhlaWdodCwgdGlsZVNpemUsIHRpbGVPdmVybGFwLCBtaW5MZXZlbCwgYW5kIG1heExldmVsKS4gRm9yIHRoZSBmb3JtZXIsXG4gKiAgICAgIHRoZSBleHRlbmRpbmcgY2xhc3MgaXMgZXhwZWN0ZWQgdG8gaW1wbGVtZW50ICdnZXRJbWFnZUluZm8nIGFuZCAnY29uZmlndXJlJy5cbiAqICAgICAgRm9yIHRoZSBsYXR0ZXIsIHRoZSBjb25zdHJ1Y3Rpb24gaXMgYXNzdW1lZCB0byBvY2N1ciB0aHJvdWdoXG4gKiAgICAgIHRoZSBleHRlbmRpbmcgY2xhc3NlcyBpbXBsZW1lbnRhdGlvbiBvZiAnY29uZmlndXJlJy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy51cmxdXG4gKiAgICAgIFRoZSBVUkwgZm9yIHRoZSBkYXRhIG5lY2Vzc2FyeSBmb3IgdGhpcyBUaWxlU291cmNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuc3VjY2Vzc11cbiAqICAgICAgQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdXBvbiBzdWNjZXNzZnVsIGNyZWF0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hamF4V2l0aENyZWRlbnRpYWxzXVxuICogICAgICBJZiB0aGlzIFRpbGVTb3VyY2UgbmVlZHMgdG8gbWFrZSBhbiBBSkFYIGNhbGwsIHRoaXMgc3BlY2lmaWVzIHdoZXRoZXIgdG8gc2V0XG4gKiAgICAgIHRoZSBYSFIncyB3aXRoQ3JlZGVudGlhbHMgKGZvciBhY2Nlc3Npbmcgc2VjdXJlIGRhdGEpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXVxuICogICAgICBXaWR0aCBvZiB0aGUgc291cmNlIGltYWdlIGF0IG1heCByZXNvbHV0aW9uIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdXG4gKiAgICAgIEhlaWdodCBvZiB0aGUgc291cmNlIGltYWdlIGF0IG1heCByZXNvbHV0aW9uIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aWxlU2l6ZV1cbiAqICAgICAgVGhlIHNpemUgb2YgdGhlIHRpbGVzIHRvIGFzc3VtZWQgdG8gbWFrZSB1cCBlYWNoIHB5cmFtaWQgbGF5ZXIgaW4gcGl4ZWxzLlxuICogICAgICBUaWxlIHNpemUgZGV0ZXJtaW5lcyB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIGltYWdlIHB5cmFtaWQgbXVzdCBiZVxuICogICAgICBkaXZpZGVkIGludG8gYSBtYXRyaXggb2Ygc21hbGxlciBpbWFnZXMuXG4gKiAgICAgIFVzZSBvcHRpb25zLnRpbGVXaWR0aCBhbmQgb3B0aW9ucy50aWxlSGVpZ2h0IHRvIHN1cHBvcnQgbm9uLXNxdWFyZSB0aWxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aWxlV2lkdGhdXG4gKiAgICAgIFRoZSB3aWR0aCBvZiB0aGUgdGlsZXMgdG8gYXNzdW1lZCB0byBtYWtlIHVwIGVhY2ggcHlyYW1pZCBsYXllciBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGlsZUhlaWdodF1cbiAqICAgICAgVGhlIGhlaWdodCBvZiB0aGUgdGlsZXMgdG8gYXNzdW1lZCB0byBtYWtlIHVwIGVhY2ggcHlyYW1pZCBsYXllciBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGlsZU92ZXJsYXBdXG4gKiAgICAgIFRoZSBudW1iZXIgb2YgcGl4ZWxzIGVhY2ggdGlsZSBpcyBleHBlY3RlZCB0byBvdmVybGFwIHRvdWNoaW5nIHRpbGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbkxldmVsXVxuICogICAgICBUaGUgbWluaW11bSBsZXZlbCB0byBhdHRlbXB0IHRvIGxvYWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4TGV2ZWxdXG4gKiAgICAgIFRoZSBtYXhpbXVtIGxldmVsIHRvIGF0dGVtcHQgdG8gbG9hZC5cbiAqL1xuJC5UaWxlU291cmNlID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIHRpbGVTaXplLCB0aWxlT3ZlcmxhcCwgbWluTGV2ZWwsIG1heExldmVsICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaTtcblxuICAgIGlmKCAkLmlzUGxhaW5PYmplY3QoIHdpZHRoICkgKXtcbiAgICAgICAgb3B0aW9ucyA9IHdpZHRoO1xuICAgIH1lbHNle1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgd2lkdGg6IGFyZ3NbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IGFyZ3NbMV0sXG4gICAgICAgICAgICB0aWxlU2l6ZTogYXJnc1syXSxcbiAgICAgICAgICAgIHRpbGVPdmVybGFwOiBhcmdzWzNdLFxuICAgICAgICAgICAgbWluTGV2ZWw6IGFyZ3NbNF0sXG4gICAgICAgICAgICBtYXhMZXZlbDogYXJnc1s1XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vVGlsZSBzb3VyY2VzIHN1cHBseSBzb21lIGV2ZW50cywgbmFtZWx5ICdyZWFkeScgd2hlbiB0aGV5IG11c3QgYmUgY29uZmlndXJlZFxuICAgIC8vYnkgYXN5bmNocm9ub3VzbHkgZmV0Y2hpbmcgdGhlaXIgY29uZmlndXJhdGlvbiBkYXRhLlxuICAgICQuRXZlbnRTb3VyY2UuY2FsbCggdGhpcyApO1xuXG4gICAgLy93ZSBhbGxvdyBvcHRpb25zIHRvIG92ZXJyaWRlIGFueXRoaW5nIHdlIGRvbnQgdHJlYXQgYXNcbiAgICAvL3JlcXVpcmVkIHZpYSBpZGlvbWF0aWMgb3B0aW9ucyBvciB3aGljaCBpcyBmdW5jdGlvbmFsbHlcbiAgICAvL3NldCBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIHRoZSByZWFkaW5lc3Mgb2YgdGhpcyB0aWxlXG4gICAgLy9zb3VyY2VcbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywgb3B0aW9ucyApO1xuXG4gICAgaWYgKCF0aGlzLnN1Y2Nlc3MpIHtcbiAgICAgICAgLy9BbnkgZnVuY3Rpb25zIHRoYXQgYXJlIHBhc3NlZCBhcyBhcmd1bWVudHMgYXJlIGJvdW5kIHRvIHRoZSByZWFkeSBjYWxsYmFja1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBhcmd1bWVudHNbIGkgXSApICkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2VzcyA9IGFyZ3VtZW50c1sgaSBdO1xuICAgICAgICAgICAgICAgIC8vb25seSBvbmUgY2FsbGJhY2sgcGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWNjZXNzKSB7XG4gICAgICAgIHRoaXMuYWRkSGFuZGxlciggJ3JlYWR5JywgZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MoIGV2ZW50ICk7XG4gICAgICAgIH0gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSYXRpbyBvZiB3aWR0aCB0byBoZWlnaHRcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGFzcGVjdFJhdGlvXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZSNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBWZWN0b3Igc3RvcmluZyB4IGFuZCB5IGRpbWVuc2lvbnMgKCB3aWR0aCBhbmQgaGVpZ2h0IHJlc3BlY3RpdmVseSApLlxuICAgICAqIEBtZW1iZXIge09wZW5TZWFkcmFnb24uUG9pbnR9IGRpbWVuc2lvbnNcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlI1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoZSBvdmVybGFwIGluIHBpeGVscyBlYWNoIHRpbGUgc2hhcmVzIHdpdGggaXRzIGFkamFjZW50IG5laWdoYm9ycy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRpbGVPdmVybGFwXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZSNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBweXJhbWlkIGxldmVsIHRoaXMgdGlsZSBzb3VyY2Ugc3VwcG9ydHMgb3Igc2hvdWxkIGF0dGVtcHQgdG8gbG9hZC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbkxldmVsXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZSNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBweXJhbWlkIGxldmVsIHRoaXMgdGlsZSBzb3VyY2Ugc3VwcG9ydHMgb3Igc2hvdWxkIGF0dGVtcHQgdG8gbG9hZC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heExldmVsXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZSNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlYWR5XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZSNcbiAgICAgKi9cblxuICAgIGlmKCAnc3RyaW5nJyA9PSAkLnR5cGUoIGFyZ3VtZW50c1sgMCBdICkgKXtcbiAgICAgICAgdGhpcy51cmwgPSBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudXJsKSB7XG4gICAgICAgIC8vaW4gY2FzZSB0aGUgZ2V0SW1hZ2VJbmZvIG1ldGhvZCBpcyBvdmVycmlkZW4gYW5kL29yIGltcGxpZXMgYW5cbiAgICAgICAgLy9hc3luYyBtZWNoYW5pc20gc2V0IHNvbWUgc2FmZSBkZWZhdWx0cyBmaXJzdFxuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gMTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zICA9IG5ldyAkLlBvaW50KCAxMCwgMTAgKTtcbiAgICAgICAgdGhpcy5fdGlsZVdpZHRoICA9IDA7XG4gICAgICAgIHRoaXMuX3RpbGVIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnRpbGVPdmVybGFwID0gMDtcbiAgICAgICAgdGhpcy5taW5MZXZlbCAgICA9IDA7XG4gICAgICAgIHRoaXMubWF4TGV2ZWwgICAgPSAwO1xuICAgICAgICB0aGlzLnJlYWR5ICAgICAgID0gZmFsc2U7XG4gICAgICAgIC8vY29uZmlndXJhdGlvbiB2aWEgdXJsIGltcGxpZXMgdGhlIGV4dGVuZGluZyBjbGFzc1xuICAgICAgICAvL2ltcGxlbWVudHMgYW5kICdjb25maWd1cmUnXG4gICAgICAgIHRoaXMuZ2V0SW1hZ2VJbmZvKCB0aGlzLnVybCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL2V4cGxpY2l0IGNvbmZpZ3VyYXRpb24gdmlhIHBvc2l0aW9uYWwgYXJncyBpbiBjb25zdHJ1Y3RvclxuICAgICAgICAvL29yIHRoZSBtb3JlIGlkaW9tYXRpYyAnb3B0aW9ucycgb2JqZWN0XG4gICAgICAgIHRoaXMucmVhZHkgICAgICAgPSB0cnVlO1xuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gKCBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0ICkgP1xuICAgICAgICAgICAgKCAgb3B0aW9ucy53aWR0aCAvIG9wdGlvbnMuaGVpZ2h0ICkgOiAxO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMgID0gbmV3ICQuUG9pbnQoIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0ICk7XG5cbiAgICAgICAgaWYgKCB0aGlzLnRpbGVTaXplICl7XG4gICAgICAgICAgICB0aGlzLl90aWxlV2lkdGggPSB0aGlzLl90aWxlSGVpZ2h0ID0gdGhpcy50aWxlU2l6ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVTaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIHRoaXMudGlsZVdpZHRoICl7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBwYXNzZWQgdGlsZVdpZHRoIGluIG9wdGlvbnMsIGJ1dCB3ZSB3YW50IHRvIHJlbmFtZSBpdFxuICAgICAgICAgICAgICAgIC8vIHdpdGggYSBsZWFkaW5nIHVuZGVyc2NvcmUgdG8gbWFrZSBjbGVhciB0aGF0IGl0IGlzIG5vdCBzYWZlIHRvIGRpcmVjdGx5IG1vZGlmeSBpdFxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlsZVdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHRoaXMudGlsZUhlaWdodCApe1xuICAgICAgICAgICAgICAgIC8vIFNlZSBub3RlIGFib3ZlIGFib3V0IHJlbmFtaW5nIHRoaXMudGlsZVdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5fdGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodDtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50aWxlSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGlsZU92ZXJsYXAgPSBvcHRpb25zLnRpbGVPdmVybGFwID8gb3B0aW9ucy50aWxlT3ZlcmxhcCA6IDA7XG4gICAgICAgIHRoaXMubWluTGV2ZWwgICAgPSBvcHRpb25zLm1pbkxldmVsID8gb3B0aW9ucy5taW5MZXZlbCA6IDA7XG4gICAgICAgIHRoaXMubWF4TGV2ZWwgICAgPSAoIHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhMZXZlbCAmJiBudWxsICE9PSBvcHRpb25zLm1heExldmVsICkgP1xuICAgICAgICAgICAgb3B0aW9ucy5tYXhMZXZlbCA6IChcbiAgICAgICAgICAgICAgICAoIG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQgKSA/IE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coIE1hdGgubWF4KCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCApICkgL1xuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZyggMiApXG4gICAgICAgICAgICAgICAgKSA6IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIGlmKCB0aGlzLnN1Y2Nlc3MgJiYgJC5pc0Z1bmN0aW9uKCB0aGlzLnN1Y2Nlc3MgKSApe1xuICAgICAgICAgICAgdGhpcy5zdWNjZXNzKCB0aGlzICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcblxuLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2UucHJvdG90eXBlICovXG4kLlRpbGVTb3VyY2UucHJvdG90eXBlID0ge1xuXG4gICAgZ2V0VGlsZVNpemU6IGZ1bmN0aW9uKCBsZXZlbCApIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJbVGlsZVNvdXJjZS5nZXRUaWxlU2l6ZV0gaXMgZGVwcmVjYXRlZC5cIiArXG4gICAgICAgICAgICBcIlVzZSBUaWxlU291cmNlLmdldFRpbGVXaWR0aCgpIGFuZCBUaWxlU291cmNlLmdldFRpbGVIZWlnaHQoKSBpbnN0ZWFkXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0aWxlV2lkdGggZm9yIGEgZ2l2ZW4gbGV2ZWwuXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBpZiB0aWxlV2lkdGggY2FuIGJlIGRpZmZlcmVudCBhdCBkaWZmZXJlbnQgbGV2ZWxzXG4gICAgICogICBzdWNoIGFzIGluIElJSUZUaWxlU291cmNlLiAgQ29kZSBzaG91bGQgdXNlIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmVhZGluZ1xuICAgICAqICAgZnJvbSAuX3RpbGVXaWR0aCBkaXJlY3RseS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXRUaWxlV2lkdGg6IGZ1bmN0aW9uKCBsZXZlbCApIHtcbiAgICAgICAgaWYgKCF0aGlzLl90aWxlV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVTaXplKGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZVdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRpbGVIZWlnaHQgZm9yIGEgZ2l2ZW4gbGV2ZWwuXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBpZiB0aWxlSGVpZ2h0IGNhbiBiZSBkaWZmZXJlbnQgYXQgZGlmZmVyZW50IGxldmVsc1xuICAgICAqICAgc3VjaCBhcyBpbiBJSUlGVGlsZVNvdXJjZS4gIENvZGUgc2hvdWxkIHVzZSB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJlYWRpbmdcbiAgICAgKiAgIGZyb20gLl90aWxlSGVpZ2h0IGRpcmVjdGx5LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqL1xuICAgIGdldFRpbGVIZWlnaHQ6IGZ1bmN0aW9uKCBsZXZlbCApIHtcbiAgICAgICAgaWYgKCF0aGlzLl90aWxlSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlU2l6ZShsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqL1xuICAgIGdldExldmVsU2NhbGU6IGZ1bmN0aW9uKCBsZXZlbCApIHtcblxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29wZW5zZWFkcmFnb24vb3BlbnNlYWRyYWdvbi9pc3N1ZXMvMjJcbiAgICAgICAgLy8gd2UgdXNlIHRoZSB0aWxlc291cmNlcyBpbXBsZW1lbnRhdGlvbiBvZiBnZXRMZXZlbFNjYWxlIHRvIGdlbmVyYXRlXG4gICAgICAgIC8vIGEgbWVtb2l6ZWQgcmUtaW1wbGVtZW50YXRpb25cbiAgICAgICAgdmFyIGxldmVsU2NhbGVDYWNoZSA9IHt9LFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yKCBpID0gMDsgaSA8PSB0aGlzLm1heExldmVsOyBpKysgKXtcbiAgICAgICAgICAgIGxldmVsU2NhbGVDYWNoZVsgaSBdID0gMSAvIE1hdGgucG93KDIsIHRoaXMubWF4TGV2ZWwgLSBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldExldmVsU2NhbGUgPSBmdW5jdGlvbiggX2xldmVsICl7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWxTY2FsZUNhY2hlWyBfbGV2ZWwgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGV2ZWxTY2FsZSggbGV2ZWwgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0TnVtVGlsZXM6IGZ1bmN0aW9uKCBsZXZlbCApIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRMZXZlbFNjYWxlKCBsZXZlbCApLFxuICAgICAgICAgICAgeCA9IE1hdGguY2VpbCggc2NhbGUgKiB0aGlzLmRpbWVuc2lvbnMueCAvIHRoaXMuZ2V0VGlsZVdpZHRoKGxldmVsKSApLFxuICAgICAgICAgICAgeSA9IE1hdGguY2VpbCggc2NhbGUgKiB0aGlzLmRpbWVuc2lvbnMueSAvIHRoaXMuZ2V0VGlsZUhlaWdodChsZXZlbCkgKTtcblxuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoIHgsIHkgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24oIGxldmVsICkge1xuICAgICAgICB2YXIgaW1hZ2VTaXplU2NhbGVkID0gdGhpcy5kaW1lbnNpb25zLnRpbWVzKCB0aGlzLmdldExldmVsU2NhbGUoIGxldmVsICkgKSxcbiAgICAgICAgICAgIHJ4ID0gMS4wIC8gaW1hZ2VTaXplU2NhbGVkLngsXG4gICAgICAgICAgICByeSA9IDEuMCAvIGltYWdlU2l6ZVNjYWxlZC55O1xuXG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChyeCwgcnkpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqL1xuICAgIGdldENsb3Nlc3RMZXZlbDogZnVuY3Rpb24oIHJlY3QgKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdGlsZXNQZXJTaWRlLFxuICAgICAgICAgICAgdGlsZXM7XG5cbiAgICAgICAgZm9yKCBpID0gdGhpcy5taW5MZXZlbDsgaSA8IHRoaXMubWF4TGV2ZWw7IGkrKyApe1xuICAgICAgICAgICAgdGlsZXMgPSB0aGlzLmdldE51bVRpbGVzKCBpICk7XG4gICAgICAgICAgICB0aWxlc1BlclNpZGUgPSBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgTWF0aC5mbG9vciggcmVjdC54IC8gdGhpcy5nZXRUaWxlV2lkdGgoaSkgKSxcbiAgICAgICAgICAgICAgTWF0aC5mbG9vciggcmVjdC55IC8gdGhpcy5nZXRUaWxlSGVpZ2h0KGkpIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmKCB0aWxlcy54ICsgMSA+PSB0aWxlc1BlclNpZGUueCAmJiB0aWxlcy55ICsgMSA+PSB0aWxlc1BlclNpZGUueSApe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCggMCwgaSAtIDEgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludFxuICAgICAqL1xuICAgIGdldFRpbGVBdFBvaW50OiBmdW5jdGlvbiggbGV2ZWwsIHBvaW50ICkge1xuICAgICAgICB2YXIgcGl4ZWwgPSBwb2ludC50aW1lcyggdGhpcy5kaW1lbnNpb25zLnggKS50aW1lcyggdGhpcy5nZXRMZXZlbFNjYWxlKGxldmVsKSApLFxuICAgICAgICAgICAgdHggPSBNYXRoLmZsb29yKCBwaXhlbC54IC8gdGhpcy5nZXRUaWxlV2lkdGgobGV2ZWwpICksXG4gICAgICAgICAgICB0eSA9IE1hdGguZmxvb3IoIHBpeGVsLnkgLyB0aGlzLmdldFRpbGVIZWlnaHQobGV2ZWwpICk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KCB0eCwgdHkgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGdldFRpbGVCb3VuZHM6IGZ1bmN0aW9uKCBsZXZlbCwgeCwgeSApIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnNTY2FsZWQgPSB0aGlzLmRpbWVuc2lvbnMudGltZXMoIHRoaXMuZ2V0TGV2ZWxTY2FsZSggbGV2ZWwgKSApLFxuICAgICAgICAgICAgdGlsZVdpZHRoID0gdGhpcy5nZXRUaWxlV2lkdGgobGV2ZWwpLFxuICAgICAgICAgICAgdGlsZUhlaWdodCA9IHRoaXMuZ2V0VGlsZUhlaWdodChsZXZlbCksXG4gICAgICAgICAgICBweCA9ICggeCA9PT0gMCApID8gMCA6IHRpbGVXaWR0aCAqIHggLSB0aGlzLnRpbGVPdmVybGFwLFxuICAgICAgICAgICAgcHkgPSAoIHkgPT09IDAgKSA/IDAgOiB0aWxlSGVpZ2h0ICogeSAtIHRoaXMudGlsZU92ZXJsYXAsXG4gICAgICAgICAgICBzeCA9IHRpbGVXaWR0aCArICggeCA9PT0gMCA/IDEgOiAyICkgKiB0aGlzLnRpbGVPdmVybGFwLFxuICAgICAgICAgICAgc3kgPSB0aWxlSGVpZ2h0ICsgKCB5ID09PSAwID8gMSA6IDIgKSAqIHRoaXMudGlsZU92ZXJsYXAsXG4gICAgICAgICAgICBzY2FsZSA9IDEuMCAvIGRpbWVuc2lvbnNTY2FsZWQueDtcblxuICAgICAgICBzeCA9IE1hdGgubWluKCBzeCwgZGltZW5zaW9uc1NjYWxlZC54IC0gcHggKTtcbiAgICAgICAgc3kgPSBNYXRoLm1pbiggc3ksIGRpbWVuc2lvbnNTY2FsZWQueSAtIHB5ICk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoIHB4ICogc2NhbGUsIHB5ICogc2NhbGUsIHN4ICogc2NhbGUsIHN5ICogc2NhbGUgKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgcmV0cmlldmluZywgYW5kIGNhY2hpbmcgdGhlXG4gICAgICogaW1hZ2UgbWV0YWRhdGEgcGVydGluZW50IHRvIHRoaXMgVGlsZVNvdXJjZXMgaW1wbGVtZW50YXRpb24uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIGdldEltYWdlSW5mbzogZnVuY3Rpb24oIHVybCApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIGNhbGxiYWNrTmFtZSxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgcmVhZHlTb3VyY2UsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgdXJsUGFydHMsXG4gICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgIGxhc3REb3Q7XG5cblxuICAgICAgICBpZiggdXJsICkge1xuICAgICAgICAgICAgdXJsUGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xuICAgICAgICAgICAgZmlsZW5hbWUgPSB1cmxQYXJ0c1sgdXJsUGFydHMubGVuZ3RoIC0gMSBdO1xuICAgICAgICAgICAgbGFzdERvdCAgPSBmaWxlbmFtZS5sYXN0SW5kZXhPZiggJy4nICk7XG4gICAgICAgICAgICBpZiAoIGxhc3REb3QgPiAtMSApIHtcbiAgICAgICAgICAgICAgICB1cmxQYXJ0c1sgdXJsUGFydHMubGVuZ3RoIC0gMSBdID0gZmlsZW5hbWUuc2xpY2UoIDAsIGxhc3REb3QgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oIGRhdGEgKXtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YoZGF0YSkgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9ICQucGFyc2VYbWwoIGRhdGEgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAkVGlsZVNvdXJjZSA9ICQuVGlsZVNvdXJjZS5kZXRlcm1pbmVUeXBlKCBfdGhpcywgZGF0YSwgdXJsICk7XG4gICAgICAgICAgICBpZiAoICEkVGlsZVNvdXJjZSApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgbG9hZGluZyBhIFRpbGVTb3VyY2UuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgb3Blbi1mYWlsZWRcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlXG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZVNvdXJjZX0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVGlsZVNvdXJjZSB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHNvdXJjZVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCAnb3Blbi1mYWlsZWQnLCB7IG1lc3NhZ2U6IFwiVW5hYmxlIHRvIGxvYWQgVGlsZVNvdXJjZVwiLCBzb3VyY2U6IHVybCB9ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zID0gJFRpbGVTb3VyY2UucHJvdG90eXBlLmNvbmZpZ3VyZS5hcHBseSggX3RoaXMsIFsgZGF0YSwgdXJsIF0pO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWpheFdpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hamF4V2l0aENyZWRlbnRpYWxzID0gX3RoaXMuYWpheFdpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVhZHlTb3VyY2UgPSBuZXcgJFRpbGVTb3VyY2UoIG9wdGlvbnMgKTtcbiAgICAgICAgICAgIF90aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gYSBUaWxlU291cmNlIGlzIG9wZW5lZCBhbmQgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IHJlYWR5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2V9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFRpbGVTb3VyY2Ugd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0aWxlU291cmNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoICdyZWFkeScsIHsgdGlsZVNvdXJjZTogcmVhZHlTb3VyY2UgfSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCB1cmwubWF0Y2goL1xcLmpzJC8pICl7XG4gICAgICAgICAgICAvL1RPRE86IEl0cyBub3QgdmVyeSBmbGV4aWJsZSB0byByZXF1aXJlIHRpbGUgc291cmNlcyB0byBlbmQganNvbnBcbiAgICAgICAgICAgIC8vICAgICAgcmVxdWVzdCBmb3IgaW5mbyAgd2l0aCBhIHVybCB0aGF0IGVuZHMgd2l0aCAnLmpzJyBidXQgZm9yXG4gICAgICAgICAgICAvLyAgICAgIG5vdyBpdCdzIHRoZSBvbmx5IHdheSBJIHNlZSB0byBkaXN0aW5ndWlzaCB1bmlmb3JtbHkuXG4gICAgICAgICAgICBjYWxsYmFja05hbWUgPSB1cmwuc3BsaXQoICcvJyApLnBvcCgpLnJlcGxhY2UoJy5qcycsJycpO1xuICAgICAgICAgICAgJC5qc29ucCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrTmFtZTogY2FsbGJhY2tOYW1lLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZXF1ZXN0IGluZm8gdmlhIHhociBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICQubWFrZUFqYXhSZXF1ZXN0KCB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0aGlzLmFqYXhXaXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oIHhociApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBwcm9jZXNzUmVzcG9uc2UoIHhociApO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggZGF0YSApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICggeGhyLCBleGMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2c7XG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIElFIDwgMTAgd2lsbCBibG9jayBYSFIgcmVxdWVzdHMgdG8gZGlmZmVyZW50IG9yaWdpbnMuIEFueSBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbiB3aGljaCB3ZSdsbCBhdHRlbXB0IHRvIGhhbmRsZSBieSBmb3JtYXR0aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uIHJhdGhlciB0aGFuIHRoZSBzZWNvbmQgb25lIHJhaXNlZCB3aGVuIHdlIHRyeSB0byBhY2Nlc3MgeGhyLnN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IFwiSFRUUCBcIiArIHhoci5zdGF0dXMgKyBcIiBhdHRlbXB0aW5nIHRvIGxvYWQgVGlsZVNvdXJjZVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRFeGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiggZXhjICkgPT0gXCJ1bmRlZmluZWRcIiB8fCAhZXhjLnRvU3RyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEV4YyA9IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRFeGMgPSBleGMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gZm9ybWF0dGVkRXhjICsgXCIgYXR0ZW1wdGluZyB0byBsb2FkIFRpbGVTb3VyY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKipcbiAgICAgICAgICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGxvYWRpbmcgYSBUaWxlU291cmNlLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgb3Blbi1mYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZVNvdXJjZX0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVGlsZVNvdXJjZSB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoICdvcGVuLWZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2libGUgZGV0ZXJtaW5pbmcgaWYgYSB0aGUgcGFydGljdWxhciBUaWxlU291cmNlIHN1cHBvcnRzIHRoZVxuICAgICAqIGRhdGEgZm9ybWF0ICggYW5kIGFsbG93ZWQgdG8gYXBwbHkgbG9naWMgYWdhaW5zdCB0aGUgdXJsIHRoZSBkYXRhIHdhc1xuICAgICAqIGxvYWRlZCBmcm9tLCBpZiBhbnkgKS4gT3ZlcnJpZGluZyBpbXBsZW1lbnRhdGlvbnMgYXJlIGV4cGVjdGVkIHRvIGRvXG4gICAgICogc29tZXRoaW5nIHNtYXJ0IHdpdGggZGF0YSBhbmQgLyBvciB1cmwgdG8gZGV0ZXJtaW5lIHN1cHBvcnQuICBBbHNvXG4gICAgICogdW5kZXJzdGFuZCB0aGF0IGl0ZXJhdGlvbiBvcmRlciBvZiBUaWxlU291cmNlcyBpcyBub3QgZ3VhcnVudGVlZCBzb1xuICAgICAqIHBsZWFzZSBtYWtlIHN1cmUgeW91ciBkYXRhIG9yIHVybCBpcyBleHByZXNzaXZlIGVub3VnaCB0byBlbnN1cmUgYSBzaW1wbGVcbiAgICAgKiBhbmQgc3VmZmljaWVudCBtZWNoYW5pc2ltIGZvciBjbGVhciBkZXRlcm1pbmF0aW9uLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheXxEb2N1bWVudH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSB0aGUgdXJsIHRoZSBkYXRhIHdhcyBsb2FkZWRcbiAgICAgKiAgICAgIGZyb20gaWYgYW55LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2libGUgZm9yIHBhcnNpbmcgYW5kIGNvbmZpZ3VyaW5nIHRoZVxuICAgICAqIGltYWdlIG1ldGFkYXRhIHBlcnRpbmVudCB0byB0aGlzIFRpbGVTb3VyY2VzIGltcGxlbWVudGF0aW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBieSB0aGlzIGNsYXNzIG90aGVyIHRoYW4gdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgKiBhbm5vdW5jaW5nIHlvdSBoYXZlIHRvIGltcGxlbWVudCBpdC4gIEJlY2F1c2Ugb2YgdGhlIHZhcmlldHkgb2YgdGlsZVxuICAgICAqIHNlcnZlciB0ZWNobm9sb2dpZXMsIGFuZCB2YXJpb3VzIHNwZWNpZmljYXRpb25zIGZvciBidWlsZGluZyBpbWFnZVxuICAgICAqIHB5cmFtaWRzLCB0aGlzIG1ldGhvZCBpcyBoZXJlIHRvIGFsbG93IGVhc3kgaW50ZWdyYXRpb24uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEFycmF5fERvY3VtZW50fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIHRoZSB1cmwgdGhlIGRhdGEgd2FzIGxvYWRlZFxuICAgICAqICAgICAgZnJvbSBpZiBhbnkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvcHRpb25zIC0gQSBkaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHN1ZmZpY2llbnRcbiAgICAgKiAgICAgIHRvIGNvbmZpZ3VyZSB0aGlzIHRpbGUgc291cmNlcyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciByZXRyaXZpbmcgdGhlIHVybCB3aGljaCB3aWxsIHJldHVybiBhbiBpbWFnZSBmb3IgdGhlXG4gICAgICogcmVnaW9uIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4geCwgeSwgYW5kIGxldmVsIGNvbXBvbmVudHMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGJ5IHRoaXMgY2xhc3Mgb3RoZXIgdGhhbiB0byB0aHJvdyBhbiBFcnJvclxuICAgICAqIGFubm91bmNpbmcgeW91IGhhdmUgdG8gaW1wbGVtZW50IGl0LiAgQmVjYXVzZSBvZiB0aGUgdmFyaWV0eSBvZiB0aWxlXG4gICAgICogc2VydmVyIHRlY2hub2xvZ2llcywgYW5kIHZhcmlvdXMgc3BlY2lmaWNhdGlvbnMgZm9yIGJ1aWxkaW5nIGltYWdlXG4gICAgICogcHlyYW1pZHMsIHRoaXMgbWV0aG9kIGlzIGhlcmUgdG8gYWxsb3cgZWFzeSBpbnRlZ3JhdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgZ2V0VGlsZVVybDogZnVuY3Rpb24oIGxldmVsLCB4LCB5ICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIiApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgdGlsZUV4aXN0czogZnVuY3Rpb24oIGxldmVsLCB4LCB5ICkge1xuICAgICAgICB2YXIgbnVtVGlsZXMgPSB0aGlzLmdldE51bVRpbGVzKCBsZXZlbCApO1xuICAgICAgICByZXR1cm4gIGxldmVsID49IHRoaXMubWluTGV2ZWwgJiZcbiAgICAgICAgICAgICAgICBsZXZlbCA8PSB0aGlzLm1heExldmVsICYmXG4gICAgICAgICAgICAgICAgeCA+PSAwICYmXG4gICAgICAgICAgICAgICAgeSA+PSAwICYmXG4gICAgICAgICAgICAgICAgeCA8IG51bVRpbGVzLnggJiZcbiAgICAgICAgICAgICAgICB5IDwgbnVtVGlsZXMueTtcbiAgICB9XG59O1xuXG5cbiQuZXh0ZW5kKCB0cnVlLCAkLlRpbGVTb3VyY2UucHJvdG90eXBlLCAkLkV2ZW50U291cmNlLnByb3RvdHlwZSApO1xuXG5cbi8qKlxuICogRGVjaWRlcyB3aGV0aGVyIHRvIHRyeSB0byBwcm9jZXNzIHRoZSByZXNwb25zZSBhcyB4bWwsIGpzb24sIG9yIGhhbmQgYmFja1xuICogdGhlIHRleHRcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0geGhyIC0gdGhlIGNvbXBsZXRlZCBuZXR3b3JrIHJlcXVlc3RcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKCB4aHIgKXtcbiAgICB2YXIgcmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgc3RhdHVzICAgICAgID0geGhyLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgZGF0YTtcblxuICAgIGlmICggIXhociApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAkLmdldFN0cmluZyggXCJFcnJvcnMuU2VjdXJpdHlcIiApICk7XG4gICAgfSBlbHNlIGlmICggeGhyLnN0YXR1cyAhPT0gMjAwICYmIHhoci5zdGF0dXMgIT09IDAgKSB7XG4gICAgICAgIHN0YXR1cyAgICAgPSB4aHIuc3RhdHVzO1xuICAgICAgICBzdGF0dXNUZXh0ID0gKCBzdGF0dXMgPT0gNDA0ICkgP1xuICAgICAgICAgICAgXCJOb3QgRm91bmRcIiA6XG4gICAgICAgICAgICB4aHIuc3RhdHVzVGV4dDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAkLmdldFN0cmluZyggXCJFcnJvcnMuU3RhdHVzXCIsIHN0YXR1cywgc3RhdHVzVGV4dCApICk7XG4gICAgfVxuXG4gICAgaWYoIHJlc3BvbnNlVGV4dC5tYXRjaCgvXFxzKjwuKi8pICl7XG4gICAgICAgIHRyeXtcbiAgICAgICAgZGF0YSA9ICggeGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQgKSA/XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VYTUwgOlxuICAgICAgICAgICAgJC5wYXJzZVhtbCggcmVzcG9uc2VUZXh0ICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICB9ZWxzZSBpZiggcmVzcG9uc2VUZXh0Lm1hdGNoKC9cXHMqW1xce1xcW10uKi8pICl7XG4gICAgICAgIGRhdGEgPSAkLnBhcnNlSlNPTihyZXNwb25zZVRleHQpO1xuICAgIH1lbHNle1xuICAgICAgICBkYXRhID0gcmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIFRpbGVTb3VyY2UgSW1wbGVtZW50YXRpb24gYnkgaW50cm9zcGVjdGlvbiBvZiBPcGVuU2VhZHJhZ29uXG4gKiBuYW1lc3BhY2UsIGNhbGxpbmcgZWFjaCBUaWxlU291cmNlIGltcGxlbWVudGF0aW9uIG9mICdpc1R5cGUnXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fERvY3VtZW50fSBkYXRhIC0gdGhlIHRpbGUgc291cmNlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gdGhlIHVybCB3aGVyZSB0aGUgdGlsZSBzb3VyY2UgY29uZmlndXJhdGlvbiBvYmplY3Qgd2FzXG4gKiAgICAgIGxvYWRlZCBmcm9tLCBpZiBhbnkuXG4gKi9cbiQuVGlsZVNvdXJjZS5kZXRlcm1pbmVUeXBlID0gZnVuY3Rpb24oIHRpbGVTb3VyY2UsIGRhdGEsIHVybCApe1xuICAgIHZhciBwcm9wZXJ0eTtcbiAgICBmb3IoIHByb3BlcnR5IGluIE9wZW5TZWFkcmFnb24gKXtcbiAgICAgICAgaWYoIHByb3BlcnR5Lm1hdGNoKC8uK1RpbGVTb3VyY2UkLykgJiZcbiAgICAgICAgICAgICQuaXNGdW5jdGlvbiggT3BlblNlYWRyYWdvblsgcHJvcGVydHkgXSApICYmXG4gICAgICAgICAgICAkLmlzRnVuY3Rpb24oIE9wZW5TZWFkcmFnb25bIHByb3BlcnR5IF0ucHJvdG90eXBlLnN1cHBvcnRzICkgJiZcbiAgICAgICAgICAgIE9wZW5TZWFkcmFnb25bIHByb3BlcnR5IF0ucHJvdG90eXBlLnN1cHBvcnRzLmNhbGwoIHRpbGVTb3VyY2UsIGRhdGEsIHVybCApXG4gICAgICAgICl7XG4gICAgICAgICAgICByZXR1cm4gT3BlblNlYWRyYWdvblsgcHJvcGVydHkgXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICQuY29uc29sZS5lcnJvciggXCJObyBUaWxlU291cmNlIHdhcyBhYmxlIHRvIG9wZW4gJXMgJXNcIiwgdXJsLCBkYXRhICk7XG59O1xuXG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gRHppVGlsZVNvdXJjZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgRHppVGlsZVNvdXJjZVxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZVxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB3aWR0aCAtIHRoZSBwaXhlbCB3aWR0aCBvZiB0aGUgaW1hZ2Ugb3IgdGhlIGlkaW9tYXRpY1xuICogICAgICBvcHRpb25zIG9iamVjdCB3aGljaCBpcyB1c2VkIGluc3RlYWQgb2YgcG9zaXRpb25hbCBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gdGlsZVNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aWxlT3ZlcmxhcFxuICogQHBhcmFtIHtTdHJpbmd9IHRpbGVzVXJsXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUZvcm1hdFxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkRpc3BsYXlSZWN0W119IGRpc3BsYXlSZWN0c1xuICogQHByb3BlcnR5IHtTdHJpbmd9IHRpbGVzVXJsXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZmlsZUZvcm1hdFxuICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkRpc3BsYXlSZWN0W119IGRpc3BsYXlSZWN0c1xuICovXG4kLkR6aVRpbGVTb3VyY2UgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgdGlsZVNpemUsIHRpbGVPdmVybGFwLCB0aWxlc1VybCwgZmlsZUZvcm1hdCwgZGlzcGxheVJlY3RzLCBtaW5MZXZlbCwgbWF4TGV2ZWwgKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHJlY3QsXG4gICAgICAgIGxldmVsLFxuICAgICAgICBvcHRpb25zO1xuXG4gICAgaWYoICQuaXNQbGFpbk9iamVjdCggd2lkdGggKSApe1xuICAgICAgICBvcHRpb25zID0gd2lkdGg7XG4gICAgfWVsc2V7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB3aWR0aDogYXJndW1lbnRzWyAwIF0sXG4gICAgICAgICAgICBoZWlnaHQ6IGFyZ3VtZW50c1sgMSBdLFxuICAgICAgICAgICAgdGlsZVNpemU6IGFyZ3VtZW50c1sgMiBdLFxuICAgICAgICAgICAgdGlsZU92ZXJsYXA6IGFyZ3VtZW50c1sgMyBdLFxuICAgICAgICAgICAgdGlsZXNVcmw6IGFyZ3VtZW50c1sgNCBdLFxuICAgICAgICAgICAgZmlsZUZvcm1hdDogYXJndW1lbnRzWyA1IF0sXG4gICAgICAgICAgICBkaXNwbGF5UmVjdHM6IGFyZ3VtZW50c1sgNiBdLFxuICAgICAgICAgICAgbWluTGV2ZWw6IGFyZ3VtZW50c1sgNyBdLFxuICAgICAgICAgICAgbWF4TGV2ZWw6IGFyZ3VtZW50c1sgOCBdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fbGV2ZWxSZWN0cyAgPSB7fTtcbiAgICB0aGlzLnRpbGVzVXJsICAgICA9IG9wdGlvbnMudGlsZXNVcmw7XG4gICAgdGhpcy5maWxlRm9ybWF0ICAgPSBvcHRpb25zLmZpbGVGb3JtYXQ7XG4gICAgdGhpcy5kaXNwbGF5UmVjdHMgPSBvcHRpb25zLmRpc3BsYXlSZWN0cztcblxuICAgIGlmICggdGhpcy5kaXNwbGF5UmVjdHMgKSB7XG4gICAgICAgIGZvciAoIGkgPSB0aGlzLmRpc3BsYXlSZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLmRpc3BsYXlSZWN0c1sgaSBdO1xuICAgICAgICAgICAgZm9yICggbGV2ZWwgPSByZWN0Lm1pbkxldmVsOyBsZXZlbCA8PSByZWN0Lm1heExldmVsOyBsZXZlbCsrICkge1xuICAgICAgICAgICAgICAgIGlmICggIXRoaXMuX2xldmVsUmVjdHNbIGxldmVsIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsUmVjdHNbIGxldmVsIF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxSZWN0c1sgbGV2ZWwgXS5wdXNoKCByZWN0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkLlRpbGVTb3VyY2UuYXBwbHkoIHRoaXMsIFsgb3B0aW9ucyBdICk7XG5cbn07XG5cbiQuZXh0ZW5kKCAkLkR6aVRpbGVTb3VyY2UucHJvdG90eXBlLCAkLlRpbGVTb3VyY2UucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uRHppVGlsZVNvdXJjZS5wcm90b3R5cGUgKi97XG5cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgZGF0YSBhbmQvb3IgdXJsIGltcGx5IHRoZSBpbWFnZSBzZXJ2aWNlIGlzIHN1cHBvcnRlZCBieVxuICAgICAqIHRoaXMgdGlsZSBzb3VyY2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uYWwgLSB1cmxcbiAgICAgKi9cbiAgICBzdXBwb3J0czogZnVuY3Rpb24oIGRhdGEsIHVybCApe1xuICAgICAgICB2YXIgbnM7XG4gICAgICAgIGlmICggZGF0YS5JbWFnZSApIHtcbiAgICAgICAgICAgIG5zID0gZGF0YS5JbWFnZS54bWxucztcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChcIkltYWdlXCIgPT0gZGF0YS5kb2N1bWVudEVsZW1lbnQubG9jYWxOYW1lIHx8IFwiSW1hZ2VcIiA9PSBkYXRhLmRvY3VtZW50RWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgbnMgPSBkYXRhLmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vZGVlcHpvb20vMjAwOFwiID09IG5zIHx8XG4gICAgICAgICAgICBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vZGVlcHpvb20vMjAwOVwiID09IG5zICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8WE1MRG9jdW1lbnR9IGRhdGEgLSB0aGUgcmF3IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gdGhlIHVybCB0aGUgZGF0YSB3YXMgcmV0cmVpdmVkIGZyb20gaWYgYW55LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb3B0aW9ucyAtIEEgZGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cyBzdWZmaWNpZW50XG4gICAgICogICAgICB0byBjb25maWd1cmUgdGhpcyB0aWxlIHNvdXJjZXMgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbiggZGF0YSwgdXJsICl7XG5cbiAgICAgICAgdmFyIG9wdGlvbnM7XG5cbiAgICAgICAgaWYoICEkLmlzUGxhaW5PYmplY3QoZGF0YSkgKXtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbmZpZ3VyZUZyb21YTUwoIHRoaXMsIGRhdGEgKTtcblxuICAgICAgICB9ZWxzZXtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbmZpZ3VyZUZyb21PYmplY3QoIHRoaXMsIGRhdGEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmwgJiYgIW9wdGlvbnMudGlsZXNVcmwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGlsZXNVcmwgPSB1cmwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgLyhbXlxcL10rPykoXFwuKGR6aXx4bWx8anMpKT9cXC8/KFxcPy4qKT8kLywgJyQxX2ZpbGVzLycpO1xuXG4gICAgICAgICAgICBpZiAodXJsLnNlYXJjaCgvXFwuKGR6aXx4bWx8anMpXFw/LykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5UGFyYW1zID0gdXJsLm1hdGNoKC9cXD8uKi8pO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeVBhcmFtcyA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGdldFRpbGVVcmw6IGZ1bmN0aW9uKCBsZXZlbCwgeCwgeSApIHtcbiAgICAgICAgcmV0dXJuIFsgdGhpcy50aWxlc1VybCwgbGV2ZWwsICcvJywgeCwgJ18nLCB5LCAnLicsIHRoaXMuZmlsZUZvcm1hdCwgdGhpcy5xdWVyeVBhcmFtcyBdLmpvaW4oICcnICk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIHRpbGVFeGlzdHM6IGZ1bmN0aW9uKCBsZXZlbCwgeCwgeSApIHtcbiAgICAgICAgdmFyIHJlY3RzID0gdGhpcy5fbGV2ZWxSZWN0c1sgbGV2ZWwgXSxcbiAgICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgIHhNaW4sXG4gICAgICAgICAgICB5TWluLFxuICAgICAgICAgICAgeE1heCxcbiAgICAgICAgICAgIHlNYXgsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmICggIXJlY3RzIHx8ICFyZWN0cy5sZW5ndGggKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSByZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIGxldmVsIDwgcmVjdC5taW5MZXZlbCB8fCBsZXZlbCA+IHJlY3QubWF4TGV2ZWwgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjYWxlID0gdGhpcy5nZXRMZXZlbFNjYWxlKCBsZXZlbCApO1xuICAgICAgICAgICAgeE1pbiA9IHJlY3QueCAqIHNjYWxlO1xuICAgICAgICAgICAgeU1pbiA9IHJlY3QueSAqIHNjYWxlO1xuICAgICAgICAgICAgeE1heCA9IHhNaW4gKyByZWN0LndpZHRoICogc2NhbGU7XG4gICAgICAgICAgICB5TWF4ID0geU1pbiArIHJlY3QuaGVpZ2h0ICogc2NhbGU7XG5cbiAgICAgICAgICAgIHhNaW4gPSBNYXRoLmZsb29yKCB4TWluIC8gdGhpcy50aWxlU2l6ZSApO1xuICAgICAgICAgICAgeU1pbiA9IE1hdGguZmxvb3IoIHlNaW4gLyB0aGlzLnRpbGVTaXplICk7XG4gICAgICAgICAgICB4TWF4ID0gTWF0aC5jZWlsKCB4TWF4IC8gdGhpcy50aWxlU2l6ZSApO1xuICAgICAgICAgICAgeU1heCA9IE1hdGguY2VpbCggeU1heCAvIHRoaXMudGlsZVNpemUgKTtcblxuICAgICAgICAgICAgaWYgKCB4TWluIDw9IHggJiYgeCA8IHhNYXggJiYgeU1pbiA8PSB5ICYmIHkgPCB5TWF4ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZUZyb21YTUwoIHRpbGVTb3VyY2UsIHhtbERvYyApe1xuXG4gICAgaWYgKCAheG1sRG9jIHx8ICF4bWxEb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5YbWxcIiApICk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgICAgICAgICAgID0geG1sRG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgcm9vdE5hbWUgICAgICAgPSByb290LmxvY2FsTmFtZSB8fCByb290LnRhZ05hbWUsXG4gICAgICAgIG5zICAgICAgICAgICAgID0geG1sRG9jLmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkksXG4gICAgICAgIGNvbmZpZ3VyYXRpb24gID0gbnVsbCxcbiAgICAgICAgZGlzcGxheVJlY3RzICAgPSBbXSxcbiAgICAgICAgZGlzcFJlY3ROb2RlcyxcbiAgICAgICAgZGlzcFJlY3ROb2RlLFxuICAgICAgICByZWN0Tm9kZSxcbiAgICAgICAgc2l6ZU5vZGUsXG4gICAgICAgIGk7XG5cbiAgICBpZiAoIHJvb3ROYW1lID09IFwiSW1hZ2VcIiApIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2l6ZU5vZGUgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiU2l6ZVwiIClbIDAgXTtcbiAgICAgICAgICAgIGlmIChzaXplTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2l6ZU5vZGUgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lTlMobnMsIFwiU2l6ZVwiIClbIDAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBJbWFnZToge1xuICAgICAgICAgICAgICAgICAgICB4bWxuczogICAgICAgXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RlZXB6b29tLzIwMDhcIixcbiAgICAgICAgICAgICAgICAgICAgVXJsOiAgICAgICAgIHJvb3QuZ2V0QXR0cmlidXRlKCBcIlVybFwiICksXG4gICAgICAgICAgICAgICAgICAgIEZvcm1hdDogICAgICByb290LmdldEF0dHJpYnV0ZSggXCJGb3JtYXRcIiApLFxuICAgICAgICAgICAgICAgICAgICBEaXNwbGF5UmVjdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgT3ZlcmxhcDogICAgIHBhcnNlSW50KCByb290LmdldEF0dHJpYnV0ZSggXCJPdmVybGFwXCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgVGlsZVNpemU6ICAgIHBhcnNlSW50KCByb290LmdldEF0dHJpYnV0ZSggXCJUaWxlU2l6ZVwiICksIDEwICksXG4gICAgICAgICAgICAgICAgICAgIFNpemU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhlaWdodDogcGFyc2VJbnQoIHNpemVOb2RlLmdldEF0dHJpYnV0ZSggXCJIZWlnaHRcIiApLCAxMCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgV2lkdGg6ICBwYXJzZUludCggc2l6ZU5vZGUuZ2V0QXR0cmlidXRlKCBcIldpZHRoXCIgKSwgMTAgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCAhJC5pbWFnZUZvcm1hdFN1cHBvcnRlZCggY29uZmlndXJhdGlvbi5JbWFnZS5Gb3JtYXQgKSApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5JbWFnZUZvcm1hdFwiLCBjb25maWd1cmF0aW9uLkltYWdlLkZvcm1hdC50b1VwcGVyQ2FzZSgpIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXNwUmVjdE5vZGVzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkRpc3BsYXlSZWN0XCIgKTtcbiAgICAgICAgICAgIGlmIChkaXNwUmVjdE5vZGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkaXNwUmVjdE5vZGVzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKG5zLCBcIkRpc3BsYXlSZWN0XCIgKVsgMCBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGRpc3BSZWN0Tm9kZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgZGlzcFJlY3ROb2RlID0gZGlzcFJlY3ROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgICAgIHJlY3ROb2RlICAgICA9IGRpc3BSZWN0Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlJlY3RcIiApWyAwIF07XG4gICAgICAgICAgICAgICAgaWYgKHJlY3ROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdE5vZGUgPSBkaXNwUmVjdE5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyhucywgXCJSZWN0XCIgKVsgMCBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpc3BsYXlSZWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgUmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgWDogcGFyc2VJbnQoIHJlY3ROb2RlLmdldEF0dHJpYnV0ZSggXCJYXCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFk6IHBhcnNlSW50KCByZWN0Tm9kZS5nZXRBdHRyaWJ1dGUoIFwiWVwiICksIDEwICksXG4gICAgICAgICAgICAgICAgICAgICAgICBXaWR0aDogcGFyc2VJbnQoIHJlY3ROb2RlLmdldEF0dHJpYnV0ZSggXCJXaWR0aFwiICksIDEwICksXG4gICAgICAgICAgICAgICAgICAgICAgICBIZWlnaHQ6IHBhcnNlSW50KCByZWN0Tm9kZS5nZXRBdHRyaWJ1dGUoIFwiSGVpZ2h0XCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1pbkxldmVsOiBwYXJzZUludCggZGlzcFJlY3ROb2RlLmdldEF0dHJpYnV0ZSggXCJNaW5MZXZlbFwiICksIDEwICksXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXhMZXZlbDogcGFyc2VJbnQoIGRpc3BSZWN0Tm9kZS5nZXRBdHRyaWJ1dGUoIFwiTWF4TGV2ZWxcIiApLCAxMCApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGRpc3BsYXlSZWN0cy5sZW5ndGggKXtcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLkltYWdlLkRpc3BsYXlSZWN0ID0gZGlzcGxheVJlY3RzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29uZmlndXJlRnJvbU9iamVjdCggdGlsZVNvdXJjZSwgY29uZmlndXJhdGlvbiApO1xuXG4gICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgdGhyb3cgKGUgaW5zdGFuY2VvZiBFcnJvcikgP1xuICAgICAgICAgICAgICAgIGUgOlxuICAgICAgICAgICAgICAgIG5ldyBFcnJvciggJC5nZXRTdHJpbmcoXCJFcnJvcnMuRHppXCIpICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCByb290TmFtZSA9PSBcIkNvbGxlY3Rpb25cIiApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAkLmdldFN0cmluZyggXCJFcnJvcnMuRHpjXCIgKSApO1xuICAgIH0gZWxzZSBpZiAoIHJvb3ROYW1lID09IFwiRXJyb3JcIiApIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VOb2RlID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIk1lc3NhZ2VcIilbMF07XG4gICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZU5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5EemlcIiApICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZUZyb21PYmplY3QoIHRpbGVTb3VyY2UsIGNvbmZpZ3VyYXRpb24gKXtcbiAgICB2YXIgaW1hZ2VEYXRhICAgICA9IGNvbmZpZ3VyYXRpb24uSW1hZ2UsXG4gICAgICAgIHRpbGVzVXJsICAgICAgPSBpbWFnZURhdGEuVXJsLFxuICAgICAgICBmaWxlRm9ybWF0ICAgID0gaW1hZ2VEYXRhLkZvcm1hdCxcbiAgICAgICAgc2l6ZURhdGEgICAgICA9IGltYWdlRGF0YS5TaXplLFxuICAgICAgICBkaXNwUmVjdERhdGEgID0gaW1hZ2VEYXRhLkRpc3BsYXlSZWN0IHx8IFtdLFxuICAgICAgICB3aWR0aCAgICAgICAgID0gcGFyc2VJbnQoIHNpemVEYXRhLldpZHRoLCAxMCApLFxuICAgICAgICBoZWlnaHQgICAgICAgID0gcGFyc2VJbnQoIHNpemVEYXRhLkhlaWdodCwgMTAgKSxcbiAgICAgICAgdGlsZVNpemUgICAgICA9IHBhcnNlSW50KCBpbWFnZURhdGEuVGlsZVNpemUsIDEwICksXG4gICAgICAgIHRpbGVPdmVybGFwICAgPSBwYXJzZUludCggaW1hZ2VEYXRhLk92ZXJsYXAsIDEwICksXG4gICAgICAgIGRpc3BsYXlSZWN0cyAgPSBbXSxcbiAgICAgICAgcmVjdERhdGEsXG4gICAgICAgIGk7XG5cbiAgICAvL1RPRE86IG5lZWQgdG8gZmlndXJlIG91dCBvdXQgdG8gYmV0dGVyIGhhbmRsZSBpbWFnZSBmb3JtYXQgY29tcGF0aWJpbGl0eVxuICAgIC8vICAgICAgd2hpY2ggYWN0dWFsbHkgaW5jbHVkZXMgYWRkaXRpb25hbCBmaWxlIGZvcm1hdHMgbGlrZSB4bWwgYW5kIHBkZlxuICAgIC8vICAgICAgYW5kIHBsYWluIHRleHQgZm9yIHZhcmlvdXMgdGlsZXNvdXJjZSBpbXBsZW1lbnRhdGlvbnMgdG8gYXZvaWQgbG93XG4gICAgLy8gICAgICBsZXZlbCBlcnJvcnMuXG4gICAgLy9cbiAgICAvLyAgICAgIEZvciBub3csIGp1c3QgZG9uJ3QgcGVyZm9ybSB0aGUgY2hlY2suXG4gICAgLy9cbiAgICAvKmlmICggIWltYWdlRm9ybWF0U3VwcG9ydGVkKCBmaWxlRm9ybWF0ICkgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5JbWFnZUZvcm1hdFwiLCBmaWxlRm9ybWF0LnRvVXBwZXJDYXNlKCkgKVxuICAgICAgICApO1xuICAgIH0qL1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBkaXNwUmVjdERhdGEubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHJlY3REYXRhID0gZGlzcFJlY3REYXRhWyBpIF0uUmVjdDtcblxuICAgICAgICBkaXNwbGF5UmVjdHMucHVzaCggbmV3ICQuRGlzcGxheVJlY3QoXG4gICAgICAgICAgICBwYXJzZUludCggcmVjdERhdGEuWCwgMTAgKSxcbiAgICAgICAgICAgIHBhcnNlSW50KCByZWN0RGF0YS5ZLCAxMCApLFxuICAgICAgICAgICAgcGFyc2VJbnQoIHJlY3REYXRhLldpZHRoLCAxMCApLFxuICAgICAgICAgICAgcGFyc2VJbnQoIHJlY3REYXRhLkhlaWdodCwgMTAgKSxcbiAgICAgICAgICAgIHBhcnNlSW50KCByZWN0RGF0YS5NaW5MZXZlbCwgMTAgKSxcbiAgICAgICAgICAgIHBhcnNlSW50KCByZWN0RGF0YS5NYXhMZXZlbCwgMTAgKVxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJC5leHRlbmQodHJ1ZSwge1xuICAgICAgICB3aWR0aDogd2lkdGgsIC8qIHdpZHRoICpyZXF1aXJlZCAqL1xuICAgICAgICBoZWlnaHQ6IGhlaWdodCwgLyogaGVpZ2h0ICpyZXF1aXJlZCAqL1xuICAgICAgICB0aWxlU2l6ZTogdGlsZVNpemUsIC8qIHRpbGVTaXplICpyZXF1aXJlZCAqL1xuICAgICAgICB0aWxlT3ZlcmxhcDogdGlsZU92ZXJsYXAsIC8qIHRpbGVPdmVybGFwICpyZXF1aXJlZCAqL1xuICAgICAgICBtaW5MZXZlbDogbnVsbCwgLyogbWluTGV2ZWwgKi9cbiAgICAgICAgbWF4TGV2ZWw6IG51bGwsIC8qIG1heExldmVsICovXG4gICAgICAgIHRpbGVzVXJsOiB0aWxlc1VybCwgLyogdGlsZXNVcmwgKi9cbiAgICAgICAgZmlsZUZvcm1hdDogZmlsZUZvcm1hdCwgLyogZmlsZUZvcm1hdCAqL1xuICAgICAgICBkaXNwbGF5UmVjdHM6IGRpc3BsYXlSZWN0cyAvKiBkaXNwbGF5UmVjdHMgKi9cbiAgICB9LCBjb25maWd1cmF0aW9uICk7XG5cbn1cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBJSUlGVGlsZVNvdXJjZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgSUlJRlRpbGVTb3VyY2VcbiAqIEBjbGFzc2Rlc2MgQSBjbGllbnQgaW1wbGVtZW50YXRpb24gb2YgdGhlIEludGVybmF0aW9uYWwgSW1hZ2UgSW50ZXJvcGVyYWJpbGl0eSBGcmFtZXdvcmtcbiAqIEZvcm1hdDogSW1hZ2UgQVBJIDEuMCAtIDIuMVxuICpcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2VcbiAqIEBzZWUgaHR0cDovL2lpaWYuaW8vYXBpL2ltYWdlL1xuICovXG4kLklJSUZUaWxlU291cmNlID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcblxuXG4gICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIG9wdGlvbnMgKTtcblxuICAgIGlmICggISggdGhpcy5oZWlnaHQgJiYgdGhpcy53aWR0aCAmJiB0aGlzWydAaWQnXSApICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdJSUlGIHJlcXVpcmVkIHBhcmFtZXRlcnMgbm90IHByb3ZpZGVkLicgKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLnRpbGVTaXplUGVyU2NhbGVGYWN0b3IgPSB7fTtcblxuICAgIC8vIE4uQi4gMi4wIHJlbmFtZWQgc2NhbGVfZmFjdG9ycyB0byBzY2FsZUZhY3RvcnNcbiAgICBpZiAoIHRoaXMudGlsZV93aWR0aCAmJiB0aGlzLnRpbGVfaGVpZ2h0ICkge1xuICAgICAgICBvcHRpb25zLnRpbGVXaWR0aCA9IHRoaXMudGlsZV93aWR0aDtcbiAgICAgICAgb3B0aW9ucy50aWxlSGVpZ2h0ID0gdGhpcy50aWxlX2hlaWdodDtcbiAgICB9IGVsc2UgaWYgKCB0aGlzLnRpbGVfd2lkdGggKSB7XG4gICAgICAgIG9wdGlvbnMudGlsZVNpemUgPSB0aGlzLnRpbGVfd2lkdGg7XG4gICAgfSBlbHNlIGlmICggdGhpcy50aWxlX2hlaWdodCApIHtcbiAgICAgICAgb3B0aW9ucy50aWxlU2l6ZSA9IHRoaXMudGlsZV9oZWlnaHQ7XG4gICAgfSBlbHNlIGlmICggdGhpcy50aWxlcyApIHtcbiAgICAgICAgLy8gVmVyc2lvbiAyLjAgZm9yd2FyZHNcbiAgICAgICAgaWYgKCB0aGlzLnRpbGVzLmxlbmd0aCA9PSAxICkge1xuICAgICAgICAgICAgb3B0aW9ucy50aWxlV2lkdGggID0gdGhpcy50aWxlc1swXS53aWR0aDtcbiAgICAgICAgICAgIC8vIFVzZSBoZWlnaHQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBhc3N1bWUgc3F1YXJlIHRpbGVzIGFuZCB1c2Ugd2lkdGguXG4gICAgICAgICAgICBvcHRpb25zLnRpbGVIZWlnaHQgPSB0aGlzLnRpbGVzWzBdLmhlaWdodCB8fCB0aGlzLnRpbGVzWzBdLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5zY2FsZV9mYWN0b3JzID0gdGhpcy50aWxlc1swXS5zY2FsZUZhY3RvcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNdWx0aXBsZSB0aWxlIHNpemVzIGF0IGRpZmZlcmVudCBsZXZlbHNcbiAgICAgICAgICAgIHRoaXMuc2NhbGVfZmFjdG9ycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLnRpbGVzLmxlbmd0aDsgdCsrICkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNmID0gMDsgc2YgPCB0aGlzLnRpbGVzW3RdLnNjYWxlRmFjdG9ycy5sZW5ndGg7IHNmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gdGhpcy50aWxlc1t0XS5zY2FsZUZhY3RvcnNbc2ZdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlX2ZhY3RvcnMucHVzaChzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudGlsZVNpemVQZXJTY2FsZUZhY3RvcltzY2FsZUZhY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy50aWxlc1t0XS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy50aWxlc1t0XS5oZWlnaHQgfHwgdGhpcy50aWxlc1t0XS53aWR0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIGNhbkJlVGlsZWQob3B0aW9ucy5wcm9maWxlKSApIHtcbiAgICAgICAgLy8gdXNlIHRoZSBsYXJnZXN0IG9mIHRpbGVPcHRpb25zIHRoYXQgaXMgc21hbGxlciB0aGFuIHRoZSBzaG9ydCBkaW1lbnNpb25cbiAgICAgICAgdmFyIHNob3J0RGltID0gTWF0aC5taW4oIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoICksXG4gICAgICAgICAgICB0aWxlT3B0aW9ucyA9IFsyNTYsNTEyLDEwMjRdLFxuICAgICAgICAgICAgc21hbGxlclRpbGVzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGMgPSAwOyBjIDwgdGlsZU9wdGlvbnMubGVuZ3RoOyBjKysgKSB7XG4gICAgICAgICAgICBpZiAoIHRpbGVPcHRpb25zW2NdIDw9IHNob3J0RGltICkge1xuICAgICAgICAgICAgICAgIHNtYWxsZXJUaWxlcy5wdXNoKCB0aWxlT3B0aW9uc1tjXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBzbWFsbGVyVGlsZXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLm1heC5hcHBseSggbnVsbCwgc21hbGxlclRpbGVzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBzbWFsbGVyIHRoYW4gMjU2LCBqdXN0IHVzZSB0aGUgc2hvcnQgc2lkZS5cbiAgICAgICAgICAgIG9wdGlvbnMudGlsZVNpemUgPSBzaG9ydERpbTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zaXplcyAmJiB0aGlzLnNpemVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVGhpcyBpbmZvLmpzb24gY2FuJ3QgYmUgdGlsZWQsIGJ1dCB3ZSBjYW4gc3RpbGwgY29uc3RydWN0IGEgbGVnYWN5IHB5cmFtaWQgZnJvbSB0aGUgc2l6ZXMgYXJyYXkuIFxuICAgICAgICAvLyBJbiB0aGlzIG1vZGUsIElJSUZUaWxlU291cmNlIHdpbGwgY2FsbCBmdW5jdGlvbnMgZnJvbSB0aGUgYWJzdHJhY3QgYmFzZVRpbGVTb3VyY2Ugb3IgdGhlIFxuICAgICAgICAvLyBMZWdhY3lUaWxlU291cmNlIGluc3RlYWQgb2YgcGVyZm9ybWluZyBJSUlGIHRpbGluZy4gICAgICBcbiAgICAgICAgdGhpcy5lbXVsYXRlTGVnYWN5SW1hZ2VQeXJhbWlkID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIG9wdGlvbnMubGV2ZWxzID0gY29uc3RydWN0TGV2ZWxzKCB0aGlzICk7XG4gICAgICAgIC8vIHVzZSB0aGUgbGFyZ2VzdCBhdmFpbGFibGUgc2l6ZSB0byBkZWZpbmUgdGlsZXNcbiAgICAgICAgJC5leHRlbmQoIHRydWUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLmxldmVsc1sgb3B0aW9ucy5sZXZlbHMubGVuZ3RoIC0gMSBdLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmxldmVsc1sgb3B0aW9ucy5sZXZlbHMubGVuZ3RoIC0gMSBdLmhlaWdodCxcbiAgICAgICAgICAgIHRpbGVTaXplOiBNYXRoLm1heCggb3B0aW9ucy5oZWlnaHQsIG9wdGlvbnMud2lkdGggKSxcbiAgICAgICAgICAgIHRpbGVPdmVybGFwOiAwLFxuICAgICAgICAgICAgbWluTGV2ZWw6IDAsXG4gICAgICAgICAgICBtYXhMZXZlbDogb3B0aW9ucy5sZXZlbHMubGVuZ3RoIC0gMVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZXZlbHMgPSBvcHRpb25zLmxldmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXCJOb3RoaW5nIGluIHRoZSBpbmZvLmpzb24gdG8gY29uc3RydWN0IGltYWdlIHB5cmFtaWRzIGZyb21cIik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1heExldmVsICYmICF0aGlzLmVtdWxhdGVMZWdhY3lJbWFnZVB5cmFtaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNjYWxlX2ZhY3RvcnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWF4TGV2ZWwgPSBOdW1iZXIoTWF0aC5jZWlsKE1hdGgubG9nKE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSwgMikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWF4TGV2ZWwgPSBNYXRoLmZsb29yKE1hdGgucG93KE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuc2NhbGVfZmFjdG9ycyksIDAuNSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJC5UaWxlU291cmNlLmFwcGx5KCB0aGlzLCBbIG9wdGlvbnMgXSApO1xufTtcblxuJC5leHRlbmQoICQuSUlJRlRpbGVTb3VyY2UucHJvdG90eXBlLCAkLlRpbGVTb3VyY2UucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uSUlJRlRpbGVTb3VyY2UucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgZGF0YSBhbmQvb3IgdXJsIGltcGx5IHRoZSBpbWFnZSBzZXJ2aWNlIGlzIHN1cHBvcnRlZCBieVxuICAgICAqIHRoaXMgdGlsZSBzb3VyY2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uYWwgLSB1cmxcbiAgICAgKi9cbiAgICAgXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKSB7XG4gICAgICAgIC8vIFZlcnNpb24gMi4wIGFuZCBmb3J3YXJkc1xuICAgICAgICBpZiAoZGF0YS5wcm90b2NvbCAmJiBkYXRhLnByb3RvY29sID09ICdodHRwOi8vaWlpZi5pby9hcGkvaW1hZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gVmVyc2lvbiAxLjFcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YVsnQGNvbnRleHQnXSAmJiAoXG4gICAgICAgICAgICBkYXRhWydAY29udGV4dCddID09IFwiaHR0cDovL2xpYnJhcnkuc3RhbmZvcmQuZWR1L2lpaWYvaW1hZ2UtYXBpLzEuMS9jb250ZXh0Lmpzb25cIiB8fFxuICAgICAgICAgICAgZGF0YVsnQGNvbnRleHQnXSA9PSBcImh0dHA6Ly9paWlmLmlvL2FwaS9pbWFnZS8xL2NvbnRleHQuanNvblwiKSApIHtcbiAgICAgICAgICAgIC8vIE4uQi4gdGhlIGlpaWYuaW8gY29udGV4dCBpcyB3cm9uZywgYnV0IHdoZXJlIHRoZSByZXByZXNlbnRhdGlvbiBsaXZlcyBzbyBsaWtlbHkgdG8gYmUgdXNlZFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gVmVyc2lvbiAxLjBcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS5wcm9maWxlICYmXG4gICAgICAgICAgICBkYXRhLnByb2ZpbGUuaW5kZXhPZihcImh0dHA6Ly9saWJyYXJ5LnN0YW5mb3JkLmVkdS9paWlmL2ltYWdlLWFwaS9jb21wbGlhbmNlLmh0bWxcIikgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLmlkZW50aWZpZXIgJiYgZGF0YS53aWR0aCAmJiBkYXRhLmhlaWdodCApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgICAgICAgXCJpbmZvXCIgPT0gZGF0YS5kb2N1bWVudEVsZW1lbnQudGFnTmFtZSAmJlxuICAgICAgICAgICAgXCJodHRwOi8vbGlicmFyeS5zdGFuZm9yZC5lZHUvaWlpZi9pbWFnZS1hcGkvbnMvXCIgPT1cbiAgICAgICAgICAgICAgICBkYXRhLmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIE5vdCBJSUlGXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHRoZSByYXcgY29uZmlndXJhdGlvblxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPklJSUYgMS4xIEluZm8gTG9va3MgbGlrZSB0aGlzPC9jYXB0aW9uPlxuICAgICAqIHtcbiAgICAgKiAgIFwiQGNvbnRleHRcIiA6IFwiaHR0cDovL2xpYnJhcnkuc3RhbmZvcmQuZWR1L2lpaWYvaW1hZ2UtYXBpLzEuMS9jb250ZXh0Lmpzb25cIixcbiAgICAgKiAgIFwiQGlkXCIgOiBcImh0dHA6Ly9paWlmLmV4YW1wbGUuY29tL3ByZWZpeC8xRTM0NzUwRC0zOERCLTQ4MjUtQTM4QS1CNjBBMzQ1RTU5MUNcIixcbiAgICAgKiAgIFwid2lkdGhcIiA6IDYwMDAsXG4gICAgICogICBcImhlaWdodFwiIDogNDAwMCxcbiAgICAgKiAgIFwic2NhbGVfZmFjdG9yc1wiIDogWyAxLCAyLCA0IF0sXG4gICAgICogICBcInRpbGVfd2lkdGhcIiA6IDEwMjQsXG4gICAgICogICBcInRpbGVfaGVpZ2h0XCIgOiAxMDI0LFxuICAgICAqICAgXCJmb3JtYXRzXCIgOiBbIFwianBnXCIsIFwicG5nXCIgXSxcbiAgICAgKiAgIFwicXVhbGl0aWVzXCIgOiBbIFwibmF0aXZlXCIsIFwiZ3JleVwiIF0sXG4gICAgICogICBcInByb2ZpbGVcIiA6IFwiaHR0cDovL2xpYnJhcnkuc3RhbmZvcmQuZWR1L2lpaWYvaW1hZ2UtYXBpLzEuMS9jb21wbGlhbmNlLmh0bWwjbGV2ZWwwXCJcbiAgICAgKiB9XG4gICAgICovXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbiggZGF0YSwgdXJsICl7XG4gICAgICAgIC8vIFRyeSB0byBkZWR1Y2Ugb3VyIHZlcnNpb24gYW5kIGZha2UgaXQgdXB3YXJkcyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCAhJC5pc1BsYWluT2JqZWN0KGRhdGEpICkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBjb25maWd1cmVGcm9tWG1sMTAoIGRhdGEgKTtcbiAgICAgICAgICAgIG9wdGlvbnNbJ0Bjb250ZXh0J10gPSBcImh0dHA6Ly9paWlmLmlvL2FwaS9pbWFnZS8xLjAvY29udGV4dC5qc29uXCI7XG4gICAgICAgICAgICBvcHRpb25zWydAaWQnXSA9IHVybC5yZXBsYWNlKCcvaW5mby54bWwnLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmICggIWRhdGFbJ0Bjb250ZXh0J10gKSB7XG4gICAgICAgICAgICBkYXRhWydAY29udGV4dCddID0gJ2h0dHA6Ly9paWlmLmlvL2FwaS9pbWFnZS8xLjAvY29udGV4dC5qc29uJztcbiAgICAgICAgICAgIGRhdGFbJ0BpZCddID0gdXJsLnJlcGxhY2UoJy9pbmZvLmpzb24nLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGlsZVdpZHRoIGZvciB0aGUgZ2l2ZW4gbGV2ZWwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0VGlsZVdpZHRoOiBmdW5jdGlvbiggbGV2ZWwgKSB7XG5cbiAgICAgICAgaWYodGhpcy5lbXVsYXRlTGVnYWN5SW1hZ2VQeXJhbWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlV2lkdGguY2FsbCh0aGlzLCBsZXZlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSBNYXRoLnBvdygyLCB0aGlzLm1heExldmVsIC0gbGV2ZWwpO1xuXG4gICAgICAgIGlmICh0aGlzLnRpbGVTaXplUGVyU2NhbGVGYWN0b3IgJiYgdGhpcy50aWxlU2l6ZVBlclNjYWxlRmFjdG9yW3NjYWxlRmFjdG9yXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemVQZXJTY2FsZUZhY3RvcltzY2FsZUZhY3Rvcl0ud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0aWxlSGVpZ2h0IGZvciB0aGUgZ2l2ZW4gbGV2ZWwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0VGlsZUhlaWdodDogZnVuY3Rpb24oIGxldmVsICkge1xuXG4gICAgICAgIGlmKHRoaXMuZW11bGF0ZUxlZ2FjeUltYWdlUHlyYW1pZCkge1xuICAgICAgICAgICAgcmV0dXJuICQuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUhlaWdodC5jYWxsKHRoaXMsIGxldmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IE1hdGgucG93KDIsIHRoaXMubWF4TGV2ZWwgLSBsZXZlbCk7XG5cbiAgICAgICAgaWYgKHRoaXMudGlsZVNpemVQZXJTY2FsZUZhY3RvciAmJiB0aGlzLnRpbGVTaXplUGVyU2NhbGVGYWN0b3Jbc2NhbGVGYWN0b3JdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZVBlclNjYWxlRmFjdG9yW3NjYWxlRmFjdG9yXS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqL1xuICAgIGdldExldmVsU2NhbGU6IGZ1bmN0aW9uICggbGV2ZWwgKSB7XG5cbiAgICAgICAgaWYodGhpcy5lbXVsYXRlTGVnYWN5SW1hZ2VQeXJhbWlkKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxTY2FsZSA9IE5hTjtcbiAgICAgICAgICAgIGlmICh0aGlzLmxldmVscy5sZW5ndGggPiAwICYmIGxldmVsID49IHRoaXMubWluTGV2ZWwgJiYgbGV2ZWwgPD0gdGhpcy5tYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgIGxldmVsU2NhbGUgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxldmVsc1tsZXZlbF0ud2lkdGggL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxldmVsc1t0aGlzLm1heExldmVsXS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZXZlbFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0TGV2ZWxTY2FsZS5jYWxsKHRoaXMsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0TnVtVGlsZXM6IGZ1bmN0aW9uKCBsZXZlbCApIHtcblxuICAgICAgICBpZih0aGlzLmVtdWxhdGVMZWdhY3lJbWFnZVB5cmFtaWQpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0TGV2ZWxTY2FsZShsZXZlbCk7XG4gICAgICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoMSwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkLlRpbGVTb3VyY2UucHJvdG90eXBlLmdldE51bVRpbGVzLmNhbGwodGhpcywgbGV2ZWwpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBnZXRUaWxlQXRQb2ludDogZnVuY3Rpb24oIGxldmVsLCBwb2ludCApIHtcblxuICAgICAgICBpZih0aGlzLmVtdWxhdGVMZWdhY3lJbWFnZVB5cmFtaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCgwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkLlRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVBdFBvaW50LmNhbGwodGhpcywgbGV2ZWwsIHBvaW50KTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgcmV0cmlldmluZyB0aGUgdXJsIHdoaWNoIHdpbGwgcmV0dXJuIGFuIGltYWdlIGZvciB0aGVcbiAgICAgKiByZWdpb24gc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiB4LCB5LCBhbmQgbGV2ZWwgY29tcG9uZW50cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgLSB6IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIGdldFRpbGVVcmw6IGZ1bmN0aW9uKCBsZXZlbCwgeCwgeSApe1xuXG4gICAgICAgIGlmKHRoaXMuZW11bGF0ZUxlZ2FjeUltYWdlUHlyYW1pZCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIHRoaXMubGV2ZWxzLmxlbmd0aCA+IDAgJiYgbGV2ZWwgPj0gdGhpcy5taW5MZXZlbCAmJiBsZXZlbCA8PSB0aGlzLm1heExldmVsICkge1xuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMubGV2ZWxzWyBsZXZlbCBdLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyMgY29uc3RhbnRzXG4gICAgICAgIHZhciBJSUlGX1JPVEFUSU9OID0gJzAnLFxuICAgICAgICAgICAgLy8jIyBnZXQgdGhlIHNjYWxlIChsZXZlbCBhcyBhIGRlY2ltYWwpXG4gICAgICAgICAgICBzY2FsZSA9IE1hdGgucG93KCAwLjUsIHRoaXMubWF4TGV2ZWwgLSBsZXZlbCApLFxuXG4gICAgICAgICAgICAvLyMgaW1hZ2UgZGltZW5zaW9ucyBhdCB0aGlzIGxldmVsXG4gICAgICAgICAgICBsZXZlbFdpZHRoID0gTWF0aC5jZWlsKCB0aGlzLndpZHRoICogc2NhbGUgKSxcbiAgICAgICAgICAgIGxldmVsSGVpZ2h0ID0gTWF0aC5jZWlsKCB0aGlzLmhlaWdodCAqIHNjYWxlICksXG5cbiAgICAgICAgICAgIC8vIyMgaWlpZiByZWdpb25cbiAgICAgICAgICAgIHRpbGVXaWR0aCxcbiAgICAgICAgICAgIHRpbGVIZWlnaHQsXG4gICAgICAgICAgICBpaWlmVGlsZVNpemVXaWR0aCxcbiAgICAgICAgICAgIGlpaWZUaWxlU2l6ZUhlaWdodCxcbiAgICAgICAgICAgIGlpaWZSZWdpb24sXG4gICAgICAgICAgICBpaWlmVGlsZVgsXG4gICAgICAgICAgICBpaWlmVGlsZVksXG4gICAgICAgICAgICBpaWlmVGlsZVcsXG4gICAgICAgICAgICBpaWlmVGlsZUgsXG4gICAgICAgICAgICBpaWlmU2l6ZSxcbiAgICAgICAgICAgIGlpaWZRdWFsaXR5LFxuICAgICAgICAgICAgdXJpO1xuXG4gICAgICAgIHRpbGVXaWR0aCA9IHRoaXMuZ2V0VGlsZVdpZHRoKGxldmVsKTtcbiAgICAgICAgdGlsZUhlaWdodCA9IHRoaXMuZ2V0VGlsZUhlaWdodChsZXZlbCk7XG4gICAgICAgIGlpaWZUaWxlU2l6ZVdpZHRoID0gTWF0aC5jZWlsKCB0aWxlV2lkdGggLyBzY2FsZSApO1xuICAgICAgICBpaWlmVGlsZVNpemVIZWlnaHQgPSBNYXRoLmNlaWwoIHRpbGVIZWlnaHQgLyBzY2FsZSApO1xuXG4gICAgICAgIGlmICggdGhpc1snQGNvbnRleHQnXS5pbmRleE9mKCcvMS4wL2NvbnRleHQuanNvbicpID4gLTEgfHxcbiAgICAgICAgICAgICB0aGlzWydAY29udGV4dCddLmluZGV4T2YoJy8xLjEvY29udGV4dC5qc29uJykgPiAtMSB8fFxuICAgICAgICAgICAgIHRoaXNbJ0Bjb250ZXh0J10uaW5kZXhPZignLzEvY29udGV4dC5qc29uJykgPiAtMSApIHtcbiAgICAgICAgICAgIGlpaWZRdWFsaXR5ID0gXCJuYXRpdmUuanBnXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaWlmUXVhbGl0eSA9IFwiZGVmYXVsdC5qcGdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbGV2ZWxXaWR0aCA8IHRpbGVXaWR0aCAmJiBsZXZlbEhlaWdodCA8IHRpbGVIZWlnaHQgKXtcbiAgICAgICAgICAgIGlpaWZTaXplID0gbGV2ZWxXaWR0aCArIFwiLFwiO1xuICAgICAgICAgICAgaWlpZlJlZ2lvbiA9ICdmdWxsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpaWZUaWxlWCA9IHggKiBpaWlmVGlsZVNpemVXaWR0aDtcbiAgICAgICAgICAgIGlpaWZUaWxlWSA9IHkgKiBpaWlmVGlsZVNpemVIZWlnaHQ7XG4gICAgICAgICAgICBpaWlmVGlsZVcgPSBNYXRoLm1pbiggaWlpZlRpbGVTaXplV2lkdGgsIHRoaXMud2lkdGggLSBpaWlmVGlsZVggKTtcbiAgICAgICAgICAgIGlpaWZUaWxlSCA9IE1hdGgubWluKCBpaWlmVGlsZVNpemVIZWlnaHQsIHRoaXMuaGVpZ2h0IC0gaWlpZlRpbGVZICk7XG4gICAgICAgICAgICBpaWlmU2l6ZSA9IE1hdGguY2VpbCggaWlpZlRpbGVXICogc2NhbGUgKSArIFwiLFwiO1xuICAgICAgICAgICAgaWlpZlJlZ2lvbiA9IFsgaWlpZlRpbGVYLCBpaWlmVGlsZVksIGlpaWZUaWxlVywgaWlpZlRpbGVIIF0uam9pbiggJywnICk7XG4gICAgICAgIH1cbiAgICAgICAgdXJpID0gWyB0aGlzWydAaWQnXSwgaWlpZlJlZ2lvbiwgaWlpZlNpemUsIElJSUZfUk9UQVRJT04sIGlpaWZRdWFsaXR5IF0uam9pbiggJy8nICk7XG5cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciBhcmJpdHJhcnkgdGlsZSByZXF1ZXN0cyBjYW4gYmUgbWFkZSBhZ2FpbnN0IGEgc2VydmljZSB3aXRoIHRoZSBnaXZlbiBwcm9maWxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb2ZpbGUgLSBJSUlGIHByb2ZpbGUgb2JqZWN0XG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FuQmVUaWxlZCAocHJvZmlsZSApIHtcbiAgICAgICAgdmFyIGxldmVsMFByb2ZpbGVzID0gW1xuICAgICAgICAgICAgXCJodHRwOi8vbGlicmFyeS5zdGFuZm9yZC5lZHUvaWlpZi9pbWFnZS1hcGkvY29tcGxpYW5jZS5odG1sI2xldmVsMFwiLFxuICAgICAgICAgICAgXCJodHRwOi8vbGlicmFyeS5zdGFuZm9yZC5lZHUvaWlpZi9pbWFnZS1hcGkvMS4xL2NvbXBsaWFuY2UuaHRtbCNsZXZlbDBcIixcbiAgICAgICAgICAgIFwiaHR0cDovL2lpaWYuaW8vYXBpL2ltYWdlLzIvbGV2ZWwwLmpzb25cIlxuICAgICAgICBdO1xuICAgICAgICB2YXIgaXNMZXZlbDAgPSAobGV2ZWwwUHJvZmlsZXMuaW5kZXhPZihwcm9maWxlWzBdKSAhPSAtMSk7XG4gICAgICAgIHJldHVybiAhaXNMZXZlbDAgfHwgKHByb2ZpbGUuaW5kZXhPZihcInNpemVCeVdcIikgIT0gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBsZWdhY3kgcHlyYW1pZCBVUkxzIChvbmUgdGlsZSBwZXIgbGV2ZWwpXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBpbmZvSnNvblxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdExldmVscyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8b3B0aW9ucy5zaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV2ZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybDogb3B0aW9uc1snQGlkJ10gKyAnL2Z1bGwvJyArIG9wdGlvbnMuc2l6ZXNbaV0ud2lkdGggKyAnLC8wL2RlZmF1bHQuanBnJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucy5zaXplc1tpXS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuc2l6ZXNbaV0uaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGV2ZWxzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS53aWR0aCAtIGIud2lkdGg7fSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb25maWd1cmVGcm9tWG1sMTAoeG1sRG9jKSB7XG4gICAgICAgIC8vcGFyc2UgdGhlIHhtbFxuICAgICAgICBpZiAoICF4bWxEb2MgfHwgIXhtbERvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5YbWxcIiApICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdCAgICAgICAgICAgID0geG1sRG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgIHJvb3ROYW1lICAgICAgICA9IHJvb3QudGFnTmFtZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gICA9IG51bGw7XG5cbiAgICAgICAgaWYgKCByb290TmFtZSA9PSBcImluZm9cIiApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIHBhcnNlWE1MMTAoIHJvb3QsIGNvbmZpZ3VyYXRpb24gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvbjtcblxuICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKGUgaW5zdGFuY2VvZiBFcnJvcikgP1xuICAgICAgICAgICAgICAgICAgICBlIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCAkLmdldFN0cmluZyhcIkVycm9ycy5JSUlGXCIpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAkLmdldFN0cmluZyggXCJFcnJvcnMuSUlJRlwiICkgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVhNTDEwKCBub2RlLCBjb25maWd1cmF0aW9uLCBwcm9wZXJ0eSApIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgaWYgKCBub2RlLm5vZGVUeXBlID09IDMgJiYgcHJvcGVydHkgKSB7Ly90ZXh0IG5vZGVcbiAgICAgICAgICAgIHZhbHVlID0gbm9kZS5ub2RlVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgaWYoIHZhbHVlLm1hdGNoKC9eXFxkKiQvKSl7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIoIHZhbHVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggIWNvbmZpZ3VyYXRpb25bIHByb3BlcnR5IF0gKXtcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uWyBwcm9wZXJ0eSBdID0gdmFsdWU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBpZiggISQuaXNBcnJheSggY29uZmlndXJhdGlvblsgcHJvcGVydHkgXSApICl7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25bIHByb3BlcnR5IF0gPSBbIGNvbmZpZ3VyYXRpb25bIHByb3BlcnR5IF0gXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvblsgcHJvcGVydHkgXS5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIG5vZGUubm9kZVR5cGUgPT0gMSApe1xuICAgICAgICAgICAgZm9yKCBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICAgIHBhcnNlWE1MMTAoIG5vZGUuY2hpbGROb2Rlc1sgaSBdLCBjb25maWd1cmF0aW9uLCBub2RlLm5vZGVOYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIE9zbVRpbGVTb3VyY2VcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLypcbiAqIERlcml2ZWQgZnJvbSB0aGUgT1NNIHRpbGUgc291cmNlIGluIFJhaW5lciBTaW1vbidzIHNlYWpheC11dGlscyBwcm9qZWN0XG4gKiA8aHR0cDovL2dpdGh1Yi5jb20vcnNpbW9uL3NlYWpheC11dGlscz4uICBSYWluZXIgU2ltb24gaGFzIGNvbnRyaWJ1dGVkXG4gKiB0aGUgaW5jbHVkZWQgY29kZSB0byB0aGUgT3BlblNlYWRyYWdvbiBwcm9qZWN0IHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2U7XG4gKiBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuc2VhZHJhZ29uL29wZW5zZWFkcmFnb24vaXNzdWVzLzU4Pi5cbiAqL1xuXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBPc21UaWxlU291cmNlXG4gKiBAY2xhc3NkZXNjIEEgdGlsZXNvdXJjZSBpbXBsZW1lbnRhdGlvbiBmb3IgT3BlblN0cmVldE1hcC48YnI+PGJyPlxuICpcbiAqIE5vdGUgMS4gWm9vbWxldmVscy4gRGVlcCBab29tIGFuZCBPU00gZGVmaW5lIHpvb20gbGV2ZWxzIGRpZmZlcmVudGx5LiBJbiAgRGVlcFxuICogWm9vbSwgbGV2ZWwgMCBlcXVhbHMgYW4gaW1hZ2Ugb2YgMXgxIHBpeGVscy4gSW4gT1NNLCBsZXZlbCAwIGVxdWFscyBhbiBpbWFnZSBvZlxuICogMjU2eDI1NiBsZXZlbHMgKHNlZSBodHRwOi8vZ2FzaS5jaC9ibG9nL2luc2lkZS1kZWVwLXpvb20tMikuIEkuZS4gdGhlcmUgaXMgYVxuICogZGlmZmVyZW5jZSBvZiBsb2cyKDI1Nik9OCBsZXZlbHMuPGJyPjxicj5cbiAqXG4gKiBOb3RlIDIuIEltYWdlIGRpbWVuc2lvbi4gQWNjb3JkaW5nIHRvIHRoZSBPU00gV2lraVxuICogKGh0dHA6Ly93aWtpLm9wZW5zdHJlZXRtYXAub3JnL3dpa2kvU2xpcHB5X21hcF90aWxlbmFtZXMjWm9vbV9sZXZlbHMpXG4gKiB0aGUgaGlnaGVzdCBNYXBuaWsgem9vbSBsZXZlbCBoYXMgMjU2LjE0NHgyNTYuMTQ0IHRpbGVzLCB3aXRoIGEgMjU2eDI1NlxuICogcGl4ZWwgc2l6ZS4gSS5lLiB0aGUgRGVlcCBab29tIGltYWdlIGRpbWVuc2lvbiBpcyA2NS41NzIuODY0eDY1LjU3Mi44NjRcbiAqIHBpeGVscy5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHdpZHRoIC0gdGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBpbWFnZSBvciB0aGUgaWRpb21hdGljXG4gKiAgICAgIG9wdGlvbnMgb2JqZWN0IHdoaWNoIGlzIHVzZWQgaW5zdGVhZCBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aWxlU2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVPdmVybGFwXG4gKiBAcGFyYW0ge1N0cmluZ30gdGlsZXNVcmxcbiAqL1xuJC5Pc21UaWxlU291cmNlID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIHRpbGVTaXplLCB0aWxlT3ZlcmxhcCwgdGlsZXNVcmwgKSB7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiggJC5pc1BsYWluT2JqZWN0KCB3aWR0aCApICl7XG4gICAgICAgIG9wdGlvbnMgPSB3aWR0aDtcbiAgICB9ZWxzZXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIHRpbGVTaXplOiBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICB0aWxlT3ZlcmxhcDogYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgdGlsZXNVcmw6IGFyZ3VtZW50c1s0XVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvL2FwcGx5IGRlZmF1bHQgc2V0dGluZyBmb3Igc3RhbmRhcmQgcHVibGljIE9wZW5TdHJlYXRNYXBzIHNlcnZpY2VcbiAgICAvL2J1dCBhbGxvdyB0aGVtIHRvIGJlIHNwZWNpZmllZCBzbyBmbGlrcyBjYW4gaG9zdCB0aGVyZSBvd24gaW5zdGFuY2VcbiAgICAvL29yIGFwcGx5IGFnYWluc3Qgb3RoZXIgc2VydmljZXMgc3VwcG9ydHRpbmcgdGhlIHNhbWUgc3RhbmRhcmRcbiAgICBpZiggIW9wdGlvbnMud2lkdGggfHwgIW9wdGlvbnMuaGVpZ2h0ICl7XG4gICAgICAgIG9wdGlvbnMud2lkdGggPSA2NTU3Mjg2NDtcbiAgICAgICAgb3B0aW9ucy5oZWlnaHQgPSA2NTU3Mjg2NDtcbiAgICB9XG4gICAgaWYoICFvcHRpb25zLnRpbGVTaXplICl7XG4gICAgICAgIG9wdGlvbnMudGlsZVNpemUgPSAyNTY7XG4gICAgICAgIG9wdGlvbnMudGlsZU92ZXJsYXAgPSAwO1xuICAgIH1cbiAgICBpZiggIW9wdGlvbnMudGlsZXNVcmwgKXtcbiAgICAgICAgb3B0aW9ucy50aWxlc1VybCA9IFwiaHR0cDovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcvXCI7XG4gICAgfVxuICAgIG9wdGlvbnMubWluTGV2ZWwgPSA4O1xuXG4gICAgJC5UaWxlU291cmNlLmFwcGx5KCB0aGlzLCBbIG9wdGlvbnMgXSApO1xuXG59O1xuXG4kLmV4dGVuZCggJC5Pc21UaWxlU291cmNlLnByb3RvdHlwZSwgJC5UaWxlU291cmNlLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLk9zbVRpbGVTb3VyY2UucHJvdG90eXBlICove1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGRhdGEgYW5kL29yIHVybCBpbXBseSB0aGUgaW1hZ2Ugc2VydmljZSBpcyBzdXBwb3J0ZWQgYnlcbiAgICAgKiB0aGlzIHRpbGUgc291cmNlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbmFsIC0gdXJsXG4gICAgICovXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKXtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRhdGEudHlwZSAmJlxuICAgICAgICAgICAgXCJvcGVuc3RyZWV0bWFwc1wiID09IGRhdGEudHlwZVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdGhlIHJhdyBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIHRoZSB1cmwgdGhlIGRhdGEgd2FzIHJldHJlaXZlZCBmcm9tIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9wdGlvbnMgLSBBIGRpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMgc3VmZmljaWVudFxuICAgICAqICAgICAgdG8gY29uZmlndXJlIHRoaXMgdGlsZSBzb3VyY2VzIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24oIGRhdGEsIHVybCApe1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgZ2V0VGlsZVVybDogZnVuY3Rpb24oIGxldmVsLCB4LCB5ICkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlc1VybCArIChsZXZlbCAtIDgpICsgXCIvXCIgKyB4ICsgXCIvXCIgKyB5ICsgXCIucG5nXCI7XG4gICAgfVxufSk7XG5cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBUbXNUaWxlU291cmNlXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qXG4gKiBEZXJpdmVkIGZyb20gdGhlIFRNUyB0aWxlIHNvdXJjZSBpbiBSYWluZXIgU2ltb24ncyBzZWFqYXgtdXRpbHMgcHJvamVjdFxuICogPGh0dHA6Ly9naXRodWIuY29tL3JzaW1vbi9zZWFqYXgtdXRpbHM+LiAgUmFpbmVyIFNpbW9uIGhhcyBjb250cmlidXRlZFxuICogdGhlIGluY2x1ZGVkIGNvZGUgdG8gdGhlIE9wZW5TZWFkcmFnb24gcHJvamVjdCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlO1xuICogc2VlIDxodHRwczovL2dpdGh1Yi5jb20vb3BlbnNlYWRyYWdvbi9vcGVuc2VhZHJhZ29uL2lzc3Vlcy81OD4uXG4gKi9cblxuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgVG1zVGlsZVNvdXJjZVxuICogQGNsYXNzZGVzYyBBIHRpbGVzb3VyY2UgaW1wbGVtZW50YXRpb24gZm9yIFRpbGVkIE1hcCBTZXJ2aWNlcyAoVE1TKS5cbiAqIFRNUyB0aWxlIHNjaGVtZSAoIFsgYXMgc3VwcG9ydGVkIGJ5IE9wZW5MYXllcnMgXSBpcyBkZXNjcmliZWQgaGVyZVxuICogKCBodHRwOi8vb3BlbmxheWVycy5vcmcvZGV2L2V4YW1wbGVzL3Rtcy5odG1sICkuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZVxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB3aWR0aCAtIHRoZSBwaXhlbCB3aWR0aCBvZiB0aGUgaW1hZ2Ugb3IgdGhlIGlkaW9tYXRpY1xuICogICAgICBvcHRpb25zIG9iamVjdCB3aGljaCBpcyB1c2VkIGluc3RlYWQgb2YgcG9zaXRpb25hbCBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gdGlsZVNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aWxlT3ZlcmxhcFxuICogQHBhcmFtIHtTdHJpbmd9IHRpbGVzVXJsXG4gKi9cbiQuVG1zVGlsZVNvdXJjZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCB0aWxlU2l6ZSwgdGlsZU92ZXJsYXAsIHRpbGVzVXJsICkge1xuICAgIHZhciBvcHRpb25zO1xuXG4gICAgaWYoICQuaXNQbGFpbk9iamVjdCggd2lkdGggKSApe1xuICAgICAgICBvcHRpb25zID0gd2lkdGg7XG4gICAgfWVsc2V7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB3aWR0aDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgaGVpZ2h0OiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICB0aWxlU2l6ZTogYXJndW1lbnRzWzJdLFxuICAgICAgICAgICAgdGlsZU92ZXJsYXA6IGFyZ3VtZW50c1szXSxcbiAgICAgICAgICAgIHRpbGVzVXJsOiBhcmd1bWVudHNbNF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVE1TIGhhcyBpbnRlZ2VyIG11bHRpcGxlcyBvZiAyNTYgZm9yIHdpZHRoL2hlaWdodCBhbmQgYWRkcyBidWZmZXJcbiAgICAvLyBpZiBuZWNlc3NhcnkgLT4gYWNjb3VudCBmb3IgdGhpcyFcbiAgICB2YXIgYnVmZmVyZWRXaWR0aCA9IE1hdGguY2VpbChvcHRpb25zLndpZHRoIC8gMjU2KSAqIDI1NixcbiAgICAgICAgYnVmZmVyZWRIZWlnaHQgPSBNYXRoLmNlaWwob3B0aW9ucy5oZWlnaHQgLyAyNTYpICogMjU2LFxuICAgICAgICBtYXg7XG5cbiAgICAvLyBDb21wdXRlIG51bWJlciBvZiB6b29tbGV2ZWxzIGluIHRoaXMgdGlsZXNldFxuICAgIGlmIChidWZmZXJlZFdpZHRoID4gYnVmZmVyZWRIZWlnaHQpIHtcbiAgICAgICAgbWF4ID0gYnVmZmVyZWRXaWR0aCAvIDI1NjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSBidWZmZXJlZEhlaWdodCAvIDI1NjtcbiAgICB9XG4gICAgb3B0aW9ucy5tYXhMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZyhtYXgpL01hdGgubG9nKDIpKSAtIDE7XG4gICAgb3B0aW9ucy50aWxlU2l6ZSA9IDI1NjtcbiAgICBvcHRpb25zLndpZHRoID0gYnVmZmVyZWRXaWR0aDtcbiAgICBvcHRpb25zLmhlaWdodCA9IGJ1ZmZlcmVkSGVpZ2h0O1xuXG4gICAgJC5UaWxlU291cmNlLmFwcGx5KCB0aGlzLCBbIG9wdGlvbnMgXSApO1xuXG59O1xuXG4kLmV4dGVuZCggJC5UbXNUaWxlU291cmNlLnByb3RvdHlwZSwgJC5UaWxlU291cmNlLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLlRtc1RpbGVTb3VyY2UucHJvdG90eXBlICove1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGRhdGEgYW5kL29yIHVybCBpbXBseSB0aGUgaW1hZ2Ugc2VydmljZSBpcyBzdXBwb3J0ZWQgYnlcbiAgICAgKiB0aGlzIHRpbGUgc291cmNlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbmFsIC0gdXJsXG4gICAgICovXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKXtcbiAgICAgICAgcmV0dXJuICggZGF0YS50eXBlICYmIFwidGlsZWRtYXBzZXJ2aWNlXCIgPT0gZGF0YS50eXBlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0aGUgcmF3IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gdGhlIHVybCB0aGUgZGF0YSB3YXMgcmV0cmVpdmVkIGZyb20gaWYgYW55LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb3B0aW9ucyAtIEEgZGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cyBzdWZmaWNpZW50XG4gICAgICogICAgICB0byBjb25maWd1cmUgdGhpcyB0aWxlIHNvdXJjZXMgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbiggZGF0YSwgdXJsICl7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKi9cbiAgICBnZXRUaWxlVXJsOiBmdW5jdGlvbiggbGV2ZWwsIHgsIHkgKSB7XG4gICAgICAgIC8vIENvbnZlcnQgZnJvbSBEZWVwIFpvb20gZGVmaW5pdGlvbiB0byBUTVMgem9vbSBkZWZpbml0aW9uXG4gICAgICAgIHZhciB5VGlsZXMgPSB0aGlzLmdldE51bVRpbGVzKCBsZXZlbCApLnkgLSAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzVXJsICsgbGV2ZWwgKyBcIi9cIiArIHggKyBcIi9cIiArICAoeVRpbGVzIC0geSkgKyBcIi5wbmdcIjtcbiAgICB9XG59KTtcblxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIExlZ2FjeVRpbGVTb3VyY2VcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogQGNsYXNzIExlZ2FjeVRpbGVTb3VyY2VcbiAqIEBjbGFzc2Rlc2MgVGhlIExlZ2FjeVRpbGVTb3VyY2UgYWxsb3dzIHNpbXBsZSwgdHJhZGl0aW9uYWwgaW1hZ2UgcHlyYW1pZHMgdG8gYmUgbG9hZGVkXG4gKiBpbnRvIGFuIE9wZW5TZWFkcmFnb24gVmlld2VyLiAgQmFzaWNhbGx5LCB0aGlzIHRyYW5zbGF0ZXMgdG8gdGhlIGhpc3RvcmljYWxseVxuICogY29tbW9uIHByYWN0aWNlIG9mIHN0YXJ0aW5nIHdpdGggYSAnbWFzdGVyJyBpbWFnZSwgbWF5YmUgYSB0aWZmIGZvciBleGFtcGxlLFxuICogYW5kIGdlbmVyYXRpbmcgYSBzZXQgb2YgJ3NlcnZpY2UnIGltYWdlcyBsaWtlIG9uZSBvciBtb3JlIHRodW1ibmFpbHMsIGEgbWVkaXVtXG4gKiByZXNvbHV0aW9uIGltYWdlIGFuZCBhIGhpZ2ggcmVzb2x1dGlvbiBpbWFnZSBpbiBzdGFuZGFyZCB3ZWIgZm9ybWF0cyBsaWtlXG4gKiBwbmcgb3IganBnLlxuICpcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGxldmVscyBBbiBhcnJheSBvZiBmaWxlIGRlc2NyaXB0aW9ucywgZWFjaCBpcyBhbiBvYmplY3Qgd2l0aFxuICogICAgICBhICd1cmwnLCBhICd3aWR0aCcsIGFuZCBhICdoZWlnaHQnLiAgT3ZlcnJpZGluZyBjbGFzc2VzIGNhbiBleHBlY3QgbW9yZVxuICogICAgICBwcm9wZXJ0aWVzIGJ1dCB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBzdWZmaWNpZW50IGZvciB0aGlzIGltcGxlbWVudGF0aW9uLlxuICogICAgICBBZGRpdGlvbmFsbHksIHRoZSBsZXZlbHMgYXJlIHJlcXVpcmVkIHRvIGJlIGxpc3RlZCBpbiBvcmRlciBmcm9tXG4gKiAgICAgIHNtYWxsZXN0IHRvIGxhcmdlc3QuXG4gKiBAcHJvcGVydHkge051bWJlcn0gYXNwZWN0UmF0aW9cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge051bWJlcn0gdGlsZVNpemVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aWxlT3ZlcmxhcFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pbkxldmVsXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWF4TGV2ZWxcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9ICBsZXZlbHNcbiAqL1xuJC5MZWdhY3lUaWxlU291cmNlID0gZnVuY3Rpb24oIGxldmVscyApIHtcblxuICAgIHZhciBvcHRpb25zLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0O1xuXG4gICAgaWYoICQuaXNBcnJheSggbGV2ZWxzICkgKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdsZWdhY3ktaW1hZ2UtcHlyYW1pZCcsXG4gICAgICAgICAgICBsZXZlbHM6IGxldmVsc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vY2xlYW4gdXAgdGhlIGxldmVscyB0byBtYWtlIHN1cmUgd2Ugc3VwcG9ydCBhbGwgZm9ybWF0c1xuICAgIG9wdGlvbnMubGV2ZWxzID0gZmlsdGVyRmlsZXMoIG9wdGlvbnMubGV2ZWxzICk7XG5cbiAgICBpZiAoIG9wdGlvbnMubGV2ZWxzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIHdpZHRoID0gb3B0aW9ucy5sZXZlbHNbIG9wdGlvbnMubGV2ZWxzLmxlbmd0aCAtIDEgXS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5sZXZlbHNbIG9wdGlvbnMubGV2ZWxzLmxlbmd0aCAtIDEgXS5oZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIGhlaWdodCA9IDA7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJObyBzdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0cyBmb3VuZFwiICk7XG4gICAgfVxuXG4gICAgJC5leHRlbmQoIHRydWUsIG9wdGlvbnMsIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdGlsZVNpemU6IE1hdGgubWF4KCBoZWlnaHQsIHdpZHRoICksXG4gICAgICAgIHRpbGVPdmVybGFwOiAwLFxuICAgICAgICBtaW5MZXZlbDogMCxcbiAgICAgICAgbWF4TGV2ZWw6IG9wdGlvbnMubGV2ZWxzLmxlbmd0aCA+IDAgPyBvcHRpb25zLmxldmVscy5sZW5ndGggLSAxIDogMFxuICAgIH0gKTtcblxuICAgICQuVGlsZVNvdXJjZS5hcHBseSggdGhpcywgWyBvcHRpb25zIF0gKTtcblxuICAgIHRoaXMubGV2ZWxzID0gb3B0aW9ucy5sZXZlbHM7XG59O1xuXG4kLmV4dGVuZCggJC5MZWdhY3lUaWxlU291cmNlLnByb3RvdHlwZSwgJC5UaWxlU291cmNlLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLkxlZ2FjeVRpbGVTb3VyY2UucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgZGF0YSBhbmQvb3IgdXJsIGltcGx5IHRoZSBpbWFnZSBzZXJ2aWNlIGlzIHN1cHBvcnRlZCBieVxuICAgICAqIHRoaXMgdGlsZSBzb3VyY2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uYWwgLSB1cmxcbiAgICAgKi9cbiAgICBzdXBwb3J0czogZnVuY3Rpb24oIGRhdGEsIHVybCApe1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGF0YS50eXBlICYmXG4gICAgICAgICAgICBcImxlZ2FjeS1pbWFnZS1weXJhbWlkXCIgPT0gZGF0YS50eXBlXG4gICAgICAgICkgfHwgKFxuICAgICAgICAgICAgZGF0YS5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICAgICAgICAgIFwibGVnYWN5LWltYWdlLXB5cmFtaWRcIiA9PSBkYXRhLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKVxuICAgICAgICApO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8WE1MRG9jdW1lbnR9IGNvbmZpZ3VyYXRpb24gLSB0aGUgcmF3IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVVybCAtIHRoZSB1cmwgdGhlIGRhdGEgd2FzIHJldHJlaXZlZCBmcm9tIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9wdGlvbnMgLSBBIGRpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMgc3VmZmljaWVudFxuICAgICAqICAgICAgdG8gY29uZmlndXJlIHRoaXMgdGlsZSBzb3VyY2VzIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24oIGNvbmZpZ3VyYXRpb24sIGRhdGFVcmwgKXtcblxuICAgICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgICBpZiggISQuaXNQbGFpbk9iamVjdChjb25maWd1cmF0aW9uKSApe1xuXG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlndXJlRnJvbVhNTCggdGhpcywgY29uZmlndXJhdGlvbiApO1xuXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlndXJlRnJvbU9iamVjdCggdGhpcywgY29uZmlndXJhdGlvbiApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0TGV2ZWxTY2FsZTogZnVuY3Rpb24gKCBsZXZlbCApIHtcbiAgICAgICAgdmFyIGxldmVsU2NhbGUgPSBOYU47XG4gICAgICAgIGlmICggdGhpcy5sZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbCA+PSB0aGlzLm1pbkxldmVsICYmIGxldmVsIDw9IHRoaXMubWF4TGV2ZWwgKSB7XG4gICAgICAgICAgICBsZXZlbFNjYWxlID1cbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsc1sgbGV2ZWwgXS53aWR0aCAvXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbHNbIHRoaXMubWF4TGV2ZWwgXS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGV2ZWxTY2FsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0TnVtVGlsZXM6IGZ1bmN0aW9uKCBsZXZlbCApIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRMZXZlbFNjYWxlKCBsZXZlbCApO1xuICAgICAgICBpZiAoIHNjYWxlICl7XG4gICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoIDEsIDEgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCggMCwgMCApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBnZXRUaWxlQXRQb2ludDogZnVuY3Rpb24oIGxldmVsLCBwb2ludCApIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KCAwLCAwICk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGJ5IHRoaXMgY2xhc3Mgb3RoZXIgdGhhbiB0byB0aHJvdyBhbiBFcnJvclxuICAgICAqIGFubm91bmNpbmcgeW91IGhhdmUgdG8gaW1wbGVtZW50IGl0LiAgQmVjYXVzZSBvZiB0aGUgdmFyaWV0eSBvZiB0aWxlXG4gICAgICogc2VydmVyIHRlY2hub2xvZ2llcywgYW5kIHZhcmlvdXMgc3BlY2lmaWNhdGlvbnMgZm9yIGJ1aWxkaW5nIGltYWdlXG4gICAgICogcHlyYW1pZHMsIHRoaXMgbWV0aG9kIGlzIGhlcmUgdG8gYWxsb3cgZWFzeSBpbnRlZ3JhdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgZ2V0VGlsZVVybDogZnVuY3Rpb24gKCBsZXZlbCwgeCwgeSApIHtcbiAgICAgICAgdmFyIHVybCA9IG51bGw7XG4gICAgICAgIGlmICggdGhpcy5sZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbCA+PSB0aGlzLm1pbkxldmVsICYmIGxldmVsIDw9IHRoaXMubWF4TGV2ZWwgKSB7XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmxldmVsc1sgbGV2ZWwgXS51cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG59ICk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmVtb3ZlcyBhbnkgZmlsZXMgZnJvbSB0aGUgQXJyYXkgd2hpY2ggZG9udCBjb25mb3JtIHRvIG91clxuICogYmFzaWMgcmVxdWlyZW1lbnRzIGZvciBhICdsZXZlbCcgaW4gdGhlIExlZ2FjeVRpbGVTb3VyY2UuXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZmlsdGVyRmlsZXMoIGZpbGVzICl7XG4gICAgdmFyIGZpbHRlcmVkID0gW10sXG4gICAgICAgIGZpbGUsXG4gICAgICAgIGk7XG4gICAgZm9yKCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGZpbGUgPSBmaWxlc1sgaSBdO1xuICAgICAgICBpZiggZmlsZS5oZWlnaHQgJiZcbiAgICAgICAgICAgIGZpbGUud2lkdGggJiZcbiAgICAgICAgICAgIGZpbGUudXJsICYmIChcbiAgICAgICAgICAgICAgICBmaWxlLnVybC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eLipcXC4ocG5nfGpwZ3xqcGVnfGdpZikoPzpcXD8uKik/JC8pIHx8IChcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5taW1ldHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICBmaWxlLm1pbWV0eXBlLnRvTG93ZXJDYXNlKCkubWF0Y2goL14uKlxcLyhwbmd8anBnfGpwZWd8Z2lmKSQvKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkgKXtcbiAgICAgICAgICAgIC8vVGhpcyBpcyBzdWZmaWNpZW50IHRvIHNlcnZlIGFzIGEgbGV2ZWxcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybDogZmlsZS51cmwsXG4gICAgICAgICAgICAgICAgd2lkdGg6IE51bWJlciggZmlsZS53aWR0aCApLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKCBmaWxlLmhlaWdodCApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQuY29uc29sZS5lcnJvciggJ1Vuc3VwcG9ydGVkIGltYWdlIGZvcm1hdDogJXMnLCBmaWxlLnVybCA/IGZpbGUudXJsIDogJzxubyBVUkw+JyApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLnNvcnQoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgcmV0dXJuIGEuaGVpZ2h0IC0gYi5oZWlnaHQ7XG4gICAgfSk7XG5cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlRnJvbVhNTCggdGlsZVNvdXJjZSwgeG1sRG9jICl7XG5cbiAgICBpZiAoICF4bWxEb2MgfHwgIXhtbERvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggJC5nZXRTdHJpbmcoIFwiRXJyb3JzLlhtbFwiICkgKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCAgICAgICAgID0geG1sRG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgcm9vdE5hbWUgICAgID0gcm9vdC50YWdOYW1lLFxuICAgICAgICBjb25mICAgICAgICAgPSBudWxsLFxuICAgICAgICBsZXZlbHMgICAgICAgPSBbXSxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIGk7XG5cbiAgICBpZiAoIHJvb3ROYW1lID09IFwiaW1hZ2VcIiApIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uZiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICAgcm9vdC5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICksXG4gICAgICAgICAgICAgICAgbGV2ZWxzOiAgICAgIFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXZlbHMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImxldmVsXCIgKTtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cbiAgICAgICAgICAgICAgICBjb25mLmxldmVscyAucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogICAgbGV2ZWwuZ2V0QXR0cmlidXRlKCBcInVybFwiICksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAgcGFyc2VJbnQoIGxldmVsLmdldEF0dHJpYnV0ZSggXCJ3aWR0aFwiICksIDEwICksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQoIGxldmVsLmdldEF0dHJpYnV0ZSggXCJoZWlnaHRcIiApLCAxMCApXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb25maWd1cmVGcm9tT2JqZWN0KCB0aWxlU291cmNlLCBjb25mICk7XG5cbiAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICB0aHJvdyAoZSBpbnN0YW5jZW9mIEVycm9yKSA/XG4gICAgICAgICAgICAgICAgZSA6XG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCAnVW5rbm93biBlcnJvciBwYXJzaW5nIExlZ2FjeSBJbWFnZSBQeXJhbWlkIFhNTC4nICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCByb290TmFtZSA9PSBcImNvbGxlY3Rpb25cIiApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnTGVnYWN5IEltYWdlIFB5cmFtaWQgQ29sbGVjdGlvbnMgbm90IHlldCBzdXBwb3J0ZWQuJyApO1xuICAgIH0gZWxzZSBpZiAoIHJvb3ROYW1lID09IFwiZXJyb3JcIiApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnRXJyb3I6ICcgKyB4bWxEb2MgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIGVsZW1lbnQgJyArIHJvb3ROYW1lICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZUZyb21PYmplY3QoIHRpbGVTb3VyY2UsIGNvbmZpZ3VyYXRpb24gKXtcblxuICAgIHJldHVybiBjb25maWd1cmF0aW9uLmxldmVscztcblxufVxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIEltYWdlVGlsZVNvdXJjZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBJbWFnZVRpbGVTb3VyY2VcbiAgICAgKiBAY2xhc3NkZXNjIFRoZSBJbWFnZVRpbGVTb3VyY2UgYWxsb3dzIGEgc2ltcGxlIGltYWdlIHRvIGJlIGxvYWRlZFxuICAgICAqIGludG8gYW4gT3BlblNlYWRyYWdvbiBWaWV3ZXIuXG4gICAgICogVGhlcmUgYXJlIDIgd2F5cyB0byBvcGVuIGFuIEltYWdlVGlsZVNvdXJjZTpcbiAgICAgKiAxLiB2aWV3ZXIub3Blbih7dHlwZTogJ2ltYWdlJywgdXJsOiBmb29Vcmx9KTtcbiAgICAgKiAyLiB2aWV3ZXIub3BlbihuZXcgT3BlblNlYWRyYWdvbi5JbWFnZVRpbGVTb3VyY2Uoe3VybDogZm9vVXJsfSkpO1xuICAgICAqXG4gICAgICogV2l0aCB0aGUgZmlyc3Qgc3ludGF4LCB0aGUgY3Jvc3NPcmlnaW5Qb2xpY3ksIGFqYXhXaXRoQ3JlZGVudGlhbHMgYW5kXG4gICAgICogdXNlQ2FudmFzIG9wdGlvbnMgYXJlIGluaGVyaXRlZCBmcm9tIHRoZSB2aWV3ZXIgaWYgdGhleSBhcmUgbm90XG4gICAgICogc3BlY2lmaWVkIGRpcmVjdGx5IGluIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXJsIFVSTCBvZiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ1aWxkUHlyYW1pZD10cnVlXSBJZiBzZXQgdG8gdHJ1ZSAoZGVmYXVsdCksIGFcbiAgICAgKiBweXJhbWlkIHdpbGwgYmUgYnVpbHQgaW50ZXJuYWxseSB0byBwcm92aWRlIGEgYmV0dGVyIGRvd25zYW1wbGluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSBbb3B0aW9ucy5jcm9zc09yaWdpblBvbGljeT1mYWxzZV0gVmFsaWQgdmFsdWVzIGFyZVxuICAgICAqICdBbm9ueW1vdXMnLCAndXNlLWNyZWRlbnRpYWxzJywgYW5kIGZhbHNlLiBJZiBmYWxzZSwgaW1hZ2UgcmVxdWVzdHMgd2lsbFxuICAgICAqIG5vdCB1c2UgQ09SUyBwcmV2ZW50aW5nIGludGVybmFsIHB5cmFtaWQgYnVpbGRpbmcgZm9yIGltYWdlcyBmcm9tIG90aGVyXG4gICAgICogZG9tYWlucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSBbb3B0aW9ucy5hamF4V2l0aENyZWRlbnRpYWxzPWZhbHNlXSBXaGV0aGVyIHRvIHNldFxuICAgICAqIHRoZSB3aXRoQ3JlZGVudGlhbHMgWEhSIGZsYWcgZm9yIEFKQVggcmVxdWVzdHMgKHdoZW4gbG9hZGluZyB0aWxlIHNvdXJjZXMpLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQ2FudmFzPXRydWVdIFNldCB0byBmYWxzZSB0byBwcmV2ZW50IGFueSB1c2VcbiAgICAgKiBvZiB0aGUgY2FudmFzIEFQSS5cbiAgICAgKi9cbiAgICAkLkltYWdlVGlsZVNvdXJjZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgIGJ1aWxkUHlyYW1pZDogdHJ1ZSxcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luUG9saWN5OiBmYWxzZSxcbiAgICAgICAgICAgIGFqYXhXaXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgdXNlQ2FudmFzOiB0cnVlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAkLlRpbGVTb3VyY2UuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcblxuICAgIH07XG5cbiAgICAkLmV4dGVuZCgkLkltYWdlVGlsZVNvdXJjZS5wcm90b3R5cGUsICQuVGlsZVNvdXJjZS5wcm90b3R5cGUsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5JbWFnZVRpbGVTb3VyY2UucHJvdG90eXBlICove1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSBkYXRhIGFuZC9vciB1cmwgaW1wbHkgdGhlIGltYWdlIHNlcnZpY2UgaXMgc3VwcG9ydGVkIGJ5XG4gICAgICAgICAqIHRoaXMgdGlsZSBzb3VyY2UuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uYWwgLSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAoZGF0YSwgdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50eXBlICYmIGRhdGEudHlwZSA9PT0gXCJpbWFnZVwiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFVcmwgLSB0aGUgdXJsIHRoZSBpbWFnZSB3YXMgcmV0cmVpdmVkIGZyb20sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBvcHRpb25zIC0gQSBkaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHN1ZmZpY2llbnRcbiAgICAgICAgICogICAgICB0byBjb25maWd1cmUgdGhpcyB0aWxlIHNvdXJjZXMgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChvcHRpb25zLCBkYXRhVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3BvbnNpYmxlIGZvciByZXRyaWV2aW5nLCBhbmQgY2FjaGluZyB0aGVcbiAgICAgICAgICogaW1hZ2UgbWV0YWRhdGEgcGVydGluZW50IHRvIHRoaXMgVGlsZVNvdXJjZXMgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW1hZ2VJbmZvOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW5Qb2xpY3kpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW5Qb2xpY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hamF4V2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UudXNlQ3JlZGVudGlhbHMgPSB0aGlzLmFqYXhXaXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuYWRkRXZlbnQoaW1hZ2UsICdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgIF90aGlzLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXNwZWN0UmF0aW8gPSBfdGhpcy53aWR0aCAvIF90aGlzLmhlaWdodDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaW1lbnNpb25zID0gbmV3ICQuUG9pbnQoX3RoaXMud2lkdGgsIF90aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RpbGVXaWR0aCA9IF90aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIF90aGlzLl90aWxlSGVpZ2h0ID0gX3RoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIF90aGlzLnRpbGVPdmVybGFwID0gMDtcbiAgICAgICAgICAgICAgICBfdGhpcy5taW5MZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgX3RoaXMubGV2ZWxzID0gX3RoaXMuX2J1aWxkTGV2ZWxzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubWF4TGV2ZWwgPSBfdGhpcy5sZXZlbHMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgIF90aGlzLnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgZXZlbnQgaXMgZG9jdW1lbnRlZCBlbHNld2hlcmUsIGluIFRpbGVTb3VyY2VcbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCdyZWFkeScsIHt0aWxlU291cmNlOiBfdGhpc30pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQuYWRkRXZlbnQoaW1hZ2UsICdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGlzIGV2ZW50IGlzIGRvY3VtZW50ZWQgZWxzZXdoZXJlLCBpbiBUaWxlU291cmNlXG4gICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCgnb3Blbi1mYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRXJyb3IgbG9hZGluZyBpbWFnZSBhdCBcIiArIHVybCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB1cmxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMZXZlbFNjYWxlOiBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbFNjYWxlID0gTmFOO1xuICAgICAgICAgICAgaWYgKGxldmVsID49IHRoaXMubWluTGV2ZWwgJiYgbGV2ZWwgPD0gdGhpcy5tYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgIGxldmVsU2NhbGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXZlbHNbbGV2ZWxdLndpZHRoIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGV2ZWxzW3RoaXMubWF4TGV2ZWxdLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxldmVsU2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBnZXROdW1UaWxlczogZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldExldmVsU2NhbGUobGV2ZWwpO1xuICAgICAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KDEsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIGdldFRpbGVBdFBvaW50OiBmdW5jdGlvbiAobGV2ZWwsIHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoMCwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYSB0aWxlIHVybFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIExldmVsIG9mIHRoZSB0aWxlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRpbGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRpbGVVcmw6IGZ1bmN0aW9uIChsZXZlbCwgeCwgeSkge1xuICAgICAgICAgICAgdmFyIHVybCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPj0gdGhpcy5taW5MZXZlbCAmJiBsZXZlbCA8PSB0aGlzLm1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5sZXZlbHNbbGV2ZWxdLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYSB0aWxlIGNvbnRleHQgMkRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBMZXZlbCBvZiB0aGUgdGlsZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGUgb2YgdGhlIHRpbGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlIG9mIHRoZSB0aWxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb250ZXh0MkQ6IGZ1bmN0aW9uIChsZXZlbCwgeCwgeSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGxldmVsID49IHRoaXMubWluTGV2ZWwgJiYgbGV2ZWwgPD0gdGhpcy5tYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmxldmVsc1tsZXZlbF0uY29udGV4dDJEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcHJpdmF0ZVxuICAgICAgICAvL1xuICAgICAgICAvLyBCdWlsZHMgdGhlIGRpZmZlcmVudHMgbGV2ZWxzIG9mIHRoZSBweXJhbWlkIGlmIHBvc3NpYmxlXG4gICAgICAgIC8vIChpLmUuIGlmIGNhbnZhcyBBUEkgZW5hYmxlZCBhbmQgbm8gY2FudmFzIHRhaW50aW5nIGlzc3VlKS5cbiAgICAgICAgX2J1aWxkTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLl9pbWFnZS5zcmMsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9pbWFnZS5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5faW1hZ2UubmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYnVpbGRQeXJhbWlkIHx8ICEkLnN1cHBvcnRzQ2FudmFzIHx8ICF0aGlzLnVzZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdGhlIGltYWdlIGFueW1vcmUuIEFsbG93cyBpdCB0byBiZSBHQy5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faW1hZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVscztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRXaWR0aCA9IHRoaXMuX2ltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gdGhpcy5faW1hZ2UubmF0dXJhbEhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGJpZ0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICB2YXIgYmlnQ29udGV4dCA9IGJpZ0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgICAgIGJpZ0NhbnZhcy53aWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICAgICAgICAgIGJpZ0NhbnZhcy5oZWlnaHQgPSBjdXJyZW50SGVpZ2h0O1xuICAgICAgICAgICAgYmlnQ29udGV4dC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDAsIGN1cnJlbnRXaWR0aCwgY3VycmVudEhlaWdodCk7XG4gICAgICAgICAgICAvLyBXZSBjYWNoZSB0aGUgY29udGV4dCBvZiB0aGUgaGlnaGVzdCBsZXZlbCBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgICAgICAgICAvLyBpcyBhIGxvdCBmYXN0ZXIgYXQgZG93bnNhbXBsaW5nIHNvbWV0aGluZyBpdCBhbHJlYWR5IGhhc1xuICAgICAgICAgICAgLy8gZG93bnNhbXBsZWQgYmVmb3JlLlxuICAgICAgICAgICAgbGV2ZWxzWzBdLmNvbnRleHQyRCA9IGJpZ0NvbnRleHQ7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRoZSBpbWFnZSBhbnltb3JlLiBBbGxvd3MgaXQgdG8gYmUgR0MuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faW1hZ2U7XG5cbiAgICAgICAgICAgIGlmICgkLmlzQ2FudmFzVGFpbnRlZChiaWdDYW52YXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNhbnZhcyBpcyB0YWludGVkLCB3ZSBjYW4ndCBjb21wdXRlIHRoZSBweXJhbWlkLlxuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGJ1aWxkIHNtYWxsZXIgbGV2ZWxzIHVudGlsIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgYmVjb21lc1xuICAgICAgICAgICAgLy8gMSBwaXhlbCB3aWRlLlxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRXaWR0aCA+PSAyICYmIGN1cnJlbnRIZWlnaHQgPj0gMikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IE1hdGguZmxvb3IoY3VycmVudFdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IE1hdGguZmxvb3IoY3VycmVudEhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBzbWFsbENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsQ29udGV4dCA9IHNtYWxsQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBzbWFsbENhbnZhcy53aWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBzbWFsbENhbnZhcy5oZWlnaHQgPSBjdXJyZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNtYWxsQ29udGV4dC5kcmF3SW1hZ2UoYmlnQ2FudmFzLCAwLCAwLCBjdXJyZW50V2lkdGgsIGN1cnJlbnRIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgbGV2ZWxzLnNwbGljZSgwLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQyRDogc21hbGxDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY3VycmVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGN1cnJlbnRIZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJpZ0NhbnZhcyA9IHNtYWxsQ2FudmFzO1xuICAgICAgICAgICAgICAgIGJpZ0NvbnRleHQgPSBzbWFsbENvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWxzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbn0oT3BlblNlYWRyYWdvbikpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFRpbGVTb3VyY2VDb2xsZWN0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vLyBkZXByZWNhdGVkXG4kLlRpbGVTb3VyY2VDb2xsZWN0aW9uID0gZnVuY3Rpb24oIHRpbGVTaXplLCB0aWxlU291cmNlcywgcm93cywgbGF5b3V0ICApIHtcbiAgICAkLmNvbnNvbGUuZXJyb3IoJ1RpbGVTb3VyY2VDb2xsZWN0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBXb3JsZCBpbnN0ZWFkJyk7XG59O1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIEJ1dHRvblxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiBidXR0b24gc3RhdGVzXG4gKiBAbWVtYmVyIEJ1dHRvblN0YXRlXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQHN0YXRpY1xuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBSRVNUXG4gKiBAcHJvcGVydHkge051bWJlcn0gR1JPVVBcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBIT1ZFUlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IERPV05cbiAqL1xuJC5CdXR0b25TdGF0ZSA9IHtcbiAgICBSRVNUOiAgIDAsXG4gICAgR1JPVVA6ICAxLFxuICAgIEhPVkVSOiAgMixcbiAgICBET1dOOiAgIDNcbn07XG5cbi8qKlxuICogQGNsYXNzIEJ1dHRvblxuICogQGNsYXNzZGVzYyBNYW5hZ2VzIGV2ZW50cywgaG92ZXIgc3RhdGVzIGZvciBpbmRpdmlkdWFsIGJ1dHRvbnMsIHRvb2wtdGlwcywgYXMgd2VsbFxuICogYXMgZmFkaW5nIHRoZSBidXR0b25zIG91dCB3aGVuIHRoZSB1c2VyIGhhcyBub3QgaW50ZXJhY3RlZCB3aXRoIHRoZW1cbiAqIGZvciBhIHNwZWNpZmllZCBwZXJpb2QuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uRXZlbnRTb3VyY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtvcHRpb25zLmVsZW1lbnQ9bnVsbF0gRWxlbWVudCB0byB1c2UgYXMgdGhlIGJ1dHRvbi4gSWYgbm90IHNwZWNpZmllZCwgYW4gSFRNTCAmbHQ7YnV0dG9uJmd0OyBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudG9vbHRpcD1udWxsXSBQcm92aWRlcyBjb250ZXh0IGhlbHAgZm9yIHRoZSBidXR0b24gd2hlbiB0aGVcbiAqICB1c2VyIGhvdmVycyBvdmVyIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNyY1Jlc3Q9bnVsbF0gVVJMIG9mIGltYWdlIHRvIHVzZSBpbiAncmVzdCcgc3RhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3JjR3JvdXA9bnVsbF0gVVJMIG9mIGltYWdlIHRvIHVzZSBpbiAndXAnIHN0YXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNyY0hvdmVyPW51bGxdIFVSTCBvZiBpbWFnZSB0byB1c2UgaW4gJ2hvdmVyJyBzdGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zcmNEb3duPW51bGxdIFVSTCBvZiBpbWFnZSB0byB1c2UgaW4gJ2Rvd24nIHN0YXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhZGVEZWxheT0wXSBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSBmYWRpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFkZUxlbmd0aD0yMDAwXSBIb3cgbG9uZyBzaG91bGQgaXQgdGFrZSB0byBmYWRlIHRoZSBidXR0b24uXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5vblByZXNzPW51bGxdIEV2ZW50IGhhbmRsZXIgY2FsbGJhY2sgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLkJ1dHRvbi5ldmVudDpwcmVzc30uXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5vblJlbGVhc2U9bnVsbF0gRXZlbnQgaGFuZGxlciBjYWxsYmFjayBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uQnV0dG9uLmV2ZW50OnJlbGVhc2V9LlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMub25DbGljaz1udWxsXSBFdmVudCBoYW5kbGVyIGNhbGxiYWNrIGZvciB7QGxpbmsgT3BlblNlYWRyYWdvbi5CdXR0b24uZXZlbnQ6Y2xpY2t9LlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMub25FbnRlcj1udWxsXSBFdmVudCBoYW5kbGVyIGNhbGxiYWNrIGZvciB7QGxpbmsgT3BlblNlYWRyYWdvbi5CdXR0b24uZXZlbnQ6ZW50ZXJ9LlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMub25FeGl0PW51bGxdIEV2ZW50IGhhbmRsZXIgY2FsbGJhY2sgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLkJ1dHRvbi5ldmVudDpleGl0fS5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLm9uRm9jdXM9bnVsbF0gRXZlbnQgaGFuZGxlciBjYWxsYmFjayBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uQnV0dG9uLmV2ZW50OmZvY3VzfS5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLm9uQmx1cj1udWxsXSBFdmVudCBoYW5kbGVyIGNhbGxiYWNrIGZvciB7QGxpbmsgT3BlblNlYWRyYWdvbi5CdXR0b24uZXZlbnQ6Ymx1cn0uXG4gKi9cbiQuQnV0dG9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgJC5FdmVudFNvdXJjZS5jYWxsKCB0aGlzICk7XG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywge1xuXG4gICAgICAgIHRvb2x0aXA6ICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgc3JjUmVzdDogICAgICAgICAgICBudWxsLFxuICAgICAgICBzcmNHcm91cDogICAgICAgICAgIG51bGwsXG4gICAgICAgIHNyY0hvdmVyOiAgICAgICAgICAgbnVsbCxcbiAgICAgICAgc3JjRG93bjogICAgICAgICAgICBudWxsLFxuICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6ICQuREVGQVVMVF9TRVRUSU5HUy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogJC5ERUZBVUxUX1NFVFRJTkdTLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIGZhZGluZy5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBmYWRlRGVsYXlcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uI1xuICAgICAgICAgKi9cbiAgICAgICAgZmFkZURlbGF5OiAgICAgICAgICAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IGxvbmcgc2hvdWxkIGl0IHRha2UgdG8gZmFkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGZhZGVMZW5ndGhcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uI1xuICAgICAgICAgKi9cbiAgICAgICAgZmFkZUxlbmd0aDogICAgICAgICAyMDAwLFxuICAgICAgICBvblByZXNzOiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIG9uUmVsZWFzZTogICAgICAgICAgbnVsbCxcbiAgICAgICAgb25DbGljazogICAgICAgICAgICBudWxsLFxuICAgICAgICBvbkVudGVyOiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIG9uRXhpdDogICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgb25Gb2N1czogICAgICAgICAgICBudWxsLFxuICAgICAgICBvbkJsdXI6ICAgICAgICAgICAgIG51bGxcblxuICAgIH0sIG9wdGlvbnMgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBidXR0b24gZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uI1xuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCAgICAgICAgPSBvcHRpb25zLmVsZW1lbnQgICB8fCAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuXG4gICAgLy9pZiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIHRoZSBlbGVtZW50IHRvIGJpbmQgdGhlIGNvbnRyb2wgdG8gZXhwbGljaXRseVxuICAgIC8vdGhlbiBkbyBub3QgYWRkIHRoZSBkZWZhdWx0IGNvbnRyb2wgaW1hZ2VzXG4gICAgaWYgKCAhb3B0aW9ucy5lbGVtZW50ICkge1xuICAgICAgICB0aGlzLmltZ1Jlc3QgICAgICA9ICQubWFrZVRyYW5zcGFyZW50SW1hZ2UoIHRoaXMuc3JjUmVzdCApO1xuICAgICAgICB0aGlzLmltZ0dyb3VwICAgICA9ICQubWFrZVRyYW5zcGFyZW50SW1hZ2UoIHRoaXMuc3JjR3JvdXAgKTtcbiAgICAgICAgdGhpcy5pbWdIb3ZlciAgICAgPSAkLm1ha2VUcmFuc3BhcmVudEltYWdlKCB0aGlzLnNyY0hvdmVyICk7XG4gICAgICAgIHRoaXMuaW1nRG93biAgICAgID0gJC5tYWtlVHJhbnNwYXJlbnRJbWFnZSggdGhpcy5zcmNEb3duICk7XG5cbiAgICAgICAgdGhpcy5pbWdSZXN0LmFsdCAgPVxuICAgICAgICB0aGlzLmltZ0dyb3VwLmFsdCA9XG4gICAgICAgIHRoaXMuaW1nSG92ZXIuYWx0ID1cbiAgICAgICAgdGhpcy5pbWdEb3duLmFsdCAgPVxuICAgICAgICAgICAgdGhpcy50b29sdGlwO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgJC5zZXRFbGVtZW50VG91Y2hBY3Rpb25Ob25lKCB0aGlzLmVsZW1lbnQgKTtcblxuICAgICAgICB0aGlzLmltZ0dyb3VwLnN0eWxlLnBvc2l0aW9uID1cbiAgICAgICAgdGhpcy5pbWdIb3Zlci5zdHlsZS5wb3NpdGlvbiA9XG4gICAgICAgIHRoaXMuaW1nRG93bi5zdHlsZS5wb3NpdGlvbiAgPVxuICAgICAgICAgICAgXCJhYnNvbHV0ZVwiO1xuXG4gICAgICAgIHRoaXMuaW1nR3JvdXAuc3R5bGUudG9wID1cbiAgICAgICAgdGhpcy5pbWdIb3Zlci5zdHlsZS50b3AgPVxuICAgICAgICB0aGlzLmltZ0Rvd24uc3R5bGUudG9wICA9XG4gICAgICAgICAgICBcIjBweFwiO1xuXG4gICAgICAgIHRoaXMuaW1nR3JvdXAuc3R5bGUubGVmdCA9XG4gICAgICAgIHRoaXMuaW1nSG92ZXIuc3R5bGUubGVmdCA9XG4gICAgICAgIHRoaXMuaW1nRG93bi5zdHlsZS5sZWZ0ICA9XG4gICAgICAgICAgICBcIjBweFwiO1xuXG4gICAgICAgIHRoaXMuaW1nSG92ZXIuc3R5bGUudmlzaWJpbGl0eSA9XG4gICAgICAgIHRoaXMuaW1nRG93bi5zdHlsZS52aXNpYmlsaXR5ICA9XG4gICAgICAgICAgICBcImhpZGRlblwiO1xuXG4gICAgICAgIGlmICggJC5Ccm93c2VyLnZlbmRvciA9PSAkLkJST1dTRVJTLkZJUkVGT1ggICYmICQuQnJvd3Nlci52ZXJzaW9uIDwgMyApe1xuICAgICAgICAgICAgdGhpcy5pbWdHcm91cC5zdHlsZS50b3AgPVxuICAgICAgICAgICAgdGhpcy5pbWdIb3Zlci5zdHlsZS50b3AgPVxuICAgICAgICAgICAgdGhpcy5pbWdEb3duLnN0eWxlLnRvcCAgPVxuICAgICAgICAgICAgICAgIFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuaW1nUmVzdCApO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuaW1nR3JvdXAgKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLmltZ0hvdmVyICk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy5pbWdEb3duICk7XG4gICAgfVxuXG5cbiAgICB0aGlzLmFkZEhhbmRsZXIoIFwicHJlc3NcIiwgICAgIHRoaXMub25QcmVzcyApO1xuICAgIHRoaXMuYWRkSGFuZGxlciggXCJyZWxlYXNlXCIsICAgdGhpcy5vblJlbGVhc2UgKTtcbiAgICB0aGlzLmFkZEhhbmRsZXIoIFwiY2xpY2tcIiwgICAgIHRoaXMub25DbGljayApO1xuICAgIHRoaXMuYWRkSGFuZGxlciggXCJlbnRlclwiLCAgICAgdGhpcy5vbkVudGVyICk7XG4gICAgdGhpcy5hZGRIYW5kbGVyKCBcImV4aXRcIiwgICAgICB0aGlzLm9uRXhpdCApO1xuICAgIHRoaXMuYWRkSGFuZGxlciggXCJmb2N1c1wiLCAgICAgdGhpcy5vbkZvY3VzICk7XG4gICAgdGhpcy5hZGRIYW5kbGVyKCBcImJsdXJcIiwgICAgICB0aGlzLm9uQmx1ciApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJ1dHRvbidzIGN1cnJlbnQgc3RhdGUuXG4gICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5CdXR0b25TdGF0ZX0gY3VycmVudFN0YXRlXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uI1xuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFN0YXRlID0gJC5CdXR0b25TdGF0ZS5HUk9VUDtcblxuICAgIC8vIFdoZW4gdGhlIGJ1dHRvbiBsYXN0IGJlZ2FuIHRvIGZhZGUuXG4gICAgdGhpcy5mYWRlQmVnaW5UaW1lICA9IG51bGw7XG4gICAgLy8gV2hldGhlciB0aGlzIGJ1dHRvbiBzaG91bGQgZmFkZSBhZnRlciB1c2VyIHN0b3BzIGludGVyYWN0aW5nIHdpdGggdGhlIHZpZXdwb3J0LlxuICAgIHRoaXMuc2hvdWxkRmFkZSAgICAgPSBmYWxzZTtcblxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ICA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIHRoaXMuZWxlbWVudC50aXRsZSAgICAgICAgICA9IHRoaXMudG9vbHRpcDtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrcyBtb3VzZS90b3VjaC9rZXkgZXZlbnRzIG9uIHRoZSBidXR0b24uXG4gICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b24jXG4gICAgICovXG4gICAgdGhpcy50cmFja2VyID0gbmV3ICQuTW91c2VUcmFja2VyKHtcblxuICAgICAgICBlbGVtZW50OiAgICAgICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcblxuICAgICAgICBlbnRlckhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGlmICggZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgKSB7XG4gICAgICAgICAgICAgICAgaW5UbyggX3RoaXMsICQuQnV0dG9uU3RhdGUuRE9XTiApO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBjdXJzb3IgZW50ZXJzIHRoZSBCdXR0b24gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBlbnRlclxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcImVudGVyXCIsIHsgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9ICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAhZXZlbnQuYnV0dG9uRG93bkFueSApIHtcbiAgICAgICAgICAgICAgICBpblRvKCBfdGhpcywgJC5CdXR0b25TdGF0ZS5IT1ZFUiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZvY3VzSGFuZGxlcjogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJIYW5kbGVyKCBldmVudCApO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgQnV0dG9uIGVsZW1lbnQgcmVjZWl2ZXMgZm9jdXMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IGZvY3VzXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b25cbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uQnV0dG9ufSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBCdXR0b24gd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggXCJmb2N1c1wiLCB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4aXRIYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICBvdXRUbyggX3RoaXMsICQuQnV0dG9uU3RhdGUuR1JPVVAgKTtcbiAgICAgICAgICAgIGlmICggZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIGN1cnNvciBsZWF2ZXMgdGhlIEJ1dHRvbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IGV4aXRcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b25cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5CdXR0b259IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEJ1dHRvbiB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggXCJleGl0XCIsIHsgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmx1ckhhbmRsZXI6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICB0aGlzLmV4aXRIYW5kbGVyKCBldmVudCApO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgQnV0dG9uIGVsZW1lbnQgbG9zZXMgZm9jdXMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IGJsdXJcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5CdXR0b259IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEJ1dHRvbiB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcImJsdXJcIiwgeyBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmVzc0hhbmRsZXI6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICBpblRvKCBfdGhpcywgJC5CdXR0b25TdGF0ZS5ET1dOICk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGEgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgb3IgdG91Y2ggb2NjdXJzIGluIHRoZSBCdXR0b24gZWxlbWVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgcHJlc3NcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5CdXR0b259IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEJ1dHRvbiB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcInByZXNzXCIsIHsgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVsZWFzZUhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGlmICggZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgJiYgZXZlbnQuaW5zaWRlRWxlbWVudFJlbGVhc2VkICkge1xuICAgICAgICAgICAgICAgIG91dFRvKCBfdGhpcywgJC5CdXR0b25TdGF0ZS5IT1ZFUiApO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQgb3IgdG91Y2ggZW5kcyBpbiB0aGUgQnV0dG9uIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgcmVsZWFzZVxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcInJlbGVhc2VcIiwgeyBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0gKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkICkge1xuICAgICAgICAgICAgICAgIG91dFRvKCBfdGhpcywgJC5CdXR0b25TdGF0ZS5HUk9VUCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpblRvKCBfdGhpcywgJC5CdXR0b25TdGF0ZS5IT1ZFUiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsaWNrSGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgaWYgKCBldmVudC5xdWljayApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCByZWxlYXNlZCBvciB0b3VjaCBpcyBpbml0aWF0ZWQgYW5kIGVuZGVkIGluIHRoZSBCdXR0b24gZWxlbWVudCB3aXRoaW4gdGhlIHRpbWUgYW5kIGRpc3RhbmNlIHRocmVzaG9sZC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBjbGlja1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KFwiY2xpY2tcIiwgeyBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGtleUhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApe1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggXCIlcyA6IGhhbmRsaW5nIGtleSAlcyFcIiwgX3RoaXMudG9vbHRpcCwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAgICAgICBpZiggMTMgPT09IGV2ZW50LmtleUNvZGUgKXtcbiAgICAgICAgICAgICAgICAvKioqXG4gICAgICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gYSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCBhbmQgcmVsZWFzZWQgb3IgdG91Y2ggaXMgaW5pdGlhdGVkIGFuZCBlbmRlZCBpbiB0aGUgQnV0dG9uIGVsZW1lbnQgd2l0aGluIHRoZSB0aW1lIGFuZCBkaXN0YW5jZSB0aHJlc2hvbGQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgY2xpY2tcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b25cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5CdXR0b259IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEJ1dHRvbiB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggXCJjbGlja1wiLCB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfSApO1xuICAgICAgICAgICAgICAgIC8qKipcbiAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHJlbGVhc2VkIG9yIHRvdWNoIGVuZHMgaW4gdGhlIEJ1dHRvbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b25cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5CdXR0b259IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEJ1dHRvbiB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggXCJyZWxlYXNlXCIsIHsgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgb3V0VG8oIHRoaXMsICQuQnV0dG9uU3RhdGUuUkVTVCApO1xufTtcblxuJC5leHRlbmQoICQuQnV0dG9uLnByb3RvdHlwZSwgJC5FdmVudFNvdXJjZS5wcm90b3R5cGUsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5CdXR0b24ucHJvdG90eXBlICove1xuXG4gICAgLyoqXG4gICAgICogVE9ETzogRGV0ZXJtaW5lIHdoYXQgdGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBkbyBhbmQgaWYgaXQncyBhY3R1YWxseVxuICAgICAqIHVzZWZ1bCBhcyBhbiBBUEkgcG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgbm90aWZ5R3JvdXBFbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGluVG8oIHRoaXMsICQuQnV0dG9uU3RhdGUuR1JPVVAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETzogRGV0ZXJtaW5lIHdoYXQgdGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBkbyBhbmQgaWYgaXQncyBhY3R1YWxseVxuICAgICAqIHVzZWZ1bCBhcyBhbiBBUEkgcG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgbm90aWZ5R3JvdXBFeGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgb3V0VG8oIHRoaXMsICQuQnV0dG9uU3RhdGUuUkVTVCApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm5vdGlmeUdyb3VwRXhpdCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAkLnNldEVsZW1lbnRPcGFjaXR5KCB0aGlzLmVsZW1lbnQsIDAuMiwgdHJ1ZSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuZWxlbWVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAkLnNldEVsZW1lbnRPcGFjaXR5KCB0aGlzLmVsZW1lbnQsIDEuMCwgdHJ1ZSApO1xuICAgICAgICB0aGlzLm5vdGlmeUdyb3VwRW50ZXIoKTtcbiAgICB9XG5cbn0pO1xuXG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmFkZSggYnV0dG9uICkge1xuICAgICQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgIHVwZGF0ZUZhZGUoIGJ1dHRvbiApO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGYWRlKCBidXR0b24gKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lLFxuICAgICAgICBkZWx0YVRpbWUsXG4gICAgICAgIG9wYWNpdHk7XG5cbiAgICBpZiAoIGJ1dHRvbi5zaG91bGRGYWRlICkge1xuICAgICAgICBjdXJyZW50VGltZSA9ICQubm93KCk7XG4gICAgICAgIGRlbHRhVGltZSAgID0gY3VycmVudFRpbWUgLSBidXR0b24uZmFkZUJlZ2luVGltZTtcbiAgICAgICAgb3BhY2l0eSAgICAgPSAxLjAgLSBkZWx0YVRpbWUgLyBidXR0b24uZmFkZUxlbmd0aDtcbiAgICAgICAgb3BhY2l0eSAgICAgPSBNYXRoLm1pbiggMS4wLCBvcGFjaXR5ICk7XG4gICAgICAgIG9wYWNpdHkgICAgID0gTWF0aC5tYXgoIDAuMCwgb3BhY2l0eSApO1xuXG4gICAgICAgIGlmKCBidXR0b24uaW1nR3JvdXAgKXtcbiAgICAgICAgICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIGJ1dHRvbi5pbWdHcm91cCwgb3BhY2l0eSwgdHJ1ZSApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggb3BhY2l0eSA+IDAgKSB7XG4gICAgICAgICAgICAvLyBmYWRlIGFnYWluXG4gICAgICAgICAgICBzY2hlZHVsZUZhZGUoIGJ1dHRvbiApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbkZhZGluZyggYnV0dG9uICkge1xuICAgIGJ1dHRvbi5zaG91bGRGYWRlID0gdHJ1ZTtcbiAgICBidXR0b24uZmFkZUJlZ2luVGltZSA9ICQubm93KCkgKyBidXR0b24uZmFkZURlbGF5O1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgICBzY2hlZHVsZUZhZGUoIGJ1dHRvbiApO1xuICAgIH0sIGJ1dHRvbi5mYWRlRGVsYXkgKTtcbn1cblxuZnVuY3Rpb24gc3RvcEZhZGluZyggYnV0dG9uICkge1xuICAgIGJ1dHRvbi5zaG91bGRGYWRlID0gZmFsc2U7XG4gICAgaWYoIGJ1dHRvbi5pbWdHcm91cCApe1xuICAgICAgICAkLnNldEVsZW1lbnRPcGFjaXR5KCBidXR0b24uaW1nR3JvdXAsIDEuMCwgdHJ1ZSApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5UbyggYnV0dG9uLCBuZXdTdGF0ZSApIHtcblxuICAgIGlmKCBidXR0b24uZWxlbWVudC5kaXNhYmxlZCApe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCBuZXdTdGF0ZSA+PSAkLkJ1dHRvblN0YXRlLkdST1VQICYmXG4gICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID09ICQuQnV0dG9uU3RhdGUuUkVTVCApIHtcbiAgICAgICAgc3RvcEZhZGluZyggYnV0dG9uICk7XG4gICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPSAkLkJ1dHRvblN0YXRlLkdST1VQO1xuICAgIH1cblxuICAgIGlmICggbmV3U3RhdGUgPj0gJC5CdXR0b25TdGF0ZS5IT1ZFUiAmJlxuICAgICAgICAgYnV0dG9uLmN1cnJlbnRTdGF0ZSA9PSAkLkJ1dHRvblN0YXRlLkdST1VQICkge1xuICAgICAgICBpZiggYnV0dG9uLmltZ0hvdmVyICl7XG4gICAgICAgICAgICBidXR0b24uaW1nSG92ZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgYnV0dG9uLmN1cnJlbnRTdGF0ZSA9ICQuQnV0dG9uU3RhdGUuSE9WRVI7XG4gICAgfVxuXG4gICAgaWYgKCBuZXdTdGF0ZSA+PSAkLkJ1dHRvblN0YXRlLkRPV04gJiZcbiAgICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPT0gJC5CdXR0b25TdGF0ZS5IT1ZFUiApIHtcbiAgICAgICAgaWYoIGJ1dHRvbi5pbWdEb3duICl7XG4gICAgICAgICAgICBidXR0b24uaW1nRG93bi5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID0gJC5CdXR0b25TdGF0ZS5ET1dOO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBvdXRUbyggYnV0dG9uLCBuZXdTdGF0ZSApIHtcblxuICAgIGlmKCBidXR0b24uZWxlbWVudC5kaXNhYmxlZCApe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCBuZXdTdGF0ZSA8PSAkLkJ1dHRvblN0YXRlLkhPVkVSICYmXG4gICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID09ICQuQnV0dG9uU3RhdGUuRE9XTiApIHtcbiAgICAgICAgaWYoIGJ1dHRvbi5pbWdEb3duICl7XG4gICAgICAgICAgICBidXR0b24uaW1nRG93bi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID0gJC5CdXR0b25TdGF0ZS5IT1ZFUjtcbiAgICB9XG5cbiAgICBpZiAoIG5ld1N0YXRlIDw9ICQuQnV0dG9uU3RhdGUuR1JPVVAgJiZcbiAgICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPT0gJC5CdXR0b25TdGF0ZS5IT1ZFUiApIHtcbiAgICAgICAgaWYoIGJ1dHRvbi5pbWdIb3ZlciApe1xuICAgICAgICAgICAgYnV0dG9uLmltZ0hvdmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPSAkLkJ1dHRvblN0YXRlLkdST1VQO1xuICAgIH1cblxuICAgIGlmICggbmV3U3RhdGUgPD0gJC5CdXR0b25TdGF0ZS5SRVNUICYmXG4gICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID09ICQuQnV0dG9uU3RhdGUuR1JPVVAgKSB7XG4gICAgICAgIGJlZ2luRmFkaW5nKCBidXR0b24gKTtcbiAgICAgICAgYnV0dG9uLmN1cnJlbnRTdGF0ZSA9ICQuQnV0dG9uU3RhdGUuUkVTVDtcbiAgICB9XG59XG5cblxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIEJ1dHRvbkdyb3VwXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuLyoqXG4gKiBAY2xhc3MgQnV0dG9uR3JvdXBcbiAqIEBjbGFzc2Rlc2MgTWFuYWdlcyBldmVudHMgb24gZ3JvdXBzIG9mIGJ1dHRvbnMuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQSBkaWN0aW9uYXJ5IG9mIHNldHRpbmdzIGFwcGxpZWQgYWdhaW5zdCB0aGUgZW50aXJlIGdyb3VwIG9mIGJ1dHRvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmJ1dHRvbnMgQXJyYXkgb2YgYnV0dG9uc1xuICogQHBhcmFtIHtFbGVtZW50fSBbb3B0aW9ucy5lbGVtZW50XSBFbGVtZW50IHRvIHVzZSBhcyB0aGUgY29udGFpbmVyXG4gKiovXG4kLkJ1dHRvbkdyb3VwID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywge1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgYnV0dG9ucyB0aGVtc2VsdmVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gYnV0dG9uc1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b25Hcm91cCNcbiAgICAgICAgICovXG4gICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgW10sXG4gICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogJC5ERUZBVUxUX1NFVFRJTkdTLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiAkLkRFRkFVTFRfU0VUVElOR1MuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICBsYWJlbFRleHQ6ICAgICAgICAgIFwiXCJcbiAgICB9LCBvcHRpb25zICk7XG5cbiAgICAvLyBjb3B5IHRoZSBidXR0b24gZWxlbWVudHMgIFRPRE86IFdoeT9cbiAgICB2YXIgYnV0dG9ucyA9IHRoaXMuYnV0dG9ucy5jb25jYXQoW10pLFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcmVkIGNvbnRhaW5lciBmb3IgdGhlIGJ1dHRvbnMuXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvbkdyb3VwI1xuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCB8fCAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuXG4gICAgLy8gVE9ETyBXaGF0IGlmIHRoZXJlIElTIGFuIG9wdGlvbnMuZ3JvdXAgc3BlY2lmaWVkP1xuICAgIGlmKCAhb3B0aW9ucy5ncm91cCApe1xuICAgICAgICB0aGlzLmxhYmVsICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJsYWJlbFwiICk7XG4gICAgICAgIC8vVE9ETzogc3VwcG9ydCBsYWJlbHMgZm9yIEJ1dHRvbkdyb3Vwc1xuICAgICAgICAvL3RoaXMubGFiZWwuaW5uZXJIVE1MID0gdGhpcy5sYWJlbFRleHQ7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLmxhYmVsICk7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggYnV0dG9uc1sgaSBdLmVsZW1lbnQgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICQuc2V0RWxlbWVudFRvdWNoQWN0aW9uTm9uZSggdGhpcy5lbGVtZW50ICk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFja3MgbW91c2UvdG91Y2gva2V5IGV2ZW50cyBhY2Nyb3NzIHRoZSBncm91cCBvZiBidXR0b25zLlxuICAgICAqIEBtZW1iZXIge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uR3JvdXAjXG4gICAgICovXG4gICAgdGhpcy50cmFja2VyID0gbmV3ICQuTW91c2VUcmFja2VyKHtcbiAgICAgICAgZWxlbWVudDogICAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgIGVudGVySGFuZGxlcjogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBfdGhpcy5idXR0b25zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1dHRvbnNbIGkgXS5ub3RpZnlHcm91cEVudGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4aXRIYW5kbGVyOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBpZiAoICFldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCApIHtcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IF90aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJ1dHRvbnNbIGkgXS5ub3RpZnlHcm91cEV4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uQnV0dG9uR3JvdXAucHJvdG90eXBlICovXG4kLkJ1dHRvbkdyb3VwLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoaXMgaXMgdXNlZCBvbiB0aGUgcHVibGljIEFQSSBhbmQgaWYgYSBtb3JlIHVzZWZ1bFxuICAgICAqIGFwaSBjYW4gYmUgY3JlYXRlZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGVtdWxhdGVFbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudHJhY2tlci5lbnRlckhhbmRsZXIoIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciB9ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoaXMgaXMgdXNlZCBvbiB0aGUgcHVibGljIEFQSSBhbmQgaWYgYSBtb3JlIHVzZWZ1bFxuICAgICAqIGFwaSBjYW4gYmUgY3JlYXRlZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGVtdWxhdGVFeGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmFja2VyLmV4aXRIYW5kbGVyKCB7IGV2ZW50U291cmNlOiB0aGlzLnRyYWNrZXIgfSApO1xuICAgIH1cbn07XG5cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBSZWN0XG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogQGNsYXNzIFJlY3RcbiAqIEBjbGFzc2Rlc2MgQSBSZWN0YW5nbGUgaXMgZGVzY3JpYmVkIGJ5IGl0IHRvcCBsZWZ0IGNvb3JkaW5hdGVzICh4LCB5KSwgd2lkdGgsXG4gKiBoZWlnaHQgYW5kIGRlZ3JlZXMgb2Ygcm90YXRpb24gYXJvdW5kICh4LCB5KS5cbiAqIE5vdGUgdGhhdCB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gdXNlZCBpcyB0aGUgb25lIGNvbW1vbmx5IHVzZWQgd2l0aCBpbWFnZXM6XG4gKiB4IGluY3JlYXNlcyB3aGVuIGdvaW5nIHRvIHRoZSByaWdodFxuICogeSBpbmNyZWFzZXMgd2hlbiBnb2luZyB0byB0aGUgYm90dG9tXG4gKiBkZWdyZWVzIGluY3JlYXNlcyBjbG9ja3dpc2Ugd2l0aCAwIGJlaW5nIHRoZSBob3Jpem9udGFsXG4gKlxuICogVGhlIGNvbnN0cnVjdG9yIG5vcm1hbGl6ZXMgdGhlIHJlY3RhbmdsZSB0byBhbHdheXMgaGF2ZSAwIDw9IGRlZ3JlZXMgPCA5MFxuICpcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gVGhlIHZlY3RvciBjb21wb25lbnQgJ3gnLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFRoZSB2ZWN0b3IgY29tcG9uZW50ICd5Jy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHZlY3RvciBjb21wb25lbnQgJ3dpZHRoJy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSB2ZWN0b3IgY29tcG9uZW50ICdoZWlnaHQnLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtkZWdyZWVzPTBdIFJvdGF0aW9uIG9mIHRoZSByZWN0YW5nbGUgYXJvdW5kICh4LHkpIGluIGRlZ3JlZXMuXG4gKi9cbiQuUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIGRlZ3JlZXMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVjdG9yIGNvbXBvbmVudCAneCcuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB4XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uUmVjdCNcbiAgICAgKi9cbiAgICB0aGlzLnggPSB0eXBlb2YoeCkgPT09IFwibnVtYmVyXCIgPyB4IDogMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVjdG9yIGNvbXBvbmVudCAneScuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB5XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uUmVjdCNcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB0eXBlb2YoeSkgPT09IFwibnVtYmVyXCIgPyB5IDogMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVjdG9yIGNvbXBvbmVudCAnd2lkdGgnLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gd2lkdGhcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5SZWN0I1xuICAgICAqL1xuICAgIHRoaXMud2lkdGggID0gdHlwZW9mKHdpZHRoKSA9PT0gXCJudW1iZXJcIiA/IHdpZHRoIDogMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVjdG9yIGNvbXBvbmVudCAnaGVpZ2h0Jy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlJlY3QjXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSB0eXBlb2YoaGVpZ2h0KSA9PT0gXCJudW1iZXJcIiA/IGhlaWdodCA6IDA7XG5cbiAgICB0aGlzLmRlZ3JlZXMgPSB0eXBlb2YoZGVncmVlcykgPT09IFwibnVtYmVyXCIgPyBkZWdyZWVzIDogMDtcblxuICAgIC8vIE5vcm1hbGl6ZXMgdGhlIHJlY3RhbmdsZS5cbiAgICB0aGlzLmRlZ3JlZXMgPSB0aGlzLmRlZ3JlZXMgJSAzNjA7XG4gICAgaWYgKHRoaXMuZGVncmVlcyA8IDApIHtcbiAgICAgICAgdGhpcy5kZWdyZWVzICs9IDM2MDtcbiAgICB9XG4gICAgdmFyIG5ld1RvcExlZnQsIG5ld1dpZHRoO1xuICAgIGlmICh0aGlzLmRlZ3JlZXMgPj0gMjcwKSB7XG4gICAgICAgIG5ld1RvcExlZnQgPSB0aGlzLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIHRoaXMueCA9IG5ld1RvcExlZnQueDtcbiAgICAgICAgdGhpcy55ID0gbmV3VG9wTGVmdC55O1xuICAgICAgICBuZXdXaWR0aCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgdGhpcy5kZWdyZWVzIC09IDI3MDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVncmVlcyA+PSAxODApIHtcbiAgICAgICAgbmV3VG9wTGVmdCA9IHRoaXMuZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgdGhpcy54ID0gbmV3VG9wTGVmdC54O1xuICAgICAgICB0aGlzLnkgPSBuZXdUb3BMZWZ0Lnk7XG4gICAgICAgIHRoaXMuZGVncmVlcyAtPSAxODA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRlZ3JlZXMgPj0gOTApIHtcbiAgICAgICAgbmV3VG9wTGVmdCA9IHRoaXMuZ2V0Qm90dG9tTGVmdCgpO1xuICAgICAgICB0aGlzLnggPSBuZXdUb3BMZWZ0Lng7XG4gICAgICAgIHRoaXMueSA9IG5ld1RvcExlZnQueTtcbiAgICAgICAgbmV3V2lkdGggPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIHRoaXMuZGVncmVlcyAtPSA5MDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJlY3RhbmdsZSBoYXZpbmcgdGhlIDMgc3BlY2lmaWVkIHBvaW50cyBhcyBzdW1taXRzLlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uUmVjdFxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSB0b3BMZWZ0XG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHRvcFJpZ2h0XG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGJvdHRvbUxlZnRcbiAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9XG4gKi9cbiQuUmVjdC5mcm9tU3VtbWl0cyA9IGZ1bmN0aW9uKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KSB7XG4gICAgdmFyIHdpZHRoID0gdG9wTGVmdC5kaXN0YW5jZVRvKHRvcFJpZ2h0KTtcbiAgICB2YXIgaGVpZ2h0ID0gdG9wTGVmdC5kaXN0YW5jZVRvKGJvdHRvbUxlZnQpO1xuICAgIHZhciBkaWZmID0gdG9wUmlnaHQubWludXModG9wTGVmdCk7XG4gICAgdmFyIHJhZGlhbnMgPSBNYXRoLmF0YW4oZGlmZi55IC8gZGlmZi54KTtcbiAgICBpZiAoZGlmZi54IDwgMCkge1xuICAgICAgICByYWRpYW5zICs9IE1hdGguUEk7XG4gICAgfSBlbHNlIGlmIChkaWZmLnkgPCAwKSB7XG4gICAgICAgIHJhZGlhbnMgKz0gMiAqIE1hdGguUEk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICB0b3BMZWZ0LngsXG4gICAgICAgIHRvcExlZnQueSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcmFkaWFucyAvIE1hdGguUEkgKiAxODApO1xufTtcblxuLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLlJlY3QucHJvdG90eXBlICovXG4kLlJlY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IGEgZHVwbGljYXRlIG9mIHRoaXMgUmVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICB0aGlzLngsXG4gICAgICAgICAgICB0aGlzLnksXG4gICAgICAgICAgICB0aGlzLndpZHRoLFxuICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB0aGlzLmRlZ3JlZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXNwZWN0IHJhdGlvIGlzIHNpbXBseSB0aGUgcmF0aW8gb2Ygd2lkdGggdG8gaGVpZ2h0LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSByYXRpbyBvZiB3aWR0aCB0byBoZWlnaHQuXG4gICAgICovXG4gICAgZ2V0QXNwZWN0UmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUgYXMgYVxuICAgICAqIHBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2ZcbiAgICAgKiAgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXRUb3BMZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgdGhpcy54LFxuICAgICAgICAgICAgdGhpcy55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlIGFzIGFcbiAgICAgKiBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXIgb2ZcbiAgICAgKiAgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXRCb3R0b21SaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCh0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodClcbiAgICAgICAgICAgIC5yb3RhdGUodGhpcy5kZWdyZWVzLCB0aGlzLmdldFRvcExlZnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdG9wLXJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlIGFzIGFcbiAgICAgKiBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIHRvcC1yaWdodCBjb3JuZXIgb2ZcbiAgICAgKiAgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXRUb3BSaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCh0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkpXG4gICAgICAgICAgICAucm90YXRlKHRoaXMuZGVncmVlcywgdGhpcy5nZXRUb3BMZWZ0KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlIGFzIGFcbiAgICAgKiBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZlxuICAgICAqICB0aGUgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQodGhpcy54LCB0aGlzLnkgKyB0aGlzLmhlaWdodClcbiAgICAgICAgICAgIC5yb3RhdGUodGhpcy5kZWdyZWVzLCB0aGlzLmdldFRvcExlZnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBjZW50ZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhlIGNlbnRlciBvZiB0aGUgcmVjdGFuZ2xlIGFzIHJlcHJlc2VudGVkXG4gICAgICogIGFzIHJlcHJlc2VudGVkIGJ5IGEgMi1kaW1lbnNpb25hbCB2ZWN0b3IgKHgseSlcbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoIC8gMi4wLFxuICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyLjBcbiAgICAgICAgKS5yb3RhdGUodGhpcy5kZWdyZWVzLCB0aGlzLmdldFRvcExlZnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY29tcG9uZW50IGFzIGEgdmVjdG9yIE9wZW5TZWFkcmFnb24uUG9pbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhlIDIgZGltZW5zaW9uYWwgdmVjdG9yIHJlcHJlc2VudGluZyB0aGVcbiAgICAgKiAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXRTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0d28gUmVjdGFuZ2xlcyBoYXZlIGVxdWl2YWxlbnQgY29tcG9uZW50cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gcmVjdGFuZ2xlIFRoZSBSZWN0YW5nbGUgdG8gY29tcGFyZSB0by5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAndHJ1ZScgaWYgYWxsIGNvbXBvbmVudHMgYXJlIGVxdWFsLCBvdGhlcndpc2UgJ2ZhbHNlJy5cbiAgICAgKi9cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiAkLlJlY3QpICYmXG4gICAgICAgICAgICB0aGlzLnggPT09IG90aGVyLnggJiZcbiAgICAgICAgICAgIHRoaXMueSA9PT0gb3RoZXIueSAmJlxuICAgICAgICAgICAgdGhpcy53aWR0aCA9PT0gb3RoZXIud2lkdGggJiZcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuZGVncmVlcyA9PT0gb3RoZXIuZGVncmVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBNdWx0aXBseSBhbGwgZGltZW5zaW9ucyAoZXhjZXB0IGRlZ3JlZXMpIGluIHRoaXMgUmVjdCBieSBhIGZhY3RvciBhbmRcbiAgICAqIHJldHVybiBhIG5ldyBSZWN0LlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcGFyYW0ge051bWJlcn0gZmFjdG9yIFRoZSBmYWN0b3IgdG8gbXVsdGlwbHkgdmVjdG9yIGNvbXBvbmVudHMuXG4gICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fSBBIG5ldyByZWN0IHJlcHJlc2VudGluZyB0aGUgbXVsdGlwbGljYXRpb25cbiAgICAqICBvZiB0aGUgdmVjdG9yIGNvbXBvbmVudHMgYnkgdGhlIGZhY3RvclxuICAgICovXG4gICAgdGltZXM6IGZ1bmN0aW9uKGZhY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIHRoaXMueCAqIGZhY3RvcixcbiAgICAgICAgICAgIHRoaXMueSAqIGZhY3RvcixcbiAgICAgICAgICAgIHRoaXMud2lkdGggKiBmYWN0b3IsXG4gICAgICAgICAgICB0aGlzLmhlaWdodCAqIGZhY3RvcixcbiAgICAgICAgICAgIHRoaXMuZGVncmVlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogVHJhbnNsYXRlL21vdmUgdGhpcyBSZWN0IGJ5IGEgdmVjdG9yIGFuZCByZXR1cm4gbmV3IFJlY3QuXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZGVsdGEgVGhlIHRyYW5zbGF0aW9uIHZlY3Rvci5cbiAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IEEgbmV3IHJlY3Qgd2l0aCBhbHRlcmVkIHBvc2l0aW9uXG4gICAgKi9cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgdGhpcy54ICsgZGVsdGEueCxcbiAgICAgICAgICAgIHRoaXMueSArIGRlbHRhLnksXG4gICAgICAgICAgICB0aGlzLndpZHRoLFxuICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB0aGlzLmRlZ3JlZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzbWFsbGVzdCByZWN0YW5nbGUgdGhhdCB3aWxsIGNvbnRhaW4gdGhpcyBhbmQgdGhlIGdpdmVuXG4gICAgICogcmVjdGFuZ2xlIGJvdW5kaW5nIGJveGVzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSByZWN0XG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5SZWN0fSBUaGUgbmV3IHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICB1bmlvbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgdGhpc0JvdW5kaW5nQm94ID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICB2YXIgb3RoZXJCb3VuZGluZ0JveCA9IHJlY3QuZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHRoaXNCb3VuZGluZ0JveC54LCBvdGhlckJvdW5kaW5nQm94LngpO1xuICAgICAgICB2YXIgdG9wID0gTWF0aC5taW4odGhpc0JvdW5kaW5nQm94LnksIG90aGVyQm91bmRpbmdCb3gueSk7XG4gICAgICAgIHZhciByaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpc0JvdW5kaW5nQm94LnggKyB0aGlzQm91bmRpbmdCb3gud2lkdGgsXG4gICAgICAgICAgICBvdGhlckJvdW5kaW5nQm94LnggKyBvdGhlckJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpc0JvdW5kaW5nQm94LnkgKyB0aGlzQm91bmRpbmdCb3guaGVpZ2h0LFxuICAgICAgICAgICAgb3RoZXJCb3VuZGluZ0JveC55ICsgb3RoZXJCb3VuZGluZ0JveC5oZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgICAgIGJvdHRvbSAtIHRvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgcmVjdGFuZ2xlIHdpdGggdGhlXG4gICAgICogZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSByZWN0XG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5SZWN0fSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgKiBvciBudWxsIGlmIHRoZSByZWN0YW5nbGVzIGRvbid0IGludGVyc2VjdC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgLy8gU2ltcGxpZmllZCB2ZXJzaW9uIG9mIFdlaWxlciBBdGhlcnRvbiBjbGlwcGluZyBhbGdvcml0aG1cbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2VpbGVyJUUyJTgwJTkzQXRoZXJ0b25fY2xpcHBpbmdfYWxnb3JpdGhtXG4gICAgICAgIC8vIEJlY2F1c2Ugd2UganVzdCB3YW50IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGludGVyc2VjdGlvbixcbiAgICAgICAgLy8gd2UgY2FuIGp1c3QgY29tcHV0ZSB0aGUgYm91bmRpbmcgYm94IG9mOlxuICAgICAgICAvLyAxLiBhbGwgdGhlIHN1bW1pdHMgb2YgdGhpcyB3aGljaCBhcmUgaW5zaWRlIHJlY3RcbiAgICAgICAgLy8gMi4gYWxsIHRoZSBzdW1taXRzIG9mIHJlY3Qgd2hpY2ggYXJlIGluc2lkZSB0aGlzXG4gICAgICAgIC8vIDMuIGFsbCB0aGUgaW50ZXJzZWN0aW9ucyBvZiByZWN0IGFuZCB0aGlzXG4gICAgICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcblxuICAgICAgICB2YXIgdGhpc1RvcExlZnQgPSB0aGlzLmdldFRvcExlZnQoKTtcbiAgICAgICAgaWYgKHJlY3QuY29udGFpbnNQb2ludCh0aGlzVG9wTGVmdCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHRoaXNUb3BMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc1RvcFJpZ2h0ID0gdGhpcy5nZXRUb3BSaWdodCgpO1xuICAgICAgICBpZiAocmVjdC5jb250YWluc1BvaW50KHRoaXNUb3BSaWdodCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHRoaXNUb3BSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCb3R0b21MZWZ0ID0gdGhpcy5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgIGlmIChyZWN0LmNvbnRhaW5zUG9pbnQodGhpc0JvdHRvbUxlZnQsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCh0aGlzQm90dG9tTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCb3R0b21SaWdodCA9IHRoaXMuZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgaWYgKHJlY3QuY29udGFpbnNQb2ludCh0aGlzQm90dG9tUmlnaHQsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCh0aGlzQm90dG9tUmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3RUb3BMZWZ0ID0gcmVjdC5nZXRUb3BMZWZ0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQocmVjdFRvcExlZnQsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChyZWN0VG9wTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY3RUb3BSaWdodCA9IHJlY3QuZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludChyZWN0VG9wUmlnaHQsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChyZWN0VG9wUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWN0Qm90dG9tTGVmdCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCgpO1xuICAgICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KHJlY3RCb3R0b21MZWZ0LCBFUFNJTE9OKSkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2gocmVjdEJvdHRvbUxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWN0Qm90dG9tUmlnaHQgPSByZWN0LmdldEJvdHRvbVJpZ2h0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQocmVjdEJvdHRvbVJpZ2h0LCBFUFNJTE9OKSkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2gocmVjdEJvdHRvbVJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzU2VnbWVudHMgPSB0aGlzLl9nZXRTZWdtZW50cygpO1xuICAgICAgICB2YXIgcmVjdFNlZ21lbnRzID0gcmVjdC5fZ2V0U2VnbWVudHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aGlzU2VnbWVudCA9IHRoaXNTZWdtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVjdFNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RTZWdtZW50ID0gcmVjdFNlZ21lbnRzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBnZXRJbnRlcnNlY3Rpb24odGhpc1NlZ21lbnRbMF0sIHRoaXNTZWdtZW50WzFdLFxuICAgICAgICAgICAgICAgICAgICByZWN0U2VnbWVudFswXSwgcmVjdFNlZ21lbnRbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgaW50ZXJzZWN0aW9uIHBvaW50IG9mIHNlZ21lbnRzIFthLGJdIGFuZCBbYyxkXVxuICAgICAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24oYSwgYiwgYywgZCkge1xuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk2ODM0NS8xNDQwNDAzXG4gICAgICAgICAgICB2YXIgYWJWZWN0b3IgPSBiLm1pbnVzKGEpO1xuICAgICAgICAgICAgdmFyIGNkVmVjdG9yID0gZC5taW51cyhjKTtcblxuICAgICAgICAgICAgdmFyIGRlbm9tID0gLWNkVmVjdG9yLnggKiBhYlZlY3Rvci55ICsgYWJWZWN0b3IueCAqIGNkVmVjdG9yLnk7XG4gICAgICAgICAgICBpZiAoZGVub20gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHMgPSAoYWJWZWN0b3IueCAqIChhLnkgLSBjLnkpIC0gYWJWZWN0b3IueSAqIChhLnggLSBjLngpKSAvIGRlbm9tO1xuICAgICAgICAgICAgdmFyIHQgPSAoY2RWZWN0b3IueCAqIChhLnkgLSBjLnkpIC0gY2RWZWN0b3IueSAqIChhLnggLSBjLngpKSAvIGRlbm9tO1xuXG4gICAgICAgICAgICBpZiAoLUVQU0lMT04gPD0gcyAmJiBzIDw9IDEgLSBFUFNJTE9OICYmXG4gICAgICAgICAgICAgICAgLUVQU0lMT04gPD0gdCAmJiB0IDw9IDEgLSBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KGEueCArIHQgKiBhYlZlY3Rvci54LCBhLnkgKyB0ICogYWJWZWN0b3IueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5YID0gaW50ZXJzZWN0aW9uUG9pbnRzWzBdLng7XG4gICAgICAgIHZhciBtYXhYID0gaW50ZXJzZWN0aW9uUG9pbnRzWzBdLng7XG4gICAgICAgIHZhciBtaW5ZID0gaW50ZXJzZWN0aW9uUG9pbnRzWzBdLnk7XG4gICAgICAgIHZhciBtYXhZID0gaW50ZXJzZWN0aW9uUG9pbnRzWzBdLnk7XG4gICAgICAgIGZvciAodmFyIGsgPSAxOyBrIDwgaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBpbnRlcnNlY3Rpb25Qb2ludHNba107XG4gICAgICAgICAgICBpZiAocG9pbnQueCA8IG1pblgpIHtcbiAgICAgICAgICAgICAgICBtaW5YID0gcG9pbnQueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludC54ID4gbWF4WCkge1xuICAgICAgICAgICAgICAgIG1heFggPSBwb2ludC54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvaW50LnkgPCBtaW5ZKSB7XG4gICAgICAgICAgICAgICAgbWluWSA9IHBvaW50Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9pbnQueSA+IG1heFkpIHtcbiAgICAgICAgICAgICAgICBtYXhZID0gcG9pbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX2dldFNlZ21lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLmdldFRvcExlZnQoKTtcbiAgICAgICAgdmFyIHRvcFJpZ2h0ID0gdGhpcy5nZXRUb3BSaWdodCgpO1xuICAgICAgICB2YXIgYm90dG9tTGVmdCA9IHRoaXMuZ2V0Qm90dG9tTGVmdCgpO1xuICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSB0aGlzLmdldEJvdHRvbVJpZ2h0KCk7XG4gICAgICAgIHJldHVybiBbW3RvcExlZnQsIHRvcFJpZ2h0XSxcbiAgICAgICAgICAgIFt0b3BSaWdodCwgYm90dG9tUmlnaHRdLFxuICAgICAgICAgICAgW2JvdHRvbVJpZ2h0LCBib3R0b21MZWZ0XSxcbiAgICAgICAgICAgIFtib3R0b21MZWZ0LCB0b3BMZWZ0XV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYSByZWN0YW5nbGUgYXJvdW5kIGEgcG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXMgdG8gcm90YXRlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gW3Bpdm90XSBUaGUgcG9pbnQgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlJlY3R9XG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbihkZWdyZWVzLCBwaXZvdCkge1xuICAgICAgICBkZWdyZWVzID0gZGVncmVlcyAlIDM2MDtcbiAgICAgICAgaWYgKGRlZ3JlZXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZ3JlZXMgPCAwKSB7XG4gICAgICAgICAgICBkZWdyZWVzICs9IDM2MDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBpdm90ID0gcGl2b3QgfHwgdGhpcy5nZXRDZW50ZXIoKTtcbiAgICAgICAgdmFyIG5ld1RvcExlZnQgPSB0aGlzLmdldFRvcExlZnQoKS5yb3RhdGUoZGVncmVlcywgcGl2b3QpO1xuICAgICAgICB2YXIgbmV3VG9wUmlnaHQgPSB0aGlzLmdldFRvcFJpZ2h0KCkucm90YXRlKGRlZ3JlZXMsIHBpdm90KTtcblxuICAgICAgICB2YXIgZGlmZiA9IG5ld1RvcFJpZ2h0Lm1pbnVzKG5ld1RvcExlZnQpO1xuICAgICAgICB2YXIgcmFkaWFucyA9IE1hdGguYXRhbihkaWZmLnkgLyBkaWZmLngpO1xuICAgICAgICBpZiAoZGlmZi54IDwgMCkge1xuICAgICAgICAgICAgcmFkaWFucyArPSBNYXRoLlBJO1xuICAgICAgICB9IGVsc2UgaWYgKGRpZmYueSA8IDApIHtcbiAgICAgICAgICAgIHJhZGlhbnMgKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBuZXdUb3BMZWZ0LngsXG4gICAgICAgICAgICBuZXdUb3BMZWZ0LnksXG4gICAgICAgICAgICB0aGlzLndpZHRoLFxuICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICByYWRpYW5zIC8gTWF0aC5QSSAqIDE4MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc21hbGxlc3QgaG9yaXpvbnRhbCAoZGVncmVlcz0wKSByZWN0YW5nbGUgd2hpY2ggY29udGFpbnNcbiAgICAgKiB0aGlzIHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fVxuICAgICAqL1xuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVncmVlcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9wTGVmdCA9IHRoaXMuZ2V0VG9wTGVmdCgpO1xuICAgICAgICB2YXIgdG9wUmlnaHQgPSB0aGlzLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gdGhpcy5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgIHZhciBib3R0b21SaWdodCA9IHRoaXMuZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgdmFyIG1pblggPSBNYXRoLm1pbih0b3BMZWZ0LngsIHRvcFJpZ2h0LngsIGJvdHRvbUxlZnQueCwgYm90dG9tUmlnaHQueCk7XG4gICAgICAgIHZhciBtYXhYID0gTWF0aC5tYXgodG9wTGVmdC54LCB0b3BSaWdodC54LCBib3R0b21MZWZ0LngsIGJvdHRvbVJpZ2h0LngpO1xuICAgICAgICB2YXIgbWluWSA9IE1hdGgubWluKHRvcExlZnQueSwgdG9wUmlnaHQueSwgYm90dG9tTGVmdC55LCBib3R0b21SaWdodC55KTtcbiAgICAgICAgdmFyIG1heFkgPSBNYXRoLm1heCh0b3BMZWZ0LnksIHRvcFJpZ2h0LnksIGJvdHRvbUxlZnQueSwgYm90dG9tUmlnaHQueSk7XG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgbWluWCxcbiAgICAgICAgICAgIG1pblksXG4gICAgICAgICAgICBtYXhYIC0gbWluWCxcbiAgICAgICAgICAgIG1heFkgLSBtaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzbWFsbGVzdCBob3Jpem9udGFsIChkZWdyZWVzPTApIHJlY3RhbmdsZSB3aGljaCBjb250YWluc1xuICAgICAqIHRoaXMgcmVjdGFuZ2xlIGFuZCBoYXMgaW50ZWdlcnMgeCwgeSwgd2lkdGggYW5kIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9XG4gICAgICovXG4gICAgZ2V0SW50ZWdlckJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueCk7XG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55KTtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKGJvdW5kaW5nQm94LndpZHRoICsgYm91bmRpbmdCb3gueCAtIHgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5jZWlsKGJvdW5kaW5nQm94LmhlaWdodCArIGJvdW5kaW5nQm94LnkgLSB5KTtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHJlY3RhbmdsZSAoZWRnZSBpbmNsdWRlZCkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZXBzaWxvbj0wXSB0aGUgbWFyZ2luIG9mIGVycm9yIGFsbG93ZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoaXMgcmVjdGFuZ2xlLCBmYWxzZVxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCwgZXBzaWxvbikge1xuICAgICAgICBlcHNpbG9uID0gZXBzaWxvbiB8fCAwO1xuXG4gICAgICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNzUyNzU0LzE0NDA0MDMgZm9yIGV4cGxhbmF0aW9uXG4gICAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5nZXRUb3BMZWZ0KCk7XG4gICAgICAgIHZhciB0b3BSaWdodCA9IHRoaXMuZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSB0aGlzLmdldEJvdHRvbUxlZnQoKTtcbiAgICAgICAgdmFyIHRvcERpZmYgPSB0b3BSaWdodC5taW51cyh0b3BMZWZ0KTtcbiAgICAgICAgdmFyIGxlZnREaWZmID0gYm90dG9tTGVmdC5taW51cyh0b3BMZWZ0KTtcblxuICAgICAgICByZXR1cm4gKChwb2ludC54IC0gdG9wTGVmdC54KSAqIHRvcERpZmYueCArXG4gICAgICAgICAgICAocG9pbnQueSAtIHRvcExlZnQueSkgKiB0b3BEaWZmLnkgPj0gLWVwc2lsb24pICYmXG5cbiAgICAgICAgICAgICgocG9pbnQueCAtIHRvcFJpZ2h0LngpICogdG9wRGlmZi54ICtcbiAgICAgICAgICAgIChwb2ludC55IC0gdG9wUmlnaHQueSkgKiB0b3BEaWZmLnkgPD0gZXBzaWxvbikgJiZcblxuICAgICAgICAgICAgKChwb2ludC54IC0gdG9wTGVmdC54KSAqIGxlZnREaWZmLnggK1xuICAgICAgICAgICAgKHBvaW50LnkgLSB0b3BMZWZ0LnkpICogbGVmdERpZmYueSA+PSAtZXBzaWxvbikgJiZcblxuICAgICAgICAgICAgKChwb2ludC54IC0gYm90dG9tTGVmdC54KSAqIGxlZnREaWZmLnggK1xuICAgICAgICAgICAgKHBvaW50LnkgLSBib3R0b21MZWZ0LnkpICogbGVmdERpZmYueSA8PSBlcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlY3RhbmdsZSB3aGljaCBpcyB1c2VmdWwgZm9yXG4gICAgICogZGVidWdnaW5nLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJbXCIgK1xuICAgICAgICAgICAgKE1hdGgucm91bmQodGhpcy54ICogMTAwKSAvIDEwMCkgKyBcIiwgXCIgK1xuICAgICAgICAgICAgKE1hdGgucm91bmQodGhpcy55ICogMTAwKSAvIDEwMCkgKyBcIiwgXCIgK1xuICAgICAgICAgICAgKE1hdGgucm91bmQodGhpcy53aWR0aCAqIDEwMCkgLyAxMDApICsgXCJ4XCIgK1xuICAgICAgICAgICAgKE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiAxMDApIC8gMTAwKSArIFwiLCBcIiArXG4gICAgICAgICAgICAoTWF0aC5yb3VuZCh0aGlzLmRlZ3JlZXMgKiAxMDApIC8gMTAwKSArIFwiZGVnXCIgK1xuICAgICAgICAgICAgXCJdXCI7XG4gICAgfVxufTtcblxuXG59KE9wZW5TZWFkcmFnb24pKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBSZWZlcmVuY2VTdHJpcFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24gKCAkICkge1xuXG4vLyBkaWN0aW9uYXJ5IGZyb20gaWQgdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG52YXIgVEhJUyA9IHt9O1xuXG4vKipcbiAqICBUaGUgQ29sbGVjdGlvbkRyYXdlciBpcyBhIHJlaW1wbGVtZW50YXRpb24gaWYgdGhlIERyYXdlciBBUEkgdGhhdFxuICogIGZvY3VzZXMgb24gYWxsb3dpbmcgYSB2aWV3cG9ydCB0byBiZSByZWRlZmluZWQgYXMgYSBjb2xsZWN0aW9uXG4gKiAgb2Ygc21hbGxlciB2aWV3cG9ydHMsIGRlZmluZWQgYnkgYSBjbGVhciBudW1iZXIgb2Ygcm93cyBhbmQgLyBvclxuICogIGNvbHVtbnMgb2Ygd2hpY2ggZWFjaCBpdGVtIGluIHRoZSBtYXRyaXggb2Ygdmlld3BvcnRzIGhhcyBpdHMgb3duXG4gKiAgc291cmNlLlxuICpcbiAqICBUaGlzIGlkZWEgaXMgYSByZWV4cHJlc3Npb24gb2YgdGhlIGlkZWEgb2YgZHppIGNvbGxlY3Rpb25zXG4gKiAgd2hpY2ggYWxsb3dzIGEgY2xlYXJlciBhbGdvcml0aG0gdG8gcmV1c2UgdGhlIHRpbGUgc291cmNlcyBhbHJlYWR5XG4gKiAgc3VwcG9ydGVkIGJ5IE9wZW5TZWFkcmFnb24sIGluIGhldGVyb2dlbmlvdXMgb3IgaG9tb2dlbmlvdXNcbiAqICBzZXF1ZW5jZXMganVzdCBsaWtlIG1peGVkIGdyb3VwcyBhbHJlYWR5IHN1cHBvcnRlZCBieSB0aGUgdmlld2VyXG4gKiAgZm9yIHRoZSBwdXJwb3NlIG9mIGltYWdlIHNlcXVuY2VzLlxuICpcbiAqICBUT0RPOiAgIFRoZSBkaWZmaWN1bHQgcGFydCBvZiB0aGlzIGZlYXR1cmUgaXMgZmlndXJpbmcgb3V0IGhvdyB0byBleHByZXNzXG4gKiAgICAgICAgICB0aGlzIGZ1bmN0aW9uYWxpdHkgYXMgYSBjb21iaW5hdGlvbiBvZiB0aGUgZnVuY3Rpb25hbGl0eSBhbHJlYWR5XG4gKiAgICAgICAgICBwcm92aWRlZCBieSBEcmF3ZXIsIFZpZXdwb3J0LCBUaWxlU291cmNlLCBhbmQgTmF2aWdhdG9yLiAgSXQgbWF5XG4gKiAgICAgICAgICByZXF1aXJlIGJldHRlciBhYnN0cmFjdGlvbiBhdCB0aG9zZSBwb2ludHMgaW4gb3JkZXIgdG8gZWZmZWNpZW50bHlcbiAqICAgICAgICAgIHJldXNlIHRob3NlIHBhcmFkaWdtcy5cbiAqL1xuLyoqXG4gKiBAY2xhc3MgUmVmZXJlbmNlU3RyaXBcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG4kLlJlZmVyZW5jZVN0cmlwID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG4gICAgdmFyIF90aGlzICAgICAgID0gdGhpcyxcbiAgICAgICAgdmlld2VyICAgICAgPSBvcHRpb25zLnZpZXdlcixcbiAgICAgICAgdmlld2VyU2l6ZSAgPSAkLmdldEVsZW1lbnRTaXplKCB2aWV3ZXIuZWxlbWVudCApLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgaTtcblxuICAgIC8vV2UgbWF5IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGlkIGlmIHRoZXkgZGlkIG5vdFxuICAgIC8vcHJvdmlkZSB0aGUgaWQgZm9yIHRoZSBleGlzdGluZyBlbGVtZW50XG4gICAgaWYgKCAhb3B0aW9ucy5pZCApIHtcbiAgICAgICAgb3B0aW9ucy5pZCAgICAgICAgICAgICAgPSAncmVmZXJlbmNlc3RyaXAtJyArICQubm93KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCAgICAgICAgICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiZGl2XCIgKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmlkICAgICAgICAgPSBvcHRpb25zLmlkO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lICA9ICdyZWZlcmVuY2VzdHJpcCc7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKCB0cnVlLCB7XG4gICAgICAgIHNpemVSYXRpbzogICQuREVGQVVMVF9TRVRUSU5HUy5yZWZlcmVuY2VTdHJpcFNpemVSYXRpbyxcbiAgICAgICAgcG9zaXRpb246ICAgJC5ERUZBVUxUX1NFVFRJTkdTLnJlZmVyZW5jZVN0cmlwUG9zaXRpb24sXG4gICAgICAgIHNjcm9sbDogICAgICQuREVGQVVMVF9TRVRUSU5HUy5yZWZlcmVuY2VTdHJpcFNjcm9sbCxcbiAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiAgJC5ERUZBVUxUX1NFVFRJTkdTLmNsaWNrVGltZVRocmVzaG9sZFxuICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgLy9yZXF1aXJlZCBvdmVycmlkZXNcbiAgICAgICAgZWxlbWVudDogICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICAvL1RoZXNlIG5lZWQgdG8gYmUgb3ZlcnJpZGRlbiB0byBwcmV2ZW50IHJlY3Vyc2lvbiBzaW5jZVxuICAgICAgICAvL3RoZSBuYXZpZ2F0b3IgaXMgYSB2aWV3ZXIgYW5kIGEgdmlld2VyIGhhcyBhIG5hdmlnYXRvclxuICAgICAgICBzaG93TmF2aWdhdG9yOiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgbW91c2VOYXZFbmFibGVkOiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNob3dOYXZpZ2F0aW9uQ29udHJvbDogIGZhbHNlLFxuICAgICAgICBzaG93U2VxdWVuY2VDb250cm9sOiAgICBmYWxzZVxuICAgIH0gKTtcblxuICAgICQuZXh0ZW5kKCB0aGlzLCBvcHRpb25zICk7XG4gICAgLy9Qcml2YXRlIHN0YXRlIHByb3BlcnRpZXNcbiAgICBUSElTW3RoaXMuaWRdID0ge1xuICAgICAgICBcImFuaW1hdGluZ1wiOiAgICAgICAgICAgZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpcy5taW5QaXhlbFJhdGlvID0gdGhpcy52aWV3ZXIubWluUGl4ZWxSYXRpbztcblxuICAgIHN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlO1xuICAgIHN0eWxlLm1hcmdpblRvcCAgICAgPSAnMHB4JztcbiAgICBzdHlsZS5tYXJnaW5SaWdodCAgID0gJzBweCc7XG4gICAgc3R5bGUubWFyZ2luQm90dG9tICA9ICcwcHgnO1xuICAgIHN0eWxlLm1hcmdpbkxlZnQgICAgPSAnMHB4JztcbiAgICBzdHlsZS5sZWZ0ICAgICAgICAgID0gJzBweCc7XG4gICAgc3R5bGUuYm90dG9tICAgICAgICA9ICcwcHgnO1xuICAgIHN0eWxlLmJvcmRlciAgICAgICAgPSAnMHB4JztcbiAgICBzdHlsZS5iYWNrZ3JvdW5kICAgID0gJyMwMDAnO1xuICAgIHN0eWxlLnBvc2l0aW9uICAgICAgPSAncmVsYXRpdmUnO1xuXG4gICAgJC5zZXRFbGVtZW50VG91Y2hBY3Rpb25Ob25lKCB0aGlzLmVsZW1lbnQgKTtcblxuICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIHRoaXMuZWxlbWVudCwgMC44ICk7XG5cbiAgICB0aGlzLnZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLmlubmVyVHJhY2tlciA9IG5ldyAkLk1vdXNlVHJhY2tlcigge1xuICAgICAgICBlbGVtZW50OiAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICBkcmFnSGFuZGxlcjogICAgJC5kZWxlZ2F0ZSggdGhpcywgb25TdHJpcERyYWcgKSxcbiAgICAgICAgc2Nyb2xsSGFuZGxlcjogICQuZGVsZWdhdGUoIHRoaXMsIG9uU3RyaXBTY3JvbGwgKSxcbiAgICAgICAgZW50ZXJIYW5kbGVyOiAgICQuZGVsZWdhdGUoIHRoaXMsIG9uU3RyaXBFbnRlciApLFxuICAgICAgICBleGl0SGFuZGxlcjogICAgJC5kZWxlZ2F0ZSggdGhpcywgb25TdHJpcEV4aXQgKSxcbiAgICAgICAga2V5RG93bkhhbmRsZXI6ICQuZGVsZWdhdGUoIHRoaXMsIG9uS2V5RG93biApLFxuICAgICAgICBrZXlIYW5kbGVyOiAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25LZXlQcmVzcyApXG4gICAgfSApO1xuXG4gICAgLy9Db250cm9scyB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3RyaXAgYW5kIHNldHMgdGhlXG4gICAgLy9hcHByb3ByaWF0ZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgaWYgKCBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0ICkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggID0gb3B0aW9ucy53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCArICdweCc7XG4gICAgICAgIHZpZXdlci5hZGRDb250cm9sKFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgeyBhbmNob3I6ICQuQ29udHJvbEFuY2hvci5CT1RUT01fTEVGVCB9XG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCBcImhvcml6b250YWxcIiA9PSBvcHRpb25zLnNjcm9sbCApIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IChcbiAgICAgICAgICAgICAgICB2aWV3ZXJTaXplLnggKlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2l6ZVJhdGlvICpcbiAgICAgICAgICAgICAgICB2aWV3ZXIudGlsZVNvdXJjZXMubGVuZ3RoXG4gICAgICAgICAgICApICsgKCAxMiAqIHZpZXdlci50aWxlU291cmNlcy5sZW5ndGggKSArICdweCc7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoXG4gICAgICAgICAgICAgICAgdmlld2VyU2l6ZS55ICpcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpemVSYXRpb1xuICAgICAgICAgICAgKSArICdweCc7XG5cbiAgICAgICAgICAgIHZpZXdlci5hZGRDb250cm9sKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB7IGFuY2hvcjogJC5Db250cm9sQW5jaG9yLkJPVFRPTV9MRUZUIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKFxuICAgICAgICAgICAgICAgIHZpZXdlclNpemUueSAqXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaXplUmF0aW8gKlxuICAgICAgICAgICAgICAgIHZpZXdlci50aWxlU291cmNlcy5sZW5ndGhcbiAgICAgICAgICAgICkgKyAoIDEyICogdmlld2VyLnRpbGVTb3VyY2VzLmxlbmd0aCApICsgJ3B4JztcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKFxuICAgICAgICAgICAgICAgIHZpZXdlclNpemUueCAqXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaXplUmF0aW9cbiAgICAgICAgICAgICkgKyAncHgnO1xuXG4gICAgICAgICAgICB2aWV3ZXIuYWRkQ29udHJvbChcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgeyBhbmNob3I6ICQuQ29udHJvbEFuY2hvci5UT1BfTEVGVCB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBhbmVsV2lkdGggPSAoIHZpZXdlclNpemUueCAqIHRoaXMuc2l6ZVJhdGlvICkgKyA4O1xuICAgIHRoaXMucGFuZWxIZWlnaHQgPSAoIHZpZXdlclNpemUueSAqIHRoaXMuc2l6ZVJhdGlvICkgKyA4O1xuICAgIHRoaXMucGFuZWxzID0gW107XG5cbiAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlKi9cbiAgICBmb3IgKCBpID0gMDsgaSA8IHZpZXdlci50aWxlU291cmNlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICBlbGVtZW50ID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoICdkaXYnICk7XG4gICAgICAgIGVsZW1lbnQuaWQgPSB0aGlzLmVsZW1lbnQuaWQgKyBcIi1cIiArIGk7XG5cbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCAgICAgICAgID0gX3RoaXMucGFuZWxXaWR0aCArICdweCc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ICAgICAgICA9IF90aGlzLnBhbmVsSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ICAgICAgID0gJ2lubGluZSc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZmxvYXQgICAgICAgICA9ICdsZWZ0JzsgLy9XZWJraXRcbiAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NGbG9hdCAgICAgID0gJ2xlZnQnOyAvL0ZpcmVmb3hcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zdHlsZUZsb2F0ICAgID0gJ2xlZnQnOyAvL0lFXG4gICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZyAgICAgICA9ICcycHgnO1xuICAgICAgICAkLnNldEVsZW1lbnRUb3VjaEFjdGlvbk5vbmUoIGVsZW1lbnQgKTtcblxuICAgICAgICBlbGVtZW50LmlubmVyVHJhY2tlciA9IG5ldyAkLk1vdXNlVHJhY2tlcigge1xuICAgICAgICAgICAgZWxlbWVudDogICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgICAgICBwcmVzc0hhbmRsZXI6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuZXZlbnRTb3VyY2UuZHJhZ2dpbmcgPSAkLm5vdygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGVhc2VIYW5kbGVyOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFja2VyID0gZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgPSB0cmFja2VyLmVsZW1lbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgICAgPSBOdW1iZXIoIGlkLnNwbGl0KCAnLScgKVsyXSApLFxuICAgICAgICAgICAgICAgICAgICBub3cgICAgID0gJC5ub3coKTtcblxuICAgICAgICAgICAgICAgIGlmICggZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lmluc2lkZUVsZW1lbnRSZWxlYXNlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgdHJhY2tlci5kcmFnZ2luZyAmJlxuICAgICAgICAgICAgICAgICAgICAgKCBub3cgLSB0cmFja2VyLmRyYWdnaW5nICkgPCB0cmFja2VyLmNsaWNrVGltZVRocmVzaG9sZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlci5kcmFnZ2luZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5nb1RvUGFnZSggcGFnZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggZWxlbWVudCApO1xuXG4gICAgICAgIGVsZW1lbnQuYWN0aXZlUGFuZWwgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnBhbmVscy5wdXNoKCBlbGVtZW50ICk7XG5cbiAgICB9XG4gICAgbG9hZFBhbmVscyggdGhpcywgdGhpcy5zY3JvbGwgPT0gJ3ZlcnRpY2FsJyA/IHZpZXdlclNpemUueSA6IHZpZXdlclNpemUueCwgMCApO1xuICAgIHRoaXMuc2V0Rm9jdXMoIDAgKTtcblxufTtcblxuJC5leHRlbmQoICQuUmVmZXJlbmNlU3RyaXAucHJvdG90eXBlLCAkLkV2ZW50U291cmNlLnByb3RvdHlwZSwgJC5WaWV3ZXIucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uUmVmZXJlbmNlU3RyaXAucHJvdG90eXBlICove1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgc2V0Rm9jdXM6IGZ1bmN0aW9uICggcGFnZSApIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgICAgICA9ICQuZ2V0RWxlbWVudCggdGhpcy5lbGVtZW50LmlkICsgJy0nICsgcGFnZSApLFxuICAgICAgICAgICAgdmlld2VyU2l6ZSAgID0gJC5nZXRFbGVtZW50U2l6ZSggdGhpcy52aWV3ZXIuY2FudmFzICksXG4gICAgICAgICAgICBzY3JvbGxXaWR0aCAgPSBOdW1iZXIoIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBOdW1iZXIoIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQucmVwbGFjZSggJ3B4JywgJycgKSApLFxuICAgICAgICAgICAgb2Zmc2V0TGVmdCAgID0gLU51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQucmVwbGFjZSggJ3B4JywgJycgKSApLFxuICAgICAgICAgICAgb2Zmc2V0VG9wICAgID0gLU51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgICAgICBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKCB0aGlzLmN1cnJlbnRTZWxlY3RlZCAhPT0gZWxlbWVudCApIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5jdXJyZW50U2VsZWN0ZWQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0ZWQuc3R5bGUuYmFja2dyb3VuZCA9ICcjMDAwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGVkID0gZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGVkLnN0eWxlLmJhY2tncm91bmQgPSAnIzk5OSc7XG5cbiAgICAgICAgICAgIGlmICggJ2hvcml6b250YWwnID09IHRoaXMuc2Nyb2xsICkge1xuICAgICAgICAgICAgICAgIC8vcmlnaHQgbGVmdFxuICAgICAgICAgICAgICAgIG9mZnNldCA9ICggTnVtYmVyKCBwYWdlICkgKSAqICggdGhpcy5wYW5lbFdpZHRoICsgMyApO1xuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0ID4gb2Zmc2V0TGVmdCArIHZpZXdlclNpemUueCAtIHRoaXMucGFuZWxXaWR0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4oIG9mZnNldCwgKCBzY3JvbGxXaWR0aCAtIHZpZXdlclNpemUueCApICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gLW9mZnNldCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueCwgLW9mZnNldCApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9mZnNldCA8IG9mZnNldExlZnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWF4KCAwLCBvZmZzZXQgLSB2aWV3ZXJTaXplLnggLyAyICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gLW9mZnNldCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueCwgLW9mZnNldCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKCBOdW1iZXIoIHBhZ2UgKSApICogKCB0aGlzLnBhbmVsSGVpZ2h0ICsgMyApO1xuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0ID4gb2Zmc2V0VG9wICsgdmlld2VyU2l6ZS55IC0gdGhpcy5wYW5lbEhlaWdodCApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4oIG9mZnNldCwgKCBzY3JvbGxIZWlnaHQgLSB2aWV3ZXJTaXplLnkgKSApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gLW9mZnNldCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueSwgLW9mZnNldCApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9mZnNldCA8IG9mZnNldFRvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoIDAsIG9mZnNldCAtIHZpZXdlclNpemUueSAvIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9IC1vZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLnksIC1vZmZzZXQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlO1xuICAgICAgICAgICAgb25TdHJpcEVudGVyLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMuaW5uZXJUcmFja2VyIH0gKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCBUSElTW3RoaXMuaWRdLmFuaW1hdGluZyApIHtcbiAgICAgICAgICAgICQuY29uc29sZS5sb2coICdpbWFnZSByZWZlcmVuY2Ugc3RyaXAgdXBkYXRlJyApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZXMgVmlld2VyLmRlc3Ryb3lcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSApO1xuXG5cblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvblN0cmlwRHJhZyggZXZlbnQgKSB7XG5cbiAgICB2YXIgb2Zmc2V0TGVmdCAgID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgIG9mZnNldFRvcCAgICA9IE51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgIHNjcm9sbFdpZHRoICA9IE51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoLnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0LnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgdmlld2VyU2l6ZSAgID0gJC5nZXRFbGVtZW50U2l6ZSggdGhpcy52aWV3ZXIuY2FudmFzICk7XG4gICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgaWYgKCB0aGlzLmVsZW1lbnQgKSB7XG4gICAgICAgIGlmICggJ2hvcml6b250YWwnID09IHRoaXMuc2Nyb2xsICkge1xuICAgICAgICAgICAgaWYgKCAtZXZlbnQuZGVsdGEueCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgLy9mb3J3YXJkXG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXRMZWZ0ID4gLSggc2Nyb2xsV2lkdGggLSB2aWV3ZXJTaXplLnggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAoIG9mZnNldExlZnQgKyAoIGV2ZW50LmRlbHRhLnggKiAyICkgKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueCwgb2Zmc2V0TGVmdCArICggZXZlbnQuZGVsdGEueCAqIDIgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC1ldmVudC5kZWx0YS54IDwgMCApIHtcbiAgICAgICAgICAgICAgICAvL3JldmVyc2VcbiAgICAgICAgICAgICAgICBpZiAoIG9mZnNldExlZnQgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9ICggb2Zmc2V0TGVmdCArICggZXZlbnQuZGVsdGEueCAqIDIgKSApICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgbG9hZFBhbmVscyggdGhpcywgdmlld2VyU2l6ZS54LCBvZmZzZXRMZWZ0ICsgKCBldmVudC5kZWx0YS54ICogMiApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCAtZXZlbnQuZGVsdGEueSA+IDAgKSB7XG4gICAgICAgICAgICAgICAgLy9mb3J3YXJkXG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXRUb3AgPiAtKCBzY3JvbGxIZWlnaHQgLSB2aWV3ZXJTaXplLnkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICggb2Zmc2V0VG9wICsgKCBldmVudC5kZWx0YS55ICogMiApICkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLnksIG9mZnNldFRvcCArICggZXZlbnQuZGVsdGEueSAqIDIgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC1ldmVudC5kZWx0YS55IDwgMCApIHtcbiAgICAgICAgICAgICAgICAvL3JldmVyc2VcbiAgICAgICAgICAgICAgICBpZiAoIG9mZnNldFRvcCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAoIG9mZnNldFRvcCArICggZXZlbnQuZGVsdGEueSAqIDIgKSApICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgbG9hZFBhbmVscyggdGhpcywgdmlld2VyU2l6ZS55LCBvZmZzZXRUb3AgKyAoIGV2ZW50LmRlbHRhLnkgKiAyICkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuXG59XG5cblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvblN0cmlwU2Nyb2xsKCBldmVudCApIHtcbiAgICB2YXIgb2Zmc2V0TGVmdCAgID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgIG9mZnNldFRvcCAgICA9IE51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgIHNjcm9sbFdpZHRoICA9IE51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoLnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0LnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgdmlld2VyU2l6ZSAgID0gJC5nZXRFbGVtZW50U2l6ZSggdGhpcy52aWV3ZXIuY2FudmFzICk7XG4gICAgaWYgKCB0aGlzLmVsZW1lbnQgKSB7XG4gICAgICAgIGlmICggJ2hvcml6b250YWwnID09IHRoaXMuc2Nyb2xsICkge1xuICAgICAgICAgICAgaWYgKCBldmVudC5zY3JvbGwgPiAwICkge1xuICAgICAgICAgICAgICAgIC8vZm9yd2FyZFxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0TGVmdCA+IC0oIHNjcm9sbFdpZHRoIC0gdmlld2VyU2l6ZS54ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gKCBvZmZzZXRMZWZ0IC0gKCBldmVudC5zY3JvbGwgKiA2MCApICkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLngsIG9mZnNldExlZnQgLSAoIGV2ZW50LnNjcm9sbCAqIDYwICkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBldmVudC5zY3JvbGwgPCAwICkge1xuICAgICAgICAgICAgICAgIC8vcmV2ZXJzZVxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0TGVmdCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gKCBvZmZzZXRMZWZ0IC0gKCBldmVudC5zY3JvbGwgKiA2MCApICkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLngsIG9mZnNldExlZnQgLSAoIGV2ZW50LnNjcm9sbCAqIDYwICkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIGV2ZW50LnNjcm9sbCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgLy9zY3JvbGwgdXBcbiAgICAgICAgICAgICAgICBpZiAoIG9mZnNldFRvcCA+IHZpZXdlclNpemUueSAtIHNjcm9sbEhlaWdodCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICggb2Zmc2V0VG9wICsgKCBldmVudC5zY3JvbGwgKiA2MCApICkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLnksIG9mZnNldFRvcCArICggZXZlbnQuc2Nyb2xsICogNjAgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50LnNjcm9sbCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgLy9zY3JvbGwgZG93bVxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0VG9wIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICggb2Zmc2V0VG9wICsgKCBldmVudC5zY3JvbGwgKiA2MCApICkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLnksIG9mZnNldFRvcCArICggZXZlbnQuc2Nyb2xsICogNjAgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2NhbmNlbHMgZXZlbnRcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuZnVuY3Rpb24gbG9hZFBhbmVscyggc3RyaXAsIHZpZXdlclNpemUsIHNjcm9sbCApIHtcbiAgICB2YXIgcGFuZWxTaXplLFxuICAgICAgICBhY3RpdmVQYW5lbHNTdGFydCxcbiAgICAgICAgYWN0aXZlUGFuZWxzRW5kLFxuICAgICAgICBtaW5pVmlld2VyLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgaSxcbiAgICAgICAgZWxlbWVudDtcbiAgICBpZiAoICdob3Jpem9udGFsJyA9PSBzdHJpcC5zY3JvbGwgKSB7XG4gICAgICAgIHBhbmVsU2l6ZSA9IHN0cmlwLnBhbmVsV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWxTaXplID0gc3RyaXAucGFuZWxIZWlnaHQ7XG4gICAgfVxuICAgIGFjdGl2ZVBhbmVsc1N0YXJ0ID0gTWF0aC5jZWlsKCB2aWV3ZXJTaXplIC8gcGFuZWxTaXplICkgKyA1O1xuICAgIGFjdGl2ZVBhbmVsc0VuZCA9IE1hdGguY2VpbCggKCBNYXRoLmFicyggc2Nyb2xsICkgKyB2aWV3ZXJTaXplICkgLyBwYW5lbFNpemUgKSArIDE7XG4gICAgYWN0aXZlUGFuZWxzU3RhcnQgPSBhY3RpdmVQYW5lbHNFbmQgLSBhY3RpdmVQYW5lbHNTdGFydDtcbiAgICBhY3RpdmVQYW5lbHNTdGFydCA9IGFjdGl2ZVBhbmVsc1N0YXJ0IDwgMCA/IDAgOiBhY3RpdmVQYW5lbHNTdGFydDtcblxuICAgIGZvciAoIGkgPSBhY3RpdmVQYW5lbHNTdGFydDsgaSA8IGFjdGl2ZVBhbmVsc0VuZCAmJiBpIDwgc3RyaXAucGFuZWxzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBlbGVtZW50ID0gc3RyaXAucGFuZWxzW2ldO1xuICAgICAgICBpZiAoICFlbGVtZW50LmFjdGl2ZVBhbmVsICkge1xuICAgICAgICAgICAgbWluaVZpZXdlciA9IG5ldyAkLlZpZXdlcigge1xuICAgICAgICAgICAgICAgIGlkOiAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQsXG4gICAgICAgICAgICAgICAgdGlsZVNvdXJjZXM6ICAgICAgICAgICAgW3N0cmlwLnZpZXdlci50aWxlU291cmNlc1tpXV0sXG4gICAgICAgICAgICAgICAgZWxlbWVudDogICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3JTaXplUmF0aW86ICAgICBzdHJpcC5zaXplUmF0aW8sXG4gICAgICAgICAgICAgICAgc2hvd05hdmlnYXRvcjogICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgbW91c2VOYXZFbmFibGVkOiAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd05hdmlnYXRpb25Db250cm9sOiAgZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1NlcXVlbmNlQ29udHJvbDogICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBibGVuZFRpbWU6ICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblRpbWU6ICAgICAgICAgIDBcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgbWluaVZpZXdlci5kaXNwbGF5UmVnaW9uICAgICAgICAgICA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG4gICAgICAgICAgICBtaW5pVmlld2VyLmRpc3BsYXlSZWdpb24uaWQgICAgICAgID0gZWxlbWVudC5pZCArICctZGlzcGxheXJlZ2lvbic7XG4gICAgICAgICAgICBtaW5pVmlld2VyLmRpc3BsYXlSZWdpb24uY2xhc3NOYW1lID0gJ2Rpc3BsYXlyZWdpb24nO1xuXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgICAgICAgID0gbWluaVZpZXdlci5kaXNwbGF5UmVnaW9uLnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gICAgICA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICBzdHlsZS50b3AgICAgICAgICAgID0gJzBweCc7XG4gICAgICAgICAgICBzdHlsZS5sZWZ0ICAgICAgICAgID0gJzBweCc7XG4gICAgICAgICAgICBzdHlsZS5mb250U2l6ZSAgICAgID0gJzBweCc7XG4gICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAgICAgID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBzdHlsZS5mbG9hdCAgICAgICAgID0gJ2xlZnQnOyAvL1dlYmtpdFxuICAgICAgICAgICAgc3R5bGUuY3NzRmxvYXQgICAgICA9ICdsZWZ0JzsgLy9GaXJlZm94XG4gICAgICAgICAgICBzdHlsZS5zdHlsZUZsb2F0ICAgID0gJ2xlZnQnOyAvL0lFXG4gICAgICAgICAgICBzdHlsZS56SW5kZXggICAgICAgID0gOTk5OTk5OTk5O1xuICAgICAgICAgICAgc3R5bGUuY3Vyc29yICAgICAgICA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIHN0eWxlLndpZHRoICAgICAgICAgPSAoIHN0cmlwLnBhbmVsV2lkdGggLSA0ICkgKyAncHgnO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ICAgICAgICA9ICggc3RyaXAucGFuZWxIZWlnaHQgLSA0ICkgKyAncHgnO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlzIHRoaXMgZm9yPyBGdXR1cmUga2V5Ym9hcmQgbmF2aWdhdGlvbiBzdXBwb3J0P1xuICAgICAgICAgICAgbWluaVZpZXdlci5kaXNwbGF5UmVnaW9uLmlubmVyVHJhY2tlciA9IG5ldyAkLk1vdXNlVHJhY2tlcigge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG1pbmlWaWV3ZXIuZGlzcGxheVJlZ2lvbixcbiAgICAgICAgICAgICAgICBzdGFydERpc2FibGVkOiB0cnVlXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdkaXYnIClbMF0uYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgbWluaVZpZXdlci5kaXNwbGF5UmVnaW9uXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBlbGVtZW50LmFjdGl2ZVBhbmVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvblN0cmlwRW50ZXIoIGV2ZW50ICkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZXZlbnRTb3VyY2UuZWxlbWVudDtcblxuICAgIC8vJC5zZXRFbGVtZW50T3BhY2l0eShlbGVtZW50LCAwLjgpO1xuXG4gICAgLy9lbGVtZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgIzU1NSc7XG4gICAgLy9lbGVtZW50LnN0eWxlLmJhY2tncm91bmQgPSAnIzAwMCc7XG5cbiAgICBpZiAoICdob3Jpem9udGFsJyA9PSB0aGlzLnNjcm9sbCApIHtcblxuICAgICAgICAvL2VsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IFwiMHB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubWFyZ2luQm90dG9tID0gXCIwcHhcIjtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMHB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG5cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uU3RyaXBFeGl0KCBldmVudCApIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmV2ZW50U291cmNlLmVsZW1lbnQ7XG5cbiAgICBpZiAoICdob3Jpem9udGFsJyA9PSB0aGlzLnNjcm9sbCApIHtcblxuICAgICAgICAvL2VsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IFwiMTBweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlLm1hcmdpbkJvdHRvbSA9IFwiLVwiICsgKCAkLmdldEVsZW1lbnRTaXplKCBlbGVtZW50ICkueSAvIDIgKSArIFwicHhcIjtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMTBweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgPSBcIi1cIiArICggJC5nZXRFbGVtZW50U2l6ZSggZWxlbWVudCApLnggLyAyICkgKyBcInB4XCI7XG5cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uS2V5RG93biggZXZlbnQgKSB7XG4gICAgLy9jb25zb2xlLmxvZyggZXZlbnQua2V5Q29kZSApO1xuXG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgIWV2ZW50LmN0cmwgJiYgIWV2ZW50LmFsdCAmJiAhZXZlbnQubWV0YSApIHtcbiAgICAgICAgc3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcbiAgICAgICAgICAgIGNhc2UgMzg6IC8vdXAgYXJyb3dcbiAgICAgICAgICAgICAgICBvblN0cmlwU2Nyb2xsLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciwgcG9zaXRpb246IG51bGwsIHNjcm9sbDogMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgNDA6IC8vZG93biBhcnJvd1xuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAtMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMzc6IC8vbGVmdCBhcnJvd1xuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAtMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMzk6IC8vcmlnaHQgYXJyb3dcbiAgICAgICAgICAgICAgICBvblN0cmlwU2Nyb2xsLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciwgcG9zaXRpb246IG51bGwsIHNjcm9sbDogMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ25hdmlnYXRvciBrZXljb2RlICVzJywgZXZlbnQua2V5Q29kZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uS2V5UHJlc3MoIGV2ZW50ICkge1xuICAgIC8vY29uc29sZS5sb2coIGV2ZW50LmtleUNvZGUgKTtcblxuICAgIGlmICggIWV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uICYmICFldmVudC5jdHJsICYmICFldmVudC5hbHQgJiYgIWV2ZW50Lm1ldGEgKSB7XG4gICAgICAgIHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG4gICAgICAgICAgICBjYXNlIDYxOiAvLz18K1xuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAxLCBzaGlmdDogbnVsbCB9ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSA0NTogLy8tfF9cbiAgICAgICAgICAgICAgICBvblN0cmlwU2Nyb2xsLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciwgcG9zaXRpb246IG51bGwsIHNjcm9sbDogLTEsIHNoaWZ0OiBudWxsIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDQ4OiAvLzB8KVxuICAgICAgICAgICAgY2FzZSAxMTk6IC8vd1xuICAgICAgICAgICAgY2FzZSA4NzogLy9XXG4gICAgICAgICAgICAgICAgb25TdHJpcFNjcm9sbC5jYWxsKCB0aGlzLCB7IGV2ZW50U291cmNlOiB0aGlzLnRyYWNrZXIsIHBvc2l0aW9uOiBudWxsLCBzY3JvbGw6IDEsIHNoaWZ0OiBudWxsIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDExNTogLy9zXG4gICAgICAgICAgICBjYXNlIDgzOiAvL1NcbiAgICAgICAgICAgICAgICBvblN0cmlwU2Nyb2xsLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciwgcG9zaXRpb246IG51bGwsIHNjcm9sbDogLTEsIHNoaWZ0OiBudWxsIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDk3OiAvL2FcbiAgICAgICAgICAgICAgICBvblN0cmlwU2Nyb2xsLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciwgcG9zaXRpb246IG51bGwsIHNjcm9sbDogLTEsIHNoaWZ0OiBudWxsIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDEwMDogLy9kXG4gICAgICAgICAgICAgICAgb25TdHJpcFNjcm9sbC5jYWxsKCB0aGlzLCB7IGV2ZW50U291cmNlOiB0aGlzLnRyYWNrZXIsIHBvc2l0aW9uOiBudWxsLCBzY3JvbGw6IDEsIHNoaWZ0OiBudWxsIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coICduYXZpZ2F0b3Iga2V5Y29kZSAlcycsIGV2ZW50LmtleUNvZGUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuXG5cbn0gKCBPcGVuU2VhZHJhZ29uICkgKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBEaXNwbGF5UmVjdFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgRGlzcGxheVJlY3RcbiAqIEBjbGFzc2Rlc2MgQSBkaXNwbGF5IHJlY3RhbmdsZSBpcyB2ZXJ5IHNpbWlsYXIgdG8ge0BsaW5rIE9wZW5TZWFkcmFnb24uUmVjdH0gYnV0IGFkZHMgdHdvXG4gKiBmaWVsZHMsICdtaW5MZXZlbCcgYW5kICdtYXhMZXZlbCcgd2hpY2ggZGVub3RlIHRoZSBzdXBwb3J0ZWQgem9vbSBsZXZlbHNcbiAqIGZvciB0aGlzIHJlY3RhbmdsZS5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5SZWN0XG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgdmVjdG9yIGNvbXBvbmVudCAneCcuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdmVjdG9yIGNvbXBvbmVudCAneScuXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHZlY3RvciBjb21wb25lbnQgJ2hlaWdodCcuXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSB2ZWN0b3IgY29tcG9uZW50ICd3aWR0aCcuXG4gKiBAcGFyYW0ge051bWJlcn0gbWluTGV2ZWwgVGhlIGxvd2VzdCB6b29tIGxldmVsIHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMZXZlbCBUaGUgaGlnaGVzdCB6b29tIGxldmVsIHN1cHBvcnRlZC5cbiAqL1xuJC5EaXNwbGF5UmVjdCA9IGZ1bmN0aW9uKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW5MZXZlbCwgbWF4TGV2ZWwgKSB7XG4gICAgJC5SZWN0LmFwcGx5KCB0aGlzLCBbIHgsIHksIHdpZHRoLCBoZWlnaHQgXSApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VzdCB6b29tIGxldmVsIHN1cHBvcnRlZC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbkxldmVsXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uRGlzcGxheVJlY3QjXG4gICAgICovXG4gICAgdGhpcy5taW5MZXZlbCA9IG1pbkxldmVsO1xuICAgIC8qKlxuICAgICAqIFRoZSBoaWdoZXN0IHpvb20gbGV2ZWwgc3VwcG9ydGVkLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4TGV2ZWxcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5EaXNwbGF5UmVjdCNcbiAgICAgKi9cbiAgICB0aGlzLm1heExldmVsID0gbWF4TGV2ZWw7XG59O1xuXG4kLmV4dGVuZCggJC5EaXNwbGF5UmVjdC5wcm90b3R5cGUsICQuUmVjdC5wcm90b3R5cGUgKTtcblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBTcHJpbmdcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogQGNsYXNzIFNwcmluZ1xuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU3ByaW5nIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zcHJpbmdTdGlmZm5lc3MgLSBTcHJpbmcgc3RpZmZuZXNzLiBNdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICogVGhlIGNsb3NlciB0byB6ZXJvLCB0aGUgY2xvc2VyIHRvIGxpbmVhciBhbmltYXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hbmltYXRpb25UaW1lIC0gQW5pbWF0aW9uIGR1cmF0aW9uIHBlciBzcHJpbmcsIGluIHNlY29uZHMuXG4gKiBNdXN0IGJlIHplcm8gb3IgZ3JlYXRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbml0aWFsPTBdIC0gSW5pdGlhbCB2YWx1ZSBvZiBzcHJpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmV4cG9uZW50aWFsPWZhbHNlXSAtIFdoZXRoZXIgdGhpcyBzcHJpbmcgcmVwcmVzZW50c1xuICogYW4gZXhwb25lbnRpYWwgc2NhbGUgKHN1Y2ggYXMgem9vbSkgYW5kIHNob3VsZCBiZSBhbmltYXRlZCBhY2NvcmRpbmdseS4gTm90ZSB0aGF0XG4gKiBleHBvbmVudGlhbCBzcHJpbmdzIG11c3QgaGF2ZSBub24temVybyB2YWx1ZXMuXG4gKi9cbiQuU3ByaW5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBpZiggdHlwZW9mKCBvcHRpb25zICkgIT0gJ29iamVjdCcgKXtcbiAgICAgICAgLy9hbGxvd3MgYmFja3dhcmQgY29tcGF0aWJsZSB1c2Ugb2YgKCBpbml0aWFsVmFsdWUsIGNvbmZpZyApIGFzXG4gICAgICAgIC8vY29uc3RydWN0b3IgcGFyYW1ldGVyc1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbDogYXJncy5sZW5ndGggJiYgdHlwZW9mICggYXJnc1sgMCBdICkgPT0gXCJudW1iZXJcIiA/XG4gICAgICAgICAgICAgICAgYXJnc1sgMCBdIDpcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNwcmluZyBzdGlmZm5lc3MuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNwcmluZ1N0aWZmbmVzc1xuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uU3ByaW5nI1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzcHJpbmdTdGlmZm5lc3M6IGFyZ3MubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgYXJnc1sgMSBdLnNwcmluZ1N0aWZmbmVzcyA6XG4gICAgICAgICAgICAgICAgNS4wLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbmltYXRpb24gZHVyYXRpb24gcGVyIHNwcmluZy5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYW5pbWF0aW9uVGltZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uU3ByaW5nI1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbmltYXRpb25UaW1lOiBhcmdzLmxlbmd0aCA+IDEgP1xuICAgICAgICAgICAgICAgIGFyZ3NbIDEgXS5hbmltYXRpb25UaW1lIDpcbiAgICAgICAgICAgICAgICAxLjVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAkLmNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBvcHRpb25zLnNwcmluZ1N0aWZmbmVzcyA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLnNwcmluZ1N0aWZmbmVzcyAhPT0gMCxcbiAgICAgICAgXCJbT3BlblNlYWRyYWdvbi5TcHJpbmddIG9wdGlvbnMuc3ByaW5nU3RpZmZuZXNzIG11c3QgYmUgYSBub24temVybyBudW1iZXJcIik7XG5cbiAgICAkLmNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBvcHRpb25zLmFuaW1hdGlvblRpbWUgPT09IFwibnVtYmVyXCIgJiYgb3B0aW9ucy5hbmltYXRpb25UaW1lID49IDAsXG4gICAgICAgIFwiW09wZW5TZWFkcmFnb24uU3ByaW5nXSBvcHRpb25zLmFuaW1hdGlvblRpbWUgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMFwiKTtcblxuICAgIGlmIChvcHRpb25zLmV4cG9uZW50aWFsKSB7XG4gICAgICAgIHRoaXMuX2V4cG9uZW50aWFsID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuZXhwb25lbnRpYWw7XG4gICAgfVxuXG4gICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBjdXJyZW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uU3ByaW5nI1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aW1lXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50ID0ge1xuICAgICAgICB2YWx1ZTogdHlwZW9mICggdGhpcy5pbml0aWFsICkgPT0gXCJudW1iZXJcIiA/XG4gICAgICAgICAgICB0aGlzLmluaXRpYWwgOlxuICAgICAgICAgICAgKHRoaXMuX2V4cG9uZW50aWFsID8gMCA6IDEpLFxuICAgICAgICB0aW1lOiAgJC5ub3coKSAvLyBhbHdheXMgd29yayBpbiBtaWxsaXNlY29uZHNcbiAgICB9O1xuXG4gICAgJC5jb25zb2xlLmFzc2VydCghdGhpcy5fZXhwb25lbnRpYWwgfHwgdGhpcy5jdXJyZW50LnZhbHVlICE9PSAwLFxuICAgICAgICBcIltPcGVuU2VhZHJhZ29uLlNwcmluZ10gdmFsdWUgbXVzdCBiZSBub24temVybyBmb3IgZXhwb25lbnRpYWwgc3ByaW5nc1wiKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gc3RhcnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5TcHJpbmcjXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50LnZhbHVlLFxuICAgICAgICB0aW1lOiAgdGhpcy5jdXJyZW50LnRpbWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5TcHJpbmcjXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHtcbiAgICAgICAgdmFsdWU6IHRoaXMuY3VycmVudC52YWx1ZSxcbiAgICAgICAgdGltZTogIHRoaXMuY3VycmVudC50aW1lXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9leHBvbmVudGlhbCkge1xuICAgICAgICB0aGlzLnN0YXJ0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuc3RhcnQudmFsdWUpO1xuICAgICAgICB0aGlzLnRhcmdldC5fbG9nVmFsdWUgPSBNYXRoLmxvZyh0aGlzLnRhcmdldC52YWx1ZSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5fbG9nVmFsdWUgPSBNYXRoLmxvZyh0aGlzLmN1cnJlbnQudmFsdWUpO1xuICAgIH1cbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5TcHJpbmcucHJvdG90eXBlICovXG4kLlNwcmluZy5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0XG4gICAgICovXG4gICAgcmVzZXRUbzogZnVuY3Rpb24oIHRhcmdldCApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCghdGhpcy5fZXhwb25lbnRpYWwgfHwgdGFyZ2V0ICE9PSAwLFxuICAgICAgICAgICAgXCJbT3BlblNlYWRyYWdvbi5TcHJpbmcucmVzZXRUb10gdGFyZ2V0IG11c3QgYmUgbm9uLXplcm8gZm9yIGV4cG9uZW50aWFsIHNwcmluZ3NcIik7XG5cbiAgICAgICAgdGhpcy5zdGFydC52YWx1ZSA9IHRoaXMudGFyZ2V0LnZhbHVlID0gdGhpcy5jdXJyZW50LnZhbHVlID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnN0YXJ0LnRpbWUgPSB0aGlzLnRhcmdldC50aW1lID0gdGhpcy5jdXJyZW50LnRpbWUgPSAkLm5vdygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9leHBvbmVudGlhbCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydC5fbG9nVmFsdWUgPSBNYXRoLmxvZyh0aGlzLnN0YXJ0LnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5fbG9nVmFsdWUgPSBNYXRoLmxvZyh0aGlzLmN1cnJlbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRcbiAgICAgKi9cbiAgICBzcHJpbmdUbzogZnVuY3Rpb24oIHRhcmdldCApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCghdGhpcy5fZXhwb25lbnRpYWwgfHwgdGFyZ2V0ICE9PSAwLFxuICAgICAgICAgICAgXCJbT3BlblNlYWRyYWdvbi5TcHJpbmcuc3ByaW5nVG9dIHRhcmdldCBtdXN0IGJlIG5vbi16ZXJvIGZvciBleHBvbmVudGlhbCBzcHJpbmdzXCIpO1xuXG4gICAgICAgIHRoaXMuc3RhcnQudmFsdWUgID0gdGhpcy5jdXJyZW50LnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0LnRpbWUgICA9IHRoaXMuY3VycmVudC50aW1lO1xuICAgICAgICB0aGlzLnRhcmdldC52YWx1ZSA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXQudGltZSAgPSB0aGlzLnN0YXJ0LnRpbWUgKyAxMDAwICogdGhpcy5hbmltYXRpb25UaW1lO1xuXG4gICAgICAgIGlmICh0aGlzLl9leHBvbmVudGlhbCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydC5fbG9nVmFsdWUgPSBNYXRoLmxvZyh0aGlzLnN0YXJ0LnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICAgKi9cbiAgICBzaGlmdEJ5OiBmdW5jdGlvbiggZGVsdGEgKSB7XG4gICAgICAgIHRoaXMuc3RhcnQudmFsdWUgICs9IGRlbHRhO1xuICAgICAgICB0aGlzLnRhcmdldC52YWx1ZSArPSBkZWx0YTtcblxuICAgICAgICBpZiAodGhpcy5fZXhwb25lbnRpYWwpIHtcbiAgICAgICAgICAgICQuY29uc29sZS5hc3NlcnQodGhpcy50YXJnZXQudmFsdWUgIT09IDAgJiYgdGhpcy5zdGFydC52YWx1ZSAhPT0gMCxcbiAgICAgICAgICAgICAgICBcIltPcGVuU2VhZHJhZ29uLlNwcmluZy5zaGlmdEJ5XSBzcHJpbmcgdmFsdWUgbXVzdCBiZSBub24temVybyBmb3IgZXhwb25lbnRpYWwgc3ByaW5nc1wiKTtcblxuICAgICAgICAgICAgdGhpcy5zdGFydC5fbG9nVmFsdWUgPSBNYXRoLmxvZyh0aGlzLnN0YXJ0LnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRFeHBvbmVudGlhbDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZXhwb25lbnRpYWwgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5fZXhwb25lbnRpYWwpIHtcbiAgICAgICAgICAgICQuY29uc29sZS5hc3NlcnQodGhpcy5jdXJyZW50LnZhbHVlICE9PSAwICYmIHRoaXMudGFyZ2V0LnZhbHVlICE9PSAwICYmIHRoaXMuc3RhcnQudmFsdWUgIT09IDAsXG4gICAgICAgICAgICAgICAgXCJbT3BlblNlYWRyYWdvbi5TcHJpbmcuc2V0RXhwb25lbnRpYWxdIHNwcmluZyB2YWx1ZSBtdXN0IGJlIG5vbi16ZXJvIGZvciBleHBvbmVudGlhbCBzcHJpbmdzXCIpO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuc3RhcnQudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuX2xvZ1ZhbHVlID0gTWF0aC5sb2codGhpcy50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuY3VycmVudC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LnRpbWUgID0gJC5ub3coKTtcblxuICAgICAgICB2YXIgc3RhcnRWYWx1ZSwgdGFyZ2V0VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9leHBvbmVudGlhbCkge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZSA9IHRoaXMuc3RhcnQuX2xvZ1ZhbHVlO1xuICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSB0aGlzLnRhcmdldC5fbG9nVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlID0gdGhpcy5zdGFydC52YWx1ZTtcbiAgICAgICAgICAgIHRhcmdldFZhbHVlID0gdGhpcy50YXJnZXQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gKHRoaXMuY3VycmVudC50aW1lID49IHRoaXMudGFyZ2V0LnRpbWUpID9cbiAgICAgICAgICAgIHRhcmdldFZhbHVlIDpcbiAgICAgICAgICAgIHN0YXJ0VmFsdWUgK1xuICAgICAgICAgICAgICAgICggdGFyZ2V0VmFsdWUgLSBzdGFydFZhbHVlICkgKlxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpbmdTdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgICAgICggdGhpcy5jdXJyZW50LnRpbWUgLSB0aGlzLnN0YXJ0LnRpbWUgKSAvXG4gICAgICAgICAgICAgICAgICAgICggdGhpcy50YXJnZXQudGltZSAgLSB0aGlzLnN0YXJ0LnRpbWUgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4cG9uZW50aWFsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQudmFsdWUgPSBNYXRoLmV4cChjdXJyZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc3ByaW5nIGlzIGF0IHRoZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhdCB0YXJnZXQgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzQXRUYXJnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQudmFsdWUgPT09IHRoaXMudGFyZ2V0LnZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKCBzdGlmZm5lc3MsIHggKSB7XG4gICAgcmV0dXJuICggMS4wIC0gTWF0aC5leHAoIHN0aWZmbmVzcyAqIC14ICkgKSAvXG4gICAgICAgICggMS4wIC0gTWF0aC5leHAoIC1zdGlmZm5lc3MgKSApO1xufVxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIEltYWdlTG9hZGVyXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLy8gcHJpdmF0ZSBjbGFzc1xuZnVuY3Rpb24gSW1hZ2VKb2IgKCBvcHRpb25zICkge1xuXG4gICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIHtcbiAgICAgICAgdGltZW91dDogICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy50aW1lb3V0LFxuICAgICAgICBqb2JJZDogICAgICAgICAgbnVsbFxuICAgIH0sIG9wdGlvbnMgKTtcblxuICAgIC8qKlxuICAgICAqIEltYWdlIG9iamVjdCB3aGljaCB3aWxsIGNvbnRhaW4gZG93bmxvYWRlZCBpbWFnZS5cbiAgICAgKiBAbWVtYmVyIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5JbWFnZUpvYiNcbiAgICAgKi9cbiAgICB0aGlzLmltYWdlID0gbnVsbDtcbn1cblxuSW1hZ2VKb2IucHJvdG90eXBlID0ge1xuICAgIGVycm9yTXNnOiBudWxsLFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW5Qb2xpY3kgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW5Qb2xpY3k7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBfdGhpcy5maW5pc2goIHRydWUgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbWFnZS5vbmFib3J0ID0gdGhpcy5pbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIF90aGlzLmVycm9yTXNnID0gXCJJbWFnZSBsb2FkIGFib3J0ZWRcIjtcbiAgICAgICAgICAgIF90aGlzLmZpbmlzaCggZmFsc2UgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmpvYklkID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBfdGhpcy5lcnJvck1zZyA9IFwiSW1hZ2UgbG9hZCBleGNlZWRlZCB0aW1lb3V0XCI7XG4gICAgICAgICAgICBfdGhpcy5maW5pc2goIGZhbHNlICk7XG4gICAgICAgIH0sIHRoaXMudGltZW91dCk7XG5cbiAgICAgICAgdGhpcy5pbWFnZS5zcmMgPSB0aGlzLnNyYztcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiggc3VjY2Vzc2Z1bCApIHtcbiAgICAgICAgdGhpcy5pbWFnZS5vbmxvYWQgPSB0aGlzLmltYWdlLm9uZXJyb3IgPSB0aGlzLmltYWdlLm9uYWJvcnQgPSBudWxsO1xuICAgICAgICBpZiAoIXN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLmpvYklkICkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCggdGhpcy5qb2JJZCApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayggdGhpcyApO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBAY2xhc3MgSW1hZ2VMb2FkZXJcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAY2xhc3NkZXNjIEhhbmRsZXMgZG93bmxvYWRpbmcgb2YgYSBzZXQgb2YgaW1hZ2VzIHVzaW5nIGFzeW5jaHJvbm91cyBxdWV1ZSBwYXR0ZXJuLlxuICogWW91IGdlbmVyYWxseSB3b24ndCBoYXZlIHRvIGludGVyYWN0IHdpdGggdGhlIEltYWdlTG9hZGVyIGRpcmVjdGx5LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGlzIEltYWdlTG9hZGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmpvYkxpbWl0XSAtIFRoZSBudW1iZXIgb2YgY29uY3VycmVudCBpbWFnZSByZXF1ZXN0cy4gU2VlIGltYWdlTG9hZGVyTGltaXQgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gKi9cbiQuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICQuZXh0ZW5kKCB0cnVlLCB0aGlzLCB7XG4gICAgICAgIGpvYkxpbWl0OiAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuaW1hZ2VMb2FkZXJMaW1pdCxcbiAgICAgICAgam9iUXVldWU6ICAgICAgIFtdLFxuICAgICAgICBqb2JzSW5Qcm9ncmVzczogMFxuICAgIH0sIG9wdGlvbnMgKTtcblxufTtcblxuLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLkltYWdlTG9hZGVyLnByb3RvdHlwZSAqL1xuJC5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gdW5sb2FkZWQgaW1hZ2UgdG8gdGhlIGxvYWRlciBxdWV1ZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyAtIFVSTCBvZiBpbWFnZSB0byBkb3dubG9hZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3Jvc3NPcmlnaW5Qb2xpY3kgLSBDT1JTIHBvbGljeSB0byB1c2UgZm9yIGRvd25sb2Fkc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGVkIG9uY2UgaW1hZ2UgaGFzIGJlZW4gZG93bmxvYWRlZC5cbiAgICAgKi9cbiAgICBhZGRKb2I6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgY29tcGxldGUgPSBmdW5jdGlvbiggam9iICkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlSm9iKCBfdGhpcywgam9iLCBvcHRpb25zLmNhbGxiYWNrICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgam9iT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBzcmM6IG9wdGlvbnMuc3JjLFxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luUG9saWN5OiBvcHRpb25zLmNyb3NzT3JpZ2luUG9saWN5LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgICAgICAgICAgICBhYm9ydDogb3B0aW9ucy5hYm9ydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld0pvYiA9IG5ldyBJbWFnZUpvYiggam9iT3B0aW9ucyApO1xuXG4gICAgICAgIGlmICggIXRoaXMuam9iTGltaXQgfHwgdGhpcy5qb2JzSW5Qcm9ncmVzcyA8IHRoaXMuam9iTGltaXQgKSB7XG4gICAgICAgICAgICBuZXdKb2Iuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuam9ic0luUHJvZ3Jlc3MrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuam9iUXVldWUucHVzaCggbmV3Sm9iICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYW55IHVuc3RhcnRlZCBpbWFnZSBsb2FkaW5nIGpvYnMgZnJvbSB0aGUgcXVldWUuXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmpvYlF1ZXVlLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGpvYiA9IHRoaXMuam9iUXVldWVbaV07XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBqb2IuYWJvcnQgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgICAgICAgICBqb2IuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuam9iUXVldWUgPSBbXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBJbWFnZUpvYiBvbmNlIGNvbXBsZXRlZC5cbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gbG9hZGVyIC0gSW1hZ2VMb2FkZXIgdXNlZCB0byBzdGFydCBqb2IuXG4gKiBAcGFyYW0gam9iIC0gVGhlIEltYWdlSm9iIHRoYXQgaGFzIGNvbXBsZXRlZC5cbiAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxlZCBvbmNlIGNsZWFudXAgaXMgZmluaXNoZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlSm9iKCBsb2FkZXIsIGpvYiwgY2FsbGJhY2sgKSB7XG4gICAgdmFyIG5leHRKb2I7XG5cbiAgICBsb2FkZXIuam9ic0luUHJvZ3Jlc3MtLTtcblxuICAgIGlmICggKCFsb2FkZXIuam9iTGltaXQgfHwgbG9hZGVyLmpvYnNJblByb2dyZXNzIDwgbG9hZGVyLmpvYkxpbWl0KSAmJiBsb2FkZXIuam9iUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXh0Sm9iID0gbG9hZGVyLmpvYlF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIG5leHRKb2Iuc3RhcnQoKTtcbiAgICAgICAgbG9hZGVyLmpvYnNJblByb2dyZXNzKys7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soIGpvYi5pbWFnZSwgam9iLmVycm9yTXNnICk7XG59XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gVGlsZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgVGlsZVxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgem9vbSBsZXZlbCB0aGlzIHRpbGUgYmVsb25ncyB0by5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB2ZWN0b3IgY29tcG9uZW50ICd4Jy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB2ZWN0b3IgY29tcG9uZW50ICd5Jy5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gYm91bmRzIFdoZXJlIHRoaXMgdGlsZSBmaXRzLCBpbiBub3JtYWxpemVkXG4gKiAgICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtCb29sZWFufSBleGlzdHMgSXMgdGhpcyB0aWxlIGEgcGFydCBvZiBhIHNwYXJzZSBpbWFnZT8gKCBBbHNvIGhhc1xuICogICAgICB0aGlzIHRpbGUgZmFpbGVkIHRvIGxvYWQ/IClcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGlzIHRpbGUncyBpbWFnZS5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MkQgVGhlIGNvbnRleHQyRCBvZiB0aGlzIHRpbGUgaWYgaXRcbiAqIGlzIHByb3ZpZGVkIGRpcmVjdGx5IGJ5IHRoZSB0aWxlIHNvdXJjZS5cbiAqL1xuJC5UaWxlID0gZnVuY3Rpb24obGV2ZWwsIHgsIHksIGJvdW5kcywgZXhpc3RzLCB1cmwsIGNvbnRleHQyRCkge1xuICAgIC8qKlxuICAgICAqIFRoZSB6b29tIGxldmVsIHRoaXMgdGlsZSBiZWxvbmdzIHRvLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMubGV2ZWwgICA9IGxldmVsO1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZWN0b3IgY29tcG9uZW50ICd4Jy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHhcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMueCAgICAgICA9IHg7XG4gICAgLyoqXG4gICAgICogVGhlIHZlY3RvciBjb21wb25lbnQgJ3knLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0geVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy55ICAgICAgID0geTtcbiAgICAvKipcbiAgICAgKiBXaGVyZSB0aGlzIHRpbGUgZml0cywgaW4gbm9ybWFsaXplZCBjb29yZGluYXRlc1xuICAgICAqIEBtZW1iZXIge09wZW5TZWFkcmFnb24uUmVjdH0gYm91bmRzXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kcyAgPSBib3VuZHM7XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyB0aWxlIGEgcGFydCBvZiBhIHNwYXJzZSBpbWFnZT8gQWxzbyBoYXMgdGhpcyB0aWxlIGZhaWxlZCB0byBsb2FkP1xuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGV4aXN0c1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5leGlzdHMgID0gZXhpc3RzO1xuICAgIC8qKlxuICAgICAqIFRoZSBVUkwgb2YgdGhpcyB0aWxlJ3MgaW1hZ2UuXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSB1cmxcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMudXJsICAgICA9IHVybDtcbiAgICAvKipcbiAgICAgKiBUaGUgY29udGV4dDJEIG9mIHRoaXMgdGlsZSBpZiBpdCBpcyBwcm92aWRlZCBkaXJlY3RseSBieSB0aGUgdGlsZSBzb3VyY2UuXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MkRcbiAgICAgKiBAbWVtYmVyT2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMuY29udGV4dDJEID0gY29udGV4dDJEO1xuICAgIC8qKlxuICAgICAqIElzIHRoaXMgdGlsZSBsb2FkZWQ/XG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbG9hZGVkXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZCAgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIHRpbGUgbG9hZGluZz9cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBsb2FkaW5nXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBIVE1MIGRpdiBlbGVtZW50IGZvciB0aGlzIHRpbGVcbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnQgICAgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBIVE1MIGltZyBlbGVtZW50IGZvciB0aGlzIHRpbGUuXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gaW1nRWxlbWVudFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5pbWdFbGVtZW50ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgSW1hZ2Ugb2JqZWN0IGZvciB0aGlzIHRpbGUuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBpbWFnZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5pbWFnZSAgICAgID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbGlhcyBvZiB0aGlzLmVsZW1lbnQuc3R5bGUuXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBzdHlsZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5zdHlsZSAgICAgID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGlzIHRpbGUncyBwb3NpdGlvbiBvbiBzY3JlZW4sIGluIHBpeGVscy5cbiAgICAgKiBAbWVtYmVyIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvblxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiAgID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGlzIHRpbGUncyBzaXplIG9uIHNjcmVlbiwgaW4gcGl4ZWxzLlxuICAgICAqIEBtZW1iZXIge09wZW5TZWFkcmFnb24uUG9pbnR9IHNpemVcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMuc2l6ZSAgICAgICA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0IHRpbWUgb2YgdGhpcyB0aWxlJ3MgYmxlbmRpbmcuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBibGVuZFN0YXJ0XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kU3RhcnQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IG9wYWNpdHkgdGhpcyB0aWxlIHNob3VsZCBiZS5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG9wYWNpdHlcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMub3BhY2l0eSAgICA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIG9mIHRoaXMgdGlsZSB0byB0aGUgdmlld3BvcnQgY2VudGVyLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gZGlzdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMuZGlzdGFuY2UgICA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIHZpc2liaWxpdHkgc2NvcmUgb2YgdGhpcyB0aWxlLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gdmlzaWJpbGl0eVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy52aXNpYmlsaXR5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyB0aWxlIGlzIGN1cnJlbnRseSBiZWluZyBkcmF3bi5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBiZWluZ0RyYXduXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmJlaW5nRHJhd24gICAgID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGltZXN0YW1wIHRoZSB0aWxlIHdhcyBsYXN0IHRvdWNoZWQuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBsYXN0VG91Y2hUaW1lXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RUb3VjaFRpbWUgID0gMDtcbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5UaWxlLnByb3RvdHlwZSAqL1xuJC5UaWxlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGlsZXMgbGV2ZWwgYW5kICh4LHkpXG4gICAgICogY29tcG9uZW50cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWwgKyBcIi9cIiArIHRoaXMueCArIFwiX1wiICsgdGhpcy55O1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX2hhc1RyYW5zcGFyZW5jeUNoYW5uZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNvbnRleHQyRCB8fCB0aGlzLnVybC5tYXRjaCgnLnBuZycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB0aWxlIGluIGFuIGh0bWwgY29udGFpbmVyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgZHJhd0hUTUw6IGZ1bmN0aW9uKCBjb250YWluZXIgKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZUltYWdlUmVjb3JkKSB7XG4gICAgICAgICAgICAkLmNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnW1RpbGUuZHJhd0hUTUxdIGF0dGVtcHRpbmcgdG8gZHJhdyB0aWxlICVzIHdoZW4gaXRcXCdzIG5vdCBjYWNoZWQnLFxuICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICF0aGlzLmxvYWRlZCApIHtcbiAgICAgICAgICAgICQuY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiQXR0ZW1wdGluZyB0byBkcmF3IHRpbGUgJXMgd2hlbiBpdCdzIG5vdCB5ZXQgbG9hZGVkLlwiLFxuICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vRVhQRVJJTUVOVEFMIC0gdHJ5aW5nIHRvIGZpZ3VyZSBvdXQgaG93IHRvIHNjYWxlIHRoZSBjb250YWluZXJcbiAgICAgICAgLy8gICAgICAgICAgICAgICBjb250ZW50IGR1cmluZyBhbmltYXRpb24gb2YgdGhlIGNvbnRhaW5lciBzaXplLlxuXG4gICAgICAgIGlmICggIXRoaXMuZWxlbWVudCApIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiZGl2XCIgKTtcbiAgICAgICAgICAgIHRoaXMuaW1nRWxlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcy5jYWNoZUltYWdlUmVjb3JkLmdldEltYWdlKCkuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgICB0aGlzLmltZ0VsZW1lbnQuc3R5bGUubXNJbnRlcnBvbGF0aW9uTW9kZSA9IFwibmVhcmVzdC1uZWlnaGJvclwiO1xuICAgICAgICAgICAgdGhpcy5pbWdFbGVtZW50LnN0eWxlLndpZHRoICAgICAgICAgICAgICAgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIHRoaXMuaW1nRWxlbWVudC5zdHlsZS5oZWlnaHQgICAgICAgICAgICAgID0gXCIxMDAlXCI7XG5cbiAgICAgICAgICAgIHRoaXMuc3R5bGUgICAgICAgICAgICAgICAgICAgICA9IHRoaXMuZWxlbWVudC5zdHlsZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUucG9zaXRpb24gICAgICAgICAgICA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlICE9IGNvbnRhaW5lciApIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5lbGVtZW50ICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0aGlzLmltZ0VsZW1lbnQucGFyZW50Tm9kZSAhPSB0aGlzLmVsZW1lbnQgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuaW1nRWxlbWVudCApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZS50b3AgICAgID0gdGhpcy5wb3NpdGlvbi55ICsgXCJweFwiO1xuICAgICAgICB0aGlzLnN0eWxlLmxlZnQgICAgPSB0aGlzLnBvc2l0aW9uLnggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuc3R5bGUuaGVpZ2h0ICA9IHRoaXMuc2l6ZS55ICsgXCJweFwiO1xuICAgICAgICB0aGlzLnN0eWxlLndpZHRoICAgPSB0aGlzLnNpemUueCArIFwicHhcIjtcblxuICAgICAgICAkLnNldEVsZW1lbnRPcGFjaXR5KCB0aGlzLmVsZW1lbnQsIHRoaXMub3BhY2l0eSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB0aWxlIGluIGEgY2FudmFzLWJhc2VkIGNvbnRleHQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtDYW52YXN9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmF3aW5nSGFuZGxlciAtIE1ldGhvZCBmb3IgZmlyaW5nIHRoZSBkcmF3aW5nIGV2ZW50LlxuICAgICAqIGRyYXdpbmdIYW5kbGVyKHtjb250ZXh0LCB0aWxlLCByZW5kZXJlZH0pXG4gICAgICogd2hlcmUgPGNvZGU+cmVuZGVyZWQ8L2NvZGU+IGlzIHRoZSBjb250ZXh0IHdpdGggdGhlIHByZS1kcmF3biBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIC0gQXBwbHkgYSBzY2FsZSB0byBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gW3RyYW5zbGF0ZV0gLSBBIHRyYW5zbGF0aW9uIHZlY3RvclxuICAgICAqL1xuICAgIGRyYXdDYW52YXM6IGZ1bmN0aW9uKCBjb250ZXh0LCBkcmF3aW5nSGFuZGxlciwgc2NhbGUsIHRyYW5zbGF0ZSApIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLnRpbWVzKCQucGl4ZWxEZW5zaXR5UmF0aW8pLFxuICAgICAgICAgICAgc2l6ZSAgICAgPSB0aGlzLnNpemUudGltZXMoJC5waXhlbERlbnNpdHlSYXRpbyksXG4gICAgICAgICAgICByZW5kZXJlZDtcblxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dDJEICYmICF0aGlzLmNhY2hlSW1hZ2VSZWNvcmQpIHtcbiAgICAgICAgICAgICQuY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdbVGlsZS5kcmF3Q2FudmFzXSBhdHRlbXB0aW5nIHRvIGRyYXcgdGlsZSAlcyB3aGVuIGl0XFwncyBub3QgY2FjaGVkJyxcbiAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZWQgPSB0aGlzLmNvbnRleHQyRCB8fCB0aGlzLmNhY2hlSW1hZ2VSZWNvcmQuZ2V0UmVuZGVyZWRDb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKCAhdGhpcy5sb2FkZWQgfHwgIXJlbmRlcmVkICl7XG4gICAgICAgICAgICAkLmNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkF0dGVtcHRpbmcgdG8gZHJhdyB0aWxlICVzIHdoZW4gaXQncyBub3QgeWV0IGxvYWRlZC5cIixcbiAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2FsZSA9PT0gJ251bWJlcicgJiYgc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgdGlsZSBhdCBhIGRpZmZlcmVudCBzY2FsZVxuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi50aW1lcyhzY2FsZSk7XG4gICAgICAgICAgICBzaXplID0gc2l6ZS50aW1lcyhzY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNsYXRlIGluc3RhbmNlb2YgJC5Qb2ludCkge1xuICAgICAgICAgICAgLy8gc2hpZnQgdGlsZSBwb3NpdGlvbiBzbGlnaHRseVxuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi5wbHVzKHRyYW5zbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHdlIGFyZSBzdXBwb3NlZCB0byBiZSByZW5kZXJpbmcgZnVsbHkgb3BhcXVlIHJlY3RhbmdsZSxcbiAgICAgICAgLy9pZSBpdHMgZG9uZSBmYWRpbmcgb3IgZmFkaW5nIGlzIHR1cm5lZCBvZmYsIGFuZCBpZiB3ZSBhcmUgZHJhd2luZ1xuICAgICAgICAvL2FuIGltYWdlIHdpdGggYW4gYWxwaGEgY2hhbm5lbCwgdGhlbiB0aGUgb25seSB3YXlcbiAgICAgICAgLy90byBhdm9pZCBzZWVpbmcgdGhlIHRpbGUgdW5kZXJuZWF0aCBpcyB0byBjbGVhciB0aGUgcmVjdGFuZ2xlXG4gICAgICAgIGlmIChjb250ZXh0Lmdsb2JhbEFscGhhID09PSAxICYmIHRoaXMuX2hhc1RyYW5zcGFyZW5jeUNoYW5uZWwoKSkge1xuICAgICAgICAgICAgLy9jbGVhcmluZyBvbmx5IHRoZSBpbnNpZGUgb2YgdGhlIHJlY3RhbmdsZSBvY2N1cGllZFxuICAgICAgICAgICAgLy9ieSB0aGUgcG5nIHByZXZlbnRzIGVkZ2UgZmxpa2VyaW5nXG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdChcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi54ICsgMSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi55ICsgMSxcbiAgICAgICAgICAgICAgICBzaXplLnggLSAyLFxuICAgICAgICAgICAgICAgIHNpemUueSAtIDJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGdpdmVzIHRoZSBhcHBsaWNhdGlvbiBhIGNoYW5jZSB0byBtYWtlIGltYWdlIG1hbmlwdWxhdGlvblxuICAgICAgICAvLyBjaGFuZ2VzIGFzIHdlIGFyZSByZW5kZXJpbmcgdGhlIGltYWdlXG4gICAgICAgIGRyYXdpbmdIYW5kbGVyKHtjb250ZXh0OiBjb250ZXh0LCB0aWxlOiB0aGlzLCByZW5kZXJlZDogcmVuZGVyZWR9KTtcblxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgIHJlbmRlcmVkLmNhbnZhcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgcmVuZGVyZWQuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgcmVuZGVyZWQuY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHBvc2l0aW9uLngsXG4gICAgICAgICAgICBwb3NpdGlvbi55LFxuICAgICAgICAgICAgc2l6ZS54LFxuICAgICAgICAgICAgc2l6ZS55XG4gICAgICAgICk7XG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmF0aW8gYmV0d2VlbiBjdXJyZW50IGFuZCBvcmlnaW5hbCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0Zsb2F0fVxuICAgICAqL1xuICAgIGdldFNjYWxlRm9yRWRnZVNtb290aGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250ZXh0O1xuICAgICAgICBpZiAodGhpcy5jYWNoZUltYWdlUmVjb3JkKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jYWNoZUltYWdlUmVjb3JkLmdldFJlbmRlcmVkQ29udGV4dCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29udGV4dDJEKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0MkQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnW1RpbGUuZHJhd0NhbnZhc10gYXR0ZW1wdGluZyB0byBnZXQgdGlsZSBzY2FsZSAlcyB3aGVuIHRpbGVcXCdzIG5vdCBjYWNoZWQnLFxuICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dC5jYW52YXMud2lkdGggLyAodGhpcy5zaXplLnggKiAkLnBpeGVsRGVuc2l0eVJhdGlvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgdHJhbnNsYXRpb24gdmVjdG9yIHRoYXQgd2hlbiBhcHBsaWVkIHRvIHRoZSB0aWxlIHBvc2l0aW9uIHByb2R1Y2VzIGludGVnZXIgY29vcmRpbmF0ZXMuXG4gICAgICogTmVlZGVkIHRvIGF2b2lkIHN3aW1taW5nIGFuZCB0d2l0Y2hpbmcuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSAtIFNjYWxlIHRvIGJlIGFwcGxpZWQgdG8gcG9zaXRpb24uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRUcmFuc2xhdGlvbkZvckVkZ2VTbW9vdGhpbmc6IGZ1bmN0aW9uKHNjYWxlLCBjYW52YXNTaXplLCBza2V0Y2hDYW52YXNTaXplKSB7XG4gICAgICAgIC8vIFRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgbXVzdCBoYXZlIHBvc2l0aXZlIHZhbHVlcywgb3RoZXJ3aXNlIHRoZSBpbWFnZSBnb2VzIGEgYml0IG9mZlxuICAgICAgICAvLyB0aGUgc2tldGNoIGNhbnZhcyB0byB0aGUgdG9wIGFuZCBsZWZ0IGFuZCB3ZSBtdXN0IHVzZSBuZWdhdGl2ZSBjb29yZGluYXRlcyB0byByZXBhaW50IGl0XG4gICAgICAgIC8vIHRvIHRoZSBtYWluIGNhbnZhcy4gSW4gdGhhdCBjYXNlLCBzb21lIGJyb3dzZXJzIHRocm93OlxuICAgICAgICAvLyBJTkRFWF9TSVpFX0VSUjogRE9NIEV4Y2VwdGlvbiAxOiBJbmRleCBvciBzaXplIHdhcyBuZWdhdGl2ZSwgb3IgZ3JlYXRlciB0aGFuIHRoZSBhbGxvd2VkIHZhbHVlLlxuICAgICAgICB2YXIgeCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCgoc2tldGNoQ2FudmFzU2l6ZS54IC0gY2FudmFzU2l6ZS54KSAvIDIpKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoKHNrZXRjaENhbnZhc1NpemUueSAtIGNhbnZhc1NpemUueSkgLyAyKSk7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCh4LCB5KS5taW51cyhcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25cbiAgICAgICAgICAgICAgICAudGltZXMoJC5waXhlbERlbnNpdHlSYXRpbylcbiAgICAgICAgICAgICAgICAudGltZXMoc2NhbGUgfHwgMSlcbiAgICAgICAgICAgICAgICAuYXBwbHkoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCAlIDE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aWxlIGZyb20gaXRzIGNvbnRhaW5lci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHRoaXMuaW1nRWxlbWVudCAmJiB0aGlzLmltZ0VsZW1lbnQucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgIHRoaXMuaW1nRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLmltZ0VsZW1lbnQgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudCAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1nRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9hZGVkICAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgICAgPSBmYWxzZTtcbiAgICB9XG59O1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIE92ZXJsYXlcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCQpIHtcblxuICAgIC8qKlxuICAgICAqIEFuIGVudW1lcmF0aW9uIG9mIHBvc2l0aW9ucyB0aGF0IGFuIG92ZXJsYXkgbWF5IGJlIGFzc2lnbmVkIHJlbGF0aXZlIHRvXG4gICAgICogdGhlIHZpZXdwb3J0LlxuICAgICAqIEl0IGlzIGlkZW50aWNhbCB0byBPcGVuU2VhZHJhZ29uLlBsYWNlbWVudCBidXQgaXMga2VwdCBmb3IgYmFja3dhcmRcbiAgICAgKiBjb21wYXRpYmlsaXR5LlxuICAgICAqIEBtZW1iZXIgT3ZlcmxheVBsYWNlbWVudFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENFTlRFUlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBUT1BfTEVGVFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBUT1BcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gVE9QX1JJR0hUXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFJJR0hUXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPVFRPTV9SSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1RUT01cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQk9UVE9NX0xFRlRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gTEVGVFxuICAgICAqL1xuICAgICQuT3ZlcmxheVBsYWNlbWVudCA9ICQuUGxhY2VtZW50O1xuXG4gICAgLyoqXG4gICAgICogQW4gZW51bWVyYXRpb24gb2YgcG9zc2libGUgd2F5cyB0byBoYW5kbGUgb3ZlcmxheXMgcm90YXRpb25cbiAgICAgKiBAbWVtYmVyIE92ZXJsYXlSb3RhdGlvbk1vZGVcbiAgICAgKiBAbWVtYmVyT2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gTk9fUk9UQVRJT04gVGhlIG92ZXJsYXkgaWdub3JlIHRoZSB2aWV3cG9ydCByb3RhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gRVhBQ1QgVGhlIG92ZXJsYXkgdXNlIENTUyAzIHRyYW5zZm9ybXMgdG8gcm90YXRlIHdpdGhcbiAgICAgKiB0aGUgdmlld3BvcnQuIElmIHRoZSBvdmVybGF5IGNvbnRhaW5zIHRleHQsIGl0IHdpbGwgZ2V0IHJvdGF0ZWQgYXMgd2VsbC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQk9VTkRJTkdfQk9YIFRoZSBvdmVybGF5IGFkanVzdHMgZm9yIHJvdGF0aW9uIGJ5XG4gICAgICogdGFraW5nIHRoZSBzaXplIG9mIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHJvdGF0ZWQgYm91bmRzLlxuICAgICAqIE9ubHkgdmFsaWQgZm9yIG92ZXJsYXlzIHdpdGggUmVjdCBsb2NhdGlvbiBhbmQgc2NhbGFibGUgaW4gYm90aCBkaXJlY3Rpb25zLlxuICAgICAqL1xuICAgICQuT3ZlcmxheVJvdGF0aW9uTW9kZSA9ICQuZnJlZXplT2JqZWN0KHtcbiAgICAgICAgTk9fUk9UQVRJT046IDEsXG4gICAgICAgIEVYQUNUOiAyLFxuICAgICAgICBCT1VORElOR19CT1g6IDNcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBPdmVybGF5XG4gICAgICogQGNsYXNzZGVzYyBQcm92aWRlcyBhIHdheSB0byBmbG9hdCBhbiBIVE1MIGVsZW1lbnQgb24gdG9wIG9mIHRoZSB2aWV3ZXIgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9wdGlvbnMuZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludHxPcGVuU2VhZHJhZ29uLlJlY3R9IG9wdGlvbnMubG9jYXRpb24gLSBUaGVcbiAgICAgKiBsb2NhdGlvbiBvZiB0aGUgb3ZlcmxheSBvbiB0aGUgaW1hZ2UuIElmIGEge0BsaW5rIE9wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICogaXMgc3BlY2lmaWVkLCB0aGUgb3ZlcmxheSB3aWxsIGJlIGxvY2F0ZWQgYXQgdGhpcyBsb2NhdGlvbiB3aXRoIHJlc3BlY3RcbiAgICAgKiB0byB0aGUgcGxhY2VtZW50IG9wdGlvbi4gSWYgYSB7QGxpbmsgT3BlblNlYWRyYWdvbi5SZWN0fSBpcyBzcGVjaWZpZWQsXG4gICAgICogdGhlIG92ZXJsYXkgd2lsbCBiZSBwbGFjZWQgYXQgdGhpcyBsb2NhdGlvbiB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHdpZHRoXG4gICAgICogYW5kIGhlaWdodCBhbmQgcGxhY2VtZW50IFRPUF9MRUZULlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IFtvcHRpb25zLnBsYWNlbWVudD1PcGVuU2VhZHJhZ29uLlBsYWNlbWVudC5UT1BfTEVGVF1cbiAgICAgKiBEZWZpbmVzIHdoYXQgcGFydCBvZiB0aGUgb3ZlcmxheSBzaG91bGQgYmUgYXQgdGhlIHNwZWNpZmllZCBvcHRpb25zLmxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk92ZXJsYXkuT25EcmF3Q2FsbGJhY2t9IFtvcHRpb25zLm9uRHJhd11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrUmVzaXplPXRydWVdIFNldCB0byBmYWxzZSB0byBhdm9pZCB0b1xuICAgICAqIGNoZWNrIHRoZSBzaXplIG9mIHRoZSBvdmVybGF5IGV2ZXJ5dGltZSBpdCBpcyBkcmF3biBpbiB0aGUgZGlyZWN0aW9uc1xuICAgICAqIHdoaWNoIGFyZSBub3Qgc2NhbGVkLiBJdCB3aWxsIGltcHJvdmUgcGVyZm9ybWFuY2VzIGJ1dCB3aWxsIGNhdXNlIGFcbiAgICAgKiBtaXNhbGlnbm1lbnQgaWYgdGhlIG92ZXJsYXkgc2l6ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gVGhlIHdpZHRoIG9mIHRoZSBvdmVybGF5IGluIHZpZXdwb3J0XG4gICAgICogY29vcmRpbmF0ZXMuIElmIHNwZWNpZmllZCwgdGhlIHdpZHRoIG9mIHRoZSBvdmVybGF5IHdpbGwgYmUgYWRqdXN0ZWQgd2hlblxuICAgICAqIHRoZSB6b29tIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gVGhlIGhlaWdodCBvZiB0aGUgb3ZlcmxheSBpbiB2aWV3cG9ydFxuICAgICAqIGNvb3JkaW5hdGVzLiBJZiBzcGVjaWZpZWQsIHRoZSBoZWlnaHQgb2YgdGhlIG92ZXJsYXkgd2lsbCBiZSBhZGp1c3RlZCB3aGVuXG4gICAgICogdGhlIHpvb20gY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJvdGF0aW9uTW9kZT1PcGVuU2VhZHJhZ29uLk92ZXJsYXlSb3RhdGlvbk1vZGUuRVhBQ1RdXG4gICAgICogSG93IHRvIGhhbmRsZSB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgICQuT3ZlcmxheSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGxvY2F0aW9uLCBwbGFjZW1lbnQpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb25EcmF3IGNhbGxiYWNrIHNpZ25hdHVyZSB1c2VkIGJ5IHtAbGluayBPcGVuU2VhZHJhZ29uLk92ZXJsYXl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2FsbGJhY2sgT25EcmF3Q2FsbGJhY2tcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uT3ZlcmxheVxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gc2l6ZVxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG9wdGlvbnMuZWxlbWVudC5zdHlsZTtcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLk92ZXJsYXkucHJvdG90eXBlICovXG4gICAgJC5PdmVybGF5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIF9pbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbjtcbiAgICAgICAgICAgIHRoaXMucGxhY2VtZW50ID0gb3B0aW9ucy5wbGFjZW1lbnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgJC5QbGFjZW1lbnQuVE9QX0xFRlQgOiBvcHRpb25zLnBsYWNlbWVudDtcbiAgICAgICAgICAgIHRoaXMub25EcmF3ID0gb3B0aW9ucy5vbkRyYXc7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVzaXplID0gb3B0aW9ucy5jaGVja1Jlc2l6ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB0cnVlIDogb3B0aW9ucy5jaGVja1Jlc2l6ZTtcblxuICAgICAgICAgICAgLy8gV2hlbiB0aGlzLndpZHRoIGlzIG5vdCBudWxsLCB0aGUgb3ZlcmxheSBnZXQgc2NhbGVkIGhvcml6b250YWxseVxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLndpZHRoO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMuaGVpZ2h0IGlzIG5vdCBudWxsLCB0aGUgb3ZlcmxheSBnZXQgc2NhbGVkIHZlcnRpY2FsbHlcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmhlaWdodDtcblxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbk1vZGUgPSBvcHRpb25zLnJvdGF0aW9uTW9kZSB8fCAkLk92ZXJsYXlSb3RhdGlvbk1vZGUuRVhBQ1Q7XG5cbiAgICAgICAgICAgIC8vIEhhdmluZyBhIHJlY3QgYXMgbG9jYXRpb24gaXMgYSBzeW50YWN0aWMgc3VnYXJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2F0aW9uIGluc3RhbmNlb2YgJC5SZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMubG9jYXRpb24ud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxvY2F0aW9uLmhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdGhpcy5sb2NhdGlvbi5nZXRUb3BMZWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSAkLlBsYWNlbWVudC5UT1BfTEVGVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVwcmVjYXRlZCBwcm9wZXJ0aWVzIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgICB0aGlzLnNjYWxlcyA9IHRoaXMud2lkdGggIT09IG51bGwgJiYgdGhpcy5oZWlnaHQgIT09IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyAkLlJlY3QoXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi54LCB0aGlzLmxvY2F0aW9uLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmxvY2F0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHBvc2l0aW9uIG9mIGFuIG92ZXJsYXlcbiAgICAgICAgICogZGVwZW5kaW5nIG9uIGl0IHNpemUgYW5kIHBsYWNlbWVudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb25cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBhZGp1c3Q6IGZ1bmN0aW9uKHBvc2l0aW9uLCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9ICQuUGxhY2VtZW50LnByb3BlcnRpZXNbdGhpcy5wbGFjZW1lbnRdO1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaXNIb3Jpem9udGFsbHlDZW50ZXJlZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnggLT0gc2l6ZS54IC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5pc1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueCAtPSBzaXplLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5pc1ZlcnRpY2FsbHlDZW50ZXJlZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgLT0gc2l6ZS55IC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5pc0JvdHRvbSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgLT0gc2l6ZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vdGhpcyBzaG91bGQgYWxsb3cgdXMgdG8gcHJlc2VydmUgb3ZlcmxheXMgd2hlbiByZXF1aXJlZCBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgLy9wYWdlc1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnByZXZFbGVtZW50UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIC8vZWxlbWVudC5wcmV2RWxlbWVudFBhcmVudC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIGVsZW1lbnQucHJldk5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBvbkRyYXcgY2FsbGJhY2tcbiAgICAgICAgICAgIHRoaXMub25EcmF3ID0gbnVsbDtcblxuICAgICAgICAgICAgc3R5bGUudG9wID0gXCJcIjtcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBcIlwiO1xuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gPSBcIlwiO1xuXG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luUHJvcCA9ICQuZ2V0Q3NzUHJvcGVydHlXaXRoVmVuZG9yUHJlZml4KFxuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm1PcmlnaW4nKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1Qcm9wID0gJC5nZXRDc3NQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXgoXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybU9yaWdpblByb3AgJiYgdHJhbnNmb3JtUHJvcCkge1xuICAgICAgICAgICAgICAgIHN0eWxlW3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCJcIjtcbiAgICAgICAgICAgICAgICBzdHlsZVt0cmFuc2Zvcm1Qcm9wXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgICAgICAgKi9cbiAgICAgICAgZHJhd0hUTUw6IGZ1bmN0aW9uKGNvbnRhaW5lciwgdmlld3BvcnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgLy9zYXZlIHRoZSBzb3VyY2UgcGFyZW50IGZvciBsYXRlciBpZiB3ZSBuZWVkIGl0XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wcmV2RWxlbWVudFBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnByZXZOZXh0U2libGluZyA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5zaXplIGlzIHVzZWQgYnkgb3ZlcmxheXMgd2hpY2ggZG9uJ3QgZ2V0IHNjYWxlZCBpbiBhdFxuICAgICAgICAgICAgICAgIC8vIGxlYXN0IG9uZSBkaXJlY3Rpb24gd2hlbiB0aGlzLmNoZWNrUmVzaXplIGlzIHNldCB0byBmYWxzZS5cbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAkLmdldEVsZW1lbnRTaXplKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BbmRTaXplID0gdGhpcy5fZ2V0T3ZlcmxheVBvc2l0aW9uQW5kU2l6ZSh2aWV3cG9ydCk7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uQW5kU2l6ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplID0gcG9zaXRpb25BbmRTaXplLnNpemU7XG4gICAgICAgICAgICB2YXIgcm90YXRlID0gcG9zaXRpb25BbmRTaXplLnJvdGF0ZTtcblxuICAgICAgICAgICAgLy8gY2FsbCB0aGUgb25EcmF3IGNhbGxiYWNrIGlmIGl0IGV4aXN0cyB0byBhbGxvdyBvbmUgdG8gb3ZlcndyaXRlXG4gICAgICAgICAgICAvLyB0aGUgZHJhd2luZy9wb3NpdGlvbmluZy9zaXppbmcgb2YgdGhlIG92ZXJsYXlcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRHJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMub25EcmF3KHBvc2l0aW9uLCBzaXplLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBwb3NpdGlvbi54ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRvcCA9IHBvc2l0aW9uLnkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBzaXplLnggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzaXplLnkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW5Qcm9wID0gJC5nZXRDc3NQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXgoXG4gICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm1PcmlnaW4nKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtUHJvcCA9ICQuZ2V0Q3NzUHJvcGVydHlXaXRoVmVuZG9yUHJlZml4KFxuICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybU9yaWdpblByb3AgJiYgdHJhbnNmb3JtUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVt0cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IHRoaXMuX2dldFRyYW5zZm9ybU9yaWdpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbdHJhbnNmb3JtUHJvcF0gPSBcInJvdGF0ZShcIiArIHJvdGF0ZSArIFwiZGVnKVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbdHJhbnNmb3JtUHJvcF0gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcHJpdmF0ZVxuICAgICAgICBfZ2V0T3ZlcmxheVBvc2l0aW9uQW5kU2l6ZTogZnVuY3Rpb24odmlld3BvcnQpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHZpZXdwb3J0LnBpeGVsRnJvbVBvaW50KHRoaXMubG9jYXRpb24sIHRydWUpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9nZXRTaXplSW5QaXhlbHModmlld3BvcnQpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3QocG9zaXRpb24sIHNpemUpO1xuXG4gICAgICAgICAgICB2YXIgcm90YXRlID0gMDtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydC5kZWdyZWVzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbk1vZGUgIT09ICQuT3ZlcmxheVJvdGF0aW9uTW9kZS5OT19ST1RBVElPTikge1xuICAgICAgICAgICAgICAgIC8vIEJPVU5ESU5HX0JPWCBpcyBvbmx5IHZhbGlkIGlmIGJvdGggZGlyZWN0aW9ucyBnZXQgc2NhbGVkLlxuICAgICAgICAgICAgICAgIC8vIEdldCByZXBsYWNlZCBieSBFWEFDVCBvdGhlcndpc2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpb25Nb2RlID09PSAkLk92ZXJsYXlSb3RhdGlvbk1vZGUuQk9VTkRJTkdfQk9YICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2lkdGggIT09IG51bGwgJiYgdGhpcy5oZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgJC5SZWN0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdGhpcy5fZ2V0Qm91bmRpbmdCb3gocmVjdCwgdmlld3BvcnQuZGVncmVlcyk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gYm91bmRpbmdCb3guZ2V0VG9wTGVmdCgpO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gYm91bmRpbmdCb3guZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSA9IHZpZXdwb3J0LmRlZ3JlZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgIHJvdGF0ZTogcm90YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHByaXZhdGVcbiAgICAgICAgX2dldFNpemVJblBpeGVsczogZnVuY3Rpb24odmlld3BvcnQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IG51bGwgfHwgdGhpcy5oZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVkU2l6ZSA9IHZpZXdwb3J0LmRlbHRhUGl4ZWxzRnJvbVBvaW50c05vUm90YXRlKFxuICAgICAgICAgICAgICAgICAgICBuZXcgJC5Qb2ludCh0aGlzLndpZHRoIHx8IDAsIHRoaXMuaGVpZ2h0IHx8IDApLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHNjYWxlZFNpemUueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHNjYWxlZFNpemUueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1Jlc2l6ZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLndpZHRoID09PSBudWxsIHx8IHRoaXMuaGVpZ2h0ID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHZhciBlbHRTaXplID0gdGhpcy5zaXplID0gJC5nZXRFbGVtZW50U2l6ZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gZWx0U2l6ZS54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gZWx0U2l6ZS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIF9nZXRCb3VuZGluZ0JveDogZnVuY3Rpb24ocmVjdCwgZGVncmVlcykge1xuICAgICAgICAgICAgdmFyIHJlZlBvaW50ID0gdGhpcy5fZ2V0UGxhY2VtZW50UG9pbnQocmVjdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5yb3RhdGUoZGVncmVlcywgcmVmUG9pbnQpLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcHJpdmF0ZVxuICAgICAgICBfZ2V0UGxhY2VtZW50UG9pbnQ6IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgJC5Qb2ludChyZWN0LngsIHJlY3QueSk7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9ICQuUGxhY2VtZW50LnByb3BlcnRpZXNbdGhpcy5wbGFjZW1lbnRdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5pc0hvcml6b250YWxseUNlbnRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC54ICs9IHJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5pc1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC54ICs9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzVmVydGljYWxseUNlbnRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC55ICs9IHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMuaXNCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnkgKz0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIF9nZXRUcmFuc2Zvcm1PcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9ICQuUGxhY2VtZW50LnByb3BlcnRpZXNbdGhpcy5wbGFjZW1lbnRdO1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzTGVmdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwibGVmdFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLmlzUmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5pc1RvcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiB0b3BcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5pc0JvdHRvbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBib3R0b21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZXMgdGhlIG92ZXJsYXkgc2V0dGluZ3MuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR8T3BlblNlYWRyYWdvbi5SZWN0fE9iamVjdH0gbG9jYXRpb25cbiAgICAgICAgICogSWYgYW4gb2JqZWN0IGlzIHNwZWNpZmllZCwgdGhlIG9wdGlvbnMgYXJlIHRoZSBzYW1lIHRoYW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAqIGV4Y2VwdCBmb3IgdGhlIGVsZW1lbnQgd2hpY2ggY2FuIG5vdCBiZSBjaGFuZ2VkLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBwb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihsb2NhdGlvbiwgcGxhY2VtZW50KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICQuaXNQbGFpbk9iamVjdChsb2NhdGlvbikgPyBsb2NhdGlvbiA6IHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9pbml0KHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogb3B0aW9ucy5sb2NhdGlvbiB8fCB0aGlzLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogb3B0aW9ucy5wbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGxhY2VtZW50IDogdGhpcy5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgb25EcmF3OiBvcHRpb25zLm9uRHJhdyB8fCB0aGlzLm9uRHJhdyxcbiAgICAgICAgICAgICAgICBjaGVja1Jlc2l6ZTogb3B0aW9ucy5jaGVja1Jlc2l6ZSB8fCB0aGlzLmNoZWNrUmVzaXplLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndpZHRoIDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmhlaWdodCA6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uTW9kZTogb3B0aW9ucy5yb3RhdGlvbk1vZGUgfHwgdGhpcy5yb3RhdGlvbk1vZGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJvdW5kcyBvZiB0aGUgb3ZlcmxheSBpbiB2aWV3cG9ydCBjb29yZGluYXRlc1xuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSB2aWV3cG9ydCB0aGUgdmlld3BvcnRcbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gb3ZlcmxheSBib3VuZHNcbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kczogZnVuY3Rpb24odmlld3BvcnQpIHtcbiAgICAgICAgICAgICQuY29uc29sZS5hc3NlcnQodmlld3BvcnQsXG4gICAgICAgICAgICAgICAgJ0Egdmlld3BvcnQgbXVzdCBub3cgYmUgcGFzc2VkIHRvIE92ZXJsYXkuZ2V0Qm91bmRzLicpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gbnVsbCB8fCBoZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVsc05vUm90YXRlKHRoaXMuc2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc2l6ZS54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHNpemUueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdChsb2NhdGlvbiwgbmV3ICQuUG9pbnQod2lkdGgsIGhlaWdodCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkanVzdEJvdW5kc0ZvclJvdGF0aW9uKFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0LCBuZXcgJC5SZWN0KGxvY2F0aW9uLngsIGxvY2F0aW9uLnksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIF9hZGp1c3RCb3VuZHNGb3JSb3RhdGlvbjogZnVuY3Rpb24odmlld3BvcnQsIGJvdW5kcykge1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydCB8fFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmRlZ3JlZXMgPT09IDAgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uTW9kZSA9PT0gJC5PdmVybGF5Um90YXRpb25Nb2RlLkVYQUNUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW9uTW9kZSA9PT0gJC5PdmVybGF5Um90YXRpb25Nb2RlLkJPVU5ESU5HX0JPWCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG92ZXJsYXkgbm90IGZ1bGx5IHNjYWxhYmxlLCBCT1VORElOR19CT1ggZmFsbHMgYmFjayB0byBFWEFDVFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZHRoID09PSBudWxsIHx8IHRoaXMuaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGVhc2llciB0byBqdXN0IGNvbXB1dGUgdGhlIHBvc2l0aW9uIGFuZCBzaXplIGFuZFxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uQW5kU2l6ZSA9IHRoaXMuX2dldE92ZXJsYXlQb3NpdGlvbkFuZFNpemUodmlld3BvcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3cG9ydC52aWV3ZXJFbGVtZW50VG9WaWV3cG9ydFJlY3RhbmdsZShuZXcgJC5SZWN0KFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFuZFNpemUucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BbmRTaXplLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQW5kU2l6ZS5zaXplLngsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQW5kU2l6ZS5zaXplLnkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTk9fUk9UQVRJT04gY2FzZVxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kcy5yb3RhdGUoLXZpZXdwb3J0LmRlZ3JlZXMsXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50UG9pbnQoYm91bmRzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KE9wZW5TZWFkcmFnb24pKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBEcmF3ZXJcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogQGNsYXNzIERyYXdlclxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBjbGFzc2Rlc2MgSGFuZGxlcyByZW5kZXJpbmcgb2YgdGlsZXMgZm9yIGFuIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlcn0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoaXMgRHJhd2VyLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gb3B0aW9ucy52aWV3ZXIgLSBUaGUgVmlld2VyIHRoYXQgb3ducyB0aGlzIERyYXdlci5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gb3B0aW9ucy52aWV3cG9ydCAtIFJlZmVyZW5jZSB0byBWaWV3ZXIgdmlld3BvcnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG9wdGlvbnMuZWxlbWVudCAtIFBhcmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlYnVnR3JpZENvbG9yXSAtIFNlZSBkZWJ1Z0dyaWRDb2xvciBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfSBmb3IgZGV0YWlscy5cbiAqL1xuJC5EcmF3ZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMudmlld2VyLCBcIltEcmF3ZXJdIG9wdGlvbnMudmlld2VyIGlzIHJlcXVpcmVkXCIgKTtcblxuICAgIC8vYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3IgcG9zaXRpb25hbCBhcmdzIHdoaWxlIHByZWZlcmluZyBtb3JlXG4gICAgLy9pZGlvbWF0aWMgamF2YXNjcmlwdCBvcHRpb25zIG9iamVjdCBhcyB0aGUgb25seSBhcmd1bWVudFxuICAgIHZhciBhcmdzICA9IGFyZ3VtZW50cztcblxuICAgIGlmKCAhJC5pc1BsYWluT2JqZWN0KCBvcHRpb25zICkgKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogICAgIGFyZ3NbIDAgXSwgLy8gUmVmZXJlbmNlIHRvIFZpZXdlciB0aWxlIHNvdXJjZS5cbiAgICAgICAgICAgIHZpZXdwb3J0OiAgIGFyZ3NbIDEgXSwgLy8gUmVmZXJlbmNlIHRvIFZpZXdlciB2aWV3cG9ydC5cbiAgICAgICAgICAgIGVsZW1lbnQ6ICAgIGFyZ3NbIDIgXSAgLy8gUGFyZW50IGVsZW1lbnQuXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy52aWV3cG9ydCwgXCJbRHJhd2VyXSBvcHRpb25zLnZpZXdwb3J0IGlzIHJlcXVpcmVkXCIgKTtcbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLmVsZW1lbnQsIFwiW0RyYXdlcl0gb3B0aW9ucy5lbGVtZW50IGlzIHJlcXVpcmVkXCIgKTtcblxuICAgIGlmICggb3B0aW9ucy5zb3VyY2UgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbRHJhd2VyXSBvcHRpb25zLnNvdXJjZSBpcyBubyBsb25nZXIgYWNjZXB0ZWQ7IHVzZSBUaWxlZEltYWdlIGluc3RlYWRcIiApO1xuICAgIH1cblxuICAgIHRoaXMudmlld2VyID0gb3B0aW9ucy52aWV3ZXI7XG4gICAgdGhpcy52aWV3cG9ydCA9IG9wdGlvbnMudmlld3BvcnQ7XG4gICAgdGhpcy5kZWJ1Z0dyaWRDb2xvciA9IG9wdGlvbnMuZGVidWdHcmlkQ29sb3IgfHwgJC5ERUZBVUxUX1NFVFRJTkdTLmRlYnVnR3JpZENvbG9yO1xuICAgIGlmIChvcHRpb25zLm9wYWNpdHkpIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKCBcIltEcmF3ZXJdIG9wdGlvbnMub3BhY2l0eSBpcyBubyBsb25nZXIgYWNjZXB0ZWQ7IHNldCB0aGUgb3BhY2l0eSBvbiB0aGUgVGlsZWRJbWFnZSBpbnN0ZWFkXCIgKTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZUNhbnZhcyAgPSAkLnN1cHBvcnRzQ2FudmFzICYmICggdGhpcy52aWV3ZXIgPyB0aGlzLnZpZXdlci51c2VDYW52YXMgOiB0cnVlICk7XG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBlbGVtZW50IG9mIHRoaXMgRHJhd2VyIGluc3RhbmNlLCBwYXNzZWQgaW4gd2hlbiB0aGUgRHJhd2VyIHdhcyBjcmVhdGVkLlxuICAgICAqIFRoZSBwYXJlbnQgb2Yge0BsaW5rIE9wZW5TZWFkcmFnb24uRHJhd2VyI2NhbnZhc30uXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gY29udGFpbmVyXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uRHJhd2VyI1xuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyICA9ICQuZ2V0RWxlbWVudCggb3B0aW9ucy5lbGVtZW50ICk7XG4gICAgLyoqXG4gICAgICogQSAmbHQ7Y2FudmFzJmd0OyBlbGVtZW50IGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZW0sIG90aGVyd2lzZSBhICZsdDtkaXYmZ3Q7IGVsZW1lbnQuXG4gICAgICogQ2hpbGQgZWxlbWVudCBvZiB7QGxpbmsgT3BlblNlYWRyYWdvbi5EcmF3ZXIjY29udGFpbmVyfS5cbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBjYW52YXNcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5EcmF3ZXIjXG4gICAgICovXG4gICAgdGhpcy5jYW52YXMgICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIHRoaXMudXNlQ2FudmFzID8gXCJjYW52YXNcIiA6IFwiZGl2XCIgKTtcbiAgICAvKipcbiAgICAgKiAyZCBkcmF3aW5nIGNvbnRleHQgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLkRyYXdlciNjYW52YXN9IGlmIGl0J3MgYSAmbHQ7Y2FudmFzJmd0OyBlbGVtZW50LCBvdGhlcndpc2UgbnVsbC5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNvbnRleHRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5EcmF3ZXIjXG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ICAgID0gdGhpcy51c2VDYW52YXMgPyB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTa2V0Y2ggY2FudmFzIHVzZWQgdG8gdGVtcG9yYXJpbHkgZHJhdyB0aWxlcyB3aGljaCBjYW5ub3QgYmUgZHJhd24gZGlyZWN0bHlcbiAgICAgKiB0byB0aGUgbWFpbiBjYW52YXMgZHVlIHRvIG9wYWNpdHkuIExhemlseSBpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICB0aGlzLnNrZXRjaENhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5za2V0Y2hDb250ZXh0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5EcmF3ZXIjXG4gICAgICogQGRlcHJlY2F0ZWQgQWxpYXMgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLkRyYXdlciNjb250YWluZXJ9LlxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCAgICA9IHRoaXMuY29udGFpbmVyO1xuXG4gICAgLy8gV2UgZm9yY2Ugb3VyIGNvbnRhaW5lciB0byBsdHIgYmVjYXVzZSBvdXIgZHJhd2luZyBtYXRoIGRvZXNuJ3Qgd29yayBpbiBydGwuXG4gICAgLy8gVGhpcyBpc3N1ZSBvbmx5IGFmZmVjdHMgb3VyIGNhbnZhcyByZW5kZXJlciwgYnV0IHdlIGRvIGl0IGFsd2F5cyBmb3IgY29uc2lzdGVuY3kuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgb3ZlcmxheXMgeW91IHdhbnQgdG8gYmUgcnRsIG5lZWQgdG8gYmUgZXhwbGljaXRseSBzZXQgdG8gcnRsLlxuICAgIHRoaXMuY29udGFpbmVyLmRpciA9ICdsdHInO1xuXG4gICAgLy8gY2hlY2sgY2FudmFzIGF2YWlsYWJsZSB3aWR0aCBhbmQgaGVpZ2h0LCBzZXQgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHQgc3VjaCB0aGF0IHRoZSBjYW52YXMgYmFja2luZyBzdG9yZSBpcyBzZXQgdG8gdGhlIHByb3BlciBwaXhlbCBkZW5zaXR5XG4gICAgaWYgKHRoaXMudXNlQ2FudmFzKSB7XG4gICAgICAgIHZhciB2aWV3cG9ydFNpemUgPSB0aGlzLl9jYWxjdWxhdGVDYW52YXNTaXplKCk7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdmlld3BvcnRTaXplLng7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZpZXdwb3J0U2l6ZS55O1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoICAgICA9IFwiMTAwJVwiO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCAgICA9IFwiMTAwJVwiO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uICA9IFwiYWJzb2x1dGVcIjtcbiAgICAkLnNldEVsZW1lbnRPcGFjaXR5KCB0aGlzLmNhbnZhcywgdGhpcy5vcGFjaXR5LCB0cnVlICk7XG5cbiAgICAvLyBleHBsaWNpdCBsZWZ0LWFsaWduXG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuY2FudmFzICk7XG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uRHJhd2VyLnByb3RvdHlwZSAqL1xuJC5EcmF3ZXIucHJvdG90eXBlID0ge1xuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBhZGRPdmVybGF5OiBmdW5jdGlvbiggZWxlbWVudCwgbG9jYXRpb24sIHBsYWNlbWVudCwgb25EcmF3ICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXCJkcmF3ZXIuYWRkT3ZlcmxheSBpcyBkZXByZWNhdGVkLiBVc2Ugdmlld2VyLmFkZE92ZXJsYXkgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMudmlld2VyLmFkZE92ZXJsYXkoIGVsZW1lbnQsIGxvY2F0aW9uLCBwbGFjZW1lbnQsIG9uRHJhdyApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIHVwZGF0ZU92ZXJsYXk6IGZ1bmN0aW9uKCBlbGVtZW50LCBsb2NhdGlvbiwgcGxhY2VtZW50ICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXCJkcmF3ZXIudXBkYXRlT3ZlcmxheSBpcyBkZXByZWNhdGVkLiBVc2Ugdmlld2VyLnVwZGF0ZU92ZXJsYXkgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMudmlld2VyLnVwZGF0ZU92ZXJsYXkoIGVsZW1lbnQsIGxvY2F0aW9uLCBwbGFjZW1lbnQgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICByZW1vdmVPdmVybGF5OiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKFwiZHJhd2VyLnJlbW92ZU92ZXJsYXkgaXMgZGVwcmVjYXRlZC4gVXNlIHZpZXdlci5yZW1vdmVPdmVybGF5IGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLnZpZXdlci5yZW1vdmVPdmVybGF5KCBlbGVtZW50ICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgY2xlYXJPdmVybGF5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcImRyYXdlci5jbGVhck92ZXJsYXlzIGlzIGRlcHJlY2F0ZWQuIFVzZSB2aWV3ZXIuY2xlYXJPdmVybGF5cyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuY2xlYXJPdmVybGF5cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBkcmF3ZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLkRyYXdlcn0gQ2hhaW5hYmxlLlxuICAgICAqL1xuICAgIHNldE9wYWNpdHk6IGZ1bmN0aW9uKCBvcGFjaXR5ICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXCJkcmF3ZXIuc2V0T3BhY2l0eSBpcyBkZXByZWNhdGVkLiBVc2UgdGlsZWRJbWFnZS5zZXRPcGFjaXR5IGluc3RlYWQuXCIpO1xuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLnZpZXdlci53b3JsZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JsZC5nZXRJdGVtQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICB3b3JsZC5nZXRJdGVtQXQoIGkgKS5zZXRPcGFjaXR5KCBvcGFjaXR5ICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3BhY2l0eSBvZiB0aGUgZHJhd2VyLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcImRyYXdlci5nZXRPcGFjaXR5IGlzIGRlcHJlY2F0ZWQuIFVzZSB0aWxlZEltYWdlLmdldE9wYWNpdHkgaW5zdGVhZC5cIik7XG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMudmlld2VyLndvcmxkO1xuICAgICAgICB2YXIgbWF4T3BhY2l0eSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29ybGQuZ2V0SXRlbUNvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSB3b3JsZC5nZXRJdGVtQXQoIGkgKS5nZXRPcGFjaXR5KCk7XG4gICAgICAgICAgICBpZiAoIG9wYWNpdHkgPiBtYXhPcGFjaXR5ICkge1xuICAgICAgICAgICAgICAgIG1heE9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhPcGFjaXR5O1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgbmVlZHNVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW0RyYXdlci5uZWVkc1VwZGF0ZV0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgV29ybGQubmVlZHNEcmF3IGluc3RlYWQuXCIgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld2VyLndvcmxkLm5lZWRzRHJhdygpO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgbnVtVGlsZXNMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW0RyYXdlci5udW1UaWxlc0xvYWRlZF0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgVGlsZUNhY2hlLm51bVRpbGVzTG9hZGVkIGluc3RlYWQuXCIgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld2VyLnRpbGVDYWNoZS5udW1UaWxlc0xvYWRlZCgpO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW0RyYXdlci5yZXNldF0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgV29ybGQucmVzZXRJdGVtcyBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHRoaXMudmlld2VyLndvcmxkLnJlc2V0SXRlbXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW0RyYXdlci51cGRhdGVdIHRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZC4gVXNlIERyYXdlci5jbGVhciBhbmQgV29ybGQuZHJhdyBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy52aWV3ZXIud29ybGQuZHJhdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiByb3RhdGlvbiBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgY2FuUm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlQ2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBkcmF3ZXIgKHVubG9hZCBjdXJyZW50IGxvYWRlZCB0aWxlcylcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9mb3JjZSB1bmxvYWRpbmcgb2YgY3VycmVudCBjYW52YXMgKDF4MSB3aWxsIGJlIGdjIGxhdGVyLCB0cmljayBub3QgbmVjZXNzYXJpbHkgbmVlZGVkKVxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCAgPSAxO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSAxO1xuICAgICAgICB0aGlzLnNrZXRjaENhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2tldGNoQ29udGV4dCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgRHJhd2VyIHNvIGl0J3MgcmVhZHkgdG8gZHJhdyBhbm90aGVyIGZyYW1lLlxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgaWYgKCB0aGlzLnVzZUNhbnZhcyApIHtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydFNpemUgPSB0aGlzLl9jYWxjdWxhdGVDYW52YXNTaXplKCk7XG4gICAgICAgICAgICBpZiggdGhpcy5jYW52YXMud2lkdGggIT0gdmlld3BvcnRTaXplLnggfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgIT0gdmlld3BvcnRTaXplLnkgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB2aWV3cG9ydFNpemUueDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB2aWV3cG9ydFNpemUueTtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc2tldGNoQ2FudmFzICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2tldGNoQ2FudmFzU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZVNrZXRjaENhbnZhc1NpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2V0Y2hDYW52YXMud2lkdGggPSBza2V0Y2hDYW52YXNTaXplLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tldGNoQ2FudmFzLmhlaWdodCA9IHNrZXRjaENhbnZhc1NpemUueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jbGVhcjogZnVuY3Rpb24gKHVzZVNrZXRjaCwgYm91bmRzKSB7XG4gICAgICAgIGlmICghdGhpcy51c2VDYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQodXNlU2tldGNoKTtcbiAgICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmcm9tIE9wZW5TZWFkcmFnb24gdmlld2VyIHJlY3RhbmdsZSB0byBkcmF3ZXIgcmVjdGFuZ2xlXG4gICAgICogKGlnbm9yaW5nIHJvdGF0aW9uKVxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUmVjdH0gUmVjdGFuZ2xlIGluIGRyYXdlciBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKi9cbiAgICB2aWV3cG9ydFRvRHJhd2VyUmVjdGFuZ2xlOiBmdW5jdGlvbihyZWN0YW5nbGUpIHtcbiAgICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLnZpZXdwb3J0LnBpeGVsRnJvbVBvaW50Tm9Sb3RhdGUocmVjdGFuZ2xlLmdldFRvcExlZnQoKSwgdHJ1ZSk7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy52aWV3cG9ydC5kZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZShyZWN0YW5nbGUuZ2V0U2l6ZSgpLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIHRvcExlZnQueCAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICB0b3BMZWZ0LnkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgc2l6ZS54ICAgICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgIHNpemUueSAgICAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGdpdmVuIHRpbGUuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGV9IHRpbGUgLSBUaGUgdGlsZSB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdpbmdIYW5kbGVyIC0gTWV0aG9kIGZvciBmaXJpbmcgdGhlIGRyYXdpbmcgZXZlbnQgaWYgdXNpbmcgY2FudmFzLlxuICAgICAqIGRyYXdpbmdIYW5kbGVyKHtjb250ZXh0LCB0aWxlLCByZW5kZXJlZH0pXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2VTa2V0Y2ggLSBXaGV0aGVyIHRvIHVzZSB0aGUgc2tldGNoIGNhbnZhcyBvciBub3QuXG4gICAgICogd2hlcmUgPGNvZGU+cmVuZGVyZWQ8L2NvZGU+IGlzIHRoZSBjb250ZXh0IHdpdGggdGhlIHByZS1kcmF3biBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBbc2NhbGU9MV0gLSBBcHBseSBhIHNjYWxlIHRvIHRpbGUgcG9zaXRpb24gYW5kIHNpemUuIERlZmF1bHRzIHRvIDEuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBbdHJhbnNsYXRlXSBBIHRyYW5zbGF0aW9uIHZlY3RvciB0byBvZmZzZXQgdGlsZSBwb3NpdGlvblxuICAgICAqL1xuICAgIGRyYXdUaWxlOiBmdW5jdGlvbih0aWxlLCBkcmF3aW5nSGFuZGxlciwgdXNlU2tldGNoLCBzY2FsZSwgdHJhbnNsYXRlKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQodGlsZSwgJ1tEcmF3ZXIuZHJhd1RpbGVdIHRpbGUgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChkcmF3aW5nSGFuZGxlciwgJ1tEcmF3ZXIuZHJhd1RpbGVdIGRyYXdpbmdIYW5kbGVyIGlzIHJlcXVpcmVkJyk7XG5cbiAgICAgICAgaWYgKHRoaXMudXNlQ2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQodXNlU2tldGNoKTtcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGUgfHwgMTtcbiAgICAgICAgICAgIHRpbGUuZHJhd0NhbnZhcyhjb250ZXh0LCBkcmF3aW5nSGFuZGxlciwgc2NhbGUsIHRyYW5zbGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlLmRyYXdIVE1MKCB0aGlzLmNhbnZhcyApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRDb250ZXh0OiBmdW5jdGlvbiggdXNlU2tldGNoICkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgaWYgKCB1c2VTa2V0Y2ggKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5za2V0Y2hDYW52YXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiY2FudmFzXCIgKTtcbiAgICAgICAgICAgICAgICB2YXIgc2tldGNoQ2FudmFzU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZVNrZXRjaENhbnZhc1NpemUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaENhbnZhcy53aWR0aCA9IHNrZXRjaENhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaENhbnZhcy5oZWlnaHQgPSBza2V0Y2hDYW52YXNTaXplLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2V0Y2hDb250ZXh0ID0gdGhpcy5za2V0Y2hDYW52YXMuZ2V0Q29udGV4dCggXCIyZFwiICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmlld3BvcnQgaXMgbm90IGN1cnJlbnRseSByb3RhdGVkLCB0aGUgc2tldGNoQ2FudmFzXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSBzYW1lIHNpemUgYXMgdGhlIG1haW4gY2FudmFzLiBIb3dldmVyLCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoZSB2aWV3cG9ydCBnZXQgcm90YXRlZCBsYXRlciBvbiwgd2Ugd2lsbCBuZWVkIHRvIHJlc2l6ZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5nZXRSb3RhdGlvbigpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3ZXIuYWRkSGFuZGxlcigncm90YXRlJywgZnVuY3Rpb24gcmVzaXplU2tldGNoQ2FudmFzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi52aWV3ZXIucmVtb3ZlSGFuZGxlcigncm90YXRlJywgcmVzaXplU2tldGNoQ2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2V0Y2hDYW52YXNTaXplID0gc2VsZi5fY2FsY3VsYXRlU2tldGNoQ2FudmFzU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5za2V0Y2hDYW52YXMud2lkdGggPSBza2V0Y2hDYW52YXNTaXplLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNrZXRjaENhbnZhcy5oZWlnaHQgPSBza2V0Y2hDYW52YXNTaXplLnk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLnNrZXRjaENvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBzYXZlQ29udGV4dDogZnVuY3Rpb24oIHVzZVNrZXRjaCApIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZUNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ2V0Q29udGV4dCggdXNlU2tldGNoICkuc2F2ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgcmVzdG9yZUNvbnRleHQ6IGZ1bmN0aW9uKCB1c2VTa2V0Y2ggKSB7XG4gICAgICAgIGlmICghdGhpcy51c2VDYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2dldENvbnRleHQoIHVzZVNrZXRjaCApLnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIHNldENsaXA6IGZ1bmN0aW9uKHJlY3QsIHVzZVNrZXRjaCkge1xuICAgICAgICBpZiAoIXRoaXMudXNlQ2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQoIHVzZVNrZXRjaCApO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBkcmF3UmVjdGFuZ2xlOiBmdW5jdGlvbihyZWN0LCBmaWxsU3R5bGUsIHVzZVNrZXRjaCkge1xuICAgICAgICBpZiAoIXRoaXMudXNlQ2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQoIHVzZVNrZXRjaCApO1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kcyB0aGUgc2tldGNoIGNhbnZhcyBpbiB0aGUgbWFpbiBjYW52YXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLm9wYWNpdHkgVGhlIG9wYWNpdHkgb2YgdGhlIGJsZW5kaW5nLlxuICAgICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLnNjYWxlPTFdIFRoZSBzY2FsZSBhdCB3aGljaCB0aWxlcyB3ZXJlIGRyYXduIG9uXG4gICAgICogdGhlIHNrZXRjaC4gRGVmYXVsdCBpcyAxLlxuICAgICAqIFVzZSBzY2FsZSB0byBkcmF3IGF0IGEgbG93ZXIgc2NhbGUgYW5kIHRoZW4gZW5sYXJnZSBvbnRvIHRoZSBtYWluIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IFtvcHRpb25zLnRyYW5zbGF0ZV0gQSB0cmFuc2xhdGlvbiB2ZWN0b3JcbiAgICAgKiB0aGF0IHdhcyB1c2VkIHRvIGRyYXcgdGhlIHRpbGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbXBvc2l0ZU9wZXJhdGlvbl0gLSBIb3cgdGhlIGltYWdlIGlzXG4gICAgICogY29tcG9zaXRlZCBvbnRvIG90aGVyIGltYWdlczsgc2VlIGNvbXBvc2l0ZU9wZXJhdGlvbiBpblxuICAgICAqIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9IGZvciBwb3NzaWJsZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFtvcHRpb25zLmJvdW5kc10gVGhlIHBhcnQgb2YgdGhlIHNrZXRjaFxuICAgICAqIGNhbnZhcyB0byBibGVuZCBpbiB0aGUgbWFpbiBjYW52YXMuIElmIHNwZWNpZmllZCwgb3B0aW9ucy5zY2FsZSBhbmRcbiAgICAgKiBvcHRpb25zLnRyYW5zbGF0ZSBnZXQgaWdub3JlZC5cbiAgICAgKi9cbiAgICBibGVuZFNrZXRjaDogZnVuY3Rpb24ob3BhY2l0eSwgc2NhbGUsIHRyYW5zbGF0ZSwgY29tcG9zaXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gb3BhY2l0eTtcbiAgICAgICAgaWYgKCEkLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlT3BlcmF0aW9uOiBjb21wb3NpdGVPcGVyYXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnVzZUNhbnZhcyB8fCAhdGhpcy5za2V0Y2hDYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICBjb21wb3NpdGVPcGVyYXRpb24gPSBvcHRpb25zLmNvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG9wdGlvbnMuYm91bmRzO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIGlmIChjb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaENhbnZhcyxcbiAgICAgICAgICAgICAgICBib3VuZHMueCxcbiAgICAgICAgICAgICAgICBib3VuZHMueSxcbiAgICAgICAgICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBib3VuZHMueCxcbiAgICAgICAgICAgICAgICBib3VuZHMueSxcbiAgICAgICAgICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgYm91bmRzLmhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZSB8fCAxO1xuICAgICAgICAgICAgdHJhbnNsYXRlID0gb3B0aW9ucy50cmFuc2xhdGU7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0cmFuc2xhdGUgaW5zdGFuY2VvZiAkLlBvaW50ID9cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGUgOiBuZXcgJC5Qb2ludCgwLCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoRXh0ID0gMDtcbiAgICAgICAgICAgIHZhciBoZWlnaHRFeHQgPSAwO1xuICAgICAgICAgICAgaWYgKHRyYW5zbGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aERpZmYgPSB0aGlzLnNrZXRjaENhbnZhcy53aWR0aCAtIHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHREaWZmID0gdGhpcy5za2V0Y2hDYW52YXMuaGVpZ2h0IC0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHdpZHRoRXh0ID0gTWF0aC5yb3VuZCh3aWR0aERpZmYgLyAyKTtcbiAgICAgICAgICAgICAgICBoZWlnaHRFeHQgPSBNYXRoLnJvdW5kKGhlaWdodERpZmYgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgdGhpcy5za2V0Y2hDYW52YXMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueCAtIHdpZHRoRXh0ICogc2NhbGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueSAtIGhlaWdodEV4dCAqIHNjYWxlLFxuICAgICAgICAgICAgICAgICh0aGlzLmNhbnZhcy53aWR0aCArIDIgKiB3aWR0aEV4dCkgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICAodGhpcy5jYW52YXMuaGVpZ2h0ICArIDIgKiBoZWlnaHRFeHQpICogc2NhbGUsXG4gICAgICAgICAgICAgICAgLXdpZHRoRXh0LFxuICAgICAgICAgICAgICAgIC1oZWlnaHRFeHQsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggKyAyICogd2lkdGhFeHQsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ICsgMiAqIGhlaWdodEV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgZHJhd0RlYnVnSW5mbzogZnVuY3Rpb24oIHRpbGUsIGNvdW50LCBpICl7XG4gICAgICAgIGlmICggIXRoaXMudXNlQ2FudmFzICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDIgKiAkLnBpeGVsRGVuc2l0eVJhdGlvO1xuICAgICAgICBjb250ZXh0LmZvbnQgPSAnc21hbGwtY2FwcyBib2xkICcgKyAoMTMgKiAkLnBpeGVsRGVuc2l0eVJhdGlvKSArICdweCBhcmlhbCc7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmRlYnVnR3JpZENvbG9yO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZGVidWdHcmlkQ29sb3I7XG5cbiAgICAgICAgaWYgKCB0aGlzLnZpZXdwb3J0LmRlZ3JlZXMgIT09IDAgKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRGb3JSb3RhdGlvbih0aGlzLnZpZXdwb3J0LmRlZ3JlZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KFxuICAgICAgICAgICAgdGlsZS5wb3NpdGlvbi54ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgIHRpbGUucG9zaXRpb24ueSAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICB0aWxlLnNpemUueCAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICB0aWxlLnNpemUueSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgdGlsZUNlbnRlclggPSAodGlsZS5wb3NpdGlvbi54ICsgKHRpbGUuc2l6ZS54IC8gMikpICogJC5waXhlbERlbnNpdHlSYXRpbztcbiAgICAgICAgdmFyIHRpbGVDZW50ZXJZID0gKHRpbGUucG9zaXRpb24ueSArICh0aWxlLnNpemUueSAvIDIpKSAqICQucGl4ZWxEZW5zaXR5UmF0aW87XG5cbiAgICAgICAgLy8gUm90YXRlIHRoZSB0ZXh0IHRoZSByaWdodCB3YXkgYXJvdW5kLlxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSggdGlsZUNlbnRlclgsIHRpbGVDZW50ZXJZICk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKCBNYXRoLlBJIC8gMTgwICogLXRoaXMudmlld3BvcnQuZGVncmVlcyApO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSggLXRpbGVDZW50ZXJYLCAtdGlsZUNlbnRlclkgKTtcblxuICAgICAgICBpZiggdGlsZS54ID09PSAwICYmIHRpbGUueSA9PT0gMCApe1xuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICBcIlpvb206IFwiICsgdGhpcy52aWV3cG9ydC5nZXRab29tKCksXG4gICAgICAgICAgICAgICAgdGlsZS5wb3NpdGlvbi54ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgICAgICAodGlsZS5wb3NpdGlvbi55IC0gMzApICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgXCJQYW46IFwiICsgdGhpcy52aWV3cG9ydC5nZXRCb3VuZHMoKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHRpbGUucG9zaXRpb24ueCAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueSAtIDIwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgIFwiTGV2ZWw6IFwiICsgdGlsZS5sZXZlbCxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnggKyAxMCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueSArIDIwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgIFwiQ29sdW1uOiBcIiArIHRpbGUueCxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnggKyAxMCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueSArIDMwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgIFwiUm93OiBcIiArIHRpbGUueSxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnggKyAxMCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueSArIDQwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgIFwiT3JkZXI6IFwiICsgaSArIFwiIG9mIFwiICsgY291bnQsXG4gICAgICAgICAgICAodGlsZS5wb3NpdGlvbi54ICsgMTApICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnkgKyA1MCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICAgICAgICBcIlNpemU6IFwiICsgdGlsZS5zaXplLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAodGlsZS5wb3NpdGlvbi54ICsgMTApICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnkgKyA2MCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICAgICAgICBcIlBvc2l0aW9uOiBcIiArIHRpbGUucG9zaXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnggKyAxMCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueSArIDcwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIHRoaXMudmlld3BvcnQuZGVncmVlcyAhPT0gMCApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVSb3RhdGlvbkNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIGRlYnVnUmVjdDogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICBpZiAoIHRoaXMudXNlQ2FudmFzICkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMiAqICQucGl4ZWxEZW5zaXR5UmF0aW87XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5kZWJ1Z0dyaWRDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5kZWJ1Z0dyaWRDb2xvcjtcblxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KFxuICAgICAgICAgICAgICAgIHJlY3QueCAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICAgICAgcmVjdC55ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodCAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FudmFzIHNpemVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNrZXRjaCBJZiBzZXQgdG8gdHJ1ZSByZXR1cm4gdGhlIHNpemUgb2YgdGhlIHNrZXRjaCBjYW52YXNcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhlIHNpemUgb2YgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGdldENhbnZhc1NpemU6IGZ1bmN0aW9uKHNrZXRjaCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fZ2V0Q29udGV4dChza2V0Y2gpLmNhbnZhcztcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfb2Zmc2V0Rm9yUm90YXRpb246IGZ1bmN0aW9uKGRlZ3JlZXMsIHVzZVNrZXRjaCkge1xuICAgICAgICB2YXIgY3ggPSB0aGlzLmNhbnZhcy53aWR0aCAvIDI7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuY2FudmFzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9nZXRDb250ZXh0KHVzZVNrZXRjaCk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKE1hdGguUEkgLyAxODAgKiBkZWdyZWVzKTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3Jlc3RvcmVSb3RhdGlvbkNoYW5nZXM6IGZ1bmN0aW9uKHVzZVNrZXRjaCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQodXNlU2tldGNoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfY2FsY3VsYXRlQ2FudmFzU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwaXhlbERlbnNpdHlSYXRpbyA9ICQucGl4ZWxEZW5zaXR5UmF0aW87XG4gICAgICAgIHZhciB2aWV3cG9ydFNpemUgPSB0aGlzLnZpZXdwb3J0LmdldENvbnRhaW5lclNpemUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHZpZXdwb3J0U2l6ZS54ICogcGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICB5OiB2aWV3cG9ydFNpemUueSAqIHBpeGVsRGVuc2l0eVJhdGlvXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfY2FsY3VsYXRlU2tldGNoQ2FudmFzU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXNTaXplID0gdGhpcy5fY2FsY3VsYXRlQ2FudmFzU2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5nZXRSb3RhdGlvbigpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdmlld3BvcnQgaXMgcm90YXRlZCwgd2UgbmVlZCBhIGxhcmdlciBza2V0Y2ggY2FudmFzIGluIG9yZGVyXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgZWRnZSBzbW9vdGhpbmcuXG4gICAgICAgIHZhciBza2V0Y2hDYW52YXNTaXplID0gTWF0aC5jZWlsKE1hdGguc3FydChcbiAgICAgICAgICAgIGNhbnZhc1NpemUueCAqIGNhbnZhc1NpemUueCArXG4gICAgICAgICAgICBjYW52YXNTaXplLnkgKiBjYW52YXNTaXplLnkpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHNrZXRjaENhbnZhc1NpemUsXG4gICAgICAgICAgICB5OiBza2V0Y2hDYW52YXNTaXplXG4gICAgICAgIH07XG4gICAgfVxufTtcblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBWaWV3cG9ydFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuXG4vKipcbiAqIEBjbGFzcyBWaWV3cG9ydFxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBjbGFzc2Rlc2MgSGFuZGxlcyBjb29yZGluYXRlLXJlbGF0ZWQgZnVuY3Rpb25hbGl0eSAoem9vbSwgcGFuLCByb3RhdGlvbiwgZXRjLilcbiAqIGZvciBhbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXJ9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGlzIFZpZXdwb3J0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1hcmdpbnNdIC0gU2VlIHZpZXdwb3J0TWFyZ2lucyBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zcHJpbmdTdGlmZm5lc3NdIC0gU2VlIHNwcmluZ1N0aWZmbmVzcyBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmltYXRpb25UaW1lXSAtIFNlZSBhbmltYXRpb25UaW1lIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblpvb21JbWFnZVJhdGlvXSAtIFNlZSBtaW5ab29tSW1hZ2VSYXRpbyBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhab29tUGl4ZWxSYXRpb10gLSBTZWUgbWF4Wm9vbVBpeGVsUmF0aW8gaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlzaWJpbGl0eVJhdGlvXSAtIFNlZSB2aXNpYmlsaXR5UmF0aW8gaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndyYXBIb3Jpem9udGFsXSAtIFNlZSB3cmFwSG9yaXpvbnRhbCBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud3JhcFZlcnRpY2FsXSAtIFNlZSB3cmFwVmVydGljYWwgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVmYXVsdFpvb21MZXZlbF0gLSBTZWUgZGVmYXVsdFpvb21MZXZlbCBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5ab29tTGV2ZWxdIC0gU2VlIG1pblpvb21MZXZlbCBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhab29tTGV2ZWxdIC0gU2VlIG1heFpvb21MZXZlbCBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZWdyZWVzXSAtIFNlZSBkZWdyZWVzIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ob21lRmlsbHNWaWV3ZXJdIC0gU2VlIGhvbWVGaWxsc1ZpZXdlciBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqL1xuJC5WaWV3cG9ydCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgLy9iYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBwb3NpdGlvbmFsIGFyZ3Mgd2hpbGUgcHJlZmVyaW5nIG1vcmVcbiAgICAvL2lkaW9tYXRpYyBqYXZhc2NyaXB0IG9wdGlvbnMgb2JqZWN0IGFzIHRoZSBvbmx5IGFyZ3VtZW50XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYoICBhcmdzLmxlbmd0aCAmJiBhcmdzWyAwIF0gaW5zdGFuY2VvZiAkLlBvaW50ICl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb250YWluZXJTaXplOiAgYXJnc1sgMCBdLFxuICAgICAgICAgICAgY29udGVudFNpemU6ICAgIGFyZ3NbIDEgXSxcbiAgICAgICAgICAgIGNvbmZpZzogICAgICAgICBhcmdzWyAyIF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvL29wdGlvbnMuY29uZmlnIGFuZCB0aGUgZ2VuZXJhbCBjb25maWcgYXJndW1lbnQgYXJlIGRlcHJlY2F0ZWRcbiAgICAvL2luIGZhdm9yIG9mIHRoZSBtb3JlIGRpcmVjdCBzcGVjaWZpY2F0aW9uIG9mIG9wdGlvbmFsIHNldHRpbmdzXG4gICAgLy9iZWluZyBwYXNzZWQgZGlyZWN0bHkgb24gdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgaWYgKCBvcHRpb25zLmNvbmZpZyApe1xuICAgICAgICAkLmV4dGVuZCggdHJ1ZSwgb3B0aW9ucywgb3B0aW9ucy5jb25maWcgKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY29uZmlnO1xuICAgIH1cblxuICAgIHRoaXMuX21hcmdpbnMgPSAkLmV4dGVuZCh7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMFxuICAgIH0sIG9wdGlvbnMubWFyZ2lucyB8fCB7fSk7XG5cbiAgICBkZWxldGUgb3B0aW9ucy5tYXJnaW5zO1xuXG4gICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIHtcblxuICAgICAgICAvL3JlcXVpcmVkIHNldHRpbmdzXG4gICAgICAgIGNvbnRhaW5lclNpemU6ICAgICAgbnVsbCxcbiAgICAgICAgY29udGVudFNpemU6ICAgICAgICBudWxsLFxuXG4gICAgICAgIC8vaW50ZXJuYWwgc3RhdGUgcHJvcGVydGllc1xuICAgICAgICB6b29tUG9pbnQ6ICAgICAgICAgIG51bGwsXG4gICAgICAgIHZpZXdlcjogICAgICAgICAgIG51bGwsXG5cbiAgICAgICAgLy9jb25maWd1cmFibGUgb3B0aW9uc1xuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6ICAgICQuREVGQVVMVF9TRVRUSU5HUy5zcHJpbmdTdGlmZm5lc3MsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6ICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLmFuaW1hdGlvblRpbWUsXG4gICAgICAgIG1pblpvb21JbWFnZVJhdGlvOiAgJC5ERUZBVUxUX1NFVFRJTkdTLm1pblpvb21JbWFnZVJhdGlvLFxuICAgICAgICBtYXhab29tUGl4ZWxSYXRpbzogICQuREVGQVVMVF9TRVRUSU5HUy5tYXhab29tUGl4ZWxSYXRpbyxcbiAgICAgICAgdmlzaWJpbGl0eVJhdGlvOiAgICAkLkRFRkFVTFRfU0VUVElOR1MudmlzaWJpbGl0eVJhdGlvLFxuICAgICAgICB3cmFwSG9yaXpvbnRhbDogICAgICQuREVGQVVMVF9TRVRUSU5HUy53cmFwSG9yaXpvbnRhbCxcbiAgICAgICAgd3JhcFZlcnRpY2FsOiAgICAgICAkLkRFRkFVTFRfU0VUVElOR1Mud3JhcFZlcnRpY2FsLFxuICAgICAgICBkZWZhdWx0Wm9vbUxldmVsOiAgICQuREVGQVVMVF9TRVRUSU5HUy5kZWZhdWx0Wm9vbUxldmVsLFxuICAgICAgICBtaW5ab29tTGV2ZWw6ICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5taW5ab29tTGV2ZWwsXG4gICAgICAgIG1heFpvb21MZXZlbDogICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLm1heFpvb21MZXZlbCxcbiAgICAgICAgZGVncmVlczogICAgICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuZGVncmVlcyxcbiAgICAgICAgaG9tZUZpbGxzVmlld2VyOiAgICAkLkRFRkFVTFRfU0VUVElOR1MuaG9tZUZpbGxzVmlld2VyXG5cbiAgICB9LCBvcHRpb25zICk7XG5cbiAgICB0aGlzLl91cGRhdGVDb250YWluZXJJbm5lclNpemUoKTtcblxuICAgIHRoaXMuY2VudGVyU3ByaW5nWCA9IG5ldyAkLlNwcmluZyh7XG4gICAgICAgIGluaXRpYWw6IDAsXG4gICAgICAgIHNwcmluZ1N0aWZmbmVzczogdGhpcy5zcHJpbmdTdGlmZm5lc3MsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6ICAgdGhpcy5hbmltYXRpb25UaW1lXG4gICAgfSk7XG4gICAgdGhpcy5jZW50ZXJTcHJpbmdZID0gbmV3ICQuU3ByaW5nKHtcbiAgICAgICAgaW5pdGlhbDogMCxcbiAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiB0aGlzLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogICB0aGlzLmFuaW1hdGlvblRpbWVcbiAgICB9KTtcbiAgICB0aGlzLnpvb21TcHJpbmcgICAgPSBuZXcgJC5TcHJpbmcoe1xuICAgICAgICBleHBvbmVudGlhbDogdHJ1ZSxcbiAgICAgICAgaW5pdGlhbDogMSxcbiAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiB0aGlzLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogICB0aGlzLmFuaW1hdGlvblRpbWVcbiAgICB9KTtcblxuICAgIHRoaXMuX29sZENlbnRlclggPSB0aGlzLmNlbnRlclNwcmluZ1guY3VycmVudC52YWx1ZTtcbiAgICB0aGlzLl9vbGRDZW50ZXJZID0gdGhpcy5jZW50ZXJTcHJpbmdZLmN1cnJlbnQudmFsdWU7XG4gICAgdGhpcy5fb2xkWm9vbSAgICA9IHRoaXMuem9vbVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgdGhpcy5fc2V0Q29udGVudEJvdW5kcyhuZXcgJC5SZWN0KDAsIDAsIDEsIDEpLCAxKTtcblxuICAgIHRoaXMuZ29Ib21lKHRydWUpO1xuICAgIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uVmlld3BvcnQucHJvdG90eXBlICovXG4kLlZpZXdwb3J0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydCdzIGhvbWUgYm91bmRzIGFuZCBjb25zdHJhaW50cyBmb3IgdGhlIGdpdmVuIGNvbnRlbnQgc2l6ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGNvbnRlbnRTaXplIC0gc2l6ZSBvZiB0aGUgY29udGVudCBpbiBjb250ZW50IHVuaXRzXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpyZXNldC1zaXplXG4gICAgICovXG4gICAgcmVzZXRDb250ZW50U2l6ZTogZnVuY3Rpb24oY29udGVudFNpemUpIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChjb250ZW50U2l6ZSwgXCJbVmlld3BvcnQucmVzZXRDb250ZW50U2l6ZV0gY29udGVudFNpemUgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoY29udGVudFNpemUgaW5zdGFuY2VvZiAkLlBvaW50LCBcIltWaWV3cG9ydC5yZXNldENvbnRlbnRTaXplXSBjb250ZW50U2l6ZSBtdXN0IGJlIGFuIE9wZW5TZWFkcmFnb24uUG9pbnRcIik7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoY29udGVudFNpemUueCA+IDAsIFwiW1ZpZXdwb3J0LnJlc2V0Q29udGVudFNpemVdIGNvbnRlbnRTaXplLnggbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChjb250ZW50U2l6ZS55ID4gMCwgXCJbVmlld3BvcnQucmVzZXRDb250ZW50U2l6ZV0gY29udGVudFNpemUueSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuXG4gICAgICAgIHRoaXMuX3NldENvbnRlbnRCb3VuZHMobmV3ICQuUmVjdCgwLCAwLCAxLCBjb250ZW50U2l6ZS55IC8gY29udGVudFNpemUueCksIGNvbnRlbnRTaXplLngpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIHNldEhvbWVCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgY29udGVudEZhY3Rvcikge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXCJbVmlld3BvcnQuc2V0SG9tZUJvdW5kc10gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOyBUaGUgY29udGVudCBib3VuZHMgc2hvdWxkIG5vdCBiZSBzZXQgbWFudWFsbHkuXCIpO1xuICAgICAgICB0aGlzLl9zZXRDb250ZW50Qm91bmRzKGJvdW5kcywgY29udGVudEZhY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIFNldCB0aGUgdmlld3BvcnQncyBjb250ZW50IGJvdW5kc1xuICAgIC8vIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSBib3VuZHMgLSB0aGUgbmV3IGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlc1xuICAgIC8vIHdpdGhvdXQgcm90YXRpb25cbiAgICAvLyBAcGFyYW0ge051bWJlcn0gY29udGVudEZhY3RvciAtIGhvdyBtYW55IGNvbnRlbnQgdW5pdHMgcGVyIHZpZXdwb3J0IHVuaXRcbiAgICAvLyBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6cmVzZXQtc2l6ZVxuICAgIC8vIEBwcml2YXRlXG4gICAgX3NldENvbnRlbnRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgY29udGVudEZhY3Rvcikge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGJvdW5kcywgXCJbVmlld3BvcnQuX3NldENvbnRlbnRCb3VuZHNdIGJvdW5kcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChib3VuZHMgaW5zdGFuY2VvZiAkLlJlY3QsIFwiW1ZpZXdwb3J0Ll9zZXRDb250ZW50Qm91bmRzXSBib3VuZHMgbXVzdCBiZSBhbiBPcGVuU2VhZHJhZ29uLlJlY3RcIik7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoYm91bmRzLndpZHRoID4gMCwgXCJbVmlld3BvcnQuX3NldENvbnRlbnRCb3VuZHNdIGJvdW5kcy53aWR0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGJvdW5kcy5oZWlnaHQgPiAwLCBcIltWaWV3cG9ydC5fc2V0Q29udGVudEJvdW5kc10gYm91bmRzLmhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZSA9IGJvdW5kcy5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZU5vUm90YXRlID0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLmdldFNpemUoKS50aW1lcyhcbiAgICAgICAgICAgIGNvbnRlbnRGYWN0b3IpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRlbnRCb3VuZHMgPSBib3VuZHMucm90YXRlKHRoaXMuZGVncmVlcykuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgdGhpcy5fY29udGVudFNpemUgPSB0aGlzLl9jb250ZW50Qm91bmRzLmdldFNpemUoKS50aW1lcyhjb250ZW50RmFjdG9yKTtcbiAgICAgICAgdGhpcy5fY29udGVudEFzcGVjdFJhdGlvID0gdGhpcy5fY29udGVudFNpemUueCAvIHRoaXMuX2NvbnRlbnRTaXplLnk7XG5cbiAgICAgICAgaWYgKHRoaXMudmlld2VyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIncyBjb250ZW50IHNpemUgb3IgaG9tZSBib3VuZHMgYXJlIHJlc2V0XG4gICAgICAgICAgICAgKiAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I3Jlc2V0Q29udGVudFNpemV9KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgcmVzZXQtc2l6ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBjb250ZW50U2l6ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlJlY3R9IGNvbnRlbnRCb3VuZHMgLSBDb250ZW50IGJvdW5kcy5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5SZWN0fSBob21lQm91bmRzIC0gQ29udGVudCBib3VuZHMuXG4gICAgICAgICAgICAgKiBEZXByZWNhdGVkIHVzZSBjb250ZW50Qm91bmRzIGluc3RlYWQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29udGVudEZhY3RvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlci5yYWlzZUV2ZW50KCdyZXNldC1zaXplJywge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTaXplOiB0aGlzLl9jb250ZW50U2l6ZU5vUm90YXRlLmNsb25lKCksXG4gICAgICAgICAgICAgICAgY29udGVudEZhY3RvcjogY29udGVudEZhY3RvcixcbiAgICAgICAgICAgICAgICBob21lQm91bmRzOiB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBjb250ZW50Qm91bmRzOiB0aGlzLl9jb250ZW50Qm91bmRzLmNsb25lKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhvbWUgem9vbSBpbiBcInZpZXdwb3J0IHpvb21cIiB2YWx1ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaG9tZSB6b29tIGluIFwidmlld3BvcnQgem9vbVwiLlxuICAgICAqL1xuICAgIGdldEhvbWVab29tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFpvb21MZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFpvb21MZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhc3BlY3RGYWN0b3IgPSB0aGlzLl9jb250ZW50QXNwZWN0UmF0aW8gLyB0aGlzLmdldEFzcGVjdFJhdGlvKCk7XG4gICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgIGlmICh0aGlzLmhvbWVGaWxsc1ZpZXdlcikgeyAvLyBmaWxsIHRoZSB2aWV3ZXIgYW5kIGNsaXAgdGhlIGltYWdlXG4gICAgICAgICAgICBvdXRwdXQgPSBhc3BlY3RGYWN0b3IgPj0gMSA/IGFzcGVjdEZhY3RvciA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBhc3BlY3RGYWN0b3IgPj0gMSA/IDEgOiBhc3BlY3RGYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0IC8gdGhpcy5fY29udGVudEJvdW5kcy53aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaG9tZSBib3VuZHMgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gVGhlIGhvbWUgYm91bmRzIGluIHZld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0SG9tZUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhvbWVCb3VuZHNOb1JvdGF0ZSgpLnJvdGF0ZSgtdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaG9tZSBib3VuZHMgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgaWdub3JlcyB0aGUgdmlld3BvcnQgcm90YXRpb24uIFVzZVxuICAgICAqIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I2dldEhvbWVCb3VuZHN9IHRvIHRha2UgaXQgaW50byBhY2NvdW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFRoZSBob21lIGJvdW5kcyBpbiB2ZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldEhvbWVCb3VuZHNOb1JvdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9jb250ZW50Qm91bmRzLmdldENlbnRlcigpO1xuICAgICAgICB2YXIgd2lkdGggID0gMS4wIC8gdGhpcy5nZXRIb21lWm9vbSgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkdGggLyB0aGlzLmdldEFzcGVjdFJhdGlvKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBjZW50ZXIueCAtICh3aWR0aCAvIDIuMCksXG4gICAgICAgICAgICBjZW50ZXIueSAtIChoZWlnaHQgLyAyLjApLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpob21lXG4gICAgICovXG4gICAgZ29Ib21lOiBmdW5jdGlvbihpbW1lZGlhdGVseSkge1xuICAgICAgICBpZiAodGhpcy52aWV3ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIFwiaG9tZVwiIG9wZXJhdGlvbiBvY2N1cnMgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNnb0hvbWV9KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgaG9tZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlci5yYWlzZUV2ZW50KCdob21lJywge1xuICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5OiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZml0Qm91bmRzKHRoaXMuZ2V0SG9tZUJvdW5kcygpLCBpbW1lZGlhdGVseSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldE1pblpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaG9tZVpvb20gPSB0aGlzLmdldEhvbWVab29tKCksXG4gICAgICAgICAgICB6b29tID0gdGhpcy5taW5ab29tTGV2ZWwgP1xuICAgICAgICAgICAgdGhpcy5taW5ab29tTGV2ZWwgOlxuICAgICAgICAgICAgICAgIHRoaXMubWluWm9vbUltYWdlUmF0aW8gKiBob21lWm9vbTtcblxuICAgICAgICByZXR1cm4gem9vbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0TWF4Wm9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB6b29tID0gdGhpcy5tYXhab29tTGV2ZWw7XG4gICAgICAgIGlmICghem9vbSkge1xuICAgICAgICAgICAgem9vbSA9IHRoaXMuX2NvbnRlbnRTaXplLnggKiB0aGlzLm1heFpvb21QaXhlbFJhdGlvIC8gdGhpcy5fY29udGFpbmVySW5uZXJTaXplLng7XG4gICAgICAgICAgICB6b29tIC89IHRoaXMuX2NvbnRlbnRCb3VuZHMud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoIHpvb20sIHRoaXMuZ2V0SG9tZVpvb20oKSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXRBc3BlY3RSYXRpbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJJbm5lclNpemUueCAvIHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldENvbnRhaW5lclNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUueCxcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZS55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXJnaW5zIHB1c2ggdGhlIFwiaG9tZVwiIHJlZ2lvbiBpbiBmcm9tIHRoZSBzaWRlcyBieSB0aGUgc3BlY2lmaWVkIGFtb3VudHMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUHJvcGVydGllcyAoTnVtYmVycywgaW4gc2NyZWVuIGNvb3JkaW5hdGVzKTogbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLlxuICAgICAqL1xuICAgIGdldE1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIHRoaXMuX21hcmdpbnMpOyAvLyBNYWtlIGEgY29weSBzbyB3ZSBhcmUgbm90IHJldHVybmluZyBvdXIgb3JpZ2luYWxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcmdpbnMgcHVzaCB0aGUgXCJob21lXCIgcmVnaW9uIGluIGZyb20gdGhlIHNpZGVzIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFyZ2lucyAtIFByb3BlcnRpZXMgKE51bWJlcnMsIGluIHNjcmVlbiBjb29yZGluYXRlcyk6IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbS5cbiAgICAgKi9cbiAgICBzZXRNYXJnaW5zOiBmdW5jdGlvbihtYXJnaW5zKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoJC50eXBlKG1hcmdpbnMpID09PSAnb2JqZWN0JywgJ1tWaWV3cG9ydC5zZXRNYXJnaW5zXSBtYXJnaW5zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5fbWFyZ2lucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9LCBtYXJnaW5zKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJJbm5lclNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMudmlld2VyKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdlci5mb3JjZVJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgdmlzaWJsZSBhcmVhIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY3VycmVudCAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247IGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFRoZSBsb2NhdGlvbiB5b3UgYXJlIHpvb21lZC9wYW5uZWQgdG8sIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHNOb1JvdGF0ZShjdXJyZW50KS5yb3RhdGUoLXRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgdmlzaWJsZSBhcmVhIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIGlnbm9yZXMgdGhlIHZpZXdwb3J0IHJvdGF0aW9uLiBVc2VcbiAgICAgKiB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNnZXRCb3VuZHN9IHRvIHRha2UgaXQgaW50byBhY2NvdW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY3VycmVudCAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247IGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFRoZSBsb2NhdGlvbiB5b3UgYXJlIHpvb21lZC9wYW5uZWQgdG8sIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldEJvdW5kc05vUm90YXRlOiBmdW5jdGlvbihjdXJyZW50KSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcihjdXJyZW50KTtcbiAgICAgICAgdmFyIHdpZHRoICA9IDEuMCAvIHRoaXMuZ2V0Wm9vbShjdXJyZW50KTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHdpZHRoIC8gdGhpcy5nZXRBc3BlY3RSYXRpbygpO1xuXG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgY2VudGVyLnggLSAod2lkdGggLyAyLjApLFxuICAgICAgICAgICAgY2VudGVyLnkgLSAoaGVpZ2h0IC8gMi4wKSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY3VycmVudCAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247IGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFRoZSBsb2NhdGlvbiB5b3UgYXJlIHpvb21lZC9wYW5uZWQgdG8sXG4gICAgICogaW5jbHVkaW5nIHRoZSBzcGFjZSB0YWtlbiBieSBtYXJnaW5zLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRCb3VuZHNXaXRoTWFyZ2luczogZnVuY3Rpb24oY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHNOb1JvdGF0ZVdpdGhNYXJnaW5zKGN1cnJlbnQpLnJvdGF0ZShcbiAgICAgICAgICAgIC10aGlzLmdldFJvdGF0aW9uKCksIHRoaXMuZ2V0Q2VudGVyKGN1cnJlbnQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjdXJyZW50IC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjsgZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gVGhlIGxvY2F0aW9uIHlvdSBhcmUgem9vbWVkL3Bhbm5lZCB0byxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIHNwYWNlIHRha2VuIGJ5IG1hcmdpbnMsIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldEJvdW5kc05vUm90YXRlV2l0aE1hcmdpbnM6IGZ1bmN0aW9uKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzTm9Sb3RhdGUoY3VycmVudCk7XG4gICAgICAgIHZhciBmYWN0b3IgPSB0aGlzLl9jb250YWluZXJJbm5lclNpemUueCAqIHRoaXMuZ2V0Wm9vbShjdXJyZW50KTtcbiAgICAgICAgYm91bmRzLnggLT0gdGhpcy5fbWFyZ2lucy5sZWZ0IC8gZmFjdG9yO1xuICAgICAgICBib3VuZHMueSAtPSB0aGlzLl9tYXJnaW5zLnRvcCAvIGZhY3RvcjtcbiAgICAgICAgYm91bmRzLndpZHRoICs9ICh0aGlzLl9tYXJnaW5zLmxlZnQgKyB0aGlzLl9tYXJnaW5zLnJpZ2h0KSAvIGZhY3RvcjtcbiAgICAgICAgYm91bmRzLmhlaWdodCArPSAodGhpcy5fbWFyZ2lucy50b3AgKyB0aGlzLl9tYXJnaW5zLmJvdHRvbSkgLyBmYWN0b3I7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY3VycmVudCAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247IGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24oIGN1cnJlbnQgKSB7XG4gICAgICAgIHZhciBjZW50ZXJDdXJyZW50ID0gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdYLmN1cnJlbnQudmFsdWUsXG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdZLmN1cnJlbnQudmFsdWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjZW50ZXJUYXJnZXQgPSBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1gudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyU3ByaW5nWS50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBvbGRab29tUGl4ZWwsXG4gICAgICAgICAgICB6b29tLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICBuZXdab29tUGl4ZWwsXG4gICAgICAgICAgICBkZWx0YVpvb21QaXhlbHMsXG4gICAgICAgICAgICBkZWx0YVpvb21Qb2ludHM7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbnRlckN1cnJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoICF0aGlzLnpvb21Qb2ludCApIHtcbiAgICAgICAgICAgIHJldHVybiBjZW50ZXJUYXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRab29tUGl4ZWwgPSB0aGlzLnBpeGVsRnJvbVBvaW50KHRoaXMuem9vbVBvaW50LCB0cnVlKTtcblxuICAgICAgICB6b29tICAgID0gdGhpcy5nZXRab29tKCk7XG4gICAgICAgIHdpZHRoICAgPSAxLjAgLyB6b29tO1xuICAgICAgICBoZWlnaHQgID0gd2lkdGggLyB0aGlzLmdldEFzcGVjdFJhdGlvKCk7XG4gICAgICAgIGJvdW5kcyAgPSBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgY2VudGVyQ3VycmVudC54IC0gd2lkdGggLyAyLjAsXG4gICAgICAgICAgICBjZW50ZXJDdXJyZW50LnkgLSBoZWlnaHQgLyAyLjAsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIG5ld1pvb21QaXhlbCA9IHRoaXMuX3BpeGVsRnJvbVBvaW50KHRoaXMuem9vbVBvaW50LCBib3VuZHMpO1xuICAgICAgICBkZWx0YVpvb21QaXhlbHMgPSBuZXdab29tUGl4ZWwubWludXMoIG9sZFpvb21QaXhlbCApO1xuICAgICAgICBkZWx0YVpvb21Qb2ludHMgPSBkZWx0YVpvb21QaXhlbHMuZGl2aWRlKCB0aGlzLl9jb250YWluZXJJbm5lclNpemUueCAqIHpvb20gKTtcblxuICAgICAgICByZXR1cm4gY2VudGVyVGFyZ2V0LnBsdXMoIGRlbHRhWm9vbVBvaW50cyApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGN1cnJlbnQgLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uOyBkZWZhdWx0cyB0byBmYWxzZSAodGFyZ2V0IGxvY2F0aW9uKS5cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbiggY3VycmVudCApIHtcbiAgICAgICAgaWYgKCBjdXJyZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9vbVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9vbVNwcmluZy50YXJnZXQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9hcHBseVpvb21Db25zdHJhaW50czogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgICAgICBNYXRoLm1pbih6b29tLCB0aGlzLmdldE1heFpvb20oKSksXG4gICAgICAgICAgICB0aGlzLmdldE1pblpvb20oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW1tZWRpYXRlbHlcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlJlY3R9IGNvbnN0cmFpbmVkIGJvdW5kcy5cbiAgICAgKi9cbiAgICBfYXBwbHlCb3VuZGFyeUNvbnN0cmFpbnRzOiBmdW5jdGlvbihib3VuZHMsIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBuZXdCb3VuZHMgPSBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgICAgIGJvdW5kcy54LFxuICAgICAgICAgICAgICAgIGJvdW5kcy55LFxuICAgICAgICAgICAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgICAgICBib3VuZHMuaGVpZ2h0KTtcblxuICAgICAgICBpZiAodGhpcy53cmFwSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgLy9kbyBub3RoaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbFRocmVzaG9sZCA9IHRoaXMudmlzaWJpbGl0eVJhdGlvICogbmV3Qm91bmRzLndpZHRoO1xuICAgICAgICAgICAgdmFyIGJvdW5kc1JpZ2h0ID0gbmV3Qm91bmRzLnggKyBuZXdCb3VuZHMud2lkdGg7XG4gICAgICAgICAgICB2YXIgY29udGVudFJpZ2h0ID0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLnggKyB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgbGVmdER4ID0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLnggLSBib3VuZHNSaWdodCArIGhvcml6b250YWxUaHJlc2hvbGQ7XG4gICAgICAgICAgICB2YXIgcmlnaHREeCA9IGNvbnRlbnRSaWdodCAtIG5ld0JvdW5kcy54IC0gaG9yaXpvbnRhbFRocmVzaG9sZDtcblxuICAgICAgICAgICAgaWYgKGhvcml6b250YWxUaHJlc2hvbGQgPiB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMueCArPSAobGVmdER4ICsgcmlnaHREeCkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodER4IDwgMCkge1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcy54ICs9IHJpZ2h0RHg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnREeCA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMueCArPSBsZWZ0RHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53cmFwVmVydGljYWwpIHtcbiAgICAgICAgICAgIC8vZG8gbm90aGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsVGhyZXNob2xkICAgPSB0aGlzLnZpc2liaWxpdHlSYXRpbyAqIG5ld0JvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgYm91bmRzQm90dG9tID0gbmV3Qm91bmRzLnkgKyBuZXdCb3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRCb3R0b20gPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUueSArIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgdG9wRHkgPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUueSAtIGJvdW5kc0JvdHRvbSArIHZlcnRpY2FsVGhyZXNob2xkO1xuICAgICAgICAgICAgdmFyIGJvdHRvbUR5ID0gY29udGVudEJvdHRvbSAtIG5ld0JvdW5kcy55IC0gdmVydGljYWxUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbFRocmVzaG9sZCA+IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMueSArPSAodG9wRHkgKyBib3R0b21EeSkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChib3R0b21EeSA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMueSArPSBib3R0b21EeTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9wRHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRzLnkgKz0gdG9wRHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy52aWV3ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdwb3J0IGNvbnN0cmFpbnRzIGFyZSBhcHBsaWVkIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld3BvcnQjYXBwbHlDb25zdHJhaW50c30pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBjb25zdHJhaW5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy52aWV3ZXIucmFpc2VFdmVudCggJ2NvbnN0cmFpbicsIHtcbiAgICAgICAgICAgICAgICBpbW1lZGlhdGVseTogaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld0JvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5mb3JjZXMgdGhlIG1pblpvb20sIG1heFpvb20gYW5kIHZpc2liaWxpdHlSYXRpbyBjb25zdHJhaW50cyBieVxuICAgICAqIHpvb21pbmcgYW5kIHBhbm5pbmcgdG8gdGhlIGNsb3Nlc3QgYWNjZXB0YWJsZSB6b29tIGFuZCBsb2NhdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmNvbnN0cmFpblxuICAgICAqL1xuICAgIGFwcGx5Q29uc3RyYWludHM6IGZ1bmN0aW9uKGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBhY3R1YWxab29tID0gdGhpcy5nZXRab29tKCk7XG4gICAgICAgIHZhciBjb25zdHJhaW5lZFpvb20gPSB0aGlzLl9hcHBseVpvb21Db25zdHJhaW50cyhhY3R1YWxab29tKTtcblxuICAgICAgICBpZiAoYWN0dWFsWm9vbSAhPT0gY29uc3RyYWluZWRab29tKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21Ubyhjb25zdHJhaW5lZFpvb20sIHRoaXMuem9vbVBvaW50LCBpbW1lZGlhdGVseSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHNOb1JvdGF0ZSgpO1xuICAgICAgICB2YXIgY29uc3RyYWluZWRCb3VuZHMgPSB0aGlzLl9hcHBseUJvdW5kYXJ5Q29uc3RyYWludHMoXG4gICAgICAgICAgICBib3VuZHMsIGltbWVkaWF0ZWx5KTtcblxuICAgICAgICBpZiAoYm91bmRzLnggIT09IGNvbnN0cmFpbmVkQm91bmRzLnggfHxcbiAgICAgICAgICAgIGJvdW5kcy55ICE9PSBjb25zdHJhaW5lZEJvdW5kcy55IHx8XG4gICAgICAgICAgICBpbW1lZGlhdGVseSkge1xuICAgICAgICAgICAgdGhpcy5maXRCb3VuZHMoXG4gICAgICAgICAgICAgICAgY29uc3RyYWluZWRCb3VuZHMucm90YXRlKC10aGlzLmdldFJvdGF0aW9uKCkpLFxuICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNhcHBseUNvbnN0cmFpbnRzfVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6Y29uc3RyYWluXG4gICAgICovXG4gICAgZW5zdXJlVmlzaWJsZTogZnVuY3Rpb24oaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDb25zdHJhaW50cyhpbW1lZGlhdGVseSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChpbW1lZGlhdGVseT1mYWxzZSwgY29uc3RyYWludHM9ZmFsc2UpXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqL1xuICAgIF9maXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGltbWVkaWF0ZWx5ID0gb3B0aW9ucy5pbW1lZGlhdGVseSB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gb3B0aW9ucy5jb25zdHJhaW50cyB8fCBmYWxzZTtcblxuICAgICAgICB2YXIgYXNwZWN0ID0gdGhpcy5nZXRBc3BlY3RSYXRpbygpO1xuICAgICAgICB2YXIgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgd2lkdGggYW5kIGhlaWdodCBvZiBib3VuZGluZyBib3guXG4gICAgICAgIHZhciBuZXdCb3VuZHMgPSBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgYm91bmRzLngsXG4gICAgICAgICAgICBib3VuZHMueSxcbiAgICAgICAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICBib3VuZHMuZGVncmVlcyArIHRoaXMuZ2V0Um90YXRpb24oKSlcbiAgICAgICAgICAgIC5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIGlmIChuZXdCb3VuZHMuZ2V0QXNwZWN0UmF0aW8oKSA+PSBhc3BlY3QpIHtcbiAgICAgICAgICAgIG5ld0JvdW5kcy5oZWlnaHQgPSBuZXdCb3VuZHMud2lkdGggLyBhc3BlY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdCb3VuZHMud2lkdGggPSBuZXdCb3VuZHMuaGVpZ2h0ICogYXNwZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB4IGFuZCB5IGZyb20gd2lkdGgsIGhlaWdodCBhbmQgY2VudGVyIHBvc2l0aW9uXG4gICAgICAgIG5ld0JvdW5kcy54ID0gY2VudGVyLnggLSBuZXdCb3VuZHMud2lkdGggLyAyO1xuICAgICAgICBuZXdCb3VuZHMueSA9IGNlbnRlci55IC0gbmV3Qm91bmRzLmhlaWdodCAvIDI7XG4gICAgICAgIHZhciBuZXdab29tID0gMS4wIC8gbmV3Qm91bmRzLndpZHRoO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50cykge1xuICAgICAgICAgICAgdmFyIG5ld0JvdW5kc0FzcGVjdFJhdGlvID0gbmV3Qm91bmRzLmdldEFzcGVjdFJhdGlvKCk7XG4gICAgICAgICAgICB2YXIgbmV3Q29uc3RyYWluZWRab29tID0gdGhpcy5fYXBwbHlab29tQ29uc3RyYWludHMobmV3Wm9vbSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdab29tICE9PSBuZXdDb25zdHJhaW5lZFpvb20pIHtcbiAgICAgICAgICAgICAgICBuZXdab29tID0gbmV3Q29uc3RyYWluZWRab29tO1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcy53aWR0aCA9IDEuMCAvIG5ld1pvb207XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRzLnggPSBjZW50ZXIueCAtIG5ld0JvdW5kcy53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRzLmhlaWdodCA9IG5ld0JvdW5kcy53aWR0aCAvIG5ld0JvdW5kc0FzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcy55ID0gY2VudGVyLnkgLSBuZXdCb3VuZHMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3Qm91bmRzID0gdGhpcy5fYXBwbHlCb3VuZGFyeUNvbnN0cmFpbnRzKG5ld0JvdW5kcywgaW1tZWRpYXRlbHkpO1xuICAgICAgICAgICAgY2VudGVyID0gbmV3Qm91bmRzLmdldENlbnRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICB0aGlzLnBhblRvKGNlbnRlciwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56b29tVG8obmV3Wm9vbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhblRvKHRoaXMuZ2V0Q2VudGVyKHRydWUpLCB0cnVlKTtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKHRydWUpLCBudWxsLCB0cnVlKTtcblxuICAgICAgICB2YXIgb2xkQm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgdmFyIG9sZFpvb20gICA9IHRoaXMuZ2V0Wm9vbSgpO1xuXG4gICAgICAgIGlmIChvbGRab29tID09PSAwIHx8IE1hdGguYWJzKG5ld1pvb20gLyBvbGRab29tIC0gMSkgPCAwLjAwMDAwMDAxKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21UbyhuZXdab29tLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhblRvKGNlbnRlciwgaW1tZWRpYXRlbHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3Qm91bmRzID0gbmV3Qm91bmRzLnJvdGF0ZSgtdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZVBvaW50ID0gbmV3Qm91bmRzLmdldFRvcExlZnQoKS50aW1lcyhuZXdab29tKVxuICAgICAgICAgICAgLm1pbnVzKG9sZEJvdW5kcy5nZXRUb3BMZWZ0KCkudGltZXMob2xkWm9vbSkpXG4gICAgICAgICAgICAuZGl2aWRlKG5ld1pvb20gLSBvbGRab29tKTtcblxuICAgICAgICByZXR1cm4gdGhpcy56b29tVG8obmV3Wm9vbSwgcmVmZXJlbmNlUG9pbnQsIGltbWVkaWF0ZWx5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIHZpZXdwb3J0IHpvb20gYW5kIHBhbiBzbyB0aGF0IHRoZSBzcGVjaWZpZWQgYm91bmRzIHRha2VcbiAgICAgKiBhcyBtdWNoIHNwYWNlIGFzIHBvc3NpYmxlIGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpZ25vcmVzIHRoZSBjb25zdHJhaW50cyAobWluWm9vbSwgbWF4Wm9vbSBhbmRcbiAgICAgKiB2aXNpYmlsaXR5UmF0aW8pLlxuICAgICAqIFVzZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNmaXRCb3VuZHNXaXRoQ29uc3RyYWludHN9IHRvIGVuZm9yY2VcbiAgICAgKiB0aGVtLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMsIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXRCb3VuZHMoYm91bmRzLCB7XG4gICAgICAgICAgICBpbW1lZGlhdGVseTogaW1tZWRpYXRlbHksXG4gICAgICAgICAgICBjb25zdHJhaW50czogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSB2aWV3cG9ydCB6b29tIGFuZCBwYW4gc28gdGhhdCB0aGUgc3BlY2lmaWVkIGJvdW5kcyB0YWtlXG4gICAgICogYXMgbXVjaCBzcGFjZSBhcyBwb3NzaWJsZSBpbiB0aGUgdmlld3BvcnQgd2hpbGUgZW5mb3JjaW5nIHRoZSBjb25zdHJhaW50c1xuICAgICAqIChtaW5ab29tLCBtYXhab29tIGFuZCB2aXNpYmlsaXR5UmF0aW8pLlxuICAgICAqIE5vdGU6IGJlY2F1c2UgdGhpcyBtZXRob2QgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRzLCBwYXJ0IG9mIHRoZVxuICAgICAqIHByb3ZpZGVkIGJvdW5kcyBtYXkgZW5kIHVwIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqIFVzZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNmaXRCb3VuZHN9IHRvIGlnbm9yZSB0aGVtLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgZml0Qm91bmRzV2l0aENvbnN0cmFpbnRzOiBmdW5jdGlvbihib3VuZHMsIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXRCb3VuZHMoYm91bmRzLCB7XG4gICAgICAgICAgICBpbW1lZGlhdGVseTogaW1tZWRpYXRlbHksXG4gICAgICAgICAgICBjb25zdHJhaW50czogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbXMgc28gdGhlIGltYWdlIGp1c3QgZmlsbHMgdGhlIHZpZXdlciB2ZXJ0aWNhbGx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW1tZWRpYXRlbHlcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgZml0VmVydGljYWxseTogZnVuY3Rpb24oaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIGJveCA9IG5ldyAkLlJlY3QoXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50Qm91bmRzLnggKyAodGhpcy5fY29udGVudEJvdW5kcy53aWR0aCAvIDIpLFxuICAgICAgICAgICAgdGhpcy5fY29udGVudEJvdW5kcy55LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRCb3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml0Qm91bmRzKGJveCwgaW1tZWRpYXRlbHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tcyBzbyB0aGUgaW1hZ2UganVzdCBmaWxscyB0aGUgdmlld2VyIGhvcml6b250YWxseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGltbWVkaWF0ZWx5XG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqL1xuICAgIGZpdEhvcml6b250YWxseTogZnVuY3Rpb24oaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIGJveCA9IG5ldyAkLlJlY3QoXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50Qm91bmRzLngsXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50Qm91bmRzLnkgKyAodGhpcy5fY29udGVudEJvdW5kcy5oZWlnaHQgLyAyKSxcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRCb3VuZHMud2lkdGgsXG4gICAgICAgICAgICAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml0Qm91bmRzKGJveCwgaW1tZWRpYXRlbHkpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGltbWVkaWF0ZWx5XG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpwYW5cbiAgICAgKi9cbiAgICBwYW5CeTogZnVuY3Rpb24oIGRlbHRhLCBpbW1lZGlhdGVseSApIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdYLnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMuY2VudGVyU3ByaW5nWS50YXJnZXQudmFsdWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFuVG8oIGNlbnRlci5wbHVzKCBkZWx0YSApLCBpbW1lZGlhdGVseSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGNlbnRlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW1tZWRpYXRlbHlcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnBhblxuICAgICAqL1xuICAgIHBhblRvOiBmdW5jdGlvbiggY2VudGVyLCBpbW1lZGlhdGVseSApIHtcbiAgICAgICAgaWYgKCBpbW1lZGlhdGVseSApIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyU3ByaW5nWC5yZXNldFRvKCBjZW50ZXIueCApO1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdZLnJlc2V0VG8oIGNlbnRlci55ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1guc3ByaW5nVG8oIGNlbnRlci54ICk7XG4gICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1kuc3ByaW5nVG8oIGNlbnRlci55ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGhpcy52aWV3ZXIgKXtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdwb3J0IGlzIHBhbm5lZCAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I3BhbkJ5fSBhbmQge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld3BvcnQjcGFuVG99KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgcGFuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IGNlbnRlclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlci5yYWlzZUV2ZW50KCAncGFuJywge1xuICAgICAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5OiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDp6b29tXG4gICAgICovXG4gICAgem9vbUJ5OiBmdW5jdGlvbihmYWN0b3IsIHJlZlBvaW50LCBpbW1lZGlhdGVseSkge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tVG8oXG4gICAgICAgICAgICB0aGlzLnpvb21TcHJpbmcudGFyZ2V0LnZhbHVlICogZmFjdG9yLCByZWZQb2ludCwgaW1tZWRpYXRlbHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tcyB0byB0aGUgc3BlY2lmaWVkIHpvb20gbGV2ZWxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gem9vbSBUaGUgem9vbSBsZXZlbCB0byB6b29tIHRvLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gW3JlZlBvaW50XSBUaGUgcG9pbnQgd2hpY2ggd2lsbCBzdGF5IGF0XG4gICAgICogdGhlIHNhbWUgc2NyZWVuIGxvY2F0aW9uLiBEZWZhdWx0cyB0byB0aGUgdmlld3BvcnQgY2VudGVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6em9vbVxuICAgICAqL1xuICAgIHpvb21UbzogZnVuY3Rpb24oIHpvb20sIHJlZlBvaW50LCBpbW1lZGlhdGVseSApIHtcblxuICAgICAgICB0aGlzLnpvb21Qb2ludCA9IHJlZlBvaW50IGluc3RhbmNlb2YgJC5Qb2ludCAmJlxuICAgICAgICAgICAgIWlzTmFOKHJlZlBvaW50LngpICYmXG4gICAgICAgICAgICAhaXNOYU4ocmVmUG9pbnQueSkgP1xuICAgICAgICAgICAgcmVmUG9pbnQgOlxuICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICBpZiAoIGltbWVkaWF0ZWx5ICkge1xuICAgICAgICAgICAgdGhpcy56b29tU3ByaW5nLnJlc2V0VG8oIHpvb20gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuem9vbVNwcmluZy5zcHJpbmdUbyggem9vbSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHRoaXMudmlld2VyICl7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3cG9ydCB6b29tIGxldmVsIGNoYW5nZXMgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCN6b29tQnl9IGFuZCB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCN6b29tVG99KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgem9vbVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHpvb21cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcmVmUG9pbnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy52aWV3ZXIucmFpc2VFdmVudCggJ3pvb20nLCB7XG4gICAgICAgICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICAgICAgICByZWZQb2ludDogcmVmUG9pbnQsXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlbHk6IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoaXMgdmlld3BvcnQgdG8gdGhlIGFuZ2xlIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdlciB8fCAhdGhpcy52aWV3ZXIuZHJhd2VyLmNhblJvdGF0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZ3JlZXMgPSBkZWdyZWVzICUgMzYwO1xuICAgICAgICBpZiAoZGVncmVlcyA8IDApIHtcbiAgICAgICAgICAgIGRlZ3JlZXMgKz0gMzYwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVncmVlcyA9IGRlZ3JlZXM7XG4gICAgICAgIHRoaXMuX3NldENvbnRlbnRCb3VuZHMoXG4gICAgICAgICAgICB0aGlzLnZpZXdlci53b3JsZC5nZXRIb21lQm91bmRzKCksXG4gICAgICAgICAgICB0aGlzLnZpZXdlci53b3JsZC5nZXRDb250ZW50RmFjdG9yKCkpO1xuICAgICAgICB0aGlzLnZpZXdlci5mb3JjZVJlZHJhdygpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiByb3RhdGlvbiBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgcm90YXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZ3JlZXMgLSBUaGUgbnVtYmVyIG9mIGRlZ3JlZXMgdGhlIHJvdGF0aW9uIHdhcyBzZXQgdG8uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld2VyLnJhaXNlRXZlbnQoJ3JvdGF0ZScsIHtcImRlZ3JlZXNcIjogZGVncmVlc30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCByb3RhdGlvbiBpbiBkZWdyZWVzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgcm90YXRpb24gaW4gZGVncmVlcy5cbiAgICAgKi9cbiAgICBnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZ3JlZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6cmVzaXplXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbiggbmV3Q29udGFpbmVyU2l6ZSwgbWFpbnRhaW4gKSB7XG4gICAgICAgIHZhciBvbGRCb3VuZHMgPSB0aGlzLmdldEJvdW5kc05vUm90YXRlKCksXG4gICAgICAgICAgICBuZXdCb3VuZHMgPSBvbGRCb3VuZHMsXG4gICAgICAgICAgICB3aWR0aERlbHRhRmFjdG9yO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZS54ID0gbmV3Q29udGFpbmVyU2l6ZS54O1xuICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUueSA9IG5ld0NvbnRhaW5lclNpemUueTtcblxuICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJJbm5lclNpemUoKTtcblxuICAgICAgICBpZiAoIG1haW50YWluICkge1xuICAgICAgICAgICAgLy8gVE9ETzogd2lkdGhEZWx0YUZhY3RvciB3aWxsIGFsd2F5cyBiZSAxOyBwcm9iYWJseSBub3Qgd2hhdCdzIGludGVuZGVkXG4gICAgICAgICAgICB3aWR0aERlbHRhRmFjdG9yID0gbmV3Q29udGFpbmVyU2l6ZS54IC8gdGhpcy5jb250YWluZXJTaXplLng7XG4gICAgICAgICAgICBuZXdCb3VuZHMud2lkdGggID0gb2xkQm91bmRzLndpZHRoICogd2lkdGhEZWx0YUZhY3RvcjtcbiAgICAgICAgICAgIG5ld0JvdW5kcy5oZWlnaHQgPSBuZXdCb3VuZHMud2lkdGggLyB0aGlzLmdldEFzcGVjdFJhdGlvKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGhpcy52aWV3ZXIgKXtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdlciBpcyByZXNpemVkIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld3BvcnQjcmVzaXplfSkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IHJlc2l6ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBuZXdDb250YWluZXJTaXplXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG1haW50YWluXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudmlld2VyLnJhaXNlRXZlbnQoICdyZXNpemUnLCB7XG4gICAgICAgICAgICAgICAgbmV3Q29udGFpbmVyU2l6ZTogbmV3Q29udGFpbmVyU2l6ZSxcbiAgICAgICAgICAgICAgICBtYWludGFpbjogbWFpbnRhaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZml0Qm91bmRzKCBuZXdCb3VuZHMsIHRydWUgKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF91cGRhdGVDb250YWluZXJJbm5lclNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXJJbm5lclNpemUgPSBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIE1hdGgubWF4KDEsIHRoaXMuY29udGFpbmVyU2l6ZS54IC0gKHRoaXMuX21hcmdpbnMubGVmdCArIHRoaXMuX21hcmdpbnMucmlnaHQpKSxcbiAgICAgICAgICAgIE1hdGgubWF4KDEsIHRoaXMuY29udGFpbmVyU2l6ZS55IC0gKHRoaXMuX21hcmdpbnMudG9wICsgdGhpcy5fbWFyZ2lucy5ib3R0b20pKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHpvb20gYW5kIGNlbnRlciAoWCBhbmQgWSkgc3ByaW5ncy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhbnkgY2hhbmdlIGhhcyBiZWVuIG1hZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnpvb21Qb2ludCkge1xuICAgICAgICAgICAgdmFyIG9sZFpvb21QaXhlbCA9IHRoaXMucGl4ZWxGcm9tUG9pbnQodGhpcy56b29tUG9pbnQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy56b29tU3ByaW5nLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG5ld1pvb21QaXhlbCA9IHRoaXMucGl4ZWxGcm9tUG9pbnQodGhpcy56b29tUG9pbnQsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgZGVsdGFab29tUGl4ZWxzID0gbmV3Wm9vbVBpeGVsLm1pbnVzKG9sZFpvb21QaXhlbCk7XG4gICAgICAgICAgICB2YXIgZGVsdGFab29tUG9pbnRzID0gdGhpcy5kZWx0YVBvaW50c0Zyb21QaXhlbHMoXG4gICAgICAgICAgICAgICAgZGVsdGFab29tUGl4ZWxzLCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdYLnNoaWZ0QnkoZGVsdGFab29tUG9pbnRzLngpO1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdZLnNoaWZ0QnkoZGVsdGFab29tUG9pbnRzLnkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy56b29tU3ByaW5nLmlzQXRUYXJnZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tUG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy56b29tU3ByaW5nLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdYLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1kudXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNlbnRlclNwcmluZ1guY3VycmVudC52YWx1ZSAhPT0gdGhpcy5fb2xkQ2VudGVyWCB8fFxuICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdZLmN1cnJlbnQudmFsdWUgIT09IHRoaXMuX29sZENlbnRlclkgfHxcbiAgICAgICAgICAgIHRoaXMuem9vbVNwcmluZy5jdXJyZW50LnZhbHVlICE9PSB0aGlzLl9vbGRab29tO1xuXG4gICAgICAgIHRoaXMuX29sZENlbnRlclggPSB0aGlzLmNlbnRlclNwcmluZ1guY3VycmVudC52YWx1ZTtcbiAgICAgICAgdGhpcy5fb2xkQ2VudGVyWSA9IHRoaXMuY2VudGVyU3ByaW5nWS5jdXJyZW50LnZhbHVlO1xuICAgICAgICB0aGlzLl9vbGRab29tICAgID0gdGhpcy56b29tU3ByaW5nLmN1cnJlbnQudmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBkZWx0YSAodHJhbnNsYXRpb24gdmVjdG9yKSBmcm9tIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIHBpeGVsc1xuICAgICAqIGNvb3JkaW5hdGVzLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB0YWtlIHJvdGF0aW9uIGludG8gYWNjb3VudC5cbiAgICAgKiBDb25zaWRlciB1c2luZyBkZWx0YVBpeGVsc0Zyb21Qb2ludHMgaWYgeW91IG5lZWQgdG8gYWNjb3VudCBmb3Igcm90YXRpb24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBkZWx0YVBvaW50cyAtIFRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247XG4gICAgICogZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgZGVsdGFQaXhlbHNGcm9tUG9pbnRzTm9Sb3RhdGU6IGZ1bmN0aW9uKGRlbHRhUG9pbnRzLCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBkZWx0YVBvaW50cy50aW1lcyhcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZS54ICogdGhpcy5nZXRab29tKGN1cnJlbnQpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBkZWx0YSAodHJhbnNsYXRpb24gdmVjdG9yKSBmcm9tIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIHBpeGVsc1xuICAgICAqIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZGVsdGFQb2ludHMgLSBUaGUgdHJhbnNsYXRpb24gdmVjdG9yIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uO1xuICAgICAqIGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIGRlbHRhUGl4ZWxzRnJvbVBvaW50czogZnVuY3Rpb24oZGVsdGFQb2ludHMsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGFQaXhlbHNGcm9tUG9pbnRzTm9Sb3RhdGUoXG4gICAgICAgICAgICBkZWx0YVBvaW50cy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbigpKSxcbiAgICAgICAgICAgIGN1cnJlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgZGVsdGEgKHRyYW5zbGF0aW9uIHZlY3RvcikgZnJvbSBwaXhlbHMgY29vcmRpbmF0ZXMgdG8gdmlld3BvcnRcbiAgICAgKiBjb29yZGluYXRlcy4gVGhpcyBtZXRob2QgZG9lcyBub3QgdGFrZSByb3RhdGlvbiBpbnRvIGFjY291bnQuXG4gICAgICogQ29uc2lkZXIgdXNpbmcgZGVsdGFQb2ludHNGcm9tUGl4ZWxzIGlmIHlvdSBuZWVkIHRvIGFjY291bnQgZm9yIHJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZGVsdGFQaXhlbHMgLSBUaGUgdHJhbnNsYXRpb24gdmVjdG9yIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uO1xuICAgICAqIGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIGRlbHRhUG9pbnRzRnJvbVBpeGVsc05vUm90YXRlOiBmdW5jdGlvbihkZWx0YVBpeGVscywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gZGVsdGFQaXhlbHMuZGl2aWRlKFxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVySW5uZXJTaXplLnggKiB0aGlzLmdldFpvb20oY3VycmVudClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGRlbHRhICh0cmFuc2xhdGlvbiB2ZWN0b3IpIGZyb20gcGl4ZWxzIGNvb3JkaW5hdGVzIHRvIHZpZXdwb3J0XG4gICAgICogY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBkZWx0YVBpeGVscyAtIFRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247XG4gICAgICogZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgZGVsdGFQb2ludHNGcm9tUGl4ZWxzOiBmdW5jdGlvbihkZWx0YVBpeGVscywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWx0YVBvaW50c0Zyb21QaXhlbHNOb1JvdGF0ZShkZWx0YVBpeGVscywgY3VycmVudClcbiAgICAgICAgICAgIC5yb3RhdGUoLXRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIGNvb3JkaW5hdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHRha2Ugcm90YXRpb24gaW50byBhY2NvdW50LlxuICAgICAqIENvbnNpZGVyIHVzaW5nIHBpeGVsRnJvbVBvaW50IGlmIHlvdSBuZWVkIHRvIGFjY291bnQgZm9yIHJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnQgdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uO1xuICAgICAqIGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHBpeGVsRnJvbVBvaW50Tm9Sb3RhdGU6IGZ1bmN0aW9uKHBvaW50LCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbEZyb21Qb2ludE5vUm90YXRlKFxuICAgICAgICAgICAgcG9pbnQsIHRoaXMuZ2V0Qm91bmRzTm9Sb3RhdGUoY3VycmVudCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIHBpeGVsIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnQgdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uO1xuICAgICAqIGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHBpeGVsRnJvbVBvaW50OiBmdW5jdGlvbihwb2ludCwgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxGcm9tUG9pbnQocG9pbnQsIHRoaXMuZ2V0Qm91bmRzTm9Sb3RhdGUoY3VycmVudCkpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3BpeGVsRnJvbVBvaW50Tm9Sb3RhdGU6IGZ1bmN0aW9uKHBvaW50LCBib3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50Lm1pbnVzKFxuICAgICAgICAgICAgYm91bmRzLmdldFRvcExlZnQoKVxuICAgICAgICApLnRpbWVzKFxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVySW5uZXJTaXplLnggLyBib3VuZHMud2lkdGhcbiAgICAgICAgKS5wbHVzKFxuICAgICAgICAgICAgbmV3ICQuUG9pbnQodGhpcy5fbWFyZ2lucy5sZWZ0LCB0aGlzLl9tYXJnaW5zLnRvcClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9waXhlbEZyb21Qb2ludDogZnVuY3Rpb24ocG9pbnQsIGJvdW5kcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxGcm9tUG9pbnROb1JvdGF0ZShcbiAgICAgICAgICAgIHBvaW50LnJvdGF0ZSh0aGlzLmdldFJvdGF0aW9uKCksIHRoaXMuZ2V0Q2VudGVyKHRydWUpKSxcbiAgICAgICAgICAgIGJvdW5kcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgdGFrZSByb3RhdGlvbiBpbnRvIGFjY291bnQuXG4gICAgICogQ29uc2lkZXIgdXNpbmcgcG9pbnRGcm9tUGl4ZWwgaWYgeW91IG5lZWQgdG8gYWNjb3VudCBmb3Igcm90YXRpb24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbCBQaXhlbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnJlbnQ9ZmFsc2VdIC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjtcbiAgICAgKiBkZWZhdWx0cyB0byBmYWxzZSAodGFyZ2V0IGxvY2F0aW9uKS5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBwb2ludEZyb21QaXhlbE5vUm90YXRlOiBmdW5jdGlvbihwaXhlbCwgY3VycmVudCkge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHNOb1JvdGF0ZShjdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIHBpeGVsLm1pbnVzKFxuICAgICAgICAgICAgbmV3ICQuUG9pbnQodGhpcy5fbWFyZ2lucy5sZWZ0LCB0aGlzLl9tYXJnaW5zLnRvcClcbiAgICAgICAgKS5kaXZpZGUoXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJJbm5lclNpemUueCAvIGJvdW5kcy53aWR0aFxuICAgICAgICApLnBsdXMoXG4gICAgICAgICAgICBib3VuZHMuZ2V0VG9wTGVmdCgpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbCBQaXhlbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnJlbnQ9ZmFsc2VdIC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjtcbiAgICAgKiBkZWZhdWx0cyB0byBmYWxzZSAodGFyZ2V0IGxvY2F0aW9uKS5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBwb2ludEZyb21QaXhlbDogZnVuY3Rpb24ocGl4ZWwsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tUGl4ZWxOb1JvdGF0ZShwaXhlbCwgY3VycmVudCkucm90YXRlKFxuICAgICAgICAgICAgLXRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2VudGVyKHRydWUpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfdmlld3BvcnRUb0ltYWdlRGVsdGE6IGZ1bmN0aW9uKCB2aWV3ZXJYLCB2aWV3ZXJZICkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUud2lkdGg7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIHZpZXdlclggKiB0aGlzLl9jb250ZW50U2l6ZU5vUm90YXRlLnggLyBzY2FsZSxcbiAgICAgICAgICAgIHZpZXdlclkgKiB0aGlzLl9jb250ZW50U2l6ZU5vUm90YXRlLnggLyBzY2FsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZnJvbSBPcGVuU2VhZHJhZ29uIHZpZXdlciBjb29yZGluYXRlIHN5c3RlbSB0byBpbWFnZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGVpdGhlciBieSBwYXNzaW5nIFgsWSBjb29yZGluYXRlcyBvciBhblxuICAgICAqIE9wZW5TZWFkcmFnb24uUG9pbnRcbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZTsgdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXMgaW5zdGVhZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhPcGVuU2VhZHJhZ29uLlBvaW50fE51bWJlcil9IHZpZXdlclggZWl0aGVyIGEgcG9pbnQgb3IgdGhlIFhcbiAgICAgKiBjb29yZGluYXRlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdmlld2VyWV0gWSBjb29yZGluYXRlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUG9pbnR9IGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb29yZGluYXRlcyBpbiB0aGUgaW1hZ2UuXG4gICAgICovXG4gICAgdmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKHZpZXdlclgsIHZpZXdlclkpIHtcbiAgICAgICAgaWYgKHZpZXdlclggaW5zdGFuY2VvZiAkLlBvaW50KSB7XG4gICAgICAgICAgICAvL3RoZXkgcGFzc2VkIGEgcG9pbnQgaW5zdGVhZCBvZiBpbmRpdmlkdWFsIGNvbXBvbmVudHNcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzKHZpZXdlclgueCwgdmlld2VyWC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZpZXdlcikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUNvdW50KCk7XG4gICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgJC5jb25zb2xlLmVycm9yKCdbVmlld3BvcnQudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXNdIGlzIG5vdCBhY2N1cmF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGggbXVsdGktaW1hZ2U7IHVzZSBUaWxlZEltYWdlLnZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYmV0dGVyIHRvIHVzZSBUaWxlZEltYWdlLnZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUgY2FuIG5vdCBiZSByZWxpZWQgb25cbiAgICAgICAgICAgICAgICAvLyB3aXRoIGNsaXBwaW5nLlxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzKHZpZXdlclgsIHZpZXdlclksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0VG9JbWFnZURlbHRhKFxuICAgICAgICAgICAgdmlld2VyWCAtIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS54LFxuICAgICAgICAgICAgdmlld2VyWSAtIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS55KTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9pbWFnZVRvVmlld3BvcnREZWx0YTogZnVuY3Rpb24oIGltYWdlWCwgaW1hZ2VZICkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUud2lkdGg7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIGltYWdlWCAvIHRoaXMuX2NvbnRlbnRTaXplTm9Sb3RhdGUueCAqIHNjYWxlLFxuICAgICAgICAgICAgaW1hZ2VZIC8gdGhpcy5fY29udGVudFNpemVOb1JvdGF0ZS54ICogc2NhbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGZyb20gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gT3BlblNlYWRyYWdvbiB2aWV3ZXIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGVpdGhlciBieSBwYXNzaW5nIFgsWSBjb29yZGluYXRlcyBvciBhblxuICAgICAqIE9wZW5TZWFkcmFnb24uUG9pbnRcbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZTsgdXNlIFRpbGVkSW1hZ2UuaW1hZ2VUb1ZpZXdwb3J0Q29vcmRpbmF0ZXMgaW5zdGVhZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhPcGVuU2VhZHJhZ29uLlBvaW50IHwgTnVtYmVyKX0gaW1hZ2VYIHRoZSBwb2ludCBvciB0aGVcbiAgICAgKiBYIGNvb3JkaW5hdGUgaW4gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbWFnZVldIFkgY29vcmRpbmF0ZSBpbiBpbWFnZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29vcmRpbmF0ZXMgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIGltYWdlVG9WaWV3cG9ydENvb3JkaW5hdGVzOiBmdW5jdGlvbihpbWFnZVgsIGltYWdlWSkge1xuICAgICAgICBpZiAoaW1hZ2VYIGluc3RhbmNlb2YgJC5Qb2ludCkge1xuICAgICAgICAgICAgLy90aGV5IHBhc3NlZCBhIHBvaW50IGluc3RlYWQgb2YgaW5kaXZpZHVhbCBjb21wb25lbnRzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlcyhpbWFnZVgueCwgaW1hZ2VYLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmlld2VyKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAkLmNvbnNvbGUuZXJyb3IoJ1tWaWV3cG9ydC5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlc10gaXMgbm90IGFjY3VyYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2l0aCBtdWx0aS1pbWFnZTsgdXNlIFRpbGVkSW1hZ2UuaW1hZ2VUb1ZpZXdwb3J0Q29vcmRpbmF0ZXMgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBiZXR0ZXIgdG8gdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZSBjYW4gbm90IGJlIHJlbGllZCBvblxuICAgICAgICAgICAgICAgIC8vIHdpdGggY2xpcHBpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW1hZ2VUb1ZpZXdwb3J0Q29vcmRpbmF0ZXMoaW1hZ2VYLCBpbWFnZVksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5faW1hZ2VUb1ZpZXdwb3J0RGVsdGEoaW1hZ2VYLCBpbWFnZVkpO1xuICAgICAgICBwb2ludC54ICs9IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS54O1xuICAgICAgICBwb2ludC55ICs9IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS55O1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZnJvbSBhIHJlY3RhbmdsZSB3aGljaCBkZXNjcmliZXMgYSBwb3J0aW9uIG9mIHRoZSBpbWFnZSBpblxuICAgICAqIHBpeGVsIGNvb3JkaW5hdGVzIHRvIE9wZW5TZWFkcmFnb24gdmlld3BvcnQgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGJ5IHBhc3NpbmcgWCxZLHdpZHRoLGhlaWdodCBvciBhblxuICAgICAqIE9wZW5TZWFkcmFnb24uUmVjdFxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlOyB1c2UgVGlsZWRJbWFnZS5pbWFnZVRvVmlld3BvcnRSZWN0YW5nbGUgaW5zdGVhZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhPcGVuU2VhZHJhZ29uLlJlY3QgfCBOdW1iZXIpfSBpbWFnZVggdGhlIHJlY3RhbmdsZSBvciB0aGUgWFxuICAgICAqIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlIGluIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VZXSB0aGUgWSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIGluIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGl4ZWxXaWR0aF0gdGhlIHdpZHRoIGluIHBpeGVsIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwaXhlbEhlaWdodF0gdGhlIGhlaWdodCBpbiBwaXhlbCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGltYWdlVG9WaWV3cG9ydFJlY3RhbmdsZTogZnVuY3Rpb24oaW1hZ2VYLCBpbWFnZVksIHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0KSB7XG4gICAgICAgIHZhciByZWN0ID0gaW1hZ2VYO1xuICAgICAgICBpZiAoIShyZWN0IGluc3RhbmNlb2YgJC5SZWN0KSkge1xuICAgICAgICAgICAgLy90aGV5IHBhc3NlZCBpbmRpdmlkdWFsIGNvbXBvbmVudHMgaW5zdGVhZCBvZiBhIHJlY3RhbmdsZVxuICAgICAgICAgICAgcmVjdCA9IG5ldyAkLlJlY3QoaW1hZ2VYLCBpbWFnZVksIHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZpZXdlcikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUNvdW50KCk7XG4gICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgJC5jb25zb2xlLmVycm9yKCdbVmlld3BvcnQuaW1hZ2VUb1ZpZXdwb3J0UmVjdGFuZ2xlXSBpcyBub3QgYWNjdXJhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRoIG11bHRpLWltYWdlOyB1c2UgVGlsZWRJbWFnZS5pbWFnZVRvVmlld3BvcnRSZWN0YW5nbGUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBiZXR0ZXIgdG8gdXNlIFRpbGVkSW1hZ2UuaW1hZ2VUb1ZpZXdwb3J0UmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUgY2FuIG5vdCBiZSByZWxpZWQgb25cbiAgICAgICAgICAgICAgICAvLyB3aXRoIGNsaXBwaW5nLlxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmltYWdlVG9WaWV3cG9ydFJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VYLCBpbWFnZVksIHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZEEgPSB0aGlzLmltYWdlVG9WaWV3cG9ydENvb3JkaW5hdGVzKHJlY3QueCwgcmVjdC55KTtcbiAgICAgICAgdmFyIGNvb3JkQiA9IHRoaXMuX2ltYWdlVG9WaWV3cG9ydERlbHRhKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBjb29yZEEueCxcbiAgICAgICAgICAgIGNvb3JkQS55LFxuICAgICAgICAgICAgY29vcmRCLngsXG4gICAgICAgICAgICBjb29yZEIueSxcbiAgICAgICAgICAgIHJlY3QuZGVncmVlc1xuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGZyb20gYSByZWN0YW5nbGUgd2hpY2ggZGVzY3JpYmVzIGEgcG9ydGlvbiBvZlxuICAgICAqIHRoZSB2aWV3cG9ydCBpbiBwb2ludCBjb29yZGluYXRlcyB0byBpbWFnZSByZWN0YW5nbGUgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBlaXRoZXIgYnkgcGFzc2luZyBYLFksd2lkdGgsaGVpZ2h0IG9yIGFuXG4gICAgICogT3BlblNlYWRyYWdvbi5SZWN0XG4gICAgICogTm90ZTogbm90IGFjY3VyYXRlIHdpdGggbXVsdGktaW1hZ2U7IHVzZSBUaWxlZEltYWdlLnZpZXdwb3J0VG9JbWFnZVJlY3RhbmdsZSBpbnN0ZWFkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KE9wZW5TZWFkcmFnb24uUmVjdCB8IE51bWJlcil9IHZpZXdlclggZWl0aGVyIGEgcmVjdGFuZ2xlIG9yXG4gICAgICogdGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUgaW4gdmlld3BvcnRcbiAgICAgKiBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ZpZXdlclldIHRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwb2ludFdpZHRoXSB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BvaW50SGVpZ2h0XSB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICovXG4gICAgdmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlOiBmdW5jdGlvbih2aWV3ZXJYLCB2aWV3ZXJZLCBwb2ludFdpZHRoLCBwb2ludEhlaWdodCkge1xuICAgICAgICB2YXIgcmVjdCA9IHZpZXdlclg7XG4gICAgICAgIGlmICghKHJlY3QgaW5zdGFuY2VvZiAkLlJlY3QpKSB7XG4gICAgICAgICAgICAvL3RoZXkgcGFzc2VkIGluZGl2aWR1YWwgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGEgcmVjdGFuZ2xlXG4gICAgICAgICAgICByZWN0ID0gbmV3ICQuUmVjdCh2aWV3ZXJYLCB2aWV3ZXJZLCBwb2ludFdpZHRoLCBwb2ludEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy52aWV3ZXIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMudmlld2VyLndvcmxkLmdldEl0ZW1Db3VudCgpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICQuY29uc29sZS5lcnJvcignW1ZpZXdwb3J0LnZpZXdwb3J0VG9JbWFnZVJlY3RhbmdsZV0gaXMgbm90IGFjY3VyYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2l0aCBtdWx0aS1pbWFnZTsgdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYmV0dGVyIHRvIHVzZSBUaWxlZEltYWdlLnZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUgY2FuIG5vdCBiZSByZWxpZWQgb25cbiAgICAgICAgICAgICAgICAvLyB3aXRoIGNsaXBwaW5nLlxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZpZXdwb3J0VG9JbWFnZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyWCwgdmlld2VyWSwgcG9pbnRXaWR0aCwgcG9pbnRIZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkQSA9IHRoaXMudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXMocmVjdC54LCByZWN0LnkpO1xuICAgICAgICB2YXIgY29vcmRCID0gdGhpcy5fdmlld3BvcnRUb0ltYWdlRGVsdGEocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIGNvb3JkQS54LFxuICAgICAgICAgICAgY29vcmRBLnksXG4gICAgICAgICAgICBjb29yZEIueCxcbiAgICAgICAgICAgIGNvb3JkQi55LFxuICAgICAgICAgICAgcmVjdC5kZWdyZWVzXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdlciBlbGVtZW50IHRvIGltYWdlXG4gICAgICogY29vcmRpbmF0ZXMuXG4gICAgICogTm90ZTogbm90IGFjY3VyYXRlIHdpdGggbXVsdGktaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHZpZXdlckVsZW1lbnRUb0ltYWdlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBwaXhlbCApIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5wb2ludEZyb21QaXhlbCggcGl4ZWwsIHRydWUgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXMoIHBvaW50ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIGltYWdlIHRvXG4gICAgICogdmlld2VyIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogTm90ZTogbm90IGFjY3VyYXRlIHdpdGggbXVsdGktaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIGltYWdlVG9WaWV3ZXJFbGVtZW50Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBwaXhlbCApIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlcyggcGl4ZWwgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGl4ZWxGcm9tUG9pbnQoIHBvaW50LCB0cnVlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdyB0byBpbWFnZSBjb29yZGluYXRlcy5cbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgd2luZG93VG9JbWFnZUNvb3JkaW5hdGVzOiBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KHRoaXMudmlld2VyLFxuICAgICAgICAgICAgXCJbVmlld3BvcnQud2luZG93VG9JbWFnZUNvb3JkaW5hdGVzXSB0aGUgdmlld3BvcnQgbXVzdCBoYXZlIGEgdmlld2VyLlwiKTtcbiAgICAgICAgdmFyIHZpZXdlckNvb3JkaW5hdGVzID0gcGl4ZWwubWludXMoXG4gICAgICAgICAgICAgICAgJC5nZXRFbGVtZW50UG9zaXRpb24odGhpcy52aWV3ZXIuZWxlbWVudCkpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3ZXJFbGVtZW50VG9JbWFnZUNvb3JkaW5hdGVzKHZpZXdlckNvb3JkaW5hdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBpbWFnZSBjb29yZGluYXRlcyB0byBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcGl4ZWxcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBpbWFnZVRvV2luZG93Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQodGhpcy52aWV3ZXIsXG4gICAgICAgICAgICBcIltWaWV3cG9ydC5pbWFnZVRvV2luZG93Q29vcmRpbmF0ZXNdIHRoZSB2aWV3cG9ydCBtdXN0IGhhdmUgYSB2aWV3ZXIuXCIpO1xuICAgICAgICB2YXIgdmlld2VyQ29vcmRpbmF0ZXMgPSB0aGlzLmltYWdlVG9WaWV3ZXJFbGVtZW50Q29vcmRpbmF0ZXMocGl4ZWwpO1xuICAgICAgICByZXR1cm4gdmlld2VyQ29vcmRpbmF0ZXMucGx1cyhcbiAgICAgICAgICAgICAgICAkLmdldEVsZW1lbnRQb3NpdGlvbih0aGlzLnZpZXdlci5lbGVtZW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdlciBlbGVtZW50IHRvIHZpZXdwb3J0XG4gICAgICogY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHZpZXdlckVsZW1lbnRUb1ZpZXdwb3J0Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBwaXhlbCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tUGl4ZWwoIHBpeGVsLCB0cnVlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgICogdmlld2VyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHZpZXdwb3J0VG9WaWV3ZXJFbGVtZW50Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBwb2ludCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGl4ZWxGcm9tUG9pbnQoIHBvaW50LCB0cnVlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSByZWN0YW5nbGUgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdlciBlbGVtZW50XG4gICAgICogdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IHJlY3RhbmdsZSB0aGUgcmVjdGFuZ2xlIHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fSB0aGUgY29udmVydGVkIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIHZpZXdlckVsZW1lbnRUb1ZpZXdwb3J0UmVjdGFuZ2xlOiBmdW5jdGlvbihyZWN0YW5nbGUpIHtcbiAgICAgICAgcmV0dXJuICQuUmVjdC5mcm9tU3VtbWl0cyhcbiAgICAgICAgICAgIHRoaXMucG9pbnRGcm9tUGl4ZWwocmVjdGFuZ2xlLmdldFRvcExlZnQoKSwgdHJ1ZSksXG4gICAgICAgICAgICB0aGlzLnBvaW50RnJvbVBpeGVsKHJlY3RhbmdsZS5nZXRUb3BSaWdodCgpLCB0cnVlKSxcbiAgICAgICAgICAgIHRoaXMucG9pbnRGcm9tUGl4ZWwocmVjdGFuZ2xlLmdldEJvdHRvbUxlZnQoKSwgdHJ1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHJlY3RhbmdsZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlcyB0byBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZVxuICAgICAqIHRvIHRoZSB2aWV3ZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gcmVjdGFuZ2xlIHRoZSByZWN0YW5nbGUgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IHRoZSBjb252ZXJ0ZWQgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgdmlld3BvcnRUb1ZpZXdlckVsZW1lbnRSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICAgICAgICByZXR1cm4gJC5SZWN0LmZyb21TdW1taXRzKFxuICAgICAgICAgICAgdGhpcy5waXhlbEZyb21Qb2ludChyZWN0YW5nbGUuZ2V0VG9wTGVmdCgpLCB0cnVlKSxcbiAgICAgICAgICAgIHRoaXMucGl4ZWxGcm9tUG9pbnQocmVjdGFuZ2xlLmdldFRvcFJpZ2h0KCksIHRydWUpLFxuICAgICAgICAgICAgdGhpcy5waXhlbEZyb21Qb2ludChyZWN0YW5nbGUuZ2V0Qm90dG9tTGVmdCgpLCB0cnVlKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHBpeGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHdpbmRvd1RvVmlld3BvcnRDb29yZGluYXRlczogZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCh0aGlzLnZpZXdlcixcbiAgICAgICAgICAgIFwiW1ZpZXdwb3J0LndpbmRvd1RvVmlld3BvcnRDb29yZGluYXRlc10gdGhlIHZpZXdwb3J0IG11c3QgaGF2ZSBhIHZpZXdlci5cIik7XG4gICAgICAgIHZhciB2aWV3ZXJDb29yZGluYXRlcyA9IHBpeGVsLm1pbnVzKFxuICAgICAgICAgICAgICAgICQuZ2V0RWxlbWVudFBvc2l0aW9uKHRoaXMudmlld2VyLmVsZW1lbnQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld2VyRWxlbWVudFRvVmlld3BvcnRDb29yZGluYXRlcyh2aWV3ZXJDb29yZGluYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgdmlld3BvcnRUb1dpbmRvd0Nvb3JkaW5hdGVzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KHRoaXMudmlld2VyLFxuICAgICAgICAgICAgXCJbVmlld3BvcnQudmlld3BvcnRUb1dpbmRvd0Nvb3JkaW5hdGVzXSB0aGUgdmlld3BvcnQgbXVzdCBoYXZlIGEgdmlld2VyLlwiKTtcbiAgICAgICAgdmFyIHZpZXdlckNvb3JkaW5hdGVzID0gdGhpcy52aWV3cG9ydFRvVmlld2VyRWxlbWVudENvb3JkaW5hdGVzKHBvaW50KTtcbiAgICAgICAgcmV0dXJuIHZpZXdlckNvb3JkaW5hdGVzLnBsdXMoXG4gICAgICAgICAgICAgICAgJC5nZXRFbGVtZW50UG9zaXRpb24odGhpcy52aWV3ZXIuZWxlbWVudCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmlld3BvcnQgem9vbSB0byBhbiBpbWFnZSB6b29tLlxuICAgICAqIEltYWdlIHpvb206IHJhdGlvIG9mIHRoZSBvcmlnaW5hbCBpbWFnZSBzaXplIHRvIGRpc3BsYXllZCBpbWFnZSBzaXplLlxuICAgICAqIDEgbWVhbnMgb3JpZ2luYWwgaW1hZ2Ugc2l6ZSwgMC41IGhhbGYgc2l6ZS4uLlxuICAgICAqIFZpZXdwb3J0IHpvb206IHJhdGlvIG9mIHRoZSBkaXNwbGF5ZWQgaW1hZ2UncyB3aWR0aCB0byB2aWV3cG9ydCdzIHdpZHRoLlxuICAgICAqIDEgbWVhbnMgaWRlbnRpY2FsIHdpZHRoLCAyIG1lYW5zIGltYWdlJ3Mgd2lkdGggaXMgdHdpY2UgdGhlIHZpZXdwb3J0J3Mgd2lkdGguLi5cbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRab29tIFRoZSB2aWV3cG9ydCB6b29tXG4gICAgICogdGFyZ2V0IHpvb20uXG4gICAgICogQHJldHVybnMge051bWJlcn0gaW1hZ2Vab29tIFRoZSBpbWFnZSB6b29tXG4gICAgICovXG4gICAgdmlld3BvcnRUb0ltYWdlWm9vbTogZnVuY3Rpb24odmlld3BvcnRab29tKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdlcikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUNvdW50KCk7XG4gICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgJC5jb25zb2xlLmVycm9yKCdbVmlld3BvcnQudmlld3BvcnRUb0ltYWdlWm9vbV0gaXMgbm90ICcgK1xuICAgICAgICAgICAgICAgICAgICAnYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZS4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBiZXR0ZXIgdG8gdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlWm9vbVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlIGNhbiBub3QgYmUgcmVsaWVkIG9uXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBjbGlwcGluZy5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMudmlld2VyLndvcmxkLmdldEl0ZW1BdCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS52aWV3cG9ydFRvSW1hZ2Vab29tKHZpZXdwb3J0Wm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2VXaWR0aCA9IHRoaXMuX2NvbnRlbnRTaXplTm9Sb3RhdGUueDtcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVySW5uZXJTaXplLng7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS53aWR0aDtcbiAgICAgICAgdmFyIHZpZXdwb3J0VG9JbWFnZVpvb21SYXRpbyA9IChjb250YWluZXJXaWR0aCAvIGltYWdlV2lkdGgpICogc2NhbGU7XG4gICAgICAgIHJldHVybiB2aWV3cG9ydFpvb20gKiB2aWV3cG9ydFRvSW1hZ2Vab29tUmF0aW87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gaW1hZ2Ugem9vbSB0byBhIHZpZXdwb3J0IHpvb20uXG4gICAgICogSW1hZ2Ugem9vbTogcmF0aW8gb2YgdGhlIG9yaWdpbmFsIGltYWdlIHNpemUgdG8gZGlzcGxheWVkIGltYWdlIHNpemUuXG4gICAgICogMSBtZWFucyBvcmlnaW5hbCBpbWFnZSBzaXplLCAwLjUgaGFsZiBzaXplLi4uXG4gICAgICogVmlld3BvcnQgem9vbTogcmF0aW8gb2YgdGhlIGRpc3BsYXllZCBpbWFnZSdzIHdpZHRoIHRvIHZpZXdwb3J0J3Mgd2lkdGguXG4gICAgICogMSBtZWFucyBpZGVudGljYWwgd2lkdGgsIDIgbWVhbnMgaW1hZ2UncyB3aWR0aCBpcyB0d2ljZSB0aGUgdmlld3BvcnQncyB3aWR0aC4uLlxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbWFnZVpvb20gVGhlIGltYWdlIHpvb21cbiAgICAgKiB0YXJnZXQgem9vbS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2aWV3cG9ydFpvb20gVGhlIHZpZXdwb3J0IHpvb21cbiAgICAgKi9cbiAgICBpbWFnZVRvVmlld3BvcnRab29tOiBmdW5jdGlvbihpbWFnZVpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMudmlld2VyKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAkLmNvbnNvbGUuZXJyb3IoJ1tWaWV3cG9ydC5pbWFnZVRvVmlld3BvcnRab29tXSBpcyBub3QgYWNjdXJhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRoIG11bHRpLWltYWdlLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGJldHRlciB0byB1c2UgVGlsZWRJbWFnZS5pbWFnZVRvVmlld3BvcnRab29tXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUgY2FuIG5vdCBiZSByZWxpZWQgb25cbiAgICAgICAgICAgICAgICAvLyB3aXRoIGNsaXBwaW5nLlxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmltYWdlVG9WaWV3cG9ydFpvb20oaW1hZ2Vab29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWFnZVdpZHRoID0gdGhpcy5fY29udGVudFNpemVOb1JvdGF0ZS54O1xuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJJbm5lclNpemUueDtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLndpZHRoO1xuICAgICAgICB2YXIgdmlld3BvcnRUb0ltYWdlWm9vbVJhdGlvID0gKGltYWdlV2lkdGggLyBjb250YWluZXJXaWR0aCkgLyBzY2FsZTtcbiAgICAgICAgcmV0dXJuIGltYWdlWm9vbSAqIHZpZXdwb3J0VG9JbWFnZVpvb21SYXRpbztcbiAgICB9XG59O1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFRpbGVkSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogWW91IHNob3VsZG4ndCBoYXZlIHRvIGNyZWF0ZSBhIFRpbGVkSW1hZ2UgZGlyZWN0bHk7IHVzZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjb3Blbn1cbiAqIG9yIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNhZGRUaWxlZEltYWdlfSBpbnN0ZWFkLlxuICogQGNsYXNzIFRpbGVkSW1hZ2VcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLkV2ZW50U291cmNlXG4gKiBAY2xhc3NkZXNjIEhhbmRsZXMgcmVuZGVyaW5nIG9mIHRpbGVzIGZvciBhbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXJ9LlxuICogQSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBmb3IgZWFjaCBUaWxlU291cmNlIG9wZW5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhpcyBUaWxlZEltYWdlLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2V9IG9wdGlvbnMuc291cmNlIC0gVGhlIFRpbGVTb3VyY2UgdGhhdCBkZWZpbmVzIHRoaXMgVGlsZWRJbWFnZS5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IG9wdGlvbnMudmlld2VyIC0gVGhlIFZpZXdlciB0aGF0IG93bnMgdGhpcyBUaWxlZEltYWdlLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGVDYWNoZX0gb3B0aW9ucy50aWxlQ2FjaGUgLSBUaGUgVGlsZUNhY2hlIGZvciB0aGlzIFRpbGVkSW1hZ2UgdG8gdXNlLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkRyYXdlcn0gb3B0aW9ucy5kcmF3ZXIgLSBUaGUgRHJhd2VyIGZvciB0aGlzIFRpbGVkSW1hZ2UgdG8gZHJhdyBvbnRvLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkltYWdlTG9hZGVyfSBvcHRpb25zLmltYWdlTG9hZGVyIC0gVGhlIEltYWdlTG9hZGVyIGZvciB0aGlzIFRpbGVkSW1hZ2UgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLng9MF0gLSBMZWZ0IHBvc2l0aW9uLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy55PTBdIC0gVG9wIHBvc2l0aW9uLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD0xXSAtIFdpZHRoLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIC0gSGVpZ2h0LCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSBbb3B0aW9ucy5maXRCb3VuZHNdIFRoZSBib3VuZHMgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXNcbiAqIHRvIGZpdCB0aGUgaW1hZ2UgaW50by4gSWYgc3BlY2lmaWVkLCB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0IGdldCBpZ25vcmVkLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gW29wdGlvbnMuZml0Qm91bmRzUGxhY2VtZW50PU9wZW5TZWFkcmFnb24uUGxhY2VtZW50LkNFTlRFUl1cbiAqIEhvdyB0byBhbmNob3IgdGhlIGltYWdlIGluIHRoZSBib3VuZHMgaWYgb3B0aW9ucy5maXRCb3VuZHMgaXMgc2V0LlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFtvcHRpb25zLmNsaXBdIC0gQW4gYXJlYSwgaW4gaW1hZ2UgcGl4ZWxzLCB0byBjbGlwIHRvXG4gKiAocG9ydGlvbnMgb2YgdGhlIGltYWdlIG91dHNpZGUgb2YgdGhpcyBhcmVhIHdpbGwgbm90IGJlIHZpc2libGUpLiBPbmx5IHdvcmtzIG9uXG4gKiBicm93c2VycyB0aGF0IHN1cHBvcnQgdGhlIEhUTUw1IGNhbnZhcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zcHJpbmdTdGlmZm5lc3NdIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbmltYXRpb25UaW1lXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5ab29tSW1hZ2VSYXRpb10gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndyYXBIb3Jpem9udGFsXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud3JhcFZlcnRpY2FsXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW1tZWRpYXRlUmVuZGVyXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ibGVuZFRpbWVdIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbHdheXNCbGVuZF0gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluUGl4ZWxSYXRpb10gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc21vb3RoVGlsZUVkZ2VzTWluWm9vbV0gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlPU0RldmljZV0gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub3BhY2l0eT0xXSAtIE9wYWNpdHkgdGhlIHRpbGVkIGltYWdlIHNob3VsZCBiZSBkcmF3biBhdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb21wb3NpdGVPcGVyYXRpb25dIC0gSG93IHRoZSBpbWFnZSBpcyBjb21wb3NpdGVkIG9udG8gb3RoZXIgaW1hZ2VzOyBzZWUgY29tcG9zaXRlT3BlcmF0aW9uIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9IGZvciBwb3NzaWJsZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlYnVnTW9kZV0gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge1N0cmluZ3xDYW52YXNHcmFkaWVudHxDYW52YXNQYXR0ZXJufEZ1bmN0aW9ufSBbb3B0aW9ucy5wbGFjZWhvbGRlckZpbGxTdHlsZV0gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSBbb3B0aW9ucy5jcm9zc09yaWdpblBvbGljeV0gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKi9cbiQuVGlsZWRJbWFnZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLnRpbGVDYWNoZSwgXCJbVGlsZWRJbWFnZV0gb3B0aW9ucy50aWxlQ2FjaGUgaXMgcmVxdWlyZWRcIiApO1xuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMuZHJhd2VyLCBcIltUaWxlZEltYWdlXSBvcHRpb25zLmRyYXdlciBpcyByZXF1aXJlZFwiICk7XG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy52aWV3ZXIsIFwiW1RpbGVkSW1hZ2VdIG9wdGlvbnMudmlld2VyIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLmltYWdlTG9hZGVyLCBcIltUaWxlZEltYWdlXSBvcHRpb25zLmltYWdlTG9hZGVyIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLnNvdXJjZSwgXCJbVGlsZWRJbWFnZV0gb3B0aW9ucy5zb3VyY2UgaXMgcmVxdWlyZWRcIiApO1xuICAgICQuY29uc29sZS5hc3NlcnQoIW9wdGlvbnMuY2xpcCB8fCBvcHRpb25zLmNsaXAgaW5zdGFuY2VvZiAkLlJlY3QsXG4gICAgICAgIFwiW1RpbGVkSW1hZ2VdIG9wdGlvbnMuY2xpcCBtdXN0IGJlIGFuIE9wZW5TZWFkcmFnb24uUmVjdCBpZiBwcmVzZW50XCIpO1xuXG4gICAgJC5FdmVudFNvdXJjZS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLl90aWxlQ2FjaGUgPSBvcHRpb25zLnRpbGVDYWNoZTtcbiAgICBkZWxldGUgb3B0aW9ucy50aWxlQ2FjaGU7XG5cbiAgICB0aGlzLl9kcmF3ZXIgPSBvcHRpb25zLmRyYXdlcjtcbiAgICBkZWxldGUgb3B0aW9ucy5kcmF3ZXI7XG5cbiAgICB0aGlzLl9pbWFnZUxvYWRlciA9IG9wdGlvbnMuaW1hZ2VMb2FkZXI7XG4gICAgZGVsZXRlIG9wdGlvbnMuaW1hZ2VMb2FkZXI7XG5cbiAgICBpZiAob3B0aW9ucy5jbGlwIGluc3RhbmNlb2YgJC5SZWN0KSB7XG4gICAgICAgIHRoaXMuX2NsaXAgPSBvcHRpb25zLmNsaXAuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0aW9ucy5jbGlwO1xuXG4gICAgdmFyIHggPSBvcHRpb25zLnggfHwgMDtcbiAgICBkZWxldGUgb3B0aW9ucy54O1xuICAgIHZhciB5ID0gb3B0aW9ucy55IHx8IDA7XG4gICAgZGVsZXRlIG9wdGlvbnMueTtcblxuICAgIC8vIFJhdGlvIG9mIHpvb21hYmxlIGltYWdlIGhlaWdodCB0byB3aWR0aC5cbiAgICB0aGlzLm5vcm1IZWlnaHQgPSBvcHRpb25zLnNvdXJjZS5kaW1lbnNpb25zLnkgLyBvcHRpb25zLnNvdXJjZS5kaW1lbnNpb25zLng7XG4gICAgdGhpcy5jb250ZW50QXNwZWN0WCA9IG9wdGlvbnMuc291cmNlLmRpbWVuc2lvbnMueCAvIG9wdGlvbnMuc291cmNlLmRpbWVuc2lvbnMueTtcblxuICAgIHZhciBzY2FsZSA9IDE7XG4gICAgaWYgKCBvcHRpb25zLndpZHRoICkge1xuICAgICAgICBzY2FsZSA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLndpZHRoO1xuXG4gICAgICAgIGlmICggb3B0aW9ucy5oZWlnaHQgKSB7XG4gICAgICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwic3BlY2lmeWluZyBib3RoIHdpZHRoIGFuZCBoZWlnaHQgdG8gYSB0aWxlZEltYWdlIGlzIG5vdCBzdXBwb3J0ZWRcIiApO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICggb3B0aW9ucy5oZWlnaHQgKSB7XG4gICAgICAgIHNjYWxlID0gb3B0aW9ucy5oZWlnaHQgLyB0aGlzLm5vcm1IZWlnaHQ7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgZml0Qm91bmRzID0gb3B0aW9ucy5maXRCb3VuZHM7XG4gICAgZGVsZXRlIG9wdGlvbnMuZml0Qm91bmRzO1xuICAgIHZhciBmaXRCb3VuZHNQbGFjZW1lbnQgPSBvcHRpb25zLmZpdEJvdW5kc1BsYWNlbWVudCB8fCBPcGVuU2VhZHJhZ29uLlBsYWNlbWVudC5DRU5URVI7XG4gICAgZGVsZXRlIG9wdGlvbnMuZml0Qm91bmRzUGxhY2VtZW50O1xuXG4gICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIHtcblxuICAgICAgICAvL2ludGVybmFsIHN0YXRlIHByb3BlcnRpZXNcbiAgICAgICAgdmlld2VyOiAgICAgICAgIG51bGwsXG4gICAgICAgIHRpbGVzTWF0cml4OiAgICB7fSwgICAgLy8gQSAnM2QnIGRpY3Rpb25hcnkgW2xldmVsXVt4XVt5XSAtLT4gVGlsZS5cbiAgICAgICAgY292ZXJhZ2U6ICAgICAgIHt9LCAgICAvLyBBICczZCcgZGljdGlvbmFyeSBbbGV2ZWxdW3hdW3ldIC0tPiBCb29sZWFuLlxuICAgICAgICBsYXN0RHJhd246ICAgICAgW10sICAgIC8vIEFuIHVub3JkZXJlZCBsaXN0IG9mIFRpbGVzIGRyYXduIGxhc3QgZnJhbWUuXG4gICAgICAgIGxhc3RSZXNldFRpbWU6ICAwLCAgICAgLy8gTGFzdCB0aW1lIGZvciB3aGljaCB0aGUgdGlsZWRJbWFnZSB3YXMgcmVzZXQuXG4gICAgICAgIF9taWREcmF3OiAgICAgICBmYWxzZSwgLy8gSXMgdGhlIHRpbGVkSW1hZ2UgY3VycmVudGx5IHVwZGF0aW5nIHRoZSB2aWV3cG9ydD9cbiAgICAgICAgX25lZWRzRHJhdzogICAgIHRydWUsICAvLyBEb2VzIHRoZSB0aWxlZEltYWdlIG5lZWQgdG8gdXBkYXRlIHRoZSB2aWV3cG9ydCBhZ2Fpbj9cbiAgICAgICAgX2hhc09wYXF1ZVRpbGU6IGZhbHNlLCAgLy8gRG8gd2UgaGF2ZSBldmVuIG9uZSBmdWxseSBvcGFxdWUgdGlsZT9cbiAgICAgICAgLy9jb25maWd1cmFibGUgc2V0dGluZ3NcbiAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogICAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLmFuaW1hdGlvblRpbWUsXG4gICAgICAgIG1pblpvb21JbWFnZVJhdGlvOiAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5taW5ab29tSW1hZ2VSYXRpbyxcbiAgICAgICAgd3JhcEhvcml6b250YWw6ICAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLndyYXBIb3Jpem9udGFsLFxuICAgICAgICB3cmFwVmVydGljYWw6ICAgICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1Mud3JhcFZlcnRpY2FsLFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6ICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBibGVuZFRpbWU6ICAgICAgICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuYmxlbmRUaW1lLFxuICAgICAgICBhbHdheXNCbGVuZDogICAgICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuYWx3YXlzQmxlbmQsXG4gICAgICAgIG1pblBpeGVsUmF0aW86ICAgICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5taW5QaXhlbFJhdGlvLFxuICAgICAgICBzbW9vdGhUaWxlRWRnZXNNaW5ab29tOiAkLkRFRkFVTFRfU0VUVElOR1Muc21vb3RoVGlsZUVkZ2VzTWluWm9vbSxcbiAgICAgICAgaU9TRGV2aWNlOiAgICAgICAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLmlPU0RldmljZSxcbiAgICAgICAgZGVidWdNb2RlOiAgICAgICAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLmRlYnVnTW9kZSxcbiAgICAgICAgY3Jvc3NPcmlnaW5Qb2xpY3k6ICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLmNyb3NzT3JpZ2luUG9saWN5LFxuICAgICAgICBwbGFjZWhvbGRlckZpbGxTdHlsZTogICAkLkRFRkFVTFRfU0VUVElOR1MucGxhY2Vob2xkZXJGaWxsU3R5bGUsXG4gICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5vcGFjaXR5LFxuICAgICAgICBjb21wb3NpdGVPcGVyYXRpb246ICAgICAkLkRFRkFVTFRfU0VUVElOR1MuY29tcG9zaXRlT3BlcmF0aW9uXG5cbiAgICB9LCBvcHRpb25zICk7XG5cbiAgICB0aGlzLl94U3ByaW5nID0gbmV3ICQuU3ByaW5nKHtcbiAgICAgICAgaW5pdGlhbDogeCxcbiAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiB0aGlzLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogdGhpcy5hbmltYXRpb25UaW1lXG4gICAgfSk7XG5cbiAgICB0aGlzLl95U3ByaW5nID0gbmV3ICQuU3ByaW5nKHtcbiAgICAgICAgaW5pdGlhbDogeSxcbiAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiB0aGlzLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogdGhpcy5hbmltYXRpb25UaW1lXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zY2FsZVNwcmluZyA9IG5ldyAkLlNwcmluZyh7XG4gICAgICAgIGluaXRpYWw6IHNjYWxlLFxuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6IHRoaXMuc3ByaW5nU3RpZmZuZXNzLFxuICAgICAgICBhbmltYXRpb25UaW1lOiB0aGlzLmFuaW1hdGlvblRpbWVcbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZUZvclNjYWxlKCk7XG5cbiAgICBpZiAoZml0Qm91bmRzKSB7XG4gICAgICAgIHRoaXMuZml0Qm91bmRzKGZpdEJvdW5kcywgZml0Qm91bmRzUGxhY2VtZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIGEgY2FsbGJhY2sgdG8gZ2l2ZSBpbWFnZSBtYW5pcHVsYXRpb24gYSBjaGFuY2UgdG8gaGFwcGVuXG4gICAgdGhpcy5fZHJhd2luZ0hhbmRsZXIgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQganVzdCBiZWZvcmUgdGhlIHRpbGUgaXMgZHJhd24gZ2l2aW5nIHRoZSBhcHBsaWNhdGlvbiBhIGNoYW5jZSB0byBhbHRlciB0aGUgaW1hZ2UuXG4gICAgICAgKlxuICAgICAgICogTk9URTogVGhpcyBldmVudCBpcyBvbmx5IGZpcmVkIHdoZW4gdGhlIGRyYXdlciBpcyB1c2luZyBhICZsdDtjYW52YXMmZ3Q7LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCB0aWxlLWRyYXdpbmdcbiAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGV9IHRpbGUgLSBUaGUgVGlsZSBiZWluZyBkcmF3bi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSB0aWxlZEltYWdlIC0gV2hpY2ggVGlsZWRJbWFnZSBpcyBiZWluZyBkcmF3bi5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlfSBjb250ZXh0IC0gVGhlIEhUTUwgY2FudmFzIGNvbnRleHQgYmVpbmcgZHJhd24gaW50by5cbiAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlfSByZW5kZXJlZCAtIFRoZSBIVE1MIGNhbnZhcyBjb250ZXh0IGNvbnRhaW5pbmcgdGhlIHRpbGUgaW1hZ2VyeS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgICBfdGhpcy52aWV3ZXIucmFpc2VFdmVudCgndGlsZS1kcmF3aW5nJywgJC5leHRlbmQoe1xuICAgICAgICAgICAgdGlsZWRJbWFnZTogX3RoaXNcbiAgICAgICAgfSwgYXJncykpO1xuICAgIH07XG59O1xuXG4kLmV4dGVuZCgkLlRpbGVkSW1hZ2UucHJvdG90eXBlLCAkLkV2ZW50U291cmNlLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2UucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBUaWxlZEltYWdlIG5lZWRzIHRvIGJlIGRyYXduLlxuICAgICAqL1xuICAgIG5lZWRzRHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZWVkc0RyYXc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgdGlsZXMgYW5kIHRyaWdnZXJzIGFuIHVwZGF0ZSBvbiB0aGUgbmV4dCBjYWxsIHRvXG4gICAgICoge0BsaW5rIE9wZW5TZWFkcmFnb24uVGlsZWRJbWFnZSN1cGRhdGV9LlxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGlsZUNhY2hlLmNsZWFyVGlsZXNGb3IodGhpcyk7XG4gICAgICAgIHRoaXMubGFzdFJlc2V0VGltZSA9ICQubm93KCk7XG4gICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIFRpbGVkSW1hZ2UncyBib3VuZHMsIGFuaW1hdGluZyBpZiBuZWVkZWQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIFRpbGVkSW1hZ2UgYW5pbWF0ZWQuXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9sZFggPSB0aGlzLl94U3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgICAgIHZhciBvbGRZID0gdGhpcy5feVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgICAgICB2YXIgb2xkU2NhbGUgPSB0aGlzLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgICAgIHRoaXMuX3hTcHJpbmcudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3lTcHJpbmcudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3NjYWxlU3ByaW5nLnVwZGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl94U3ByaW5nLmN1cnJlbnQudmFsdWUgIT09IG9sZFggfHwgdGhpcy5feVNwcmluZy5jdXJyZW50LnZhbHVlICE9PSBvbGRZIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZSAhPT0gb2xkU2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvclNjYWxlKCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBUaWxlZEltYWdlIHRvIGl0cyBEcmF3ZXIuXG4gICAgICovXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX21pZERyYXcgPSB0cnVlO1xuICAgICAgICAgICAgdXBkYXRlVmlld3BvcnQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9taWREcmF3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgVGlsZWRJbWFnZSAodW5sb2FkIGN1cnJlbnQgbG9hZGVkIHRpbGVzKS5cbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fSBUaGlzIFRpbGVkSW1hZ2UncyBib3VuZHMgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uOyBmYWxzZSBmb3IgdGFyZ2V0IGxvY2F0aW9uLlxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoIHRoaXMuX3hTcHJpbmcuY3VycmVudC52YWx1ZSwgdGhpcy5feVNwcmluZy5jdXJyZW50LnZhbHVlLFxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmxkV2lkdGhDdXJyZW50LCB0aGlzLl93b3JsZEhlaWdodEN1cnJlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KCB0aGlzLl94U3ByaW5nLnRhcmdldC52YWx1ZSwgdGhpcy5feVNwcmluZy50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICB0aGlzLl93b3JsZFdpZHRoVGFyZ2V0LCB0aGlzLl93b3JsZEhlaWdodFRhcmdldCApO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZ2V0V29ybGRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoJ1tUaWxlZEltYWdlLmdldFdvcmxkQm91bmRzXSBpcyBkZXByZWNhdGVkOyB1c2UgVGlsZWRJbWFnZS5nZXRCb3VuZHMgaW5zdGVhZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXllZCBwYXJ0IG9mIHRoZSB0aWxlZCBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uLFxuICAgICAqIGZhbHNlIGZvciB0aGUgdGFyZ2V0IGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHskLlJlY3R9IFRoZSBjbGlwcGVkIGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRDbGlwcGVkQm91bmRzOiBmdW5jdGlvbihjdXJyZW50KSB7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyhjdXJyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2NsaXApIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IHRoaXMuX3dvcmxkV2lkdGhDdXJyZW50IC8gdGhpcy5zb3VyY2UuZGltZW5zaW9ucy54O1xuICAgICAgICAgICAgdmFyIGNsaXAgPSB0aGlzLl9jbGlwLnRpbWVzKHJhdGlvKTtcbiAgICAgICAgICAgIGJvdW5kcyA9IG5ldyAkLlJlY3QoXG4gICAgICAgICAgICAgICAgYm91bmRzLnggKyBjbGlwLngsXG4gICAgICAgICAgICAgICAgYm91bmRzLnkgKyBjbGlwLnksXG4gICAgICAgICAgICAgICAgY2xpcC53aWR0aCxcbiAgICAgICAgICAgICAgICBjbGlwLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IFRoaXMgVGlsZWRJbWFnZSdzIGNvbnRlbnQgc2l6ZSwgaW4gb3JpZ2luYWwgcGl4ZWxzLlxuICAgICAqL1xuICAgIGdldENvbnRlbnRTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHRoaXMuc291cmNlLmRpbWVuc2lvbnMueCwgdGhpcy5zb3VyY2UuZGltZW5zaW9ucy55KTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF92aWV3cG9ydFRvSW1hZ2VEZWx0YTogZnVuY3Rpb24oIHZpZXdlclgsIHZpZXdlclksIGN1cnJlbnQgKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IChjdXJyZW50ID8gdGhpcy5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZSA6IHRoaXMuX3NjYWxlU3ByaW5nLnRhcmdldC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCh2aWV3ZXJYICogKHRoaXMuc291cmNlLmRpbWVuc2lvbnMueCAvIHNjYWxlKSxcbiAgICAgICAgICAgIHZpZXdlclkgKiAoKHRoaXMuc291cmNlLmRpbWVuc2lvbnMueSAqIHRoaXMuY29udGVudEFzcGVjdFgpIC8gc2NhbGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBmcm9tIE9wZW5TZWFkcmFnb24gdmlld2VyIGNvb3JkaW5hdGUgc3lzdGVtIHRvIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGJ5IHBhc3NpbmcgWCxZIGNvb3JkaW5hdGVzIG9yIGFuIHtAbGluayBPcGVuU2VhZHJhZ29uLlBvaW50fS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxPcGVuU2VhZHJhZ29uLlBvaW50fSB2aWV3ZXJYIC0gVGhlIFggY29vcmRpbmF0ZSBvciBwb2ludCBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ZpZXdlclldIC0gVGhlIFkgY29vcmRpbmF0ZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIGN1cnJlbnQgbG9jYXRpb247IGZhbHNlIGZvciB0YXJnZXQgbG9jYXRpb24uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5Qb2ludH0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvb3JkaW5hdGVzIGluIHRoZSBpbWFnZS5cbiAgICAgKi9cbiAgICB2aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlczogZnVuY3Rpb24oIHZpZXdlclgsIHZpZXdlclksIGN1cnJlbnQgKSB7XG4gICAgICAgIGlmICh2aWV3ZXJYIGluc3RhbmNlb2YgJC5Qb2ludCkge1xuICAgICAgICAgICAgLy90aGV5IHBhc3NlZCBhIHBvaW50IGluc3RlYWQgb2YgaW5kaXZpZHVhbCBjb21wb25lbnRzXG4gICAgICAgICAgICBjdXJyZW50ID0gdmlld2VyWTtcbiAgICAgICAgICAgIHZpZXdlclkgPSB2aWV3ZXJYLnk7XG4gICAgICAgICAgICB2aWV3ZXJYID0gdmlld2VyWC54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFRvSW1hZ2VEZWx0YSh2aWV3ZXJYIC0gdGhpcy5feFNwcmluZy5jdXJyZW50LnZhbHVlLFxuICAgICAgICAgICAgICAgIHZpZXdlclkgLSB0aGlzLl95U3ByaW5nLmN1cnJlbnQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0VG9JbWFnZURlbHRhKHZpZXdlclggLSB0aGlzLl94U3ByaW5nLnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgIHZpZXdlclkgLSB0aGlzLl95U3ByaW5nLnRhcmdldC52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfaW1hZ2VUb1ZpZXdwb3J0RGVsdGE6IGZ1bmN0aW9uKCBpbWFnZVgsIGltYWdlWSwgY3VycmVudCApIHtcbiAgICAgICAgdmFyIHNjYWxlID0gKGN1cnJlbnQgPyB0aGlzLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlIDogdGhpcy5fc2NhbGVTcHJpbmcudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KChpbWFnZVggLyB0aGlzLnNvdXJjZS5kaW1lbnNpb25zLngpICogc2NhbGUsXG4gICAgICAgICAgICAoaW1hZ2VZIC8gdGhpcy5zb3VyY2UuZGltZW5zaW9ucy55IC8gdGhpcy5jb250ZW50QXNwZWN0WCkgKiBzY2FsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZnJvbSBpbWFnZSBjb29yZGluYXRlIHN5c3RlbSB0byBPcGVuU2VhZHJhZ29uIHZpZXdlciBjb29yZGluYXRlIHN5c3RlbVxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGJ5IHBhc3NpbmcgWCxZIGNvb3JkaW5hdGVzIG9yIGFuIHtAbGluayBPcGVuU2VhZHJhZ29uLlBvaW50fS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxPcGVuU2VhZHJhZ29uLlBvaW50fSBpbWFnZVggLSBUaGUgWCBjb29yZGluYXRlIG9yIHBvaW50IGluIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VZXSAtIFRoZSBZIGNvb3JkaW5hdGUgaW4gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgdG8gdXNlIHRoZSBjdXJyZW50IGxvY2F0aW9uOyBmYWxzZSBmb3IgdGFyZ2V0IGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUG9pbnR9IEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb29yZGluYXRlcyBpbiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgaW1hZ2VUb1ZpZXdwb3J0Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBpbWFnZVgsIGltYWdlWSwgY3VycmVudCApIHtcbiAgICAgICAgaWYgKGltYWdlWCBpbnN0YW5jZW9mICQuUG9pbnQpIHtcbiAgICAgICAgICAgIC8vdGhleSBwYXNzZWQgYSBwb2ludCBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgY29tcG9uZW50c1xuICAgICAgICAgICAgY3VycmVudCA9IGltYWdlWTtcbiAgICAgICAgICAgIGltYWdlWSA9IGltYWdlWC55O1xuICAgICAgICAgICAgaW1hZ2VYID0gaW1hZ2VYLng7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLl9pbWFnZVRvVmlld3BvcnREZWx0YShpbWFnZVgsIGltYWdlWSk7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBwb2ludC54ICs9IHRoaXMuX3hTcHJpbmcuY3VycmVudC52YWx1ZTtcbiAgICAgICAgICAgIHBvaW50LnkgKz0gdGhpcy5feVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnQueCArPSB0aGlzLl94U3ByaW5nLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIHBvaW50LnkgKz0gdGhpcy5feVNwcmluZy50YXJnZXQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZnJvbSBhIHJlY3RhbmdsZSB3aGljaCBkZXNjcmliZXMgYSBwb3J0aW9uIG9mIHRoZSBpbWFnZSBpblxuICAgICAqIHBpeGVsIGNvb3JkaW5hdGVzIHRvIE9wZW5TZWFkcmFnb24gdmlld3BvcnQgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGJ5IHBhc3NpbmcgWCxZLHdpZHRoLGhlaWdodCBvciBhbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5SZWN0fS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxPcGVuU2VhZHJhZ29uLlJlY3R9IGltYWdlWCAtIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb3IgcmVjdGFuZ2xlIGluIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VZXSAtIFRoZSB0b3AgY29vcmRpbmF0ZSBpbiBpbWFnZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BpeGVsV2lkdGhdIC0gVGhlIHdpZHRoIGluIHBpeGVsIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwaXhlbEhlaWdodF0gLSBUaGUgaGVpZ2h0IGluIHBpeGVsIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgdG8gdXNlIHRoZSBjdXJyZW50IGxvY2F0aW9uOyBmYWxzZSBmb3IgdGFyZ2V0IGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUmVjdH0gQSByZWN0IHJlcHJlc2VudGluZyB0aGUgY29vcmRpbmF0ZXMgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIGltYWdlVG9WaWV3cG9ydFJlY3RhbmdsZTogZnVuY3Rpb24oIGltYWdlWCwgaW1hZ2VZLCBwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCwgY3VycmVudCApIHtcbiAgICAgICAgdmFyIHJlY3QgPSBpbWFnZVg7XG4gICAgICAgIGlmIChyZWN0IGluc3RhbmNlb2YgJC5SZWN0KSB7XG4gICAgICAgICAgICAvL3RoZXkgcGFzc2VkIGEgcmVjdCBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgY29tcG9uZW50c1xuICAgICAgICAgICAgY3VycmVudCA9IGltYWdlWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QgPSBuZXcgJC5SZWN0KGltYWdlWCwgaW1hZ2VZLCBwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRBID0gdGhpcy5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlcyhyZWN0LmdldFRvcExlZnQoKSwgY3VycmVudCk7XG4gICAgICAgIHZhciBjb29yZEIgPSB0aGlzLl9pbWFnZVRvVmlld3BvcnREZWx0YShyZWN0LndpZHRoLCByZWN0LmhlaWdodCwgY3VycmVudCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBjb29yZEEueCxcbiAgICAgICAgICAgIGNvb3JkQS55LFxuICAgICAgICAgICAgY29vcmRCLngsXG4gICAgICAgICAgICBjb29yZEIueSxcbiAgICAgICAgICAgIHJlY3QuZGVncmVlc1xuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGZyb20gYSByZWN0YW5nbGUgd2hpY2ggZGVzY3JpYmVzIGEgcG9ydGlvbiBvZlxuICAgICAqIHRoZSB2aWV3cG9ydCBpbiBwb2ludCBjb29yZGluYXRlcyB0byBpbWFnZSByZWN0YW5nbGUgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBlaXRoZXIgYnkgcGFzc2luZyBYLFksd2lkdGgsaGVpZ2h0IG9yIGFuIHtAbGluayBPcGVuU2VhZHJhZ29uLlJlY3R9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9wZW5TZWFkcmFnb24uUmVjdH0gdmlld2VyWCAtIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb3IgcmVjdGFuZ2xlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdmlld2VyWV0gLSBUaGUgdG9wIGNvb3JkaW5hdGUgaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwb2ludFdpZHRoXSAtIFRoZSB3aWR0aCBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BvaW50SGVpZ2h0XSAtIFRoZSBoZWlnaHQgaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgdG8gdXNlIHRoZSBjdXJyZW50IGxvY2F0aW9uOyBmYWxzZSBmb3IgdGFyZ2V0IGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUmVjdH0gQSByZWN0IHJlcHJlc2VudGluZyB0aGUgY29vcmRpbmF0ZXMgaW4gdGhlIGltYWdlLlxuICAgICAqL1xuICAgIHZpZXdwb3J0VG9JbWFnZVJlY3RhbmdsZTogZnVuY3Rpb24oIHZpZXdlclgsIHZpZXdlclksIHBvaW50V2lkdGgsIHBvaW50SGVpZ2h0LCBjdXJyZW50ICkge1xuICAgICAgICB2YXIgcmVjdCA9IHZpZXdlclg7XG4gICAgICAgIGlmICh2aWV3ZXJYIGluc3RhbmNlb2YgJC5SZWN0KSB7XG4gICAgICAgICAgICAvL3RoZXkgcGFzc2VkIGEgcmVjdCBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgY29tcG9uZW50c1xuICAgICAgICAgICAgY3VycmVudCA9IHZpZXdlclk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN0ID0gbmV3ICQuUmVjdCh2aWV3ZXJYLCB2aWV3ZXJZLCBwb2ludFdpZHRoLCBwb2ludEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRBID0gdGhpcy52aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlcyhyZWN0LmdldFRvcExlZnQoKSwgY3VycmVudCk7XG4gICAgICAgIHZhciBjb29yZEIgPSB0aGlzLl92aWV3cG9ydFRvSW1hZ2VEZWx0YShyZWN0LndpZHRoLCByZWN0LmhlaWdodCwgY3VycmVudCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBjb29yZEEueCxcbiAgICAgICAgICAgIGNvb3JkQS55LFxuICAgICAgICAgICAgY29vcmRCLngsXG4gICAgICAgICAgICBjb29yZEIueSxcbiAgICAgICAgICAgIHJlY3QuZGVncmVlc1xuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHBpeGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB2aWV3ZXIgZWxlbWVudCB0byBpbWFnZVxuICAgICAqIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcGl4ZWxcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICB2aWV3ZXJFbGVtZW50VG9JbWFnZUNvb3JkaW5hdGVzOiBmdW5jdGlvbiggcGl4ZWwgKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMudmlld3BvcnQucG9pbnRGcm9tUGl4ZWwoIHBpeGVsLCB0cnVlICk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzKCBwb2ludCApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHBpeGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSBpbWFnZSB0b1xuICAgICAqIHZpZXdlciBlbGVtZW50IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcGl4ZWxcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBpbWFnZVRvVmlld2VyRWxlbWVudENvb3JkaW5hdGVzOiBmdW5jdGlvbiggcGl4ZWwgKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuaW1hZ2VUb1ZpZXdwb3J0Q29vcmRpbmF0ZXMoIHBpeGVsICk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0LnBpeGVsRnJvbVBvaW50KCBwb2ludCwgdHJ1ZSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHBpeGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cgdG8gaW1hZ2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHdpbmRvd1RvSW1hZ2VDb29yZGluYXRlczogZnVuY3Rpb24oIHBpeGVsICkge1xuICAgICAgICB2YXIgdmlld2VyQ29vcmRpbmF0ZXMgPSBwaXhlbC5taW51cyhcbiAgICAgICAgICAgICAgICBPcGVuU2VhZHJhZ29uLmdldEVsZW1lbnRQb3NpdGlvbiggdGhpcy52aWV3ZXIuZWxlbWVudCApKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld2VyRWxlbWVudFRvSW1hZ2VDb29yZGluYXRlcyggdmlld2VyQ29vcmRpbmF0ZXMgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBpbWFnZSBjb29yZGluYXRlcyB0byBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcGl4ZWxcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBpbWFnZVRvV2luZG93Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBwaXhlbCApIHtcbiAgICAgICAgdmFyIHZpZXdlckNvb3JkaW5hdGVzID0gdGhpcy5pbWFnZVRvVmlld2VyRWxlbWVudENvb3JkaW5hdGVzKCBwaXhlbCApO1xuICAgICAgICByZXR1cm4gdmlld2VyQ29vcmRpbmF0ZXMucGx1cyhcbiAgICAgICAgICAgICAgICBPcGVuU2VhZHJhZ29uLmdldEVsZW1lbnRQb3NpdGlvbiggdGhpcy52aWV3ZXIuZWxlbWVudCApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHZpZXdwb3J0IHpvb20gdG8gYW4gaW1hZ2Ugem9vbS5cbiAgICAgKiBJbWFnZSB6b29tOiByYXRpbyBvZiB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZSB0byBkaXNwbGF5ZWQgaW1hZ2Ugc2l6ZS5cbiAgICAgKiAxIG1lYW5zIG9yaWdpbmFsIGltYWdlIHNpemUsIDAuNSBoYWxmIHNpemUuLi5cbiAgICAgKiBWaWV3cG9ydCB6b29tOiByYXRpbyBvZiB0aGUgZGlzcGxheWVkIGltYWdlJ3Mgd2lkdGggdG8gdmlld3BvcnQncyB3aWR0aC5cbiAgICAgKiAxIG1lYW5zIGlkZW50aWNhbCB3aWR0aCwgMiBtZWFucyBpbWFnZSdzIHdpZHRoIGlzIHR3aWNlIHRoZSB2aWV3cG9ydCdzIHdpZHRoLi4uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0Wm9vbSBUaGUgdmlld3BvcnQgem9vbVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGltYWdlWm9vbSBUaGUgaW1hZ2Ugem9vbVxuICAgICAqL1xuICAgIHZpZXdwb3J0VG9JbWFnZVpvb206IGZ1bmN0aW9uKCB2aWV3cG9ydFpvb20gKSB7XG4gICAgICAgIHZhciByYXRpbyA9IHRoaXMuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWUgKlxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuX2NvbnRhaW5lcklubmVyU2l6ZS54IC8gdGhpcy5zb3VyY2UuZGltZW5zaW9ucy54O1xuICAgICAgICByZXR1cm4gcmF0aW8gKiB2aWV3cG9ydFpvb20gO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGltYWdlIHpvb20gdG8gYSB2aWV3cG9ydCB6b29tLlxuICAgICAqIEltYWdlIHpvb206IHJhdGlvIG9mIHRoZSBvcmlnaW5hbCBpbWFnZSBzaXplIHRvIGRpc3BsYXllZCBpbWFnZSBzaXplLlxuICAgICAqIDEgbWVhbnMgb3JpZ2luYWwgaW1hZ2Ugc2l6ZSwgMC41IGhhbGYgc2l6ZS4uLlxuICAgICAqIFZpZXdwb3J0IHpvb206IHJhdGlvIG9mIHRoZSBkaXNwbGF5ZWQgaW1hZ2UncyB3aWR0aCB0byB2aWV3cG9ydCdzIHdpZHRoLlxuICAgICAqIDEgbWVhbnMgaWRlbnRpY2FsIHdpZHRoLCAyIG1lYW5zIGltYWdlJ3Mgd2lkdGggaXMgdHdpY2UgdGhlIHZpZXdwb3J0J3Mgd2lkdGguLi5cbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW1hZ2Vab29tIFRoZSBpbWFnZSB6b29tXG4gICAgICogQHJldHVybnMge051bWJlcn0gdmlld3BvcnRab29tIFRoZSB2aWV3cG9ydCB6b29tXG4gICAgICovXG4gICAgaW1hZ2VUb1ZpZXdwb3J0Wm9vbTogZnVuY3Rpb24oIGltYWdlWm9vbSApIHtcbiAgICAgICAgdmFyIHJhdGlvID0gdGhpcy5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZSAqXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5fY29udGFpbmVySW5uZXJTaXplLnggLyB0aGlzLnNvdXJjZS5kaW1lbnNpb25zLng7XG4gICAgICAgIHJldHVybiBpbWFnZVpvb20gLyByYXRpbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgVGlsZWRJbWFnZSdzIHBvc2l0aW9uIGluIHRoZSB3b3JsZC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIG5ldyBwb3NpdGlvbiwgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdIC0gV2hldGhlciB0byBhbmltYXRlIHRvIHRoZSBuZXcgcG9zaXRpb24gb3Igc25hcCBpbW1lZGlhdGVseS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5UaWxlZEltYWdlLmV2ZW50OmJvdW5kcy1jaGFuZ2VcbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBzYW1lVGFyZ2V0ID0gKHRoaXMuX3hTcHJpbmcudGFyZ2V0LnZhbHVlID09PSBwb3NpdGlvbi54ICYmXG4gICAgICAgICAgICB0aGlzLl95U3ByaW5nLnRhcmdldC52YWx1ZSA9PT0gcG9zaXRpb24ueSk7XG5cbiAgICAgICAgaWYgKGltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICBpZiAoc2FtZVRhcmdldCAmJiB0aGlzLl94U3ByaW5nLmN1cnJlbnQudmFsdWUgPT09IHBvc2l0aW9uLnggJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feVNwcmluZy5jdXJyZW50LnZhbHVlID09PSBwb3NpdGlvbi55KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl94U3ByaW5nLnJlc2V0VG8ocG9zaXRpb24ueCk7XG4gICAgICAgICAgICB0aGlzLl95U3ByaW5nLnJlc2V0VG8ocG9zaXRpb24ueSk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNhbWVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hTcHJpbmcuc3ByaW5nVG8ocG9zaXRpb24ueCk7XG4gICAgICAgICAgICB0aGlzLl95U3ByaW5nLnNwcmluZ1RvKHBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2FtZVRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fcmFpc2VCb3VuZHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBUaWxlZEltYWdlJ3Mgd2lkdGggaW4gdGhlIHdvcmxkLCBhZGp1c3RpbmcgdGhlIGhlaWdodCB0byBtYXRjaCBiYXNlZCBvbiBhc3BlY3QgcmF0aW8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCwgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdIC0gV2hldGhlciB0byBhbmltYXRlIHRvIHRoZSBuZXcgc2l6ZSBvciBzbmFwIGltbWVkaWF0ZWx5LlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2UuZXZlbnQ6Ym91bmRzLWNoYW5nZVxuICAgICAqL1xuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCwgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdGhpcy5fc2V0U2NhbGUod2lkdGgsIGltbWVkaWF0ZWx5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgVGlsZWRJbWFnZSdzIGhlaWdodCBpbiB0aGUgd29ybGQsIGFkanVzdGluZyB0aGUgd2lkdGggdG8gbWF0Y2ggYmFzZWQgb24gYXNwZWN0IHJhdGlvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCwgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdIC0gV2hldGhlciB0byBhbmltYXRlIHRvIHRoZSBuZXcgc2l6ZSBvciBzbmFwIGltbWVkaWF0ZWx5LlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2UuZXZlbnQ6Ym91bmRzLWNoYW5nZVxuICAgICAqL1xuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBpbW1lZGlhdGVseSkge1xuICAgICAgICB0aGlzLl9zZXRTY2FsZShoZWlnaHQgLyB0aGlzLm5vcm1IZWlnaHQsIGltbWVkaWF0ZWx5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIGFuZCBzY2FsZXMgdGhlIFRpbGVkSW1hZ2UgdG8gZml0IGluIHRoZSBzcGVjaWZpZWQgYm91bmRzLlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGZpcmVzIE9wZW5TZWFkcmFnb24uVGlsZWRJbWFnZS5ldmVudDpib3VuZHMtY2hhbmdlXG4gICAgICogdHdpY2VcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gYm91bmRzIFRoZSBib3VuZHMgdG8gZml0IHRoZSBpbWFnZSBpbnRvLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IFthbmNob3I9T3BlblNlYWRyYWdvbi5QbGFjZW1lbnQuQ0VOVEVSXVxuICAgICAqIEhvdyB0byBhbmNob3IgdGhlIGltYWdlIGluIHRoZSBib3VuZHMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdIFdoZXRoZXIgdG8gYW5pbWF0ZSB0byB0aGUgbmV3IHNpemVcbiAgICAgKiBvciBzbmFwIGltbWVkaWF0ZWx5LlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2UuZXZlbnQ6Ym91bmRzLWNoYW5nZVxuICAgICAqL1xuICAgIGZpdEJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBhbmNob3IsIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGFuY2hvciA9IGFuY2hvciB8fCAkLlBsYWNlbWVudC5DRU5URVI7XG4gICAgICAgIHZhciBhbmNob3JQcm9wZXJ0aWVzID0gJC5QbGFjZW1lbnQucHJvcGVydGllc1thbmNob3JdO1xuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSB0aGlzLmNvbnRlbnRBc3BlY3RYO1xuICAgICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGRpc3BsYXllZFdpZHRoUmF0aW8gPSAxO1xuICAgICAgICB2YXIgZGlzcGxheWVkSGVpZ2h0UmF0aW8gPSAxO1xuICAgICAgICBpZiAodGhpcy5fY2xpcCkge1xuICAgICAgICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLl9jbGlwLmdldEFzcGVjdFJhdGlvKCk7XG4gICAgICAgICAgICBkaXNwbGF5ZWRXaWR0aFJhdGlvID0gdGhpcy5fY2xpcC53aWR0aCAvIHRoaXMuc291cmNlLmRpbWVuc2lvbnMueDtcbiAgICAgICAgICAgIGRpc3BsYXllZEhlaWdodFJhdGlvID0gdGhpcy5fY2xpcC5oZWlnaHQgLyB0aGlzLnNvdXJjZS5kaW1lbnNpb25zLnk7XG4gICAgICAgICAgICBpZiAoYm91bmRzLmdldEFzcGVjdFJhdGlvKCkgPiBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIHhPZmZzZXQgPSB0aGlzLl9jbGlwLnggLyB0aGlzLl9jbGlwLmhlaWdodCAqIGJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgeU9mZnNldCA9IHRoaXMuX2NsaXAueSAvIHRoaXMuX2NsaXAuaGVpZ2h0ICogYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeE9mZnNldCA9IHRoaXMuX2NsaXAueCAvIHRoaXMuX2NsaXAud2lkdGggKiBib3VuZHMud2lkdGg7XG4gICAgICAgICAgICAgICAgeU9mZnNldCA9IHRoaXMuX2NsaXAueSAvIHRoaXMuX2NsaXAud2lkdGggKiBib3VuZHMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm91bmRzLmdldEFzcGVjdFJhdGlvKCkgPiBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgLy8gV2Ugd2lsbCBoYXZlIG1hcmdpbnMgb24gdGhlIFggYXhpc1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLyBkaXNwbGF5ZWRIZWlnaHRSYXRpbztcbiAgICAgICAgICAgIHZhciBtYXJnaW5MZWZ0ID0gMDtcbiAgICAgICAgICAgIGlmIChhbmNob3JQcm9wZXJ0aWVzLmlzSG9yaXpvbnRhbGx5Q2VudGVyZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gKGJvdW5kcy53aWR0aCAtIGJvdW5kcy5oZWlnaHQgKiBhc3BlY3RSYXRpbykgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNob3JQcm9wZXJ0aWVzLmlzUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gYm91bmRzLndpZHRoIC0gYm91bmRzLmhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihcbiAgICAgICAgICAgICAgICBuZXcgJC5Qb2ludChib3VuZHMueCAtIHhPZmZzZXQgKyBtYXJnaW5MZWZ0LCBib3VuZHMueSAtIHlPZmZzZXQpLFxuICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCwgaW1tZWRpYXRlbHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2Ugd2lsbCBoYXZlIG1hcmdpbnMgb24gdGhlIFkgYXhpc1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gYm91bmRzLndpZHRoIC8gZGlzcGxheWVkV2lkdGhSYXRpbztcbiAgICAgICAgICAgIHZhciBtYXJnaW5Ub3AgPSAwO1xuICAgICAgICAgICAgaWYgKGFuY2hvclByb3BlcnRpZXMuaXNWZXJ0aWNhbGx5Q2VudGVyZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSAoYm91bmRzLmhlaWdodCAtIGJvdW5kcy53aWR0aCAvIGFzcGVjdFJhdGlvKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvclByb3BlcnRpZXMuaXNCb3R0b20pIHtcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBib3VuZHMuaGVpZ2h0IC0gYm91bmRzLndpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgIG5ldyAkLlBvaW50KGJvdW5kcy54IC0geE9mZnNldCwgYm91bmRzLnkgLSB5T2Zmc2V0ICsgbWFyZ2luVG9wKSxcbiAgICAgICAgICAgICAgICBpbW1lZGlhdGVseSk7XG4gICAgICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoLCBpbW1lZGlhdGVseSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdHxudWxsfSBUaGUgVGlsZWRJbWFnZSdzIGN1cnJlbnQgY2xpcCByZWN0YW5nbGUsXG4gICAgICogaW4gaW1hZ2UgcGl4ZWxzLCBvciBudWxsIGlmIG5vbmUuXG4gICAgICovXG4gICAgZ2V0Q2xpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGlwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcC5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fG51bGx9IG5ld0NsaXAgLSBBbiBhcmVhLCBpbiBpbWFnZSBwaXhlbHMsIHRvIGNsaXAgdG9cbiAgICAgKiAocG9ydGlvbnMgb2YgdGhlIGltYWdlIG91dHNpZGUgb2YgdGhpcyBhcmVhIHdpbGwgbm90IGJlIHZpc2libGUpLiBPbmx5IHdvcmtzIG9uXG4gICAgICogYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHRoZSBIVE1MNSBjYW52YXMuXG4gICAgICovXG4gICAgc2V0Q2xpcDogZnVuY3Rpb24obmV3Q2xpcCkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KCFuZXdDbGlwIHx8IG5ld0NsaXAgaW5zdGFuY2VvZiAkLlJlY3QsXG4gICAgICAgICAgICBcIltUaWxlZEltYWdlLnNldENsaXBdIG5ld0NsaXAgbXVzdCBiZSBhbiBPcGVuU2VhZHJhZ29uLlJlY3Qgb3IgbnVsbFwiKTtcblxuICAgICAgICBpZiAobmV3Q2xpcCBpbnN0YW5jZW9mICQuUmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcCA9IG5ld0NsaXAuY2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXAgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIFRpbGVkSW1hZ2UncyBjdXJyZW50IG9wYWNpdHkuXG4gICAgICovXG4gICAgZ2V0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wYWNpdHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkgdGhlIHRpbGVkIGltYWdlIHNob3VsZCBiZSBkcmF3biBhdC5cbiAgICAgKi9cbiAgICBzZXRPcGFjaXR5OiBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBUaWxlZEltYWdlJ3MgY3VycmVudCBjb21wb3NpdGVPcGVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0Q29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIHRoZSB0aWxlZCBpbWFnZSBzaG91bGQgYmUgZHJhd24gd2l0aCB0aGlzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBzZXRDb21wb3NpdGVPcGVyYXRpb246IGZ1bmN0aW9uKGNvbXBvc2l0ZU9wZXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9zZXRTY2FsZTogZnVuY3Rpb24oc2NhbGUsIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBzYW1lVGFyZ2V0ID0gKHRoaXMuX3NjYWxlU3ByaW5nLnRhcmdldC52YWx1ZSA9PT0gc2NhbGUpO1xuICAgICAgICBpZiAoaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIGlmIChzYW1lVGFyZ2V0ICYmIHRoaXMuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWUgPT09IHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zY2FsZVNwcmluZy5yZXNldFRvKHNjYWxlKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvclNjYWxlKCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNhbWVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NjYWxlU3ByaW5nLnNwcmluZ1RvKHNjYWxlKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvclNjYWxlKCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzYW1lVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9yYWlzZUJvdW5kc0NoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfdXBkYXRlRm9yU2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl93b3JsZFdpZHRoVGFyZ2V0ID0gdGhpcy5fc2NhbGVTcHJpbmcudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0aGlzLl93b3JsZEhlaWdodFRhcmdldCA9IHRoaXMubm9ybUhlaWdodCAqIHRoaXMuX3NjYWxlU3ByaW5nLnRhcmdldC52YWx1ZTtcbiAgICAgICAgdGhpcy5fd29ybGRXaWR0aEN1cnJlbnQgPSB0aGlzLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgICAgICB0aGlzLl93b3JsZEhlaWdodEN1cnJlbnQgPSB0aGlzLm5vcm1IZWlnaHQgKiB0aGlzLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3JhaXNlQm91bmRzQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBUaWxlZEltYWdlJ3MgYm91bmRzIGFyZSBjaGFuZ2VkLlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBldmVudCBpcyB0cmlnZ2VyZWQgb25seSB3aGVuIHRoZSBhbmltYXRpb24gdGFyZ2V0IGlzIGNoYW5nZWQ7XG4gICAgICAgICAqIG5vdCBmb3IgZXZlcnkgZnJhbWUgb2YgYW5pbWF0aW9uLlxuICAgICAgICAgKiBAZXZlbnQgYm91bmRzLWNoYW5nZVxuICAgICAgICAgKiBAbWVtYmVyT2YgT3BlblNlYWRyYWdvbi5UaWxlZEltYWdlXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Xb3JsZH0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVGlsZWRJbWFnZSB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoJ2JvdW5kcy1jaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9pc0JvdHRvbUl0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUF0KDApID09PSB0aGlzO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIFByZXR0eSBtdWNoIGV2ZXJ5IG90aGVyIGxpbmUgaW4gdGhpcyBuZWVkcyB0byBiZSBkb2N1bWVudGVkIHNvIGl0J3MgY2xlYXJcbiAqIGhvdyBlYWNoIHBpZWNlIG9mIHRoaXMgcm91dGluZSBjb250cmlidXRlcyB0byB0aGUgZHJhd2luZyBwcm9jZXNzLiAgVGhhdCdzXG4gKiB3aHkgdGhlcmUgYXJlIHNvIG1hbnkgVE9ETydzIGluc2lkZSB0aGlzIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB1cGRhdGVWaWV3cG9ydCggdGlsZWRJbWFnZSApIHtcblxuICAgIHRpbGVkSW1hZ2UuX25lZWRzRHJhdyA9IGZhbHNlO1xuXG4gICAgdmFyIHRpbGUsXG4gICAgICAgIGxldmVsLFxuICAgICAgICBiZXN0ICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICBoYXZlRHJhd24gICAgICAgPSBmYWxzZSxcbiAgICAgICAgY3VycmVudFRpbWUgICAgID0gJC5ub3coKSxcbiAgICAgICAgdmlld3BvcnRCb3VuZHMgID0gdGlsZWRJbWFnZS52aWV3cG9ydC5nZXRCb3VuZHNXaXRoTWFyZ2lucyggdHJ1ZSApLFxuICAgICAgICB6ZXJvUmF0aW9DICAgICAgPSB0aWxlZEltYWdlLnZpZXdwb3J0LmRlbHRhUGl4ZWxzRnJvbVBvaW50c05vUm90YXRlKFxuICAgICAgICAgICAgdGlsZWRJbWFnZS5zb3VyY2UuZ2V0UGl4ZWxSYXRpbyggMCApLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApLnggKiB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlLFxuICAgICAgICBsb3dlc3RMZXZlbCAgICAgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLm1pbkxldmVsLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICBNYXRoLmxvZyggdGlsZWRJbWFnZS5taW5ab29tSW1hZ2VSYXRpbyApIC9cbiAgICAgICAgICAgICAgICBNYXRoLmxvZyggMiApXG4gICAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIGhpZ2hlc3RMZXZlbCAgICA9IE1hdGgubWluKFxuICAgICAgICAgICAgTWF0aC5hYnModGlsZWRJbWFnZS5zb3VyY2UubWF4TGV2ZWwpLFxuICAgICAgICAgICAgTWF0aC5hYnMoTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICBNYXRoLmxvZyggemVyb1JhdGlvQyAvIHRpbGVkSW1hZ2UubWluUGl4ZWxSYXRpbyApIC9cbiAgICAgICAgICAgICAgICBNYXRoLmxvZyggMiApXG4gICAgICAgICAgICApKVxuICAgICAgICApLFxuICAgICAgICByZW5kZXJQaXhlbFJhdGlvQyxcbiAgICAgICAgcmVuZGVyUGl4ZWxSYXRpb1QsXG4gICAgICAgIHplcm9SYXRpb1QsXG4gICAgICAgIG9wdGltYWxSYXRpbyxcbiAgICAgICAgbGV2ZWxPcGFjaXR5LFxuICAgICAgICBsZXZlbFZpc2liaWxpdHk7XG5cbiAgICAvLyBSZXNldCB0aWxlJ3MgaW50ZXJuYWwgZHJhd24gc3RhdGVcbiAgICB3aGlsZSAodGlsZWRJbWFnZS5sYXN0RHJhd24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0aWxlID0gdGlsZWRJbWFnZS5sYXN0RHJhd24ucG9wKCk7XG4gICAgICAgIHRpbGUuYmVpbmdEcmF3biA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGlsZWRJbWFnZS53cmFwSG9yaXpvbnRhbCAmJiAhdGlsZWRJbWFnZS53cmFwVmVydGljYWwpIHtcbiAgICAgICAgdmFyIHRpbGVkSW1hZ2VCb3VuZHMgPSB0aWxlZEltYWdlLmdldENsaXBwZWRCb3VuZHModHJ1ZSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB2aWV3cG9ydEJvdW5kcy5pbnRlcnNlY3Rpb24odGlsZWRJbWFnZUJvdW5kcyk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3cG9ydEJvdW5kcyA9IGludGVyc2VjdGlvbjtcbiAgICB9XG4gICAgdmlld3BvcnRCb3VuZHMgPSB2aWV3cG9ydEJvdW5kcy5nZXRCb3VuZGluZ0JveCgpO1xuICAgIHZpZXdwb3J0Qm91bmRzLnggLT0gdGlsZWRJbWFnZS5feFNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgIHZpZXdwb3J0Qm91bmRzLnkgLT0gdGlsZWRJbWFnZS5feVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgdmFyIHZpZXdwb3J0VEwgPSB2aWV3cG9ydEJvdW5kcy5nZXRUb3BMZWZ0KCk7XG4gICAgdmFyIHZpZXdwb3J0QlIgPSB2aWV3cG9ydEJvdW5kcy5nZXRCb3R0b21SaWdodCgpO1xuXG4gICAgLy9Eb24ndCBkcmF3IGlmIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnRcbiAgICBpZiAgKCAhdGlsZWRJbWFnZS53cmFwSG9yaXpvbnRhbCAmJiAodmlld3BvcnRCUi54IDwgMCB8fCB2aWV3cG9ydFRMLnggPiB0aWxlZEltYWdlLl93b3JsZFdpZHRoQ3VycmVudCApICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCAhdGlsZWRJbWFnZS53cmFwVmVydGljYWwgJiYgKCB2aWV3cG9ydEJSLnkgPCAwIHx8IHZpZXdwb3J0VEwueSA+IHRpbGVkSW1hZ2UuX3dvcmxkSGVpZ2h0Q3VycmVudCApICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHZpZXdwb3J0IHJlY3QgLyBib3VuZHNcbiAgICBpZiAoICF0aWxlZEltYWdlLndyYXBIb3Jpem9udGFsICkge1xuICAgICAgICB2aWV3cG9ydFRMLnggPSBNYXRoLm1heCggdmlld3BvcnRUTC54LCAwICk7XG4gICAgICAgIHZpZXdwb3J0QlIueCA9IE1hdGgubWluKCB2aWV3cG9ydEJSLngsIHRpbGVkSW1hZ2UuX3dvcmxkV2lkdGhDdXJyZW50ICk7XG4gICAgfVxuXG4gICAgaWYgKCAhdGlsZWRJbWFnZS53cmFwVmVydGljYWwgKSB7XG4gICAgICAgIHZpZXdwb3J0VEwueSA9IE1hdGgubWF4KCB2aWV3cG9ydFRMLnksIDAgKTtcbiAgICAgICAgdmlld3BvcnRCUi55ID0gTWF0aC5taW4oIHZpZXdwb3J0QlIueSwgdGlsZWRJbWFnZS5fd29ybGRIZWlnaHRDdXJyZW50ICk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRpb25zIGZvciB0aGUgaW50ZXJ2YWwgb2YgbGV2ZWxzIHRvIGRyYXdcbiAgICAvLyAoYWJvdmUgaW4gaW5pdGlhbCB2YXIgc3RhdGVtZW50KVxuICAgIC8vIGNhbiByZXR1cm4gaW52YWxpZCBpbnRlcnZhbHM7IGZpeCB0aGF0IGhlcmUgaWYgbmVjZXNzYXJ5XG4gICAgbG93ZXN0TGV2ZWwgPSBNYXRoLm1pbiggbG93ZXN0TGV2ZWwsIGhpZ2hlc3RMZXZlbCApO1xuXG4gICAgLy8gVXBkYXRlIGFueSBsZXZlbCB0aGF0IHdpbGwgYmUgZHJhd25cbiAgICB2YXIgZHJhd0xldmVsOyAvLyBGSVhNRTogZHJhd0xldmVsIHNob3VsZCBoYXZlIGEgbW9yZSBleHBsYW5hdG9yeSBuYW1lXG4gICAgZm9yICggbGV2ZWwgPSBoaWdoZXN0TGV2ZWw7IGxldmVsID49IGxvd2VzdExldmVsOyBsZXZlbC0tICkge1xuICAgICAgICBkcmF3TGV2ZWwgPSBmYWxzZTtcblxuICAgICAgICAvL0F2b2lkIGNhbGN1bGF0aW9ucyBmb3IgZHJhdyBpZiB3ZSBoYXZlIGFscmVhZHkgZHJhd24gdGhpc1xuICAgICAgICByZW5kZXJQaXhlbFJhdGlvQyA9IHRpbGVkSW1hZ2Uudmlld3BvcnQuZGVsdGFQaXhlbHNGcm9tUG9pbnRzTm9Sb3RhdGUoXG4gICAgICAgICAgICB0aWxlZEltYWdlLnNvdXJjZS5nZXRQaXhlbFJhdGlvKCBsZXZlbCApLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApLnggKiB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgICAgIGlmICggKCAhaGF2ZURyYXduICYmIHJlbmRlclBpeGVsUmF0aW9DID49IHRpbGVkSW1hZ2UubWluUGl4ZWxSYXRpbyApIHx8XG4gICAgICAgICAgICAgKCBsZXZlbCA9PSBsb3dlc3RMZXZlbCApICkge1xuICAgICAgICAgICAgZHJhd0xldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhdmVEcmF3biA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoICFoYXZlRHJhd24gKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vUGVyZm9ybSBjYWxjdWxhdGlvbnMgZm9yIGRyYXcgaWYgd2UgaGF2ZW4ndCBkcmF3biB0aGlzXG4gICAgICAgIHJlbmRlclBpeGVsUmF0aW9UID0gdGlsZWRJbWFnZS52aWV3cG9ydC5kZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZShcbiAgICAgICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLmdldFBpeGVsUmF0aW8oIGxldmVsICksXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApLnggKiB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgICAgIHplcm9SYXRpb1QgICAgICA9IHRpbGVkSW1hZ2Uudmlld3BvcnQuZGVsdGFQaXhlbHNGcm9tUG9pbnRzTm9Sb3RhdGUoXG4gICAgICAgICAgICB0aWxlZEltYWdlLnNvdXJjZS5nZXRQaXhlbFJhdGlvKFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICB0aWxlZEltYWdlLnNvdXJjZS5nZXRDbG9zZXN0TGV2ZWwoIHRpbGVkSW1hZ2Uudmlld3BvcnQuY29udGFpbmVyU2l6ZSApIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApLnggKiB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgICAgIG9wdGltYWxSYXRpbyAgICA9IHRpbGVkSW1hZ2UuaW1tZWRpYXRlUmVuZGVyID9cbiAgICAgICAgICAgIDEgOlxuICAgICAgICAgICAgemVyb1JhdGlvVDtcblxuICAgICAgICBsZXZlbE9wYWNpdHkgICAgPSBNYXRoLm1pbiggMSwgKCByZW5kZXJQaXhlbFJhdGlvQyAtIDAuNSApIC8gMC41ICk7XG5cbiAgICAgICAgbGV2ZWxWaXNpYmlsaXR5ID0gb3B0aW1hbFJhdGlvIC8gTWF0aC5hYnMoXG4gICAgICAgICAgICBvcHRpbWFsUmF0aW8gLSByZW5kZXJQaXhlbFJhdGlvVFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGV2ZWwgYW5kIGtlZXAgdHJhY2sgb2YgJ2Jlc3QnIHRpbGUgdG8gbG9hZFxuICAgICAgICBiZXN0ID0gdXBkYXRlTGV2ZWwoXG4gICAgICAgICAgICB0aWxlZEltYWdlLFxuICAgICAgICAgICAgaGF2ZURyYXduLFxuICAgICAgICAgICAgZHJhd0xldmVsLFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBsZXZlbE9wYWNpdHksXG4gICAgICAgICAgICBsZXZlbFZpc2liaWxpdHksXG4gICAgICAgICAgICB2aWV3cG9ydFRMLFxuICAgICAgICAgICAgdmlld3BvcnRCUixcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgYmVzdFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgbG93ZXItcmVzIHRpbGVzIHdvdWxkIGFsbCBiZSBjb3ZlcmVkIGJ5XG4gICAgICAgIC8vIGFscmVhZHkgZHJhd24gdGlsZXNcbiAgICAgICAgaWYgKCAgcHJvdmlkZXNDb3ZlcmFnZSggdGlsZWRJbWFnZS5jb3ZlcmFnZSwgbGV2ZWwgKSApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSB0aGUgYWN0dWFsIGRyYXdpbmdcbiAgICBkcmF3VGlsZXMoIHRpbGVkSW1hZ2UsIHRpbGVkSW1hZ2UubGFzdERyYXduICk7XG5cbiAgICAvLyBMb2FkIHRoZSBuZXcgJ2Jlc3QnIHRpbGVcbiAgICBpZiAoYmVzdCAmJiAhYmVzdC5jb250ZXh0MkQpIHtcbiAgICAgICAgbG9hZFRpbGUoIHRpbGVkSW1hZ2UsIGJlc3QsIGN1cnJlbnRUaW1lICk7XG4gICAgfVxuXG59XG5cblxuZnVuY3Rpb24gdXBkYXRlTGV2ZWwoIHRpbGVkSW1hZ2UsIGhhdmVEcmF3biwgZHJhd0xldmVsLCBsZXZlbCwgbGV2ZWxPcGFjaXR5LCBsZXZlbFZpc2liaWxpdHksIHZpZXdwb3J0VEwsIHZpZXdwb3J0QlIsIGN1cnJlbnRUaW1lLCBiZXN0ICl7XG5cbiAgICB2YXIgeCwgeSxcbiAgICAgICAgdGlsZVRMLFxuICAgICAgICB0aWxlQlIsXG4gICAgICAgIG51bWJlck9mVGlsZXMsXG4gICAgICAgIHZpZXdwb3J0Q2VudGVyICA9IHRpbGVkSW1hZ2Uudmlld3BvcnQucGl4ZWxGcm9tUG9pbnQoIHRpbGVkSW1hZ2Uudmlld3BvcnQuZ2V0Q2VudGVyKCkgKTtcblxuXG4gICAgaWYoIHRpbGVkSW1hZ2Uudmlld2VyICl7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8ZW0+LSBOZWVkcyBkb2N1bWVudGF0aW9uIC08L2VtPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgdXBkYXRlLWxldmVsXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IHRpbGVkSW1hZ2UgLSBXaGljaCBUaWxlZEltYWdlIGlzIGJlaW5nIGRyYXduLlxuICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaGF2ZWRyYXduXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsZXZlbFxuICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3BhY2l0eVxuICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gdmlzaWJpbGl0eVxuICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gdG9wbGVmdFxuICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gYm90dG9tcmlnaHRcbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGN1cnJlbnR0aW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBiZXN0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRpbGVkSW1hZ2Uudmlld2VyLnJhaXNlRXZlbnQoICd1cGRhdGUtbGV2ZWwnLCB7XG4gICAgICAgICAgICB0aWxlZEltYWdlOiB0aWxlZEltYWdlLFxuICAgICAgICAgICAgaGF2ZWRyYXduOiBoYXZlRHJhd24sXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICBvcGFjaXR5OiBsZXZlbE9wYWNpdHksXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBsZXZlbFZpc2liaWxpdHksXG4gICAgICAgICAgICB0b3BsZWZ0OiB2aWV3cG9ydFRMLFxuICAgICAgICAgICAgYm90dG9tcmlnaHQ6IHZpZXdwb3J0QlIsXG4gICAgICAgICAgICBjdXJyZW50dGltZTogY3VycmVudFRpbWUsXG4gICAgICAgICAgICBiZXN0OiBiZXN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vT0ssIGEgbmV3IGRyYXdpbmcgc28gZG8geW91ciBjYWxjdWxhdGlvbnNcbiAgICB0aWxlVEwgICAgPSB0aWxlZEltYWdlLnNvdXJjZS5nZXRUaWxlQXRQb2ludCggbGV2ZWwsIHZpZXdwb3J0VEwuZGl2aWRlKCB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlICkpO1xuICAgIHRpbGVCUiAgICA9IHRpbGVkSW1hZ2Uuc291cmNlLmdldFRpbGVBdFBvaW50KCBsZXZlbCwgdmlld3BvcnRCUi5kaXZpZGUoIHRpbGVkSW1hZ2UuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWUgKSk7XG4gICAgbnVtYmVyT2ZUaWxlcyAgPSB0aWxlZEltYWdlLnNvdXJjZS5nZXROdW1UaWxlcyggbGV2ZWwgKTtcblxuICAgIHJlc2V0Q292ZXJhZ2UoIHRpbGVkSW1hZ2UuY292ZXJhZ2UsIGxldmVsICk7XG5cbiAgICBpZiAoICF0aWxlZEltYWdlLndyYXBIb3Jpem9udGFsICkge1xuICAgICAgICB0aWxlQlIueCA9IE1hdGgubWluKCB0aWxlQlIueCwgbnVtYmVyT2ZUaWxlcy54IC0gMSApO1xuICAgIH1cbiAgICBpZiAoICF0aWxlZEltYWdlLndyYXBWZXJ0aWNhbCApIHtcbiAgICAgICAgdGlsZUJSLnkgPSBNYXRoLm1pbiggdGlsZUJSLnksIG51bWJlck9mVGlsZXMueSAtIDEgKTtcbiAgICB9XG5cbiAgICBmb3IgKCB4ID0gdGlsZVRMLng7IHggPD0gdGlsZUJSLng7IHgrKyApIHtcbiAgICAgICAgZm9yICggeSA9IHRpbGVUTC55OyB5IDw9IHRpbGVCUi55OyB5KysgKSB7XG5cbiAgICAgICAgICAgIGJlc3QgPSB1cGRhdGVUaWxlKFxuICAgICAgICAgICAgICAgIHRpbGVkSW1hZ2UsXG4gICAgICAgICAgICAgICAgZHJhd0xldmVsLFxuICAgICAgICAgICAgICAgIGhhdmVEcmF3bixcbiAgICAgICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICAgIGxldmVsT3BhY2l0eSxcbiAgICAgICAgICAgICAgICBsZXZlbFZpc2liaWxpdHksXG4gICAgICAgICAgICAgICAgdmlld3BvcnRDZW50ZXIsXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZUaWxlcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgICBiZXN0XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVGlsZSggdGlsZWRJbWFnZSwgZHJhd0xldmVsLCBoYXZlRHJhd24sIHgsIHksIGxldmVsLCBsZXZlbE9wYWNpdHksIGxldmVsVmlzaWJpbGl0eSwgdmlld3BvcnRDZW50ZXIsIG51bWJlck9mVGlsZXMsIGN1cnJlbnRUaW1lLCBiZXN0KXtcblxuICAgIHZhciB0aWxlID0gZ2V0VGlsZShcbiAgICAgICAgICAgIHgsIHksXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLFxuICAgICAgICAgICAgdGlsZWRJbWFnZS50aWxlc01hdHJpeCxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgbnVtYmVyT2ZUaWxlcyxcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UuX3dvcmxkV2lkdGhDdXJyZW50LFxuICAgICAgICAgICAgdGlsZWRJbWFnZS5fd29ybGRIZWlnaHRDdXJyZW50XG4gICAgICAgICksXG4gICAgICAgIGRyYXdUaWxlID0gZHJhd0xldmVsO1xuXG4gICAgaWYoIHRpbGVkSW1hZ2Uudmlld2VyICl7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8ZW0+LSBOZWVkcyBkb2N1bWVudGF0aW9uIC08L2VtPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgdXBkYXRlLXRpbGVcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZWRJbWFnZX0gdGlsZWRJbWFnZSAtIFdoaWNoIFRpbGVkSW1hZ2UgaXMgYmVpbmcgZHJhd24uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlfSB0aWxlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRpbGVkSW1hZ2Uudmlld2VyLnJhaXNlRXZlbnQoICd1cGRhdGUtdGlsZScsIHtcbiAgICAgICAgICAgIHRpbGVkSW1hZ2U6IHRpbGVkSW1hZ2UsXG4gICAgICAgICAgICB0aWxlOiB0aWxlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldENvdmVyYWdlKCB0aWxlZEltYWdlLmNvdmVyYWdlLCBsZXZlbCwgeCwgeSwgZmFsc2UgKTtcblxuICAgIGlmICggIXRpbGUuZXhpc3RzICkge1xuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICB9XG5cbiAgICBpZiAoIGhhdmVEcmF3biAmJiAhZHJhd1RpbGUgKSB7XG4gICAgICAgIGlmICggaXNDb3ZlcmVkKCB0aWxlZEltYWdlLmNvdmVyYWdlLCBsZXZlbCwgeCwgeSApICkge1xuICAgICAgICAgICAgc2V0Q292ZXJhZ2UoIHRpbGVkSW1hZ2UuY292ZXJhZ2UsIGxldmVsLCB4LCB5LCB0cnVlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmF3VGlsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoICFkcmF3VGlsZSApIHtcbiAgICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfVxuXG4gICAgcG9zaXRpb25UaWxlKFxuICAgICAgICB0aWxlLFxuICAgICAgICB0aWxlZEltYWdlLnNvdXJjZS50aWxlT3ZlcmxhcCxcbiAgICAgICAgdGlsZWRJbWFnZS52aWV3cG9ydCxcbiAgICAgICAgdmlld3BvcnRDZW50ZXIsXG4gICAgICAgIGxldmVsVmlzaWJpbGl0eSxcbiAgICAgICAgdGlsZWRJbWFnZVxuICAgICk7XG5cbiAgICBpZiAoIXRpbGUubG9hZGVkKSB7XG4gICAgICAgIGlmICh0aWxlLmNvbnRleHQyRCkge1xuICAgICAgICAgICAgc2V0VGlsZUxvYWRlZCh0aWxlZEltYWdlLCB0aWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbWFnZVJlY29yZCA9IHRpbGVkSW1hZ2UuX3RpbGVDYWNoZS5nZXRJbWFnZVJlY29yZCh0aWxlLnVybCk7XG4gICAgICAgICAgICBpZiAoaW1hZ2VSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBpbWFnZVJlY29yZC5nZXRJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHNldFRpbGVMb2FkZWQodGlsZWRJbWFnZSwgdGlsZSwgaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCB0aWxlLmxvYWRlZCApIHtcbiAgICAgICAgdmFyIG5lZWRzRHJhdyA9IGJsZW5kVGlsZShcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UsXG4gICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgeCwgeSxcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgbGV2ZWxPcGFjaXR5LFxuICAgICAgICAgICAgY3VycmVudFRpbWVcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIG5lZWRzRHJhdyApIHtcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UuX25lZWRzRHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCB0aWxlLmxvYWRpbmcgKSB7XG4gICAgICAgIC8vIHRoZSB0aWxlIGlzIGFscmVhZHkgaW4gdGhlIGRvd25sb2FkIHF1ZXVlXG4gICAgICAgIC8vIHRoYW5rcyBqb3NoMTA5MyBmb3IgZmluYWxseSB0cmFuc2xhdGluZyB0aGlzIHR5cG9cbiAgICB9IGVsc2Uge1xuICAgICAgICBiZXN0ID0gY29tcGFyZVRpbGVzKCBiZXN0LCB0aWxlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3Q7XG59XG5cbmZ1bmN0aW9uIGdldFRpbGUoIHgsIHksIGxldmVsLCB0aWxlU291cmNlLCB0aWxlc01hdHJpeCwgdGltZSwgbnVtVGlsZXMsIHdvcmxkV2lkdGgsIHdvcmxkSGVpZ2h0ICkge1xuICAgIHZhciB4TW9kLFxuICAgICAgICB5TW9kLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGV4aXN0cyxcbiAgICAgICAgdXJsLFxuICAgICAgICBjb250ZXh0MkQsXG4gICAgICAgIHRpbGU7XG5cbiAgICBpZiAoICF0aWxlc01hdHJpeFsgbGV2ZWwgXSApIHtcbiAgICAgICAgdGlsZXNNYXRyaXhbIGxldmVsIF0gPSB7fTtcbiAgICB9XG4gICAgaWYgKCAhdGlsZXNNYXRyaXhbIGxldmVsIF1bIHggXSApIHtcbiAgICAgICAgdGlsZXNNYXRyaXhbIGxldmVsIF1bIHggXSA9IHt9O1xuICAgIH1cblxuICAgIGlmICggIXRpbGVzTWF0cml4WyBsZXZlbCBdWyB4IF1bIHkgXSApIHtcbiAgICAgICAgeE1vZCAgICA9ICggbnVtVGlsZXMueCArICggeCAlIG51bVRpbGVzLnggKSApICUgbnVtVGlsZXMueDtcbiAgICAgICAgeU1vZCAgICA9ICggbnVtVGlsZXMueSArICggeSAlIG51bVRpbGVzLnkgKSApICUgbnVtVGlsZXMueTtcbiAgICAgICAgYm91bmRzICA9IHRpbGVTb3VyY2UuZ2V0VGlsZUJvdW5kcyggbGV2ZWwsIHhNb2QsIHlNb2QgKTtcbiAgICAgICAgZXhpc3RzICA9IHRpbGVTb3VyY2UudGlsZUV4aXN0cyggbGV2ZWwsIHhNb2QsIHlNb2QgKTtcbiAgICAgICAgdXJsICAgICA9IHRpbGVTb3VyY2UuZ2V0VGlsZVVybCggbGV2ZWwsIHhNb2QsIHlNb2QgKTtcbiAgICAgICAgY29udGV4dDJEID0gdGlsZVNvdXJjZS5nZXRDb250ZXh0MkQgP1xuICAgICAgICAgICAgdGlsZVNvdXJjZS5nZXRDb250ZXh0MkQobGV2ZWwsIHhNb2QsIHlNb2QpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGJvdW5kcy54ICs9ICggeCAtIHhNb2QgKSAvIG51bVRpbGVzLng7XG4gICAgICAgIGJvdW5kcy55ICs9ICh3b3JsZEhlaWdodCAvIHdvcmxkV2lkdGgpICogKCggeSAtIHlNb2QgKSAvIG51bVRpbGVzLnkpO1xuXG4gICAgICAgIHRpbGVzTWF0cml4WyBsZXZlbCBdWyB4IF1bIHkgXSA9IG5ldyAkLlRpbGUoXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgYm91bmRzLFxuICAgICAgICAgICAgZXhpc3RzLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgY29udGV4dDJEXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdGlsZSA9IHRpbGVzTWF0cml4WyBsZXZlbCBdWyB4IF1bIHkgXTtcbiAgICB0aWxlLmxhc3RUb3VjaFRpbWUgPSB0aW1lO1xuXG4gICAgcmV0dXJuIHRpbGU7XG59XG5cbmZ1bmN0aW9uIGxvYWRUaWxlKCB0aWxlZEltYWdlLCB0aWxlLCB0aW1lICkge1xuICAgIHRpbGUubG9hZGluZyA9IHRydWU7XG4gICAgdGlsZWRJbWFnZS5faW1hZ2VMb2FkZXIuYWRkSm9iKHtcbiAgICAgICAgc3JjOiB0aWxlLnVybCxcbiAgICAgICAgY3Jvc3NPcmlnaW5Qb2xpY3k6IHRpbGVkSW1hZ2UuY3Jvc3NPcmlnaW5Qb2xpY3ksXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiggaW1hZ2UsIGVycm9yTXNnICl7XG4gICAgICAgICAgICBvblRpbGVMb2FkKCB0aWxlZEltYWdlLCB0aWxlLCB0aW1lLCBpbWFnZSwgZXJyb3JNc2cgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25UaWxlTG9hZCggdGlsZWRJbWFnZSwgdGlsZSwgdGltZSwgaW1hZ2UsIGVycm9yTXNnICkge1xuICAgIGlmICggIWltYWdlICkge1xuICAgICAgICAkLmNvbnNvbGUubG9nKCBcIlRpbGUgJXMgZmFpbGVkIHRvIGxvYWQ6ICVzIC0gZXJyb3I6ICVzXCIsIHRpbGUsIHRpbGUudXJsLCBlcnJvck1zZyApO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIGZhaWxzIHRvIGxvYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCB0aWxlLWxvYWQtZmFpbGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZX0gdGlsZSAtIFRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSB0aWxlZEltYWdlIC0gVGhlIHRpbGVkIGltYWdlIHRoZSB0aWxlIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHdoZW4gdGhlIHRpbGUgbG9hZCBiZWdhbi5cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIHRpbGVkSW1hZ2Uudmlld2VyLnJhaXNlRXZlbnQoXCJ0aWxlLWxvYWQtZmFpbGVkXCIsIHt0aWxlOiB0aWxlLCB0aWxlZEltYWdlOiB0aWxlZEltYWdlLCB0aW1lOiB0aW1lLCBtZXNzYWdlOiBlcnJvck1zZ30pO1xuICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGlsZS5leGlzdHMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICggdGltZSA8IHRpbGVkSW1hZ2UubGFzdFJlc2V0VGltZSApIHtcbiAgICAgICAgJC5jb25zb2xlLmxvZyggXCJJZ25vcmluZyB0aWxlICVzIGxvYWRlZCBiZWZvcmUgcmVzZXQ6ICVzXCIsIHRpbGUsIHRpbGUudXJsICk7XG4gICAgICAgIHRpbGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3V0b2ZmID0gTWF0aC5jZWlsKCBNYXRoLmxvZyhcbiAgICAgICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLmdldFRpbGVXaWR0aCh0aWxlLmxldmVsKSApIC8gTWF0aC5sb2coIDIgKSApO1xuICAgICAgICBzZXRUaWxlTG9hZGVkKHRpbGVkSW1hZ2UsIHRpbGUsIGltYWdlLCBjdXRvZmYpO1xuICAgIH07XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBtaWQtdXBkYXRlOyB0aGlzIGNhbiBoYXBwZW4gb24gSUU4IGJlY2F1c2UgaW1hZ2UgbG9hZCBldmVudHMgZm9yXG4gICAgLy8gY2FjaGVkIGltYWdlcyBoYXBwZW4gaW1tZWRpYXRlbHkgdGhlcmVcbiAgICBpZiAoICF0aWxlZEltYWdlLl9taWREcmF3ICkge1xuICAgICAgICBmaW5pc2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXYWl0IHVudGlsIGFmdGVyIHRoZSB1cGRhdGUsIGluIGNhc2UgY2FjaGluZyB1bmxvYWRzIGFueSB0aWxlc1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggZmluaXNoLCAxKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldFRpbGVMb2FkZWQodGlsZWRJbWFnZSwgdGlsZSwgaW1hZ2UsIGN1dG9mZikge1xuICAgIHZhciBpbmNyZW1lbnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcGxldGlvbkNhbGxiYWNrKCkge1xuICAgICAgICBpbmNyZW1lbnQrKztcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25DYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0aW9uQ2FsbGJhY2soKSB7XG4gICAgICAgIGluY3JlbWVudC0tO1xuICAgICAgICBpZiAoaW5jcmVtZW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRpbGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGlsZS5jb250ZXh0MkQpIHtcbiAgICAgICAgICAgICAgICB0aWxlZEltYWdlLl90aWxlQ2FjaGUuY2FjaGVUaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICBjdXRvZmY6IGN1dG9mZixcbiAgICAgICAgICAgICAgICAgICAgdGlsZWRJbWFnZTogdGlsZWRJbWFnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGlsZWRJbWFnZS5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBoYXMganVzdCBiZWVuIGxvYWRlZCBpbiBtZW1vcnkuIFRoYXQgbWVhbnMgdGhhdCB0aGVcbiAgICAgKiBpbWFnZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCBjYW4gYmUgbW9kaWZpZWQgYmVmb3JlIGJlaW5nIGRyYXduIHRvIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgdGlsZS1sb2FkZWRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SW1hZ2V9IGltYWdlIC0gVGhlIGltYWdlIG9mIHRoZSB0aWxlLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSB0aWxlZEltYWdlIC0gVGhlIHRpbGVkIGltYWdlIG9mIHRoZSBsb2FkZWQgdGlsZS5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZX0gdGlsZSAtIFRoZSB0aWxlIHdoaWNoIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBnZXRDb21wbGV0aW9uQ2FsbGJhY2sgLSBBIGZ1bmN0aW9uIGdpdmluZyBhIGNhbGxiYWNrIHRvIGNhbGxcbiAgICAgKiB3aGVuIHRoZSBhc3luY2hyb25vdXMgcHJvY2Vzc2luZyBvZiB0aGUgaW1hZ2UgaXMgZG9uZS4gVGhlIGltYWdlIHdpbGwgYmVcbiAgICAgKiBtYXJrZWQgYXMgZW50aXJlbHkgbG9hZGVkIHdoZW4gdGhlIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZCBvbmNlIGZvciBlYWNoXG4gICAgICogY2FsbCB0byBnZXRDb21wbGV0aW9uQ2FsbGJhY2suXG4gICAgICovXG4gICAgdGlsZWRJbWFnZS52aWV3ZXIucmFpc2VFdmVudChcInRpbGUtbG9hZGVkXCIsIHtcbiAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgdGlsZWRJbWFnZTogdGlsZWRJbWFnZSxcbiAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICBnZXRDb21wbGV0aW9uQ2FsbGJhY2s6IGdldENvbXBsZXRpb25DYWxsYmFja1xuICAgIH0pO1xuICAgIC8vIEluIGNhc2UgdGhlIGNvbXBsZXRpb24gY2FsbGJhY2sgaXMgbmV2ZXIgY2FsbGVkLCB3ZSBhdCBsZWFzdCBmb3JjZSBpdCBvbmNlLlxuICAgIGdldENvbXBsZXRpb25DYWxsYmFjaygpKCk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uVGlsZSggdGlsZSwgb3ZlcmxhcCwgdmlld3BvcnQsIHZpZXdwb3J0Q2VudGVyLCBsZXZlbFZpc2liaWxpdHksIHRpbGVkSW1hZ2UgKXtcbiAgICB2YXIgYm91bmRzVEwgICAgID0gdGlsZS5ib3VuZHMuZ2V0VG9wTGVmdCgpO1xuXG4gICAgYm91bmRzVEwueCAqPSB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgIGJvdW5kc1RMLnkgKj0gdGlsZWRJbWFnZS5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZTtcbiAgICBib3VuZHNUTC54ICs9IHRpbGVkSW1hZ2UuX3hTcHJpbmcuY3VycmVudC52YWx1ZTtcbiAgICBib3VuZHNUTC55ICs9IHRpbGVkSW1hZ2UuX3lTcHJpbmcuY3VycmVudC52YWx1ZTtcblxuICAgIHZhciBib3VuZHNTaXplICAgPSB0aWxlLmJvdW5kcy5nZXRTaXplKCk7XG5cbiAgICBib3VuZHNTaXplLnggKj0gdGlsZWRJbWFnZS5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZTtcbiAgICBib3VuZHNTaXplLnkgKj0gdGlsZWRJbWFnZS5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZTtcblxuICAgIHZhciBwb3NpdGlvbkMgICAgPSB2aWV3cG9ydC5waXhlbEZyb21Qb2ludE5vUm90YXRlKGJvdW5kc1RMLCB0cnVlKSxcbiAgICAgICAgcG9zaXRpb25UICAgID0gdmlld3BvcnQucGl4ZWxGcm9tUG9pbnROb1JvdGF0ZShib3VuZHNUTCwgZmFsc2UpLFxuICAgICAgICBzaXplQyAgICAgICAgPSB2aWV3cG9ydC5kZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZShib3VuZHNTaXplLCB0cnVlKSxcbiAgICAgICAgc2l6ZVQgICAgICAgID0gdmlld3BvcnQuZGVsdGFQaXhlbHNGcm9tUG9pbnRzTm9Sb3RhdGUoYm91bmRzU2l6ZSwgZmFsc2UpLFxuICAgICAgICB0aWxlQ2VudGVyICAgPSBwb3NpdGlvblQucGx1cyggc2l6ZVQuZGl2aWRlKCAyICkgKSxcbiAgICAgICAgdGlsZURpc3RhbmNlID0gdmlld3BvcnRDZW50ZXIuZGlzdGFuY2VUbyggdGlsZUNlbnRlciApO1xuXG4gICAgaWYgKCAhb3ZlcmxhcCApIHtcbiAgICAgICAgc2l6ZUMgPSBzaXplQy5wbHVzKCBuZXcgJC5Qb2ludCggMSwgMSApICk7XG4gICAgfVxuXG4gICAgdGlsZS5wb3NpdGlvbiAgID0gcG9zaXRpb25DO1xuICAgIHRpbGUuc2l6ZSAgICAgICA9IHNpemVDO1xuICAgIHRpbGUuZGlzdGFuY2UgICA9IHRpbGVEaXN0YW5jZTtcbiAgICB0aWxlLnZpc2liaWxpdHkgPSBsZXZlbFZpc2liaWxpdHk7XG59XG5cblxuZnVuY3Rpb24gYmxlbmRUaWxlKCB0aWxlZEltYWdlLCB0aWxlLCB4LCB5LCBsZXZlbCwgbGV2ZWxPcGFjaXR5LCBjdXJyZW50VGltZSApe1xuICAgIHZhciBibGVuZFRpbWVNaWxsaXMgPSAxMDAwICogdGlsZWRJbWFnZS5ibGVuZFRpbWUsXG4gICAgICAgIGRlbHRhVGltZSxcbiAgICAgICAgb3BhY2l0eTtcblxuICAgIGlmICggIXRpbGUuYmxlbmRTdGFydCApIHtcbiAgICAgICAgdGlsZS5ibGVuZFN0YXJ0ID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgZGVsdGFUaW1lICAgPSBjdXJyZW50VGltZSAtIHRpbGUuYmxlbmRTdGFydDtcbiAgICBvcGFjaXR5ICAgICA9IGJsZW5kVGltZU1pbGxpcyA/IE1hdGgubWluKCAxLCBkZWx0YVRpbWUgLyAoIGJsZW5kVGltZU1pbGxpcyApICkgOiAxO1xuXG4gICAgaWYgKCB0aWxlZEltYWdlLmFsd2F5c0JsZW5kICkge1xuICAgICAgICBvcGFjaXR5ICo9IGxldmVsT3BhY2l0eTtcbiAgICB9XG5cbiAgICB0aWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgdGlsZWRJbWFnZS5sYXN0RHJhd24ucHVzaCggdGlsZSApO1xuXG4gICAgaWYgKCBvcGFjaXR5ID09IDEgKSB7XG4gICAgICAgIHNldENvdmVyYWdlKCB0aWxlZEltYWdlLmNvdmVyYWdlLCBsZXZlbCwgeCwgeSwgdHJ1ZSApO1xuICAgICAgICB0aWxlZEltYWdlLl9oYXNPcGFxdWVUaWxlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCBkZWx0YVRpbWUgPCBibGVuZFRpbWVNaWxsaXMgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHRpbGUgcHJvdmlkZXMgY292ZXJhZ2UgdG8gbG93ZXItbGV2ZWwgdGlsZXMgb2ZcbiAqIGxvd2VyIHJlc29sdXRpb24gcmVwcmVzZW50aW5nIHRoZSBzYW1lIGNvbnRlbnQuIElmIG5laXRoZXIgeCBub3IgeSBpc1xuICogZ2l2ZW4sIHJldHVybnMgdHJ1ZSBpZiB0aGUgZW50aXJlIHZpc2libGUgbGV2ZWwgcHJvdmlkZXMgY292ZXJhZ2UuXG4gKlxuICogTm90ZSB0aGF0IG91dC1vZi1ib3VuZHMgdGlsZXMgcHJvdmlkZSBjb3ZlcmFnZSBpbiB0aGlzIHNlbnNlLCBzaW5jZVxuICogdGhlcmUncyBubyBjb250ZW50IHRoYXQgdGhleSB3b3VsZCBuZWVkIHRvIGNvdmVyLiBUaWxlcyBhdCBub24tZXhpc3RlbnRcbiAqIGxldmVscyB0aGF0IGFyZSB3aXRoaW4gdGhlIGltYWdlIGJvdW5kcywgaG93ZXZlciwgZG8gbm90LlxuICovXG5mdW5jdGlvbiBwcm92aWRlc0NvdmVyYWdlKCBjb3ZlcmFnZSwgbGV2ZWwsIHgsIHkgKSB7XG4gICAgdmFyIHJvd3MsXG4gICAgICAgIGNvbHMsXG4gICAgICAgIGksIGo7XG5cbiAgICBpZiAoICFjb3ZlcmFnZVsgbGV2ZWwgXSApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICggeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgcm93cyA9IGNvdmVyYWdlWyBsZXZlbCBdO1xuICAgICAgICBmb3IgKCBpIGluIHJvd3MgKSB7XG4gICAgICAgICAgICBpZiAoIHJvd3MuaGFzT3duUHJvcGVydHkoIGkgKSApIHtcbiAgICAgICAgICAgICAgICBjb2xzID0gcm93c1sgaSBdO1xuICAgICAgICAgICAgICAgIGZvciAoIGogaW4gY29scyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2xzLmhhc093blByb3BlcnR5KCBqICkgJiYgIWNvbHNbIGogXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIGNvdmVyYWdlWyBsZXZlbCBdWyB4XSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGNvdmVyYWdlWyBsZXZlbCBdWyB4IF1bIHkgXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGNvdmVyYWdlWyBsZXZlbCBdWyB4IF1bIHkgXSA9PT0gdHJ1ZVxuICAgICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB0aWxlIGlzIGNvbXBsZXRlbHkgY292ZXJlZCBieSBoaWdoZXItbGV2ZWxcbiAqIHRpbGVzIG9mIGhpZ2hlciByZXNvbHV0aW9uIHJlcHJlc2VudGluZyB0aGUgc2FtZSBjb250ZW50LiBJZiBuZWl0aGVyIHhcbiAqIG5vciB5IGlzIGdpdmVuLCByZXR1cm5zIHRydWUgaWYgdGhlIGVudGlyZSB2aXNpYmxlIGxldmVsIGlzIGNvdmVyZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ292ZXJlZCggY292ZXJhZ2UsIGxldmVsLCB4LCB5ICkge1xuICAgIGlmICggeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVzQ292ZXJhZ2UoIGNvdmVyYWdlLCBsZXZlbCArIDEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgIHByb3ZpZGVzQ292ZXJhZ2UoIGNvdmVyYWdlLCBsZXZlbCArIDEsIDIgKiB4LCAyICogeSApICYmXG4gICAgICAgICAgICAgcHJvdmlkZXNDb3ZlcmFnZSggY292ZXJhZ2UsIGxldmVsICsgMSwgMiAqIHgsIDIgKiB5ICsgMSApICYmXG4gICAgICAgICAgICAgcHJvdmlkZXNDb3ZlcmFnZSggY292ZXJhZ2UsIGxldmVsICsgMSwgMiAqIHggKyAxLCAyICogeSApICYmXG4gICAgICAgICAgICAgcHJvdmlkZXNDb3ZlcmFnZSggY292ZXJhZ2UsIGxldmVsICsgMSwgMiAqIHggKyAxLCAyICogeSArIDEgKVxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBTZXRzIHdoZXRoZXIgdGhlIGdpdmVuIHRpbGUgcHJvdmlkZXMgY292ZXJhZ2Ugb3Igbm90LlxuICovXG5mdW5jdGlvbiBzZXRDb3ZlcmFnZSggY292ZXJhZ2UsIGxldmVsLCB4LCB5LCBjb3ZlcnMgKSB7XG4gICAgaWYgKCAhY292ZXJhZ2VbIGxldmVsIF0gKSB7XG4gICAgICAgICQuY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJTZXR0aW5nIGNvdmVyYWdlIGZvciBhIHRpbGUgYmVmb3JlIGl0cyBsZXZlbCdzIGNvdmVyYWdlIGhhcyBiZWVuIHJlc2V0OiAlc1wiLFxuICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICggIWNvdmVyYWdlWyBsZXZlbCBdWyB4IF0gKSB7XG4gICAgICAgIGNvdmVyYWdlWyBsZXZlbCBdWyB4IF0gPSB7fTtcbiAgICB9XG5cbiAgICBjb3ZlcmFnZVsgbGV2ZWwgXVsgeCBdWyB5IF0gPSBjb3ZlcnM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogUmVzZXRzIGNvdmVyYWdlIGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gbGV2ZWwuIFRoaXMgc2hvdWxkIGJlIGNhbGxlZFxuICogYWZ0ZXIgZXZlcnkgZHJhdyByb3V0aW5lLiBOb3RlIHRoYXQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBkcmF3XG4gKiByb3V0aW5lLCBjb3ZlcmFnZSBmb3IgZXZlcnkgdmlzaWJsZSB0aWxlIHNob3VsZCBiZSBleHBsaWNpdGx5IHNldC5cbiAqL1xuZnVuY3Rpb24gcmVzZXRDb3ZlcmFnZSggY292ZXJhZ2UsIGxldmVsICkge1xuICAgIGNvdmVyYWdlWyBsZXZlbCBdID0ge307XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSAnbGFzdCBiZXN0JyB0aWxlIGZvciB0aGUgYXJlYSBpcyBiZXR0ZXIgdGhhbiB0aGVcbiAqIHRpbGUgaW4gcXVlc3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVUaWxlcyggcHJldmlvdXNCZXN0LCB0aWxlICkge1xuICAgIGlmICggIXByZXZpb3VzQmVzdCApIHtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfVxuXG4gICAgaWYgKCB0aWxlLnZpc2liaWxpdHkgPiBwcmV2aW91c0Jlc3QudmlzaWJpbGl0eSApIHtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfSBlbHNlIGlmICggdGlsZS52aXNpYmlsaXR5ID09IHByZXZpb3VzQmVzdC52aXNpYmlsaXR5ICkge1xuICAgICAgICBpZiAoIHRpbGUuZGlzdGFuY2UgPCBwcmV2aW91c0Jlc3QuZGlzdGFuY2UgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c0Jlc3Q7XG59XG5cbmZ1bmN0aW9uIGRyYXdUaWxlcyggdGlsZWRJbWFnZSwgbGFzdERyYXduICkge1xuICAgIGlmIChsYXN0RHJhd24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbGUgPSBsYXN0RHJhd25bMF07XG5cbiAgICB2YXIgdXNlU2tldGNoID0gdGlsZWRJbWFnZS5vcGFjaXR5IDwgMSB8fFxuICAgICAgICAodGlsZWRJbWFnZS5jb21wb3NpdGVPcGVyYXRpb24gJiZcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UuY29tcG9zaXRlT3BlcmF0aW9uICE9PSAnc291cmNlLW92ZXInKSB8fFxuICAgICAgICAoIXRpbGVkSW1hZ2UuX2lzQm90dG9tSXRlbSgpICYmIHRpbGUuX2hhc1RyYW5zcGFyZW5jeUNoYW5uZWwoKSk7XG5cbiAgICB2YXIgc2tldGNoU2NhbGU7XG4gICAgdmFyIHNrZXRjaFRyYW5zbGF0ZTtcblxuICAgIHZhciB6b29tID0gdGlsZWRJbWFnZS52aWV3cG9ydC5nZXRab29tKHRydWUpO1xuICAgIHZhciBpbWFnZVpvb20gPSB0aWxlZEltYWdlLnZpZXdwb3J0VG9JbWFnZVpvb20oem9vbSk7XG4gICAgaWYgKGltYWdlWm9vbSA+IHRpbGVkSW1hZ2Uuc21vb3RoVGlsZUVkZ2VzTWluWm9vbSAmJiAhdGlsZWRJbWFnZS5pT1NEZXZpY2UpIHtcbiAgICAgICAgLy8gV2hlbiB6b29tZWQgaW4gYSBsb3QgKD4xMDAlKSB0aGUgdGlsZSBlZGdlcyBhcmUgdmlzaWJsZS5cbiAgICAgICAgLy8gU28gd2UgaGF2ZSB0byBjb21wb3NpdGUgdGhlbSBhdCB+MTAwJSBhbmQgc2NhbGUgdGhlbSB1cCB0b2dldGhlci5cbiAgICAgICAgLy8gTm90ZTogRGlzYWJsZWQgb24gaU9TIGRldmljZXMgcGVyIGRlZmF1bHQgYXMgaXQgY2F1c2VzIGEgbmF0aXZlIGNyYXNoXG4gICAgICAgIHVzZVNrZXRjaCA9IHRydWU7XG4gICAgICAgIHNrZXRjaFNjYWxlID0gdGlsZS5nZXRTY2FsZUZvckVkZ2VTbW9vdGhpbmcoKTtcbiAgICAgICAgc2tldGNoVHJhbnNsYXRlID0gdGlsZS5nZXRUcmFuc2xhdGlvbkZvckVkZ2VTbW9vdGhpbmcoc2tldGNoU2NhbGUsXG4gICAgICAgICAgICB0aWxlZEltYWdlLl9kcmF3ZXIuZ2V0Q2FudmFzU2l6ZShmYWxzZSksXG4gICAgICAgICAgICB0aWxlZEltYWdlLl9kcmF3ZXIuZ2V0Q2FudmFzU2l6ZSh0cnVlKSk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kcztcbiAgICBpZiAodXNlU2tldGNoKSB7XG4gICAgICAgIGlmICghc2tldGNoU2NhbGUpIHtcbiAgICAgICAgICAgIC8vIEV4Y2VwdCB3aGVuIGVkZ2Ugc21vb3RoaW5nLCB3ZSBvbmx5IGNsZWFuIHRoZSBwYXJ0IG9mIHRoZVxuICAgICAgICAgICAgLy8gc2tldGNoIGNhbnZhcyB3ZSBhcmUgZ29pbmcgdG8gdXNlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgICAgICAgICAgYm91bmRzID0gdGlsZWRJbWFnZS52aWV3cG9ydC52aWV3cG9ydFRvVmlld2VyRWxlbWVudFJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICB0aWxlZEltYWdlLmdldENsaXBwZWRCb3VuZHModHJ1ZSkpXG4gICAgICAgICAgICAgICAgLmdldEludGVnZXJCb3VuZGluZ0JveCgpXG4gICAgICAgICAgICAgICAgLnRpbWVzKCQucGl4ZWxEZW5zaXR5UmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5fY2xlYXIodHJ1ZSwgYm91bmRzKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHNjYWxpbmcsIHdlIG11c3Qgcm90YXRlIG9ubHkgd2hlbiBibGVuZGluZyB0aGUgc2tldGNoIGNhbnZhcyB0byBhdm9pZFxuICAgIC8vIGludGVycG9sYXRpb25cbiAgICBpZiAodGlsZWRJbWFnZS52aWV3cG9ydC5kZWdyZWVzICE9PSAwICYmICFza2V0Y2hTY2FsZSkge1xuICAgICAgICB0aWxlZEltYWdlLl9kcmF3ZXIuX29mZnNldEZvclJvdGF0aW9uKHRpbGVkSW1hZ2Uudmlld3BvcnQuZGVncmVlcywgdXNlU2tldGNoKTtcbiAgICB9XG5cbiAgICB2YXIgdXNlZENsaXAgPSBmYWxzZTtcbiAgICBpZiAoIHRpbGVkSW1hZ2UuX2NsaXAgKSB7XG4gICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5zYXZlQ29udGV4dCh1c2VTa2V0Y2gpO1xuXG4gICAgICAgIHZhciBib3ggPSB0aWxlZEltYWdlLmltYWdlVG9WaWV3cG9ydFJlY3RhbmdsZSh0aWxlZEltYWdlLl9jbGlwLCB0cnVlKTtcbiAgICAgICAgdmFyIGNsaXBSZWN0ID0gdGlsZWRJbWFnZS5fZHJhd2VyLnZpZXdwb3J0VG9EcmF3ZXJSZWN0YW5nbGUoYm94KTtcbiAgICAgICAgaWYgKHNrZXRjaFNjYWxlKSB7XG4gICAgICAgICAgICBjbGlwUmVjdCA9IGNsaXBSZWN0LnRpbWVzKHNrZXRjaFNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tldGNoVHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBjbGlwUmVjdCA9IGNsaXBSZWN0LnRyYW5zbGF0ZShza2V0Y2hUcmFuc2xhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5zZXRDbGlwKGNsaXBSZWN0LCB1c2VTa2V0Y2gpO1xuXG4gICAgICAgIHVzZWRDbGlwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIHRpbGVkSW1hZ2UucGxhY2Vob2xkZXJGaWxsU3R5bGUgJiYgdGlsZWRJbWFnZS5faGFzT3BhcXVlVGlsZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlclJlY3QgPSB0aWxlZEltYWdlLl9kcmF3ZXIudmlld3BvcnRUb0RyYXdlclJlY3RhbmdsZSh0aWxlZEltYWdlLmdldEJvdW5kcyh0cnVlKSk7XG4gICAgICAgIGlmIChza2V0Y2hTY2FsZSkge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXJSZWN0ID0gcGxhY2Vob2xkZXJSZWN0LnRpbWVzKHNrZXRjaFNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tldGNoVHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlclJlY3QgPSBwbGFjZWhvbGRlclJlY3QudHJhbnNsYXRlKHNrZXRjaFRyYW5zbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsbFN0eWxlID0gbnVsbDtcbiAgICAgICAgaWYgKCB0eXBlb2YgdGlsZWRJbWFnZS5wbGFjZWhvbGRlckZpbGxTdHlsZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgZmlsbFN0eWxlID0gdGlsZWRJbWFnZS5wbGFjZWhvbGRlckZpbGxTdHlsZSh0aWxlZEltYWdlLCB0aWxlZEltYWdlLl9kcmF3ZXIuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWxsU3R5bGUgPSB0aWxlZEltYWdlLnBsYWNlaG9sZGVyRmlsbFN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLmRyYXdSZWN0YW5nbGUocGxhY2Vob2xkZXJSZWN0LCBmaWxsU3R5bGUsIHVzZVNrZXRjaCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IGxhc3REcmF3bi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aWxlID0gbGFzdERyYXduWyBpIF07XG4gICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5kcmF3VGlsZSggdGlsZSwgdGlsZWRJbWFnZS5fZHJhd2luZ0hhbmRsZXIsIHVzZVNrZXRjaCwgc2tldGNoU2NhbGUsIHNrZXRjaFRyYW5zbGF0ZSApO1xuICAgICAgICB0aWxlLmJlaW5nRHJhd24gPSB0cnVlO1xuXG4gICAgICAgIGlmKCB0aWxlZEltYWdlLnZpZXdlciApe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiA8ZW0+LSBOZWVkcyBkb2N1bWVudGF0aW9uIC08L2VtPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCB0aWxlLWRyYXduXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSB0aWxlZEltYWdlIC0gV2hpY2ggVGlsZWRJbWFnZSBpcyBiZWluZyBkcmF3bi5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlfSB0aWxlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRpbGVkSW1hZ2Uudmlld2VyLnJhaXNlRXZlbnQoICd0aWxlLWRyYXduJywge1xuICAgICAgICAgICAgICAgIHRpbGVkSW1hZ2U6IHRpbGVkSW1hZ2UsXG4gICAgICAgICAgICAgICAgdGlsZTogdGlsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIHVzZWRDbGlwICkge1xuICAgICAgICB0aWxlZEltYWdlLl9kcmF3ZXIucmVzdG9yZUNvbnRleHQoIHVzZVNrZXRjaCApO1xuICAgIH1cblxuICAgIGlmICh0aWxlZEltYWdlLnZpZXdwb3J0LmRlZ3JlZXMgIT09IDAgJiYgIXNrZXRjaFNjYWxlKSB7XG4gICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5fcmVzdG9yZVJvdGF0aW9uQ2hhbmdlcyh1c2VTa2V0Y2gpO1xuICAgIH1cblxuICAgIGlmICh1c2VTa2V0Y2gpIHtcbiAgICAgICAgdmFyIG9mZnNldEZvclJvdGF0aW9uID0gdGlsZWRJbWFnZS52aWV3cG9ydC5kZWdyZWVzICE9PSAwICYmIHNrZXRjaFNjYWxlO1xuICAgICAgICBpZiAob2Zmc2V0Rm9yUm90YXRpb24pIHtcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5fb2Zmc2V0Rm9yUm90YXRpb24odGlsZWRJbWFnZS52aWV3cG9ydC5kZWdyZWVzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLmJsZW5kU2tldGNoKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHRpbGVkSW1hZ2Uub3BhY2l0eSxcbiAgICAgICAgICAgIHNjYWxlOiBza2V0Y2hTY2FsZSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogc2tldGNoVHJhbnNsYXRlLFxuICAgICAgICAgICAgY29tcG9zaXRlT3BlcmF0aW9uOiB0aWxlZEltYWdlLmNvbXBvc2l0ZU9wZXJhdGlvbixcbiAgICAgICAgICAgIGJvdW5kczogYm91bmRzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob2Zmc2V0Rm9yUm90YXRpb24pIHtcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5fcmVzdG9yZVJvdGF0aW9uQ2hhbmdlcyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhd0RlYnVnSW5mbyggdGlsZWRJbWFnZSwgbGFzdERyYXduICk7XG59XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1Z0luZm8oIHRpbGVkSW1hZ2UsIGxhc3REcmF3biApIHtcbiAgICBpZiggdGlsZWRJbWFnZS5kZWJ1Z01vZGUgKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gbGFzdERyYXduLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSBsYXN0RHJhd25bIGkgXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLmRyYXdEZWJ1Z0luZm8oIHRpbGUsIGxhc3REcmF3bi5sZW5ndGgsIGkgKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICQuY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBUaWxlQ2FjaGVcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8vIHByaXZhdGUgY2xhc3NcbnZhciBUaWxlUmVjb3JkID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucywgXCJbVGlsZUNhY2hlLmNhY2hlVGlsZV0gb3B0aW9ucyBpcyByZXF1aXJlZFwiICk7XG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy50aWxlLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zLnRpbGUgaXMgcmVxdWlyZWRcIiApO1xuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMudGlsZWRJbWFnZSwgXCJbVGlsZUNhY2hlLmNhY2hlVGlsZV0gb3B0aW9ucy50aWxlZEltYWdlIGlzIHJlcXVpcmVkXCIgKTtcbiAgICB0aGlzLnRpbGUgPSBvcHRpb25zLnRpbGU7XG4gICAgdGhpcy50aWxlZEltYWdlID0gb3B0aW9ucy50aWxlZEltYWdlO1xufTtcblxuLy8gcHJpdmF0ZSBjbGFzc1xudmFyIEltYWdlUmVjb3JkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMsIFwiW0ltYWdlUmVjb3JkXSBvcHRpb25zIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLmltYWdlLCBcIltJbWFnZVJlY29yZF0gb3B0aW9ucy5pbWFnZSBpcyByZXF1aXJlZFwiICk7XG4gICAgdGhpcy5faW1hZ2UgPSBvcHRpb25zLmltYWdlO1xuICAgIHRoaXMuX3RpbGVzID0gW107XG59O1xuXG5JbWFnZVJlY29yZC5wcm90b3R5cGUgPSB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2ltYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGlsZXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZTtcbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVyZWRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlZENvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5faW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5faW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRleHQuZHJhd0ltYWdlKCB0aGlzLl9pbWFnZSwgMCwgMCApO1xuICAgICAgICAgICAgLy9zaW5jZSB3ZSBhcmUgY2FjaGluZyB0aGUgcHJlcmVuZGVyZWQgaW1hZ2Ugb24gYSBjYW52YXNcbiAgICAgICAgICAgIC8vYWxsb3cgdGhlIGltYWdlIHRvIG5vdCBiZSBoZWxkIGluIG1lbW9yeVxuICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZENvbnRleHQ7XG4gICAgfSxcblxuICAgIHNldFJlbmRlcmVkQ29udGV4dDogZnVuY3Rpb24ocmVuZGVyZWRDb250ZXh0KSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcIkltYWdlUmVjb3JkLnNldFJlbmRlcmVkQ29udGV4dCBpcyBkZXByZWNhdGVkLiBcIiArXG4gICAgICAgICAgICAgICAgXCJUaGUgcmVuZGVyZWQgY29udGV4dCBzaG91bGQgYmUgY3JlYXRlZCBieSB0aGUgSW1hZ2VSZWNvcmQgXCIgK1xuICAgICAgICAgICAgICAgIFwiaXRzZWxmIHdoZW4gY2FsbGluZyBJbWFnZVJlY29yZC5nZXRSZW5kZXJlZENvbnRleHQuXCIpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRleHQgPSByZW5kZXJlZENvbnRleHQ7XG4gICAgfSxcblxuICAgIGFkZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCh0aWxlLCAnW0ltYWdlUmVjb3JkLmFkZFRpbGVdIHRpbGUgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgdGhpcy5fdGlsZXMucHVzaCh0aWxlKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGlsZXNbaV0gPT09IHRpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJC5jb25zb2xlLndhcm4oJ1tJbWFnZVJlY29yZC5yZW1vdmVUaWxlXSB0cnlpbmcgdG8gcmVtb3ZlIHVua25vd24gdGlsZScsIHRpbGUpO1xuICAgIH0sXG5cbiAgICBnZXRUaWxlQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXMubGVuZ3RoO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGNsYXNzIFRpbGVDYWNoZVxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBjbGFzc2Rlc2MgU3RvcmVzIGFsbCB0aGUgdGlsZXMgZGlzcGxheWVkIGluIGEge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyfS5cbiAqIFlvdSBnZW5lcmFsbHkgd29uJ3QgaGF2ZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBUaWxlQ2FjaGUgZGlyZWN0bHkuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gZm9yIHRoaXMgVGlsZUNhY2hlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEltYWdlQ2FjaGVDb3VudF0gLSBTZWUgbWF4SW1hZ2VDYWNoZUNvdW50IGluXG4gKiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfSBmb3IgZGV0YWlscy5cbiAqL1xuJC5UaWxlQ2FjaGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuX21heEltYWdlQ2FjaGVDb3VudCA9IG9wdGlvbnMubWF4SW1hZ2VDYWNoZUNvdW50IHx8ICQuREVGQVVMVF9TRVRUSU5HUy5tYXhJbWFnZUNhY2hlQ291bnQ7XG4gICAgdGhpcy5fdGlsZXNMb2FkZWQgPSBbXTtcbiAgICB0aGlzLl9pbWFnZXNMb2FkZWQgPSBbXTtcbiAgICB0aGlzLl9pbWFnZXNMb2FkZWRDb3VudCA9IDA7XG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uVGlsZUNhY2hlLnByb3RvdHlwZSAqL1xuJC5UaWxlQ2FjaGUucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2YgdGlsZXMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkIGJ5XG4gICAgICogdGhpcyBUaWxlQ2FjaGUuXG4gICAgICovXG4gICAgbnVtVGlsZXNMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNMb2FkZWQubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZXMgdGhlIHNwZWNpZmllZCB0aWxlLCByZW1vdmluZyBhbiBvbGQgdGlsZSBpZiBuZWNlc3NhcnkgdG8gc3RheSB1bmRlciB0aGVcbiAgICAgKiBtYXhJbWFnZUNhY2hlQ291bnQgc3BlY2lmaWVkIG9uIGNvbnN0cnVjdGlvbi4gTm90ZSB0aGF0IGlmIG11bHRpcGxlIHRpbGVzIHJlZmVyZW5jZVxuICAgICAqIHRoZSBzYW1lIGltYWdlLCB0aGVyZSBtYXkgYmUgbW9yZSB0aWxlcyB0aGFuIG1heEltYWdlQ2FjaGVDb3VudDsgdGhlIGdvYWwgaXMgdG8ga2VlcFxuICAgICAqIHRoZSBudW1iZXIgb2YgaW1hZ2VzIGJlbG93IHRoYXQgbnVtYmVyLiBOb3RlLCBhcyB3ZWxsLCB0aGF0IGV2ZW4gdGhlIG51bWJlciBvZiBpbWFnZXNcbiAgICAgKiBtYXkgdGVtcG9yYXJpbHkgc3VycGFzcyB0aGF0IG51bWJlciwgYnV0IHNob3VsZCBldmVudHVhbGx5IGNvbWUgYmFjayBkb3duIHRvIHRoZSBtYXggc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGlsZSBpbmZvLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5UaWxlfSBvcHRpb25zLnRpbGUgLSBUaGUgdGlsZSB0byBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBvcHRpb25zLmltYWdlIC0gVGhlIGltYWdlIG9mIHRoZSB0aWxlIHRvIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSBvcHRpb25zLnRpbGVkSW1hZ2UgLSBUaGUgVGlsZWRJbWFnZSB0aGF0IG93bnMgdGhhdCB0aWxlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jdXRvZmY9MF0gLSBJZiBhZGRpbmcgdGhpcyB0aWxlIGdvZXMgb3ZlciB0aGUgY2FjaGUgbWF4IGNvdW50LCB0aGlzXG4gICAgICogZnVuY3Rpb24gd2lsbCByZWxlYXNlIGFuIG9sZCB0aWxlLiBUaGUgY3V0b2ZmIG9wdGlvbiBzcGVjaWZpZXMgYSB0aWxlIGxldmVsIGF0IG9yIGJlbG93IHdoaWNoXG4gICAgICogdGlsZXMgd2lsbCBub3QgYmUgcmVsZWFzZWQuXG4gICAgICovXG4gICAgY2FjaGVUaWxlOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucywgXCJbVGlsZUNhY2hlLmNhY2hlVGlsZV0gb3B0aW9ucyBpcyByZXF1aXJlZFwiICk7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMudGlsZSwgXCJbVGlsZUNhY2hlLmNhY2hlVGlsZV0gb3B0aW9ucy50aWxlIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy50aWxlLnVybCwgXCJbVGlsZUNhY2hlLmNhY2hlVGlsZV0gb3B0aW9ucy50aWxlLnVybCBpcyByZXF1aXJlZFwiICk7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMudGlsZWRJbWFnZSwgXCJbVGlsZUNhY2hlLmNhY2hlVGlsZV0gb3B0aW9ucy50aWxlZEltYWdlIGlzIHJlcXVpcmVkXCIgKTtcblxuICAgICAgICB2YXIgY3V0b2ZmID0gb3B0aW9ucy5jdXRvZmYgfHwgMDtcbiAgICAgICAgdmFyIGluc2VydGlvbkluZGV4ID0gdGhpcy5fdGlsZXNMb2FkZWQubGVuZ3RoO1xuXG4gICAgICAgIHZhciBpbWFnZVJlY29yZCA9IHRoaXMuX2ltYWdlc0xvYWRlZFtvcHRpb25zLnRpbGUudXJsXTtcbiAgICAgICAgaWYgKCFpbWFnZVJlY29yZCkge1xuICAgICAgICAgICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy5pbWFnZSwgXCJbVGlsZUNhY2hlLmNhY2hlVGlsZV0gb3B0aW9ucy5pbWFnZSBpcyByZXF1aXJlZCB0byBjcmVhdGUgYW4gSW1hZ2VSZWNvcmRcIiApO1xuICAgICAgICAgICAgaW1hZ2VSZWNvcmQgPSB0aGlzLl9pbWFnZXNMb2FkZWRbb3B0aW9ucy50aWxlLnVybF0gPSBuZXcgSW1hZ2VSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGltYWdlOiBvcHRpb25zLmltYWdlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5faW1hZ2VzTG9hZGVkQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlUmVjb3JkLmFkZFRpbGUob3B0aW9ucy50aWxlKTtcbiAgICAgICAgb3B0aW9ucy50aWxlLmNhY2hlSW1hZ2VSZWNvcmQgPSBpbWFnZVJlY29yZDtcblxuICAgICAgICAvLyBOb3RlIHRoYXQganVzdCBiZWNhdXNlIHdlJ3JlIHVubG9hZGluZyBhIHRpbGUgZG9lc24ndCBuZWNlc3NhcmlseSBtZWFuXG4gICAgICAgIC8vIHdlJ3JlIHVubG9hZGluZyBhbiBpbWFnZS4gV2l0aCByZXBlYXRlZCBjYWxscyBpdCBzaG91bGQgc29ydCBpdHNlbGYgb3V0LCB0aG91Z2guXG4gICAgICAgIGlmICggdGhpcy5faW1hZ2VzTG9hZGVkQ291bnQgPiB0aGlzLl9tYXhJbWFnZUNhY2hlQ291bnQgKSB7XG4gICAgICAgICAgICB2YXIgd29yc3RUaWxlICAgICAgID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB3b3JzdFRpbGVJbmRleCAgPSAtMTtcbiAgICAgICAgICAgIHZhciB3b3JzdFRpbGVSZWNvcmQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHByZXZUaWxlLCB3b3JzdFRpbWUsIHdvcnN0TGV2ZWwsIHByZXZUaW1lLCBwcmV2TGV2ZWwsIHByZXZUaWxlUmVjb3JkO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHRoaXMuX3RpbGVzTG9hZGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgICAgICAgIHByZXZUaWxlUmVjb3JkID0gdGhpcy5fdGlsZXNMb2FkZWRbIGkgXTtcbiAgICAgICAgICAgICAgICBwcmV2VGlsZSA9IHByZXZUaWxlUmVjb3JkLnRpbGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHByZXZUaWxlLmxldmVsIDw9IGN1dG9mZiB8fCBwcmV2VGlsZS5iZWluZ0RyYXduICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhd29yc3RUaWxlICkge1xuICAgICAgICAgICAgICAgICAgICB3b3JzdFRpbGUgICAgICAgPSBwcmV2VGlsZTtcbiAgICAgICAgICAgICAgICAgICAgd29yc3RUaWxlSW5kZXggID0gaTtcbiAgICAgICAgICAgICAgICAgICAgd29yc3RUaWxlUmVjb3JkID0gcHJldlRpbGVSZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZUaW1lICAgID0gcHJldlRpbGUubGFzdFRvdWNoVGltZTtcbiAgICAgICAgICAgICAgICB3b3JzdFRpbWUgICA9IHdvcnN0VGlsZS5sYXN0VG91Y2hUaW1lO1xuICAgICAgICAgICAgICAgIHByZXZMZXZlbCAgID0gcHJldlRpbGUubGV2ZWw7XG4gICAgICAgICAgICAgICAgd29yc3RMZXZlbCAgPSB3b3JzdFRpbGUubGV2ZWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHByZXZUaW1lIDwgd29yc3RUaW1lIHx8XG4gICAgICAgICAgICAgICAgICAgKCBwcmV2VGltZSA9PSB3b3JzdFRpbWUgJiYgcHJldkxldmVsID4gd29yc3RMZXZlbCApICkge1xuICAgICAgICAgICAgICAgICAgICB3b3JzdFRpbGUgICAgICAgPSBwcmV2VGlsZTtcbiAgICAgICAgICAgICAgICAgICAgd29yc3RUaWxlSW5kZXggID0gaTtcbiAgICAgICAgICAgICAgICAgICAgd29yc3RUaWxlUmVjb3JkID0gcHJldlRpbGVSZWNvcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHdvcnN0VGlsZSAmJiB3b3JzdFRpbGVJbmRleCA+PSAwICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubG9hZFRpbGUod29yc3RUaWxlUmVjb3JkKTtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25JbmRleCA9IHdvcnN0VGlsZUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGlsZXNMb2FkZWRbIGluc2VydGlvbkluZGV4IF0gPSBuZXcgVGlsZVJlY29yZCh7XG4gICAgICAgICAgICB0aWxlOiBvcHRpb25zLnRpbGUsXG4gICAgICAgICAgICB0aWxlZEltYWdlOiBvcHRpb25zLnRpbGVkSW1hZ2VcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgdGlsZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdGlsZWRJbWFnZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVGlsZWRJbWFnZX0gdGlsZWRJbWFnZVxuICAgICAqL1xuICAgIGNsZWFyVGlsZXNGb3I6IGZ1bmN0aW9uKCB0aWxlZEltYWdlICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KHRpbGVkSW1hZ2UsICdbVGlsZUNhY2hlLmNsZWFyVGlsZXNGb3JdIHRpbGVkSW1hZ2UgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgdmFyIHRpbGVSZWNvcmQ7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbGVzTG9hZGVkLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgdGlsZVJlY29yZCA9IHRoaXMuX3RpbGVzTG9hZGVkWyBpIF07XG4gICAgICAgICAgICBpZiAoIHRpbGVSZWNvcmQudGlsZWRJbWFnZSA9PT0gdGlsZWRJbWFnZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmxvYWRUaWxlKHRpbGVSZWNvcmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVzTG9hZGVkLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgZ2V0SW1hZ2VSZWNvcmQ6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KHVybCwgJ1tUaWxlQ2FjaGUuZ2V0SW1hZ2VSZWNvcmRdIHVybCBpcyByZXF1aXJlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VzTG9hZGVkW3VybF07XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfdW5sb2FkVGlsZTogZnVuY3Rpb24odGlsZVJlY29yZCkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KHRpbGVSZWNvcmQsICdbVGlsZUNhY2hlLl91bmxvYWRUaWxlXSB0aWxlUmVjb3JkIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIHZhciB0aWxlID0gdGlsZVJlY29yZC50aWxlO1xuICAgICAgICB2YXIgdGlsZWRJbWFnZSA9IHRpbGVSZWNvcmQudGlsZWRJbWFnZTtcblxuICAgICAgICB0aWxlLnVubG9hZCgpO1xuICAgICAgICB0aWxlLmNhY2hlSW1hZ2VSZWNvcmQgPSBudWxsO1xuXG4gICAgICAgIHZhciBpbWFnZVJlY29yZCA9IHRoaXMuX2ltYWdlc0xvYWRlZFt0aWxlLnVybF07XG4gICAgICAgIGltYWdlUmVjb3JkLnJlbW92ZVRpbGUodGlsZSk7XG4gICAgICAgIGlmICghaW1hZ2VSZWNvcmQuZ2V0VGlsZUNvdW50KCkpIHtcbiAgICAgICAgICAgIGltYWdlUmVjb3JkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbWFnZXNMb2FkZWRbdGlsZS51cmxdO1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VzTG9hZGVkQ291bnQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgaGFzIGp1c3QgYmVlbiB1bmxvYWRlZCBmcm9tIG1lbW9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IHRpbGUtdW5sb2FkZWRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSB0aWxlZEltYWdlIC0gVGhlIHRpbGVkIGltYWdlIG9mIHRoZSB1bmxvYWRlZCB0aWxlLlxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZX0gdGlsZSAtIFRoZSB0aWxlIHdoaWNoIGhhcyBiZWVuIHVubG9hZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGlsZWRJbWFnZS52aWV3ZXIucmFpc2VFdmVudChcInRpbGUtdW5sb2FkZWRcIiwge1xuICAgICAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgICAgIHRpbGVkSW1hZ2U6IHRpbGVkSW1hZ2VcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBXb3JsZFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgV29ybGRcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLkV2ZW50U291cmNlXG4gKiBAY2xhc3NkZXNjIEtlZXBzIHRyYWNrIG9mIGFsbCBvZiB0aGUgdGlsZWQgaW1hZ2VzIGluIHRoZSBzY2VuZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gV29ybGQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IG9wdGlvbnMudmlld2VyIC0gVGhlIFZpZXdlciB0aGF0IG93bnMgdGhpcyBXb3JsZC5cbiAqKi9cbiQuV29ybGQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy52aWV3ZXIsIFwiW1dvcmxkXSBvcHRpb25zLnZpZXdlciBpcyByZXF1aXJlZFwiICk7XG5cbiAgICAkLkV2ZW50U291cmNlLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudmlld2VyID0gb3B0aW9ucy52aWV3ZXI7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9uZWVkc0RyYXcgPSBmYWxzZTtcbiAgICB0aGlzLl9hdXRvUmVmaWd1cmVTaXplcyA9IHRydWU7XG4gICAgdGhpcy5fbmVlZHNTaXplc0ZpZ3VyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWxlZ2F0ZWRGaWd1cmVTaXplcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpcy5fYXV0b1JlZmlndXJlU2l6ZXMpIHtcbiAgICAgICAgICAgIF90aGlzLl9maWd1cmVTaXplcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX25lZWRzU2l6ZXNGaWd1cmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9maWd1cmVTaXplcygpO1xufTtcblxuJC5leHRlbmQoICQuV29ybGQucHJvdG90eXBlLCAkLkV2ZW50U291cmNlLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLldvcmxkLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHNwZWNpZmllZCBpdGVtLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSBpdGVtIC0gVGhlIGl0ZW0gdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbmRleF0gLSBJbmRleCBmb3IgdGhlIGl0ZW0uIElmIG5vdCBzcGVjaWZpZWQsIGdvZXMgYXQgdGhlIHRvcC5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5Xb3JsZC5ldmVudDphZGQtaXRlbVxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLldvcmxkLmV2ZW50Om1ldHJpY3MtY2hhbmdlXG4gICAgICovXG4gICAgYWRkSXRlbTogZnVuY3Rpb24oIGl0ZW0sIG9wdGlvbnMgKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoaXRlbSwgXCJbV29ybGQuYWRkSXRlbV0gaXRlbSBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChpdGVtIGluc3RhbmNlb2YgJC5UaWxlZEltYWdlLCBcIltXb3JsZC5hZGRJdGVtXSBvbmx5IFRpbGVkSW1hZ2VzIHN1cHBvcnRlZCBhdCB0aGlzIHRpbWVcIik7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChvcHRpb25zLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX2l0ZW1zLmxlbmd0aCwgb3B0aW9ucy5pbmRleCkpO1xuICAgICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goIGl0ZW0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hdXRvUmVmaWd1cmVTaXplcykge1xuICAgICAgICAgICAgdGhpcy5fZmlndXJlU2l6ZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzU2l6ZXNGaWd1cmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG5cbiAgICAgICAgaXRlbS5hZGRIYW5kbGVyKCdib3VuZHMtY2hhbmdlJywgdGhpcy5fZGVsZWdhdGVkRmlndXJlU2l6ZXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbiBpdGVtIGlzIGFkZGVkIHRvIHRoZSBXb3JsZC5cbiAgICAgICAgICogQGV2ZW50IGFkZC1pdGVtXG4gICAgICAgICAqIEBtZW1iZXJPZiBPcGVuU2VhZHJhZ29uLldvcmxkXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFdvcmxkIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSBpdGVtIC0gVGhlIGl0ZW0gdGhhdCBoYXMgYmVlbiBhZGRlZC5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAnYWRkLWl0ZW0nLCB7XG4gICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGl0ZW0ncyBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSBUaGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqL1xuICAgIGdldEl0ZW1BdDogZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGluZGV4ICE9PSB1bmRlZmluZWQsIFwiW1dvcmxkLmdldEl0ZW1BdF0gaW5kZXggaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1sgaW5kZXggXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gaXRlbSBvciAtMSBpZiBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVGlsZWRJbWFnZX0gaXRlbSAtIFRoZSBpdGVtLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgaXRlbSBvciAtMSBpZiBub3QgcHJlc2VudC5cbiAgICAgKi9cbiAgICBnZXRJbmRleE9mSXRlbTogZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoaXRlbSwgXCJbV29ybGQuZ2V0SW5kZXhPZkl0ZW1dIGl0ZW0gaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIHJldHVybiAkLmluZGV4T2YoIHRoaXMuX2l0ZW1zLCBpdGVtICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgaXRlbXMgdXNlZC5cbiAgICAgKi9cbiAgICBnZXRJdGVtQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGluZGV4IG9mIGEgaXRlbSBzbyB0aGF0IGl0IGFwcGVhcnMgb3ZlciBvciB1bmRlciBvdGhlcnMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IGl0ZW0gLSBUaGUgaXRlbSB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBuZXcgaW5kZXguXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6aXRlbS1pbmRleC1jaGFuZ2VcbiAgICAgKi9cbiAgICBzZXRJdGVtSW5kZXg6IGZ1bmN0aW9uKCBpdGVtLCBpbmRleCApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChpdGVtLCBcIltXb3JsZC5zZXRJdGVtSW5kZXhdIGl0ZW0gaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoaW5kZXggIT09IHVuZGVmaW5lZCwgXCJbV29ybGQuc2V0SXRlbUluZGV4XSBpbmRleCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmdldEluZGV4T2ZJdGVtKCBpdGVtICk7XG5cbiAgICAgICAgaWYgKCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGggKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiSW5kZXggYmlnZ2VyIHRoYW4gbnVtYmVyIG9mIGxheWVycy5cIiApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbmRleCA9PT0gb2xkSW5kZXggfHwgb2xkSW5kZXggPT09IC0xICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKCBvbGRJbmRleCwgMSApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoIGluZGV4LCAwLCBpdGVtICk7XG4gICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBvcmRlciBvZiB0aGUgaW5kZXhlcyBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgICAgICAgKiBAZXZlbnQgaXRlbS1pbmRleC1jaGFuZ2VcbiAgICAgICAgICogQG1lbWJlck9mIE9wZW5TZWFkcmFnb24uV29ybGRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLldvcmxkfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBXb3JsZCB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZWRJbWFnZX0gaXRlbSAtIFRoZSBpdGVtIHdob3NlIGluZGV4IGhhc1xuICAgICAgICAgKiBiZWVuIGNoYW5nZWRcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByZXZpb3VzSW5kZXggLSBUaGUgcHJldmlvdXMgaW5kZXggb2YgdGhlIGl0ZW1cbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG5ld0luZGV4IC0gVGhlIG5ldyBpbmRleCBvZiB0aGUgaXRlbVxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdpdGVtLWluZGV4LWNoYW5nZScsIHtcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBwcmV2aW91c0luZGV4OiBvbGRJbmRleCxcbiAgICAgICAgICAgIG5ld0luZGV4OiBpbmRleFxuICAgICAgICB9ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBpdGVtLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSBpdGVtIC0gVGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLldvcmxkLmV2ZW50OnJlbW92ZS1pdGVtXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6bWV0cmljcy1jaGFuZ2VcbiAgICAgKi9cbiAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChpdGVtLCBcIltXb3JsZC5yZW1vdmVJdGVtXSBpdGVtIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICAgIHZhciBpbmRleCA9ICQuaW5kZXhPZih0aGlzLl9pdGVtcywgaXRlbSApO1xuICAgICAgICBpZiAoIGluZGV4ID09PSAtMSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0ucmVtb3ZlSGFuZGxlcignYm91bmRzLWNoYW5nZScsIHRoaXMuX2RlbGVnYXRlZEZpZ3VyZVNpemVzKTtcbiAgICAgICAgaXRlbS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgdGhpcy5fZmlndXJlU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmFpc2VSZW1vdmVJdGVtKGl0ZW0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGl0ZW1zLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLldvcmxkLmV2ZW50OnJlbW92ZS1pdGVtXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6bWV0cmljcy1jaGFuZ2VcbiAgICAgKi9cbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbnkgcGVuZGluZyBpbWFnZXMgYXJlIGNhbmNlbGVkIHNvIHRoZSB3b3JsZCBpdGVtcyBkb24ndCBnZXQgbWVzc2VkIHVwXG4gICAgICAgIHRoaXMudmlld2VyLl9jYW5jZWxQZW5kaW5nSW1hZ2VzKCk7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICBpdGVtLnJlbW92ZUhhbmRsZXIoJ2JvdW5kcy1jaGFuZ2UnLCB0aGlzLl9kZWxlZ2F0ZWRGaWd1cmVTaXplcyk7XG4gICAgICAgICAgICBpdGVtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1vdmVkSXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZmlndXJlU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gcmVtb3ZlZEl0ZW1zW2ldO1xuICAgICAgICAgICAgdGhpcy5fcmFpc2VSZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgdGlsZXMgYW5kIHRyaWdnZXJzIHVwZGF0ZXMgZm9yIGFsbCBpdGVtcy5cbiAgICAgKi9cbiAgICByZXNldEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1tpXS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgKGkuZS4gYW5pbWF0ZXMgYm91bmRzIG9mKSBhbGwgaXRlbXMuXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgYW5pbWF0ZWQgPSB0aGlzLl9pdGVtc1tpXS51cGRhdGUoKSB8fCBhbmltYXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmltYXRlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYWxsIGl0ZW1zLlxuICAgICAqL1xuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2ldLmRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBhbnkgaXRlbXMgbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBuZWVkc0RyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5faXRlbXNbaV0ubmVlZHNEcmF3KCkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZWRzRHJhdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gVGhlIHNtYWxsZXN0IHJlY3RhbmdsZSB0aGF0IGVuY2xvc2VzIGFsbCBpdGVtcywgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0SG9tZUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob21lQm91bmRzLmNsb25lKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGZhY2lsaXRhdGUgem9vbSBjb25zdHJhaW50cywgd2Uga2VlcCB0cmFjayBvZiB0aGUgcGl4ZWwgZGVuc2l0eSBvZiB0aGVcbiAgICAgKiBkZW5zZXN0IGl0ZW0gaW4gdGhlIFdvcmxkIChpLmUuIHRoZSBpdGVtIHdob3NlIGNvbnRlbnQgc2l6ZSB0byB2aWV3cG9ydCBzaXplXG4gICAgICogcmF0aW8gaXMgdGhlIGhpZ2hlc3QpIGFuZCBzYXZlIGl0IGFzIHRoaXMgXCJjb250ZW50IGZhY3RvclwiLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2YgY29udGVudCB1bml0cyBwZXIgdmlld3BvcnQgdW5pdC5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50RmFjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRGYWN0b3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBzZXR0aW5nIHRoaXMgZmxhZyB0byBmYWxzZSBhbGxvd3MgdGhlIGJvdW5kcy1jaGFuZ2UgZXZlbnQgaGFuZGxlclxuICAgICAqIG9uIHRpbGVkSW1hZ2VzIHRvIHNraXAgY2FsY3VsYXRpb25zIG9uIHRoZSB3b3JsZCBib3VuZHMuIElmIGEgbG90IG9mIGltYWdlcyBhcmUgZ29pbmcgdG8gYmUgcG9zaXRpb25lZCBpblxuICAgICAqIHJhcGlkIHN1Y2Nlc3Npb24sIHRoaXMgaXMgYSBnb29kIGlkZWEuIFdoZW4gZmluaXNoZWQsIHNldEF1dG9SZWZpZ3VyZVNpemVzIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0cnVlXG4gICAgICogb3IgdGhlIHN5c3RlbSBtYXkgYmVoYXZlIG9kZGx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gd2hpY2ggdG8gc2V0IHRoZSBmbGFnLlxuICAgICAqL1xuICAgIHNldEF1dG9SZWZpZ3VyZVNpemVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hdXRvUmVmaWd1cmVTaXplcyA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiB0aGlzLl9uZWVkc1NpemVzRmlndXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fZmlndXJlU2l6ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzU2l6ZXNGaWd1cmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXJyYW5nZXMgYWxsIG9mIHRoZSBUaWxlZEltYWdlcyB3aXRoIHRoZSBzcGVjaWZpZWQgc2V0dGluZ3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTcGVjaWZpZXMgaG93IHRvIGFycmFuZ2UuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbW1lZGlhdGVseT1mYWxzZV0gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdG8gdGhlIG5ldyBhcnJhbmdlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGF5b3V0XSAtIFNlZSBjb2xsZWN0aW9uTGF5b3V0IGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3dzXSAtIFNlZSBjb2xsZWN0aW9uUm93cyBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29sdW1uc10gLSBTZWUgY29sbGVjdGlvbkNvbHVtbnMgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbGVTaXplXSAtIFNlZSBjb2xsZWN0aW9uVGlsZVNpemUgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbGVNYXJnaW5dIC0gU2VlIGNvbGxlY3Rpb25UaWxlTWFyZ2luIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLldvcmxkLmV2ZW50Om1ldHJpY3MtY2hhbmdlXG4gICAgICovXG4gICAgYXJyYW5nZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGltbWVkaWF0ZWx5ID0gb3B0aW9ucy5pbW1lZGlhdGVseSB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0IHx8ICQuREVGQVVMVF9TRVRUSU5HUy5jb2xsZWN0aW9uTGF5b3V0O1xuICAgICAgICB2YXIgcm93cyA9IG9wdGlvbnMucm93cyB8fCAkLkRFRkFVTFRfU0VUVElOR1MuY29sbGVjdGlvblJvd3M7XG4gICAgICAgIHZhciBjb2x1bW5zID0gb3B0aW9ucy5jb2x1bW5zIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5jb2xsZWN0aW9uQ29sdW1ucztcbiAgICAgICAgdmFyIHRpbGVTaXplID0gb3B0aW9ucy50aWxlU2l6ZSB8fCAkLkRFRkFVTFRfU0VUVElOR1MuY29sbGVjdGlvblRpbGVTaXplO1xuICAgICAgICB2YXIgdGlsZU1hcmdpbiA9IG9wdGlvbnMudGlsZU1hcmdpbiB8fCAkLkRFRkFVTFRfU0VUVElOR1MuY29sbGVjdGlvblRpbGVNYXJnaW47XG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSB0aWxlU2l6ZSArIHRpbGVNYXJnaW47XG4gICAgICAgIHZhciB3cmFwO1xuICAgICAgICBpZiAoIW9wdGlvbnMucm93cyAmJiBjb2x1bW5zKSB7XG4gICAgICAgICAgICB3cmFwID0gY29sdW1ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXAgPSBNYXRoLmNlaWwodGhpcy5faXRlbXMubGVuZ3RoIC8gcm93cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgIHZhciBpdGVtLCBib3gsIHdpZHRoLCBoZWlnaHQsIHBvc2l0aW9uO1xuXG4gICAgICAgIHRoaXMuc2V0QXV0b1JlZmlndXJlU2l6ZXMoZmFsc2UpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAmJiAoaSAlIHdyYXApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICBib3ggPSBpdGVtLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgaWYgKGJveC53aWR0aCA+IGJveC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRpbGVTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRpbGVTaXplICogKGJveC53aWR0aCAvIGJveC5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAqIChib3guaGVpZ2h0IC8gYm94LndpZHRoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gbmV3ICQuUG9pbnQoeCArICgodGlsZVNpemUgLSB3aWR0aCkgLyAyKSxcbiAgICAgICAgICAgICAgICB5ICsgKCh0aWxlU2l6ZSAtIGhlaWdodCkgLyAyKSk7XG5cbiAgICAgICAgICAgIGl0ZW0uc2V0UG9zaXRpb24ocG9zaXRpb24sIGltbWVkaWF0ZWx5KTtcbiAgICAgICAgICAgIGl0ZW0uc2V0V2lkdGgod2lkdGgsIGltbWVkaWF0ZWx5KTtcblxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgeCArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgKz0gaW5jcmVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXV0b1JlZmlndXJlU2l6ZXModHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfZmlndXJlU2l6ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2xkSG9tZUJvdW5kcyA9IHRoaXMuX2hvbWVCb3VuZHMgPyB0aGlzLl9ob21lQm91bmRzLmNsb25lKCkgOiBudWxsO1xuICAgICAgICB2YXIgb2xkQ29udGVudFNpemUgPSB0aGlzLl9jb250ZW50U2l6ZSA/IHRoaXMuX2NvbnRlbnRTaXplLmNsb25lKCkgOiBudWxsO1xuICAgICAgICB2YXIgb2xkQ29udGVudEZhY3RvciA9IHRoaXMuX2NvbnRlbnRGYWN0b3IgfHwgMDtcblxuICAgICAgICBpZiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faG9tZUJvdW5kcyA9IG5ldyAkLlJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IG5ldyAkLlBvaW50KDEsIDEpO1xuICAgICAgICAgICAgdGhpcy5fY29udGVudEZhY3RvciA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGl0ZW0uZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50RmFjdG9yID0gaXRlbS5nZXRDb250ZW50U2l6ZSgpLnggLyBib3VuZHMud2lkdGg7XG4gICAgICAgICAgICB2YXIgY2xpcHBlZEJvdW5kcyA9IGl0ZW0uZ2V0Q2xpcHBlZEJvdW5kcygpO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBjbGlwcGVkQm91bmRzLng7XG4gICAgICAgICAgICB2YXIgdG9wID0gY2xpcHBlZEJvdW5kcy55O1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY2xpcHBlZEJvdW5kcy54ICsgY2xpcHBlZEJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSBjbGlwcGVkQm91bmRzLnkgKyBjbGlwcGVkQm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICAgICAgYm91bmRzID0gaXRlbS5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50RmFjdG9yID0gTWF0aC5tYXgodGhpcy5fY29udGVudEZhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5nZXRDb250ZW50U2l6ZSgpLnggLyBib3VuZHMud2lkdGgpO1xuICAgICAgICAgICAgICAgIGNsaXBwZWRCb3VuZHMgPSBpdGVtLmdldENsaXBwZWRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgY2xpcHBlZEJvdW5kcy54KTtcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1pbih0b3AsIGNsaXBwZWRCb3VuZHMueSk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgY2xpcHBlZEJvdW5kcy54ICsgY2xpcHBlZEJvdW5kcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYm90dG9tLCBjbGlwcGVkQm91bmRzLnkgKyBjbGlwcGVkQm91bmRzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2hvbWVCb3VuZHMgPSBuZXcgJC5SZWN0KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgICAgICAgdGhpcy5fY29udGVudFNpemUgPSBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICB0aGlzLl9ob21lQm91bmRzLndpZHRoICogdGhpcy5fY29udGVudEZhY3RvcixcbiAgICAgICAgICAgICAgICB0aGlzLl9ob21lQm91bmRzLmhlaWdodCAqIHRoaXMuX2NvbnRlbnRGYWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRGYWN0b3IgIT09IG9sZENvbnRlbnRGYWN0b3IgfHxcbiAgICAgICAgICAgICF0aGlzLl9ob21lQm91bmRzLmVxdWFscyhvbGRIb21lQm91bmRzKSB8fFxuICAgICAgICAgICAgIXRoaXMuX2NvbnRlbnRTaXplLmVxdWFscyhvbGRDb250ZW50U2l6ZSkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIGhvbWUgYm91bmRzIG9yIGNvbnRlbnQgZmFjdG9yIGNoYW5nZS5cbiAgICAgICAgICAgICAqIEBldmVudCBtZXRyaWNzLWNoYW5nZVxuICAgICAgICAgICAgICogQG1lbWJlck9mIE9wZW5TZWFkcmFnb24uV29ybGRcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uV29ybGR9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFdvcmxkIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmFpc2VFdmVudCgnbWV0cmljcy1jaGFuZ2UnLCB7fSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9yYWlzZVJlbW92ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZC5cbiAgICAgICAgICogQGV2ZW50IHJlbW92ZS1pdGVtXG4gICAgICAgICAqIEBtZW1iZXJPZiBPcGVuU2VhZHJhZ29uLldvcmxkXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Xb3JsZH0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgV29ybGQgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IGl0ZW0gLSBUaGUgaXRlbSdzIHVuZGVybHlpbmcgaXRlbS5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAncmVtb3ZlLWl0ZW0nLCB7IGl0ZW06IGl0ZW0gfSApO1xuICAgIH1cbn0pO1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVuc2VhZHJhZ29uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vb3BlbnNlYWRyYWdvbi9idWlsZC9vcGVuc2VhZHJhZ29uL29wZW5zZWFkcmFnb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('!function(t){"use strict";function e(e){this.viewer.setMouseNavEnabled(!1);var i=this.viewer.viewport.deltaPointsFromPixels(e.delta,!0),s=this.viewer.viewport.pointFromPixel(e.position,!0),r=new t.Point(s.x-i.x,s.y-i.y);if(this.rect){var n;if(this.restrictToImage&&(n=this.rect.clone()),this.rectDone){var o=this.rect.getAngleFromCenter(r),h=this.rect.getAngleFromCenter(s);this.rect.rotation=(this.rect.rotation+o-h)%Math.PI}else this.startRotated?this.rect=l(this.rotatedStartPoint,s,this.startRotatedHeight):(this.rect.width+=i.x,this.rect.height+=i.y);var d=this.viewer.world.getHomeBounds();this.restrictToImage&&!this.rect.fitsIn(new t.Rect(0,0,d.width,d.height))&&(this.rect=n)}else{if(this.restrictToImage){if(!a(this,r))return;c(i,s)}this.startRotated?(this.rotatedStartPoint=r,this.rect=l(r,s,this.startRotatedHeight)):this.rect=new t.SelectionRect(r.x,r.y,i.x,i.y),this.rectDone=!1}this.draw()}function i(){this.viewer.setMouseNavEnabled(!0),this.rectDone=!0}function s(){this.viewer.canvas.focus()}function r(e){t.addClass(this.element,"dragging");var i=this.viewer.viewport.deltaPointsFromPixels(e.delta,!0);this.rect.x+=i.x,this.rect.y+=i.y;var s=this.viewer.world.getHomeBounds();this.restrictToImage&&!this.rect.fitsIn(new t.Rect(0,0,s.width,s.height))&&(this.rect.x-=i.x,this.rect.y-=i.y),this.draw()}function n(){t.removeClass(this.element,"dragging")}function o(e,i){var s,r=i.delta,n=this.rect.getDegreeRotation(),o=this.restrictToImage?this.rect.clone():null;switch(0!==n&&(r=r.rotate(-1*n,new t.Point(0,0)),s=this.rect.getCenter()),r=this.viewer.viewport.deltaPointsFromPixels(r,!0),e){case 0:this.rect.y+=r.y,this.rect.height-=r.y;break;case 1:this.rect.width+=r.x;break;case 2:this.rect.height+=r.y;break;case 3:this.rect.x+=r.x,this.rect.width-=r.x;break;case.5:this.rect.y+=r.y,this.rect.height-=r.y,this.rect.x+=r.x,this.rect.width-=r.x;break;case 1.5:this.rect.y+=r.y,this.rect.height-=r.y,this.rect.width+=r.x;break;case 2.5:this.rect.width+=r.x,this.rect.height+=r.y;break;case 3.5:this.rect.height+=r.y,this.rect.x+=r.x,this.rect.width-=r.x}if(0!==n){var h=this.rect.getCenter(),l=h.rotate(n,s);r=l.minus(h),this.rect.x+=r.x,this.rect.y+=r.y}var a=this.viewer.world.getHomeBounds();this.restrictToImage&&!this.rect.fitsIn(new t.Rect(0,0,a.width,a.height))&&(this.rect=o),this.draw()}function h(t){var e=t.keyCode?t.keyCode:t.charCode;13===e?this.confirm():String.fromCharCode(e)===this.keyboardShortcut&&this.toggleState()}function l(e,i,s){if(e.x>i.x){var r=e;e=i,i=r}var n=i.minus(e),o=e.distanceTo(i),h=-1*Math.atan2(n.x,n.y)+Math.PI/2,l=new t.Point(n.x/2+e.x,n.y/2+e.y),a=new t.SelectionRect(l.x-o/2,l.y-s/2,o,s,h),c=new t.Point(0,s);return c=c.rotate(a.getDegreeRotation(),new t.Point(0,0)),a.x+=c.x/2,a.y+=c.y/2,a}function a(t,e){var i=t.viewer.world.getHomeBounds();return e.x>=0&&e.x<=i.width&&e.y>=0&&e.y<=i.height}function c(t,e){var i;for(var s in{x:0,y:0})i=e[s]-t[s],i<1&&i>0&&(e[s]>1?(t[s]-=e[s]-1,e[s]=1):e[s]<0&&(t[s]-=e[s],e[s]=0))}if(!t.version||t.version.major<2)throw new Error("This version of OpenSeadragonSelection requires OpenSeadragon version 2.0.0+");t.Viewer.prototype.selection=function(e){return this.selectionInstance&&!e||(e=e||{},e.viewer=this,this.selectionInstance=new t.Selection(e)),this.selectionInstance},t.Selection=function(l){t.extend(!0,this,{viewer:null,isSelecting:!1,buttonActiveImg:!1,rectDone:!0,element:null,toggleButton:null,showSelectionControl:!0,showConfirmDenyButtons:!0,styleConfirmDenyButtons:!0,returnPixelCoordinates:!0,keyboardShortcut:"c",rect:null,startRotated:!1,startRotatedHeight:.1,restrictToImage:!1,onSelection:null,prefixUrl:null,navImages:{selection:{REST:"selection_rest.png",GROUP:"selection_grouphover.png",HOVER:"selection_hover.png",DOWN:"selection_pressed.png"},selectionConfirm:{REST:"selection_confirm_rest.png",GROUP:"selection_confirm_grouphover.png",HOVER:"selection_confirm_hover.png",DOWN:"selection_confirm_pressed.png"},selectionCancel:{REST:"selection_cancel_rest.png",GROUP:"selection_cancel_grouphover.png",HOVER:"selection_cancel_hover.png",DOWN:"selection_cancel_pressed.png"}}},l),t.extend(!0,this.navImages,this.viewer.navImages),this.element||(this.element=t.makeNeutralElement("div"),this.element.style.background="rgba(0, 0, 0, 0.1)",this.element.className="selection-box"),this.borders=this.borders||[];for(var a,c=[],d=0;d<4;d++)this.borders[d]||(this.borders[d]=t.makeNeutralElement("div"),this.borders[d].className="border-"+d,this.borders[d].style.position="absolute",this.borders[d].style.width="1px",this.borders[d].style.height="1px",this.borders[d].style.background="#fff"),a=t.makeNeutralElement("div"),a.className="border-"+d+"-handle",a.style.position="absolute",a.style.top="50%",a.style.left="50%",a.style.width="6px",a.style.height="6px",a.style.margin="-4px 0 0 -4px",a.style.background="#000",a.style.border="1px solid #ccc",new t.MouseTracker({element:this.borders[d],dragHandler:o.bind(this,d)}),c[d]=t.makeNeutralElement("div"),c[d].className="corner-"+d+"-handle",c[d].style.position="absolute",c[d].style.width="6px",c[d].style.height="6px",c[d].style.background="#000",c[d].style.border="1px solid #ccc",new t.MouseTracker({element:c[d],dragHandler:o.bind(this,d+.5)}),this.borders[d].appendChild(a),this.element.appendChild(this.borders[d]),setTimeout(this.element.appendChild.bind(this.element,c[d]),0);this.borders[0].style.top=0,this.borders[0].style.width="100%",this.borders[1].style.right=0,this.borders[1].style.height="100%",this.borders[2].style.bottom=0,this.borders[2].style.width="100%",this.borders[3].style.left=0,this.borders[3].style.height="100%",c[0].style.top="-3px",c[0].style.left="-3px",c[1].style.top="-3px",c[1].style.right="-3px",c[2].style.bottom="-3px",c[2].style.right="-3px",c[3].style.bottom="-3px",c[3].style.left="-3px",this.overlay||(this.overlay=new t.SelectionOverlay(this.element,this.rect||new t.SelectionRect)),this.innerTracker=new t.MouseTracker({element:this.element,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,dragHandler:t.delegate(this,r),dragEndHandler:t.delegate(this,n),clickHandler:t.delegate(this,s)}),this.outerTracker=new t.MouseTracker({element:this.viewer.canvas,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,dragHandler:t.delegate(this,e),dragEndHandler:t.delegate(this,i),clickHandler:t.delegate(this,s),startDisabled:!this.isSelecting}),this.keyboardShortcut&&t.addEvent(this.viewer.container,"keypress",t.delegate(this,h),!1);var u=this.prefixUrl||this.viewer.prefixUrl||"",g=this.viewer.buttons&&this.viewer.buttons.buttons,m=g?this.viewer.buttons.buttons[0]:null,w=m?m.onFocus:null,v=m?m.onBlur:null;if(this.showSelectionControl&&(this.toggleButton=new t.Button({element:this.toggleButton?t.getElement(this.toggleButton):null,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,tooltip:t.getString("Tooltips.SelectionToggle")||"Toggle selection",srcRest:u+this.navImages.selection.REST,srcGroup:u+this.navImages.selection.GROUP,srcHover:u+this.navImages.selection.HOVER,srcDown:u+this.navImages.selection.DOWN,onRelease:this.toggleState.bind(this),onFocus:w,onBlur:v}),g&&(this.viewer.buttons.buttons.push(this.toggleButton),this.viewer.buttons.element.appendChild(this.toggleButton.element)),this.toggleButton.imgDown&&(this.buttonActiveImg=this.toggleButton.imgDown.cloneNode(!0),this.toggleButton.element.appendChild(this.buttonActiveImg))),this.showConfirmDenyButtons){this.confirmButton=new t.Button({element:this.confirmButton?t.getElement(this.confirmButton):null,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,tooltip:t.getString("Tooltips.SelectionConfirm")||"Confirm selection",srcRest:u+this.navImages.selectionConfirm.REST,srcGroup:u+this.navImages.selectionConfirm.GROUP,srcHover:u+this.navImages.selectionConfirm.HOVER,srcDown:u+this.navImages.selectionConfirm.DOWN,onRelease:this.confirm.bind(this),onFocus:w,onBlur:v});var p=this.confirmButton.element;p.classList.add("confirm-button"),this.element.appendChild(p),this.cancelButton=new t.Button({element:this.cancelButton?t.getElement(this.cancelButton):null,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,tooltip:t.getString("Tooltips.SelectionConfirm")||"Cancel selection",srcRest:u+this.navImages.selectionCancel.REST,srcGroup:u+this.navImages.selectionCancel.GROUP,srcHover:u+this.navImages.selectionCancel.HOVER,srcDown:u+this.navImages.selectionCancel.DOWN,onRelease:this.cancel.bind(this),onFocus:w,onBlur:v});var y=this.cancelButton.element;y.classList.add("cancel-button"),this.element.appendChild(y),this.styleConfirmDenyButtons&&(p.style.position="absolute",p.style.top="50%",p.style.left="50%",p.style.transform="translate(-100%, -50%)",y.style.position="absolute",y.style.top="50%",y.style.left="50%",y.style.transform="translate(0, -50%)")}this.viewer.addHandler("selection",this.onSelection),this.viewer.addHandler("open",this.draw.bind(this)),this.viewer.addHandler("animation",this.draw.bind(this)),this.viewer.addHandler("resize",this.draw.bind(this)),this.viewer.addHandler("rotate",this.draw.bind(this))},t.extend(t.Selection.prototype,t.ControlDock.prototype,{toggleState:function(){return this.setState(!this.isSelecting)},setState:function(t){return this.isSelecting=t,this.outerTracker.setTracking(t),t?this.draw():this.undraw(),this.buttonActiveImg&&(this.buttonActiveImg.style.visibility=t?"visible":"hidden"),this.viewer.raiseEvent("selection_toggle",{enabled:t}),this},enable:function(){return this.setState(!0)},disable:function(){return this.setState(!1)},draw:function(){return this.rect&&(this.overlay.update(this.rect.normalize()),this.overlay.drawHTML(this.viewer.drawer.container,this.viewer.viewport)),this},undraw:function(){return this.overlay.destroy(),this.rect=null,this},confirm:function(){if(this.rect){var e=this.rect.normalize();if(this.returnPixelCoordinates){var i=this.viewer.viewport.viewportToImageRectangle(e);i=t.SelectionRect.fromRect(i).round(),i.rotation=e.rotation,e=i}this.viewer.raiseEvent("selection",e),this.undraw()}return this},cancel:function(){return this.viewer.raiseEvent("selection_cancel",!1),this.undraw()}})}(OpenSeadragon),function(t){"use strict";t.SelectionOverlay=function(e,i){t.Overlay.apply(this,arguments),t.isPlainObject(e)?this.rotation=e.location.rotation||0:this.rotation=i.rotation||0},t.SelectionOverlay.prototype=t.extend(Object.create(t.Overlay.prototype),{drawHTML:function(){t.Overlay.prototype.drawHTML.apply(this,arguments),this.style.transform=this.style.transform.replace(/ ?rotate\\(.+rad\\)/,"")+" rotate("+this.rotation+"rad)"},update:function(e){t.Overlay.prototype.update.apply(this,arguments),this.rotation=e.rotation||0}})}(OpenSeadragon),function(t){"use strict";t.SelectionRect=function(e,i,s,r,n){t.Rect.apply(this,[e,i,s,r]),this.rotation=n||0},t.SelectionRect.fromRect=function(e){return new t.SelectionRect(e.x,e.y,e.width,e.height)},t.SelectionRect.prototype=t.extend(Object.create(t.Rect.prototype),{clone:function(){return new t.SelectionRect(this.x,this.y,this.width,this.height,this.rotation)},equals:function(e){return t.Rect.prototype.equals.apply(this,[e])&&this.rotation===e.rotation},toString:function(){return"["+Math.round(100*this.x)/100+","+Math.round(100*this.y)/100+","+Math.round(100*this.width)/100+"x"+Math.round(100*this.height)/100+"@"+Math.round(100*this.rotation)/100+"]"},swapWidthHeight:function(){var t=this.clone();return t.width=this.height,t.height=this.width,t.x+=(this.width-this.height)/2,t.y+=(this.height-this.width)/2,t},getDegreeRotation:function(){return this.rotation*(180/Math.PI)},getAngleFromCenter:function(t){var e=t.minus(this.getCenter());return Math.atan2(e.x,e.y)},round:function(){return new t.SelectionRect(Math.round(this.x),Math.round(this.y),Math.round(this.width),Math.round(this.height),this.rotation)},normalize:function(){var t=this.clone();return t.width<0&&(t.x+=t.width,t.width*=-1),t.height<0&&(t.y+=t.height,t.height*=-1),t.rotation%=Math.PI,t},fitsIn:function(t){for(var e=this.normalize(),i=[e.getTopLeft(),e.getTopRight(),e.getBottomRight(),e.getBottomLeft()],s=e.getCenter(),r=e.getDegreeRotation(),n=t.getBottomRight(),o=0;o<4;o++)if(i[o]=i[o].rotate(r,s),i[o].x<t.x||i[o].x>n.x||i[o].y<t.y||i[o].y>n.y)return!1;return!0},reduceRotation:function(){var t;return this.rotation<Math.PI/-4?(t=this.swapWidthHeight(),t.rotation+=Math.PI/2):this.rotation>Math.PI/4?(t=this.swapWidthHeight(),t.rotation-=Math.PI/2):t=this.clone(),t}})}(OpenSeadragon);\n//# sourceMappingURL=openseadragonselection.js.map\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9vcGVuc2VhZHJhZ29uc2VsZWN0aW9uL2Rpc3Qvb3BlbnNlYWRyYWdvbnNlbGVjdGlvbi5qcz9mZDAzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsYUFBYSxjQUFjLG1DQUFtQyxpSkFBaUosY0FBYyxNQUFNLDhEQUE4RCx3RUFBd0Usb0RBQW9ELGtJQUFrSSx3Q0FBd0MseUZBQXlGLEtBQUsseUJBQXlCLHFCQUFxQixPQUFPLHNKQUFzSixZQUFZLGFBQWEsb0RBQW9ELGFBQWEsMkJBQTJCLGNBQWMsb0NBQW9DLDZEQUE2RCxrQ0FBa0Msd0NBQXdDLDJIQUEySCxhQUFhLHVDQUF1QyxnQkFBZ0IsOEZBQThGLGdJQUFnSSw4Q0FBOEMsTUFBTSw0QkFBNEIsTUFBTSw2QkFBNkIsTUFBTSw2Q0FBNkMsTUFBTSxvRkFBb0YsTUFBTSxxRUFBcUUsTUFBTSxvREFBb0QsTUFBTSxxRUFBcUUsVUFBVSw0Q0FBNEMsK0NBQStDLHdDQUF3QyxxR0FBcUcsY0FBYyxxQ0FBcUMseUZBQXlGLGtCQUFrQixZQUFZLFFBQVEsUUFBUSx5S0FBeUssa0ZBQWtGLGdCQUFnQixxQ0FBcUMsbURBQW1ELGdCQUFnQixNQUFNLGFBQWEsUUFBUSxrRkFBa0YsaUlBQWlJLHlDQUF5QywyQ0FBMkMsaUZBQWlGLHlCQUF5QixrQkFBa0IsbVVBQW1VLFdBQVcsb0hBQW9ILG1CQUFtQixvSkFBb0osa0JBQWtCLGtKQUFrSix1T0FBdU8sbUJBQW1CLElBQUksdWhCQUF1aEIsbURBQW1ELDBPQUEwTywyQ0FBMkMsMElBQTBJLHVrQkFBdWtCLDBOQUEwTix3Q0FBd0MsZ1FBQWdRLDRGQUE0RixnTEFBZ0wsK0RBQStELG9jQUFvYyxrVEFBa1QsaUNBQWlDLGdlQUFnZSxFQUFFLGlDQUFpQyw4RkFBOEYsd2RBQXdkLEVBQUUsZ0NBQWdDLGlUQUFpVCw4UUFBOFEseURBQXlELHVCQUF1Qix3Q0FBd0Msc0JBQXNCLHFOQUFxTixVQUFVLE9BQU8sbUJBQW1CLHlCQUF5QixvQkFBb0IseUJBQXlCLGlCQUFpQiw2SUFBNkksbUJBQW1CLGtEQUFrRCxvQkFBb0IsY0FBYyw0QkFBNEIsZ0NBQWdDLHVEQUF1RCxnRUFBZ0Usb0RBQW9ELFlBQVksbUJBQW1CLG9FQUFvRSxFQUFFLDRCQUE0QixhQUFhLGlDQUFpQyxvSEFBb0gsMkVBQTJFLG9CQUFvQiw2SkFBNkosb0JBQW9CLDhFQUE4RSxFQUFFLDRCQUE0QixhQUFhLG9DQUFvQyxnREFBZ0Qsc0NBQXNDLHFEQUFxRCxxRUFBcUUsaUJBQWlCLCtFQUErRSxvQkFBb0IsMkVBQTJFLHFCQUFxQixxTEFBcUwsNEJBQTRCLG1CQUFtQixpSEFBaUgsOEJBQThCLG1DQUFtQyxnQ0FBZ0MsZ0NBQWdDLDJCQUEyQixrQkFBa0IsK0hBQStILHNCQUFzQixtQkFBbUIsNEdBQTRHLG9CQUFvQixvS0FBb0ssSUFBSSxxRkFBcUYsU0FBUywyQkFBMkIsTUFBTSw0S0FBNEssRUFBRTtBQUMzMVkiLCJmaWxlIjoiMTA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoZSl7dGhpcy52aWV3ZXIuc2V0TW91c2VOYXZFbmFibGVkKCExKTt2YXIgaT10aGlzLnZpZXdlci52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMoZS5kZWx0YSwhMCkscz10aGlzLnZpZXdlci52aWV3cG9ydC5wb2ludEZyb21QaXhlbChlLnBvc2l0aW9uLCEwKSxyPW5ldyB0LlBvaW50KHMueC1pLngscy55LWkueSk7aWYodGhpcy5yZWN0KXt2YXIgbjtpZih0aGlzLnJlc3RyaWN0VG9JbWFnZSYmKG49dGhpcy5yZWN0LmNsb25lKCkpLHRoaXMucmVjdERvbmUpe3ZhciBvPXRoaXMucmVjdC5nZXRBbmdsZUZyb21DZW50ZXIociksaD10aGlzLnJlY3QuZ2V0QW5nbGVGcm9tQ2VudGVyKHMpO3RoaXMucmVjdC5yb3RhdGlvbj0odGhpcy5yZWN0LnJvdGF0aW9uK28taCklTWF0aC5QSX1lbHNlIHRoaXMuc3RhcnRSb3RhdGVkP3RoaXMucmVjdD1sKHRoaXMucm90YXRlZFN0YXJ0UG9pbnQscyx0aGlzLnN0YXJ0Um90YXRlZEhlaWdodCk6KHRoaXMucmVjdC53aWR0aCs9aS54LHRoaXMucmVjdC5oZWlnaHQrPWkueSk7dmFyIGQ9dGhpcy52aWV3ZXIud29ybGQuZ2V0SG9tZUJvdW5kcygpO3RoaXMucmVzdHJpY3RUb0ltYWdlJiYhdGhpcy5yZWN0LmZpdHNJbihuZXcgdC5SZWN0KDAsMCxkLndpZHRoLGQuaGVpZ2h0KSkmJih0aGlzLnJlY3Q9bil9ZWxzZXtpZih0aGlzLnJlc3RyaWN0VG9JbWFnZSl7aWYoIWEodGhpcyxyKSlyZXR1cm47YyhpLHMpfXRoaXMuc3RhcnRSb3RhdGVkPyh0aGlzLnJvdGF0ZWRTdGFydFBvaW50PXIsdGhpcy5yZWN0PWwocixzLHRoaXMuc3RhcnRSb3RhdGVkSGVpZ2h0KSk6dGhpcy5yZWN0PW5ldyB0LlNlbGVjdGlvblJlY3Qoci54LHIueSxpLngsaS55KSx0aGlzLnJlY3REb25lPSExfXRoaXMuZHJhdygpfWZ1bmN0aW9uIGkoKXt0aGlzLnZpZXdlci5zZXRNb3VzZU5hdkVuYWJsZWQoITApLHRoaXMucmVjdERvbmU9ITB9ZnVuY3Rpb24gcygpe3RoaXMudmlld2VyLmNhbnZhcy5mb2N1cygpfWZ1bmN0aW9uIHIoZSl7dC5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsXCJkcmFnZ2luZ1wiKTt2YXIgaT10aGlzLnZpZXdlci52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMoZS5kZWx0YSwhMCk7dGhpcy5yZWN0LngrPWkueCx0aGlzLnJlY3QueSs9aS55O3ZhciBzPXRoaXMudmlld2VyLndvcmxkLmdldEhvbWVCb3VuZHMoKTt0aGlzLnJlc3RyaWN0VG9JbWFnZSYmIXRoaXMucmVjdC5maXRzSW4obmV3IHQuUmVjdCgwLDAscy53aWR0aCxzLmhlaWdodCkpJiYodGhpcy5yZWN0LngtPWkueCx0aGlzLnJlY3QueS09aS55KSx0aGlzLmRyYXcoKX1mdW5jdGlvbiBuKCl7dC5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsXCJkcmFnZ2luZ1wiKX1mdW5jdGlvbiBvKGUsaSl7dmFyIHMscj1pLmRlbHRhLG49dGhpcy5yZWN0LmdldERlZ3JlZVJvdGF0aW9uKCksbz10aGlzLnJlc3RyaWN0VG9JbWFnZT90aGlzLnJlY3QuY2xvbmUoKTpudWxsO3N3aXRjaCgwIT09biYmKHI9ci5yb3RhdGUoLTEqbixuZXcgdC5Qb2ludCgwLDApKSxzPXRoaXMucmVjdC5nZXRDZW50ZXIoKSkscj10aGlzLnZpZXdlci52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMociwhMCksZSl7Y2FzZSAwOnRoaXMucmVjdC55Kz1yLnksdGhpcy5yZWN0LmhlaWdodC09ci55O2JyZWFrO2Nhc2UgMTp0aGlzLnJlY3Qud2lkdGgrPXIueDticmVhaztjYXNlIDI6dGhpcy5yZWN0LmhlaWdodCs9ci55O2JyZWFrO2Nhc2UgMzp0aGlzLnJlY3QueCs9ci54LHRoaXMucmVjdC53aWR0aC09ci54O2JyZWFrO2Nhc2UuNTp0aGlzLnJlY3QueSs9ci55LHRoaXMucmVjdC5oZWlnaHQtPXIueSx0aGlzLnJlY3QueCs9ci54LHRoaXMucmVjdC53aWR0aC09ci54O2JyZWFrO2Nhc2UgMS41OnRoaXMucmVjdC55Kz1yLnksdGhpcy5yZWN0LmhlaWdodC09ci55LHRoaXMucmVjdC53aWR0aCs9ci54O2JyZWFrO2Nhc2UgMi41OnRoaXMucmVjdC53aWR0aCs9ci54LHRoaXMucmVjdC5oZWlnaHQrPXIueTticmVhaztjYXNlIDMuNTp0aGlzLnJlY3QuaGVpZ2h0Kz1yLnksdGhpcy5yZWN0LngrPXIueCx0aGlzLnJlY3Qud2lkdGgtPXIueH1pZigwIT09bil7dmFyIGg9dGhpcy5yZWN0LmdldENlbnRlcigpLGw9aC5yb3RhdGUobixzKTtyPWwubWludXMoaCksdGhpcy5yZWN0LngrPXIueCx0aGlzLnJlY3QueSs9ci55fXZhciBhPXRoaXMudmlld2VyLndvcmxkLmdldEhvbWVCb3VuZHMoKTt0aGlzLnJlc3RyaWN0VG9JbWFnZSYmIXRoaXMucmVjdC5maXRzSW4obmV3IHQuUmVjdCgwLDAsYS53aWR0aCxhLmhlaWdodCkpJiYodGhpcy5yZWN0PW8pLHRoaXMuZHJhdygpfWZ1bmN0aW9uIGgodCl7dmFyIGU9dC5rZXlDb2RlP3Qua2V5Q29kZTp0LmNoYXJDb2RlOzEzPT09ZT90aGlzLmNvbmZpcm0oKTpTdHJpbmcuZnJvbUNoYXJDb2RlKGUpPT09dGhpcy5rZXlib2FyZFNob3J0Y3V0JiZ0aGlzLnRvZ2dsZVN0YXRlKCl9ZnVuY3Rpb24gbChlLGkscyl7aWYoZS54PmkueCl7dmFyIHI9ZTtlPWksaT1yfXZhciBuPWkubWludXMoZSksbz1lLmRpc3RhbmNlVG8oaSksaD0tMSpNYXRoLmF0YW4yKG4ueCxuLnkpK01hdGguUEkvMixsPW5ldyB0LlBvaW50KG4ueC8yK2UueCxuLnkvMitlLnkpLGE9bmV3IHQuU2VsZWN0aW9uUmVjdChsLngtby8yLGwueS1zLzIsbyxzLGgpLGM9bmV3IHQuUG9pbnQoMCxzKTtyZXR1cm4gYz1jLnJvdGF0ZShhLmdldERlZ3JlZVJvdGF0aW9uKCksbmV3IHQuUG9pbnQoMCwwKSksYS54Kz1jLngvMixhLnkrPWMueS8yLGF9ZnVuY3Rpb24gYSh0LGUpe3ZhciBpPXQudmlld2VyLndvcmxkLmdldEhvbWVCb3VuZHMoKTtyZXR1cm4gZS54Pj0wJiZlLng8PWkud2lkdGgmJmUueT49MCYmZS55PD1pLmhlaWdodH1mdW5jdGlvbiBjKHQsZSl7dmFyIGk7Zm9yKHZhciBzIGlue3g6MCx5OjB9KWk9ZVtzXS10W3NdLGk8MSYmaT4wJiYoZVtzXT4xPyh0W3NdLT1lW3NdLTEsZVtzXT0xKTplW3NdPDAmJih0W3NdLT1lW3NdLGVbc109MCkpfWlmKCF0LnZlcnNpb258fHQudmVyc2lvbi5tYWpvcjwyKXRocm93IG5ldyBFcnJvcihcIlRoaXMgdmVyc2lvbiBvZiBPcGVuU2VhZHJhZ29uU2VsZWN0aW9uIHJlcXVpcmVzIE9wZW5TZWFkcmFnb24gdmVyc2lvbiAyLjAuMCtcIik7dC5WaWV3ZXIucHJvdG90eXBlLnNlbGVjdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zZWxlY3Rpb25JbnN0YW5jZSYmIWV8fChlPWV8fHt9LGUudmlld2VyPXRoaXMsdGhpcy5zZWxlY3Rpb25JbnN0YW5jZT1uZXcgdC5TZWxlY3Rpb24oZSkpLHRoaXMuc2VsZWN0aW9uSW5zdGFuY2V9LHQuU2VsZWN0aW9uPWZ1bmN0aW9uKGwpe3QuZXh0ZW5kKCEwLHRoaXMse3ZpZXdlcjpudWxsLGlzU2VsZWN0aW5nOiExLGJ1dHRvbkFjdGl2ZUltZzohMSxyZWN0RG9uZTohMCxlbGVtZW50Om51bGwsdG9nZ2xlQnV0dG9uOm51bGwsc2hvd1NlbGVjdGlvbkNvbnRyb2w6ITAsc2hvd0NvbmZpcm1EZW55QnV0dG9uczohMCxzdHlsZUNvbmZpcm1EZW55QnV0dG9uczohMCxyZXR1cm5QaXhlbENvb3JkaW5hdGVzOiEwLGtleWJvYXJkU2hvcnRjdXQ6XCJjXCIscmVjdDpudWxsLHN0YXJ0Um90YXRlZDohMSxzdGFydFJvdGF0ZWRIZWlnaHQ6LjEscmVzdHJpY3RUb0ltYWdlOiExLG9uU2VsZWN0aW9uOm51bGwscHJlZml4VXJsOm51bGwsbmF2SW1hZ2VzOntzZWxlY3Rpb246e1JFU1Q6XCJzZWxlY3Rpb25fcmVzdC5wbmdcIixHUk9VUDpcInNlbGVjdGlvbl9ncm91cGhvdmVyLnBuZ1wiLEhPVkVSOlwic2VsZWN0aW9uX2hvdmVyLnBuZ1wiLERPV046XCJzZWxlY3Rpb25fcHJlc3NlZC5wbmdcIn0sc2VsZWN0aW9uQ29uZmlybTp7UkVTVDpcInNlbGVjdGlvbl9jb25maXJtX3Jlc3QucG5nXCIsR1JPVVA6XCJzZWxlY3Rpb25fY29uZmlybV9ncm91cGhvdmVyLnBuZ1wiLEhPVkVSOlwic2VsZWN0aW9uX2NvbmZpcm1faG92ZXIucG5nXCIsRE9XTjpcInNlbGVjdGlvbl9jb25maXJtX3ByZXNzZWQucG5nXCJ9LHNlbGVjdGlvbkNhbmNlbDp7UkVTVDpcInNlbGVjdGlvbl9jYW5jZWxfcmVzdC5wbmdcIixHUk9VUDpcInNlbGVjdGlvbl9jYW5jZWxfZ3JvdXBob3Zlci5wbmdcIixIT1ZFUjpcInNlbGVjdGlvbl9jYW5jZWxfaG92ZXIucG5nXCIsRE9XTjpcInNlbGVjdGlvbl9jYW5jZWxfcHJlc3NlZC5wbmdcIn19fSxsKSx0LmV4dGVuZCghMCx0aGlzLm5hdkltYWdlcyx0aGlzLnZpZXdlci5uYXZJbWFnZXMpLHRoaXMuZWxlbWVudHx8KHRoaXMuZWxlbWVudD10Lm1ha2VOZXV0cmFsRWxlbWVudChcImRpdlwiKSx0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZD1cInJnYmEoMCwgMCwgMCwgMC4xKVwiLHRoaXMuZWxlbWVudC5jbGFzc05hbWU9XCJzZWxlY3Rpb24tYm94XCIpLHRoaXMuYm9yZGVycz10aGlzLmJvcmRlcnN8fFtdO2Zvcih2YXIgYSxjPVtdLGQ9MDtkPDQ7ZCsrKXRoaXMuYm9yZGVyc1tkXXx8KHRoaXMuYm9yZGVyc1tkXT10Lm1ha2VOZXV0cmFsRWxlbWVudChcImRpdlwiKSx0aGlzLmJvcmRlcnNbZF0uY2xhc3NOYW1lPVwiYm9yZGVyLVwiK2QsdGhpcy5ib3JkZXJzW2RdLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLmJvcmRlcnNbZF0uc3R5bGUud2lkdGg9XCIxcHhcIix0aGlzLmJvcmRlcnNbZF0uc3R5bGUuaGVpZ2h0PVwiMXB4XCIsdGhpcy5ib3JkZXJzW2RdLnN0eWxlLmJhY2tncm91bmQ9XCIjZmZmXCIpLGE9dC5tYWtlTmV1dHJhbEVsZW1lbnQoXCJkaXZcIiksYS5jbGFzc05hbWU9XCJib3JkZXItXCIrZCtcIi1oYW5kbGVcIixhLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixhLnN0eWxlLnRvcD1cIjUwJVwiLGEuc3R5bGUubGVmdD1cIjUwJVwiLGEuc3R5bGUud2lkdGg9XCI2cHhcIixhLnN0eWxlLmhlaWdodD1cIjZweFwiLGEuc3R5bGUubWFyZ2luPVwiLTRweCAwIDAgLTRweFwiLGEuc3R5bGUuYmFja2dyb3VuZD1cIiMwMDBcIixhLnN0eWxlLmJvcmRlcj1cIjFweCBzb2xpZCAjY2NjXCIsbmV3IHQuTW91c2VUcmFja2VyKHtlbGVtZW50OnRoaXMuYm9yZGVyc1tkXSxkcmFnSGFuZGxlcjpvLmJpbmQodGhpcyxkKX0pLGNbZF09dC5tYWtlTmV1dHJhbEVsZW1lbnQoXCJkaXZcIiksY1tkXS5jbGFzc05hbWU9XCJjb3JuZXItXCIrZCtcIi1oYW5kbGVcIixjW2RdLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixjW2RdLnN0eWxlLndpZHRoPVwiNnB4XCIsY1tkXS5zdHlsZS5oZWlnaHQ9XCI2cHhcIixjW2RdLnN0eWxlLmJhY2tncm91bmQ9XCIjMDAwXCIsY1tkXS5zdHlsZS5ib3JkZXI9XCIxcHggc29saWQgI2NjY1wiLG5ldyB0Lk1vdXNlVHJhY2tlcih7ZWxlbWVudDpjW2RdLGRyYWdIYW5kbGVyOm8uYmluZCh0aGlzLGQrLjUpfSksdGhpcy5ib3JkZXJzW2RdLmFwcGVuZENoaWxkKGEpLHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmJvcmRlcnNbZF0pLHNldFRpbWVvdXQodGhpcy5lbGVtZW50LmFwcGVuZENoaWxkLmJpbmQodGhpcy5lbGVtZW50LGNbZF0pLDApO3RoaXMuYm9yZGVyc1swXS5zdHlsZS50b3A9MCx0aGlzLmJvcmRlcnNbMF0uc3R5bGUud2lkdGg9XCIxMDAlXCIsdGhpcy5ib3JkZXJzWzFdLnN0eWxlLnJpZ2h0PTAsdGhpcy5ib3JkZXJzWzFdLnN0eWxlLmhlaWdodD1cIjEwMCVcIix0aGlzLmJvcmRlcnNbMl0uc3R5bGUuYm90dG9tPTAsdGhpcy5ib3JkZXJzWzJdLnN0eWxlLndpZHRoPVwiMTAwJVwiLHRoaXMuYm9yZGVyc1szXS5zdHlsZS5sZWZ0PTAsdGhpcy5ib3JkZXJzWzNdLnN0eWxlLmhlaWdodD1cIjEwMCVcIixjWzBdLnN0eWxlLnRvcD1cIi0zcHhcIixjWzBdLnN0eWxlLmxlZnQ9XCItM3B4XCIsY1sxXS5zdHlsZS50b3A9XCItM3B4XCIsY1sxXS5zdHlsZS5yaWdodD1cIi0zcHhcIixjWzJdLnN0eWxlLmJvdHRvbT1cIi0zcHhcIixjWzJdLnN0eWxlLnJpZ2h0PVwiLTNweFwiLGNbM10uc3R5bGUuYm90dG9tPVwiLTNweFwiLGNbM10uc3R5bGUubGVmdD1cIi0zcHhcIix0aGlzLm92ZXJsYXl8fCh0aGlzLm92ZXJsYXk9bmV3IHQuU2VsZWN0aW9uT3ZlcmxheSh0aGlzLmVsZW1lbnQsdGhpcy5yZWN0fHxuZXcgdC5TZWxlY3Rpb25SZWN0KSksdGhpcy5pbm5lclRyYWNrZXI9bmV3IHQuTW91c2VUcmFja2VyKHtlbGVtZW50OnRoaXMuZWxlbWVudCxjbGlja1RpbWVUaHJlc2hvbGQ6dGhpcy52aWV3ZXIuY2xpY2tUaW1lVGhyZXNob2xkLGNsaWNrRGlzdFRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja0Rpc3RUaHJlc2hvbGQsZHJhZ0hhbmRsZXI6dC5kZWxlZ2F0ZSh0aGlzLHIpLGRyYWdFbmRIYW5kbGVyOnQuZGVsZWdhdGUodGhpcyxuKSxjbGlja0hhbmRsZXI6dC5kZWxlZ2F0ZSh0aGlzLHMpfSksdGhpcy5vdXRlclRyYWNrZXI9bmV3IHQuTW91c2VUcmFja2VyKHtlbGVtZW50OnRoaXMudmlld2VyLmNhbnZhcyxjbGlja1RpbWVUaHJlc2hvbGQ6dGhpcy52aWV3ZXIuY2xpY2tUaW1lVGhyZXNob2xkLGNsaWNrRGlzdFRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja0Rpc3RUaHJlc2hvbGQsZHJhZ0hhbmRsZXI6dC5kZWxlZ2F0ZSh0aGlzLGUpLGRyYWdFbmRIYW5kbGVyOnQuZGVsZWdhdGUodGhpcyxpKSxjbGlja0hhbmRsZXI6dC5kZWxlZ2F0ZSh0aGlzLHMpLHN0YXJ0RGlzYWJsZWQ6IXRoaXMuaXNTZWxlY3Rpbmd9KSx0aGlzLmtleWJvYXJkU2hvcnRjdXQmJnQuYWRkRXZlbnQodGhpcy52aWV3ZXIuY29udGFpbmVyLFwia2V5cHJlc3NcIix0LmRlbGVnYXRlKHRoaXMsaCksITEpO3ZhciB1PXRoaXMucHJlZml4VXJsfHx0aGlzLnZpZXdlci5wcmVmaXhVcmx8fFwiXCIsZz10aGlzLnZpZXdlci5idXR0b25zJiZ0aGlzLnZpZXdlci5idXR0b25zLmJ1dHRvbnMsbT1nP3RoaXMudmlld2VyLmJ1dHRvbnMuYnV0dG9uc1swXTpudWxsLHc9bT9tLm9uRm9jdXM6bnVsbCx2PW0/bS5vbkJsdXI6bnVsbDtpZih0aGlzLnNob3dTZWxlY3Rpb25Db250cm9sJiYodGhpcy50b2dnbGVCdXR0b249bmV3IHQuQnV0dG9uKHtlbGVtZW50OnRoaXMudG9nZ2xlQnV0dG9uP3QuZ2V0RWxlbWVudCh0aGlzLnRvZ2dsZUJ1dHRvbik6bnVsbCxjbGlja1RpbWVUaHJlc2hvbGQ6dGhpcy52aWV3ZXIuY2xpY2tUaW1lVGhyZXNob2xkLGNsaWNrRGlzdFRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja0Rpc3RUaHJlc2hvbGQsdG9vbHRpcDp0LmdldFN0cmluZyhcIlRvb2x0aXBzLlNlbGVjdGlvblRvZ2dsZVwiKXx8XCJUb2dnbGUgc2VsZWN0aW9uXCIsc3JjUmVzdDp1K3RoaXMubmF2SW1hZ2VzLnNlbGVjdGlvbi5SRVNULHNyY0dyb3VwOnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uLkdST1VQLHNyY0hvdmVyOnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uLkhPVkVSLHNyY0Rvd246dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb24uRE9XTixvblJlbGVhc2U6dGhpcy50b2dnbGVTdGF0ZS5iaW5kKHRoaXMpLG9uRm9jdXM6dyxvbkJsdXI6dn0pLGcmJih0aGlzLnZpZXdlci5idXR0b25zLmJ1dHRvbnMucHVzaCh0aGlzLnRvZ2dsZUJ1dHRvbiksdGhpcy52aWV3ZXIuYnV0dG9ucy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudG9nZ2xlQnV0dG9uLmVsZW1lbnQpKSx0aGlzLnRvZ2dsZUJ1dHRvbi5pbWdEb3duJiYodGhpcy5idXR0b25BY3RpdmVJbWc9dGhpcy50b2dnbGVCdXR0b24uaW1nRG93bi5jbG9uZU5vZGUoITApLHRoaXMudG9nZ2xlQnV0dG9uLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5idXR0b25BY3RpdmVJbWcpKSksdGhpcy5zaG93Q29uZmlybURlbnlCdXR0b25zKXt0aGlzLmNvbmZpcm1CdXR0b249bmV3IHQuQnV0dG9uKHtlbGVtZW50OnRoaXMuY29uZmlybUJ1dHRvbj90LmdldEVsZW1lbnQodGhpcy5jb25maXJtQnV0dG9uKTpudWxsLGNsaWNrVGltZVRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja1RpbWVUaHJlc2hvbGQsY2xpY2tEaXN0VGhyZXNob2xkOnRoaXMudmlld2VyLmNsaWNrRGlzdFRocmVzaG9sZCx0b29sdGlwOnQuZ2V0U3RyaW5nKFwiVG9vbHRpcHMuU2VsZWN0aW9uQ29uZmlybVwiKXx8XCJDb25maXJtIHNlbGVjdGlvblwiLHNyY1Jlc3Q6dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb25Db25maXJtLlJFU1Qsc3JjR3JvdXA6dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb25Db25maXJtLkdST1VQLHNyY0hvdmVyOnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uQ29uZmlybS5IT1ZFUixzcmNEb3duOnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uQ29uZmlybS5ET1dOLG9uUmVsZWFzZTp0aGlzLmNvbmZpcm0uYmluZCh0aGlzKSxvbkZvY3VzOncsb25CbHVyOnZ9KTt2YXIgcD10aGlzLmNvbmZpcm1CdXR0b24uZWxlbWVudDtwLmNsYXNzTGlzdC5hZGQoXCJjb25maXJtLWJ1dHRvblwiKSx0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQocCksdGhpcy5jYW5jZWxCdXR0b249bmV3IHQuQnV0dG9uKHtlbGVtZW50OnRoaXMuY2FuY2VsQnV0dG9uP3QuZ2V0RWxlbWVudCh0aGlzLmNhbmNlbEJ1dHRvbik6bnVsbCxjbGlja1RpbWVUaHJlc2hvbGQ6dGhpcy52aWV3ZXIuY2xpY2tUaW1lVGhyZXNob2xkLGNsaWNrRGlzdFRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja0Rpc3RUaHJlc2hvbGQsdG9vbHRpcDp0LmdldFN0cmluZyhcIlRvb2x0aXBzLlNlbGVjdGlvbkNvbmZpcm1cIil8fFwiQ2FuY2VsIHNlbGVjdGlvblwiLHNyY1Jlc3Q6dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb25DYW5jZWwuUkVTVCxzcmNHcm91cDp1K3RoaXMubmF2SW1hZ2VzLnNlbGVjdGlvbkNhbmNlbC5HUk9VUCxzcmNIb3Zlcjp1K3RoaXMubmF2SW1hZ2VzLnNlbGVjdGlvbkNhbmNlbC5IT1ZFUixzcmNEb3duOnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uQ2FuY2VsLkRPV04sb25SZWxlYXNlOnRoaXMuY2FuY2VsLmJpbmQodGhpcyksb25Gb2N1czp3LG9uQmx1cjp2fSk7dmFyIHk9dGhpcy5jYW5jZWxCdXR0b24uZWxlbWVudDt5LmNsYXNzTGlzdC5hZGQoXCJjYW5jZWwtYnV0dG9uXCIpLHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh5KSx0aGlzLnN0eWxlQ29uZmlybURlbnlCdXR0b25zJiYocC5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIscC5zdHlsZS50b3A9XCI1MCVcIixwLnN0eWxlLmxlZnQ9XCI1MCVcIixwLnN0eWxlLnRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMTAwJSwgLTUwJSlcIix5LnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix5LnN0eWxlLnRvcD1cIjUwJVwiLHkuc3R5bGUubGVmdD1cIjUwJVwiLHkuc3R5bGUudHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsIC01MCUpXCIpfXRoaXMudmlld2VyLmFkZEhhbmRsZXIoXCJzZWxlY3Rpb25cIix0aGlzLm9uU2VsZWN0aW9uKSx0aGlzLnZpZXdlci5hZGRIYW5kbGVyKFwib3BlblwiLHRoaXMuZHJhdy5iaW5kKHRoaXMpKSx0aGlzLnZpZXdlci5hZGRIYW5kbGVyKFwiYW5pbWF0aW9uXCIsdGhpcy5kcmF3LmJpbmQodGhpcykpLHRoaXMudmlld2VyLmFkZEhhbmRsZXIoXCJyZXNpemVcIix0aGlzLmRyYXcuYmluZCh0aGlzKSksdGhpcy52aWV3ZXIuYWRkSGFuZGxlcihcInJvdGF0ZVwiLHRoaXMuZHJhdy5iaW5kKHRoaXMpKX0sdC5leHRlbmQodC5TZWxlY3Rpb24ucHJvdG90eXBlLHQuQ29udHJvbERvY2sucHJvdG90eXBlLHt0b2dnbGVTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNldFN0YXRlKCF0aGlzLmlzU2VsZWN0aW5nKX0sc2V0U3RhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNTZWxlY3Rpbmc9dCx0aGlzLm91dGVyVHJhY2tlci5zZXRUcmFja2luZyh0KSx0P3RoaXMuZHJhdygpOnRoaXMudW5kcmF3KCksdGhpcy5idXR0b25BY3RpdmVJbWcmJih0aGlzLmJ1dHRvbkFjdGl2ZUltZy5zdHlsZS52aXNpYmlsaXR5PXQ/XCJ2aXNpYmxlXCI6XCJoaWRkZW5cIiksdGhpcy52aWV3ZXIucmFpc2VFdmVudChcInNlbGVjdGlvbl90b2dnbGVcIix7ZW5hYmxlZDp0fSksdGhpc30sZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0U3RhdGUoITApfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0U3RhdGUoITEpfSxkcmF3OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVjdCYmKHRoaXMub3ZlcmxheS51cGRhdGUodGhpcy5yZWN0Lm5vcm1hbGl6ZSgpKSx0aGlzLm92ZXJsYXkuZHJhd0hUTUwodGhpcy52aWV3ZXIuZHJhd2VyLmNvbnRhaW5lcix0aGlzLnZpZXdlci52aWV3cG9ydCkpLHRoaXN9LHVuZHJhdzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm92ZXJsYXkuZGVzdHJveSgpLHRoaXMucmVjdD1udWxsLHRoaXN9LGNvbmZpcm06ZnVuY3Rpb24oKXtpZih0aGlzLnJlY3Qpe3ZhciBlPXRoaXMucmVjdC5ub3JtYWxpemUoKTtpZih0aGlzLnJldHVyblBpeGVsQ29vcmRpbmF0ZXMpe3ZhciBpPXRoaXMudmlld2VyLnZpZXdwb3J0LnZpZXdwb3J0VG9JbWFnZVJlY3RhbmdsZShlKTtpPXQuU2VsZWN0aW9uUmVjdC5mcm9tUmVjdChpKS5yb3VuZCgpLGkucm90YXRpb249ZS5yb3RhdGlvbixlPWl9dGhpcy52aWV3ZXIucmFpc2VFdmVudChcInNlbGVjdGlvblwiLGUpLHRoaXMudW5kcmF3KCl9cmV0dXJuIHRoaXN9LGNhbmNlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXdlci5yYWlzZUV2ZW50KFwic2VsZWN0aW9uX2NhbmNlbFwiLCExKSx0aGlzLnVuZHJhdygpfX0pfShPcGVuU2VhZHJhZ29uKSxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjt0LlNlbGVjdGlvbk92ZXJsYXk9ZnVuY3Rpb24oZSxpKXt0Lk92ZXJsYXkuYXBwbHkodGhpcyxhcmd1bWVudHMpLHQuaXNQbGFpbk9iamVjdChlKT90aGlzLnJvdGF0aW9uPWUubG9jYXRpb24ucm90YXRpb258fDA6dGhpcy5yb3RhdGlvbj1pLnJvdGF0aW9ufHwwfSx0LlNlbGVjdGlvbk92ZXJsYXkucHJvdG90eXBlPXQuZXh0ZW5kKE9iamVjdC5jcmVhdGUodC5PdmVybGF5LnByb3RvdHlwZSkse2RyYXdIVE1MOmZ1bmN0aW9uKCl7dC5PdmVybGF5LnByb3RvdHlwZS5kcmF3SFRNTC5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5zdHlsZS50cmFuc2Zvcm09dGhpcy5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvID9yb3RhdGVcXCguK3JhZFxcKS8sXCJcIikrXCIgcm90YXRlKFwiK3RoaXMucm90YXRpb24rXCJyYWQpXCJ9LHVwZGF0ZTpmdW5jdGlvbihlKXt0Lk92ZXJsYXkucHJvdG90eXBlLnVwZGF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5yb3RhdGlvbj1lLnJvdGF0aW9ufHwwfX0pfShPcGVuU2VhZHJhZ29uKSxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjt0LlNlbGVjdGlvblJlY3Q9ZnVuY3Rpb24oZSxpLHMscixuKXt0LlJlY3QuYXBwbHkodGhpcyxbZSxpLHMscl0pLHRoaXMucm90YXRpb249bnx8MH0sdC5TZWxlY3Rpb25SZWN0LmZyb21SZWN0PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdC5TZWxlY3Rpb25SZWN0KGUueCxlLnksZS53aWR0aCxlLmhlaWdodCl9LHQuU2VsZWN0aW9uUmVjdC5wcm90b3R5cGU9dC5leHRlbmQoT2JqZWN0LmNyZWF0ZSh0LlJlY3QucHJvdG90eXBlKSx7Y2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHQuU2VsZWN0aW9uUmVjdCh0aGlzLngsdGhpcy55LHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5yb3RhdGlvbil9LGVxdWFsczpmdW5jdGlvbihlKXtyZXR1cm4gdC5SZWN0LnByb3RvdHlwZS5lcXVhbHMuYXBwbHkodGhpcyxbZV0pJiZ0aGlzLnJvdGF0aW9uPT09ZS5yb3RhdGlvbn0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIltcIitNYXRoLnJvdW5kKDEwMCp0aGlzLngpLzEwMCtcIixcIitNYXRoLnJvdW5kKDEwMCp0aGlzLnkpLzEwMCtcIixcIitNYXRoLnJvdW5kKDEwMCp0aGlzLndpZHRoKS8xMDArXCJ4XCIrTWF0aC5yb3VuZCgxMDAqdGhpcy5oZWlnaHQpLzEwMCtcIkBcIitNYXRoLnJvdW5kKDEwMCp0aGlzLnJvdGF0aW9uKS8xMDArXCJdXCJ9LHN3YXBXaWR0aEhlaWdodDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY2xvbmUoKTtyZXR1cm4gdC53aWR0aD10aGlzLmhlaWdodCx0LmhlaWdodD10aGlzLndpZHRoLHQueCs9KHRoaXMud2lkdGgtdGhpcy5oZWlnaHQpLzIsdC55Kz0odGhpcy5oZWlnaHQtdGhpcy53aWR0aCkvMix0fSxnZXREZWdyZWVSb3RhdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJvdGF0aW9uKigxODAvTWF0aC5QSSl9LGdldEFuZ2xlRnJvbUNlbnRlcjpmdW5jdGlvbih0KXt2YXIgZT10Lm1pbnVzKHRoaXMuZ2V0Q2VudGVyKCkpO3JldHVybiBNYXRoLmF0YW4yKGUueCxlLnkpfSxyb3VuZDpmdW5jdGlvbigpe3JldHVybiBuZXcgdC5TZWxlY3Rpb25SZWN0KE1hdGgucm91bmQodGhpcy54KSxNYXRoLnJvdW5kKHRoaXMueSksTWF0aC5yb3VuZCh0aGlzLndpZHRoKSxNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0KSx0aGlzLnJvdGF0aW9uKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jbG9uZSgpO3JldHVybiB0LndpZHRoPDAmJih0LngrPXQud2lkdGgsdC53aWR0aCo9LTEpLHQuaGVpZ2h0PDAmJih0LnkrPXQuaGVpZ2h0LHQuaGVpZ2h0Kj0tMSksdC5yb3RhdGlvbiU9TWF0aC5QSSx0fSxmaXRzSW46ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMubm9ybWFsaXplKCksaT1bZS5nZXRUb3BMZWZ0KCksZS5nZXRUb3BSaWdodCgpLGUuZ2V0Qm90dG9tUmlnaHQoKSxlLmdldEJvdHRvbUxlZnQoKV0scz1lLmdldENlbnRlcigpLHI9ZS5nZXREZWdyZWVSb3RhdGlvbigpLG49dC5nZXRCb3R0b21SaWdodCgpLG89MDtvPDQ7bysrKWlmKGlbb109aVtvXS5yb3RhdGUocixzKSxpW29dLng8dC54fHxpW29dLng+bi54fHxpW29dLnk8dC55fHxpW29dLnk+bi55KXJldHVybiExO3JldHVybiEwfSxyZWR1Y2VSb3RhdGlvbjpmdW5jdGlvbigpe3ZhciB0O3JldHVybiB0aGlzLnJvdGF0aW9uPE1hdGguUEkvLTQ/KHQ9dGhpcy5zd2FwV2lkdGhIZWlnaHQoKSx0LnJvdGF0aW9uKz1NYXRoLlBJLzIpOnRoaXMucm90YXRpb24+TWF0aC5QSS80Pyh0PXRoaXMuc3dhcFdpZHRoSGVpZ2h0KCksdC5yb3RhdGlvbi09TWF0aC5QSS8yKTp0PXRoaXMuY2xvbmUoKSx0fX0pfShPcGVuU2VhZHJhZ29uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW5zZWFkcmFnb25zZWxlY3Rpb24uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L29wZW5zZWFkcmFnb25zZWxlY3Rpb24vZGlzdC9vcGVuc2VhZHJhZ29uc2VsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcz8yOGQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTA3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIHJldHVybiBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi91dWlkL2xpYi9ybmctYnJvd3Nlci5qcz9hMTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTA4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cbnZhciBybmc7XG5cbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bzsgLy8gZm9yIElFIDExXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICBybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufVxuXG5pZiAoIXJuZykge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcm5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi91dWlkL2xpYi9ybmctYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var rng = __webpack_require__(108);\nvar bytesToUuid = __webpack_require__(107);\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi91dWlkL3Y0LmpzPzQyZTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxMDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3V1aWQvdjQuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"chevron-down":{"width":1792,"height":1792,"paths":[{"d":"M1683 808l-742 741q-19 19-45 19t-45-19l-742-741q-19-19-19-45.5t19-45.5l166-165q19-19 45-19t45 19l531 531 531-531q19-19 45-19t45 19l166 165q19 19 19 45.5t-19 45.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLWRvd24uanM/OWU3YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMseUtBQXlLLEdBQUciLCJmaWxlIjoiMTEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJjaGV2cm9uLWRvd25cIjp7XCJ3aWR0aFwiOjE3OTIsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTE2ODMgODA4bC03NDIgNzQxcS0xOSAxOS00NSAxOXQtNDUtMTlsLTc0Mi03NDFxLTE5LTE5LTE5LTQ1LjV0MTktNDUuNWwxNjYtMTY1cTE5LTE5IDQ1LTE5dDQ1IDE5bDUzMSA1MzEgNTMxLTUzMXExOS0xOSA0NS0xOXQ0NSAxOWwxNjYgMTY1cTE5IDE5IDE5IDQ1LjV0LTE5IDQ1LjV6XCJ9XX19KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLWRvd24uanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"chevron-left":{"width":1280,"height":1792,"paths":[{"d":"M1171 301l-531 531 531 531q19 19 19 45t-19 45l-166 166q-19 19-45 19t-45-19l-742-742q-19-19-19-45t19-45l742-742q19-19 45-19t45 19l166 166q19 19 19 45t-19 45z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLWxlZnQuanM/MTk3ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMsbUtBQW1LLEdBQUciLCJmaWxlIjoiMTExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJjaGV2cm9uLWxlZnRcIjp7XCJ3aWR0aFwiOjEyODAsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTExNzEgMzAxbC01MzEgNTMxIDUzMSA1MzFxMTkgMTkgMTkgNDV0LTE5IDQ1bC0xNjYgMTY2cS0xOSAxOS00NSAxOXQtNDUtMTlsLTc0Mi03NDJxLTE5LTE5LTE5LTQ1dDE5LTQ1bDc0Mi03NDJxMTktMTkgNDUtMTl0NDUgMTlsMTY2IDE2NnExOSAxOSAxOSA0NXQtMTkgNDV6XCJ9XX19KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLWxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"chevron-right":{"width":1280,"height":1792,"paths":[{"d":"M1107 877l-742 742q-19 19-45 19t-45-19l-166-166q-19-19-19-45t19-45l531-531-531-531q-19-19-19-45t19-45l166-166q19-19 45-19t45 19l742 742q19 19 19 45t-19 45z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLXJpZ2h0LmpzPzFhOWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQSx1RUFBZSxpQkFBaUIscUNBQXFDLGtLQUFrSyxHQUFHIiwiZmlsZSI6IjExMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi52dWUnXG5cbkljb24ucmVnaXN0ZXIoe1wiY2hldnJvbi1yaWdodFwiOntcIndpZHRoXCI6MTI4MCxcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMTEwNyA4NzdsLTc0MiA3NDJxLTE5IDE5LTQ1IDE5dC00NS0xOWwtMTY2LTE2NnEtMTktMTktMTktNDV0MTktNDVsNTMxLTUzMS01MzEtNTMxcS0xOS0xOS0xOS00NXQxOS00NWwxNjYtMTY2cTE5LTE5IDQ1LTE5dDQ1IDE5bDc0MiA3NDJxMTkgMTkgMTkgNDV0LTE5IDQ1elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvY2hldnJvbi1yaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"chevron-up":{"width":1792,"height":1792,"paths":[{"d":"M1683 1331l-166 165q-19 19-45 19t-45-19l-531-531-531 531q-19 19-45 19t-45-19l-166-165q-19-19-19-45.5t19-45.5l742-741q19-19 45-19t45 19l742 741q19 19 19 45.5t-19 45.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGV2cm9uLXVwLmpzPzk4YjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQSx1RUFBZSxjQUFjLHFDQUFxQyw2S0FBNkssR0FBRyIsImZpbGUiOiIxMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcImNoZXZyb24tdXBcIjp7XCJ3aWR0aFwiOjE3OTIsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTE2ODMgMTMzMWwtMTY2IDE2NXEtMTkgMTktNDUgMTl0LTQ1LTE5bC01MzEtNTMxLTUzMSA1MzFxLTE5IDE5LTQ1IDE5dC00NS0xOWwtMTY2LTE2NXEtMTktMTktMTktNDUuNXQxOS00NS41bDc0Mi03NDFxMTktMTkgNDUtMTl0NDUgMTlsNzQyIDc0MXExOSAxOSAxOSA0NS41dC0xOSA0NS41elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvY2hldnJvbi11cC5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(95);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"cd21c31e\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlPzAzNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBc007QUFDdE07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMDYwYzA1MjBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vTW9kYWwudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJjZDIxYzMxZVwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTA2MGMwNTIwXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(96);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"666b599f\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlPzQwNDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBcU07QUFDck07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzMxNjNiYzNcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9Db250cm9scy52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjY2NmI1OTlmXCIsIGNvbnRlbnQsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMzMxNjNiYzNcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL0NvbnRyb2xzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(97);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"6cfe16be\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvVGFzay52dWU/NjczOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLG9DQUEyTTtBQUMzTTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi00YWU4MTAwMFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1Rhc2sudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI2Y2ZlMTZiZVwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTRhZTgxMDAwXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zaWRlYmFycy9UYXNrLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(98);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"7ee7790d\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/YTMwNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLG9DQUFxTTtBQUNyTTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi00ZjQ5MWZkZlxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1NpZGViYXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI3ZWU3NzkwZFwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTRmNDkxZmRmXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9TaWRlYmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(99);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"7da17536\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT9lNzlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0Esb0NBQTJNO0FBQzNNO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTc2YmYxMWExXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2VsZWN0aW9uLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiN2RhMTc1MzZcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi03NmJmMTFhMVwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(100);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"88ffdace\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL0hlbHAudnVlPzM3MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxxQ0FBMk07QUFDM007QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtODg5MGJlZTZcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9IZWxwLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiODhmZmRhY2VcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi04ODkwYmVlNlwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL0hlbHAudnVlXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(101);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"7d601987\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT8yYzhmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EscUNBQXNNO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWFhZDQxYjQyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1ZpZXdlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjdkNjAxOTg3XCIsIGNvbnRlbnQsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYWFkNDFiNDJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(102);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"3a1cd613\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbW9kYWxzL01ldGFkYXRhLnZ1ZT82YTU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EscUNBQTJNO0FBQzNNO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWVmOWMyOTBhXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vTWV0YWRhdGEudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIzYTFjZDYxM1wiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWVmOWMyOTBhXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tb2RhbHMvTWV0YWRhdGEudnVlXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(103);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(5)(\"440d0959\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlP2RjY2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxxQ0FBcU07QUFDck07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/bWluaW1pemUhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wNjY1OTcwYlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9JY29uLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI0NDBkMDk1OVwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyP21pbmltaXplIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTA2NjU5NzBiXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9+L3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWVcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanM/ODFlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export Store */\n/* unused harmony export mapState */\n/* unused harmony export mapMutations */\n/* unused harmony export mapGetters */\n/* unused harmony export mapActions */\n/**\n * vuex v2.3.0\n * (c) 2017 Evan You\n * @license MIT\n */\nvar applyMixin = function (Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n};\n\nvar devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\n\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime;\n  this._children = Object.create(null);\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors$1 = { namespaced: {} };\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors$1 );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  var this$1 = this;\n\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false);\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, function (rawModule, key) {\n      this$1.register([key], rawModule, false);\n    });\n  }\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update(this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  var parent = this.get(path.slice(0, -1));\n  var newModule = new Module(rawModule, runtime);\n  parent.addChild(path[path.length - 1], newModule);\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  if (!parent.getChild(key).runtime) { return }\n\n  parent.removeChild(key);\n};\n\nfunction update (targetModule, newModule) {\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        console.warn(\n          \"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" +\n          'manual reload is needed'\n        );\n        return\n      }\n      update(targetModule.getChild(key), newModule.modules[key]);\n    }\n  }\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n\n  var state = options.state; if ( state === void 0 ) state = {};\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  };\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); });\n};\n\nvar prototypeAccessors = { state: {} };\n\nprototypeAccessors.state.get = function () {\n  return this._vm._data.$$state\n};\n\nprototypeAccessors.state.set = function (v) {\n  assert(false, \"Use store.replaceState() to explicit replace store state.\");\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    console.error((\"[vuex] unknown mutation type: \" + type));\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload);\n    });\n  });\n  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });\n\n  if (options && options.silent) {\n    console.warn(\n      \"[vuex] mutation type: \" + type + \". Silent option has been removed. \" +\n      'Use the filter functionality in the vue-devtools'\n    );\n  }\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var entry = this._actions[type];\n  if (!entry) {\n    console.error((\"[vuex] unknown action type: \" + type));\n    return\n  }\n  return entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload)\n};\n\nStore.prototype.subscribe = function subscribe (fn) {\n  var subs = this._subscribers;\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  }\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  assert(typeof getter === 'function', \"store.watch only accepts a function.\");\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule) {\n  if (typeof path === 'string') { path = [path]; }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path));\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path]; }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors );\n\nfunction resetStore (store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM (store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () { return fn(store); };\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () { return oldVm.$destroy(); });\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var namespacedType = namespace + key;\n    registerAction(store, namespacedType, action, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._actions[type]) {\n          console.error((\"[vuex] unknown local action type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._mutations[type]) {\n          console.error((\"[vuex] unknown local mutation type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? function () { return store.getters; }\n        : function () { return makeLocalGetters(store, namespace); }\n    },\n    state: {\n      get: function () { return getNestedState(store.state, path); }\n    }\n  });\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  var gettersProxy = {};\n\n  var splitPos = namespace.length;\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) { return }\n\n    // extract local getter type\n    var localType = type.slice(splitPos);\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function () { return store.getters[type]; },\n      enumerable: true\n    });\n  });\n\n  return gettersProxy\n}\n\nfunction registerMutation (store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler (payload) {\n    handler(local.state, payload);\n  });\n}\n\nfunction registerAction (store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler (payload, cb) {\n    var res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err\n      })\n    } else {\n      return res\n    }\n  });\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    console.error((\"[vuex] duplicate getter key: \" + type));\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  };\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, function () {\n    assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\");\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce(function (state, key) { return state[key]; }, state)\n    : state\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  assert(typeof type === 'string', (\"Expects string as the type, but found \" + (typeof type) + \".\"));\n\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    );\n    return\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue);\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {\n        return\n      }\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n      if (!(val in this.$store.getters)) {\n        console.error((\"[vuex] unknown getter: \" + val));\n        return\n      }\n      return this.$store.getters[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {\n        return\n      }\n      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map)\n  }\n}\n\nfunction getModuleByNamespace (store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (!module) {\n    console.error((\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace));\n  }\n  return module\n}\n\nvar index_esm = {\n  Store: Store,\n  install: install,\n  version: '2.3.0',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (index_esm);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWV4L2Rpc3QvdnVleC5lc20uanM/MjBkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQixJQUFJLHlCQUF5QjtBQUN4RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMEJBQTBCLEVBQUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsZUFBZTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxxQkFBcUIsRUFBRSxFQUFFO0FBQ2pFLDJDQUEyQyxVQUFVLDBCQUEwQixFQUFFLEVBQUU7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUUiLCJmaWxlIjoiMTI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB2dWV4IHYyLjMuMFxuICogKGMpIDIwMTcgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgYXBwbHlNaXhpbiA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIHZhciB1c2VzSW5pdCA9IFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xO1xuICAgIFZ1ZS5taXhpbih1c2VzSW5pdCA/IHsgaW5pdDogdnVleEluaXQgfSA6IHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdmVycmlkZSBpbml0IGFuZCBpbmplY3QgdnVleCBpbml0IHByb2NlZHVyZVxuICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdmFyIF9pbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBvcHRpb25zLmluaXQgPSBvcHRpb25zLmluaXRcbiAgICAgICAgPyBbdnVleEluaXRdLmNvbmNhdChvcHRpb25zLmluaXQpXG4gICAgICAgIDogdnVleEluaXQ7XG4gICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVnVleCBpbml0IGhvb2ssIGluamVjdGVkIGludG8gZWFjaCBpbnN0YW5jZXMgaW5pdCBob29rcyBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiB2dWV4SW5pdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHN0b3JlIGluamVjdGlvblxuICAgIGlmIChvcHRpb25zLnN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldnRvb2xIb29rID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBpdGVtIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogYnkgc2Vjb25kIGFyZ3VtZW50IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7Kn1cbiAqL1xuLyoqXG4gKiBEZWVwIGNvcHkgdGhlIGdpdmVuIG9iamVjdCBjb25zaWRlcmluZyBjaXJjdWxhciBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGl0cyBjb3BpZXMuXG4gKiBJZiBpdCBkZXRlY3RzIGNpcmN1bGFyIHN0cnVjdHVyZSwgdXNlIGNhY2hlZCBjb3B5IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2FjaGVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fcmF3TW9kdWxlID0gcmF3TW9kdWxlO1xuICB2YXIgcmF3U3RhdGUgPSByYXdNb2R1bGUuc3RhdGU7XG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDoge30gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yb290ID0gbmV3IE1vZHVsZShyYXdSb290TW9kdWxlLCBmYWxzZSk7XG5cbiAgLy8gcmVnaXN0ZXIgYWxsIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdSb290TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3JFYWNoVmFsdWUocmF3Um9vdE1vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3TW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3Rlcihba2V5XSwgcmF3TW9kdWxlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG1vZHVsZSwga2V5KSB7XG4gICAgcmV0dXJuIG1vZHVsZS5nZXRDaGlsZChrZXkpXG4gIH0sIHRoaXMucm9vdClcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uIGdldE5hbWVzcGFjZSAocGF0aCkge1xuICB2YXIgbW9kdWxlID0gdGhpcy5yb290O1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgbW9kdWxlID0gbW9kdWxlLmdldENoaWxkKGtleSk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSArIChtb2R1bGUubmFtZXNwYWNlZCA/IGtleSArICcvJyA6ICcnKVxuICB9LCAnJylcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxIChyYXdSb290TW9kdWxlKSB7XG4gIHVwZGF0ZSh0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlICh0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbdnVleF0gdHJ5aW5nIHRvIGFkZCBhIG5ldyBtb2R1bGUgJ1wiICsga2V5ICsgXCInIG9uIGhvdCByZWxvYWRpbmcsIFwiICtcbiAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLCBuZXdNb2R1bGUubW9kdWxlc1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgYXNzZXJ0KHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJywgXCJ2dWV4IHJlcXVpcmVzIGEgUHJvbWlzZSBwb2x5ZmlsbCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuXG4gIHZhciBzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7IGlmICggc3RhdGUgPT09IHZvaWQgMCApIHN0YXRlID0ge307XG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmNvbmNhdChkZXZ0b29sUGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEpOyB9KTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdm0uX2RhdGEuJCRzdGF0ZVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGVudHJ5Lmxlbmd0aCA+IDFcbiAgICA/IFByb21pc2UuYWxsKGVudHJ5Lm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihwYXlsb2FkKTsgfSkpXG4gICAgOiBlbnRyeVswXShwYXlsb2FkKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoZm4pIHtcbiAgdmFyIHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICByZXR1cm4gdGhpcy5fd2F0Y2hlclZNLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXIodGhpcyQxLnN0YXRlLCB0aGlzJDEuZ2V0dGVycyk7IH0sIGNiLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuX3ZtLl9kYXRhLiQkc3RhdGUgPSBzdGF0ZTtcbiAgfSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpO1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHRoaXMuc3RhdGUsIHBhdGgsIHRoaXMuX21vZHVsZXMuZ2V0KHBhdGgpKTtcbiAgLy8gcmVzZXQgc3RvcmUgdG8gdXBkYXRlIGdldHRlcnMuLi5cbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHRoaXMuc3RhdGUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlIChwYXRoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oc3RvcmUpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZS5nZXR0ZXJzLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3ZtW2tleV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlIC8vIGZvciBsb2NhbCBnZXR0ZXJzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHVzZSBhIFZ1ZSBpbnN0YW5jZSB0byBzdG9yZSB0aGUgc3RhdGUgdHJlZVxuICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YToge1xuICAgICAgJCRzdGF0ZTogc3RhdGVcbiAgICB9LFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICB9KTtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgdm1cbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFZtKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFZtLl9kYXRhLiQkc3RhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTW9kdWxlIChzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLCBtb2R1bGUsIGhvdCkge1xuICB2YXIgaXNSb290ID0gIXBhdGgubGVuZ3RoO1xuICB2YXIgbmFtZXNwYWNlID0gc3RvcmUuX21vZHVsZXMuZ2V0TmFtZXNwYWNlKHBhdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7XG4gICAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIG1vZHVsZU5hbWUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgVnVlLnNldChwYXJlbnRTdGF0ZSwgbW9kdWxlTmFtZSwgbW9kdWxlLnN0YXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJBY3Rpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBhY3Rpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyR2V0dGVyKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgZ2V0dGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBtYWtlIGxvY2FsaXplZCBkaXNwYXRjaCwgY29tbWl0LCBnZXR0ZXJzIGFuZCBzdGF0ZVxuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnO1xuXG4gIHZhciBsb2NhbCA9IHtcbiAgICBkaXNwYXRjaDogbm9OYW1lc3BhY2UgPyBzdG9yZS5kaXNwYXRjaCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKCFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSB2bSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnZXR0ZXJzUHJveHlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIobG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQsIGNiKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIoe1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCwgY2IpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBsb2NhbC5zdGF0ZSwgLy8gbG9jYWwgc3RhdGVcbiAgICAgIGxvY2FsLmdldHRlcnMsIC8vIGxvY2FsIGdldHRlcnNcbiAgICAgIHN0b3JlLnN0YXRlLCAvLyByb290IHN0YXRlXG4gICAgICBzdG9yZS5nZXR0ZXJzIC8vIHJvb3QgZ2V0dGVyc1xuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgc3RvcmUuX3ZtLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLiQkc3RhdGUgfSwgZnVuY3Rpb24gKCkge1xuICAgIGFzc2VydChzdG9yZS5fY29tbWl0dGluZywgXCJEbyBub3QgbXV0YXRlIHZ1ZXggc3RvcmUgc3RhdGUgb3V0c2lkZSBtdXRhdGlvbiBoYW5kbGVycy5cIik7XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsIChcIkV4cGVjdHMgc3RyaW5nIGFzIHRoZSB0eXBlLCBidXQgZm91bmQgXCIgKyAodHlwZW9mIHR5cGUpICsgXCIuXCIpKTtcblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG4vLyBhdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xufVxuXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZE11dGF0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkQWN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmRpc3BhdGNoLmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmICghbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxudmFyIGluZGV4X2VzbSA9IHtcbiAgU3RvcmU6IFN0b3JlLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICB2ZXJzaW9uOiAnMi4zLjAnLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zXG59O1xuXG5leHBvcnQgeyBTdG9yZSwgbWFwU3RhdGUsIG1hcE11dGF0aW9ucywgbWFwR2V0dGVycywgbWFwQWN0aW9ucyB9O2V4cG9ydCBkZWZhdWx0IGluZGV4X2VzbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVleC9kaXN0L3Z1ZXguZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")}]);