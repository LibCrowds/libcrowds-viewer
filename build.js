!function(g){function I(e){if(n[e])return n[e].exports;var t=n[e]={i:e,l:!1,exports:{}};return g[e].call(t.exports,t,t.exports,I),t.l=!0,t.exports}var n={};I.m=g,I.c=n,I.i=function(g){return g},I.d=function(g,n,e){I.o(g,n)||Object.defineProperty(g,n,{configurable:!1,enumerable:!0,get:e})},I.n=function(g){var n=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(n,"a",n),n},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="/dist/",I(I.s=22)}([function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(92)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(62),\n  /* template */\n  __webpack_require__(35),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlPzIxNGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQXNMOztBQUV0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP21pbmltaXplIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMDY2NTk3MGJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vSWNvbi52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0ljb24udnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTA2NjU5NzBiXFxcIn0hLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vSWNvbi52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar bind = __webpack_require__(15);\nvar isBuffer = __webpack_require__(76);\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object' && !isArray(obj)) {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvdXRpbHMuanM/NmJmMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmICFpc0FycmF5KG9iaikpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval('/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join("");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === "string")\r\n\t\t\tmodules = [[null, modules, ""]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === "number")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz80MmNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(94)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanM/MTY1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(1);\nvar normalizeHeaderName = __webpack_require__(59);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(11);\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(11);\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvZGVmYXVsdHMuanM/ZDNiNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiK0NBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvZGVmYXVsdHMuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return store; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuex__ = __webpack_require__(95);\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */].use(__WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */]);\n\nvar store = new __WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */].Store({\n  state: {\n    viewer: {}\n  },\n\n  mutations: {\n    SET_ITEM: function SET_ITEM(state, obj) {\n      state[obj.key] = obj.value;\n    },\n    DEL_ITEM: function DEL_ITEM(state, obj) {\n      state[obj.key].splice(obj.index, 1);\n    },\n    ADD_ITEM: function ADD_ITEM(state, obj) {\n      state[obj.key].unshift(obj.value);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3N0b3JlLmpzP2EyNTYiXSwibmFtZXMiOlsiVnVlIiwidXNlIiwic3RvcmUiLCJWdWV4IiwiU3RvcmUiLCJzdGF0ZSIsInZpZXdlciIsIm11dGF0aW9ucyIsIlNFVF9JVEVNIiwib2JqIiwia2V5IiwidmFsdWUiLCJERUxfSVRFTSIsInNwbGljZSIsImluZGV4IiwiQUREX0lURU0iLCJ1bnNoaWZ0Il0sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBOztBQUVBLG9EQUFBQSxDQUFJQyxHQUFKLENBQVEscURBQVI7O0FBRU8sSUFBTUMsUUFBUSxJQUFJLHFEQUFBQyxDQUFLQyxLQUFULENBQWU7QUFDbENDLFNBQU87QUFDTEMsWUFBUTtBQURILEdBRDJCOztBQUtsQ0MsYUFBVztBQUNUQyxjQUFVLGtCQUFDSCxLQUFELEVBQVFJLEdBQVIsRUFBZ0I7QUFDeEJKLFlBQU1JLElBQUlDLEdBQVYsSUFBaUJELElBQUlFLEtBQXJCO0FBQ0QsS0FIUTtBQUlUQyxjQUFVLGtCQUFDUCxLQUFELEVBQVFJLEdBQVIsRUFBZ0I7QUFDeEJKLFlBQU1JLElBQUlDLEdBQVYsRUFBZUcsTUFBZixDQUFzQkosSUFBSUssS0FBMUIsRUFBaUMsQ0FBakM7QUFDRCxLQU5RO0FBT1RDLGNBQVUsa0JBQUNWLEtBQUQsRUFBUUksR0FBUixFQUFnQjtBQUN4QkosWUFBTUksSUFBSUMsR0FBVixFQUFlTSxPQUFmLENBQXVCUCxJQUFJRSxLQUEzQjtBQUNEO0FBVFE7QUFMdUIsQ0FBZixDQUFkIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnXG5cblZ1ZS51c2UoVnVleClcblxuZXhwb3J0IGNvbnN0IHN0b3JlID0gbmV3IFZ1ZXguU3RvcmUoe1xuICBzdGF0ZToge1xuICAgIHZpZXdlcjoge31cbiAgfSxcblxuICBtdXRhdGlvbnM6IHtcbiAgICBTRVRfSVRFTTogKHN0YXRlLCBvYmopID0+IHtcbiAgICAgIHN0YXRlW29iai5rZXldID0gb2JqLnZhbHVlXG4gICAgfSxcbiAgICBERUxfSVRFTTogKHN0YXRlLCBvYmopID0+IHtcbiAgICAgIHN0YXRlW29iai5rZXldLnNwbGljZShvYmouaW5kZXgsIDEpXG4gICAgfSxcbiAgICBBRERfSVRFTTogKHN0YXRlLCBvYmopID0+IHtcbiAgICAgIHN0YXRlW29iai5rZXldLnVuc2hpZnQob2JqLnZhbHVlKVxuICAgIH1cbiAgfVxufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvc3RvcmUuanMiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join("");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === "string")\r\n\t\t\tmodules = [[null, modules, ""]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === "number")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(87)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(65),\n  /* template */\n  __webpack_require__(34),\n  /* scopeId */\n  "data-v-060c0520",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlP2Y2ZWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQXlLOztBQUV6SztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMDYwYzA1MjBcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9Nb2RhbC52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL01vZGFsLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wNjBjMDUyMFxcXCJ9IS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL01vZGFsLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi0wNjBjMDUyMFwiLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(45);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9pbmRleC5qcz9iNmUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\nvar settle = __webpack_require__(51);\nvar buildURL = __webpack_require__(54);\nvar parseHeaders = __webpack_require__(60);\nvar isURLSameOrigin = __webpack_require__(58);\nvar createError = __webpack_require__(14);\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(53);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (\"production\" !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(56);\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzP2Y5ZGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9heGlvcy9pc3N1ZXMvMjAxKVxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcz8yYWVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzP2YxN2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar enhanceError = __webpack_require__(50);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcz8zYjVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzPzA3ZjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"times-circle":{"width":1536,"height":1792,"paths":[{"d":"M1149 1122q0-26-19-45l-181-181 181-181q19-19 19-45 0-27-19-46l-90-90q-19-19-46-19-26 0-45 19l-181 181-181-181q-19-19-45-19-27 0-46 19l-90 90q-19 19-19 46 0 26 19 45l181 181-181 181q-19 19-19 45 0 27 19 46l90 90q19 19 46 19 26 0 45-19l181-181 181 181q19 19 45 19 27 0 46-19l90-90q19-19 19-46zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy90aW1lcy1jaXJjbGUuanM/MGEyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMsMmJBQTJiLEdBQUciLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcInRpbWVzLWNpcmNsZVwiOntcIndpZHRoXCI6MTUzNixcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMTE0OSAxMTIycTAtMjYtMTktNDVsLTE4MS0xODEgMTgxLTE4MXExOS0xOSAxOS00NSAwLTI3LTE5LTQ2bC05MC05MHEtMTktMTktNDYtMTktMjYgMC00NSAxOWwtMTgxIDE4MS0xODEtMTgxcS0xOS0xOS00NS0xOS0yNyAwLTQ2IDE5bC05MCA5MHEtMTkgMTktMTkgNDYgMCAyNiAxOSA0NWwxODEgMTgxLTE4MSAxODFxLTE5IDE5LTE5IDQ1IDAgMjcgMTkgNDZsOTAgOTBxMTkgMTkgNDYgMTkgMjYgMCA0NS0xOWwxODEtMTgxIDE4MSAxODFxMTkgMTkgNDUgMTkgMjcgMCA0Ni0xOWw5MC05MHExOS0xOSAxOS00NnpNMTUzNiA4OTZxMCAyMDktMTAzIDM4NS41dC0yNzkuNSAyNzkuNS0zODUuNSAxMDMtMzg1LjUtMTAzLTI3OS41LTI3OS41LTEwMy0zODUuNSAxMDMtMzg1LjUgMjc5LjUtMjc5LjUgMzg1LjUtMTAzIDM4NS41IDEwMyAyNzkuNSAyNzkuNSAxMDMgMzg1LjV6XCJ9XX19KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtYXdlc29tZS9pY29ucy90aW1lcy1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.3.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    } )); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (false) {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (false) {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.3.4';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (isUndef(value)) {\n    return ''\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((isDef(modifiers) && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^\x3c!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('--\x3e');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/\x3c!--([\\s\\S]*?)--\x3e/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (false\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    false\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, warn$3)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, warn$3)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (false) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}}\"\n}\n\nfunction genForScopedSlot (key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el)) +\n    '})'\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (false) {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(9)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUvZGlzdC92dWUuZXNtLmpzP2FlNjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRCxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFB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QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QjtBQUN6QjtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQsbUJBQW1CLDJCQUEyQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsK0JBQStCO0FBQzNELDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQWtEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0YsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyREFBMkQsMkJBQTJCLEVBQUU7QUFDeEYsS0FBSztBQUNMO0FBQ0EsMkRBQTJELDRCQUE0QixFQUFFO0FBQ3pGO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHNCQUFzQjs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCLEVBQUU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCLEVBQUU7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQ0FBMkMsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLGNBQWMsRUFBRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSwwQkFBMEIsRUFBRTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLDZDQUE2QywyQkFBMkIsRUFBRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkM7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjMuNFxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBwb3NzaWJsZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgIHJldHVybiBhID09PSBiXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChudWxsKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gKSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWUsXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlclxuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSAnJztcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGNoaWxkLmRhdGEgJiYgY2hpbGQuZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gY2hpbGQuZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZUhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHtcbiAga2V5OiAxLFxuICByZWY6IDEsXG4gIHNsb3Q6IDFcbn07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldIHx8IGNvbmZpZy5pc1Jlc2VydmVkQXR0cihrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJObyBnZXR0ZXIgZnVuY3Rpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICAvLyBpc0FycmF5IGhlcmVcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGlzQXJyYXlcbiAgICAgID8gaW5qZWN0XG4gICAgICA6IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCB7fSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGxpc3RlbmVyczogZGF0YS5vbiB8fCB7fSxcbiAgICBpbmplY3Rpb25zOiByZXNvbHZlSW5qZWN0KEN0b3Iub3B0aW9ucy5pbmplY3QsIGNvbnRleHQpLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB2bm9kZS5mdW5jdGlvbmFsT3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDErKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHBdO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgY3VycmVudCwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIGlmIChjYWNoZWROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjMuNCc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmKHZhbHVlKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChpc0RlZih2YWx1ZVtpXSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQgKyAnICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkgeyByZXMgKz0ga2V5ICsgJyAnOyB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiZcbiAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICApXG59XG5cbi8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgZHluYW1pY2FsbHkgY2hhbmdpbmcgdHlwZSBmb3IgPGlucHV0PlxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgaW5QcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluUHJlICYmXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuICAgICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHRhZylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGluUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgIGlmIChyZWYucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSkgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV0gOiBudWxsO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBuZXdTdGFydFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICFiYWlsZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwidmFyICQkZXhwID0gXCIgKyAobW9kZWxScy5leHApICsgXCIsICQkaWR4ID0gXCIgKyAobW9kZWxScy5pZHgpICsgXCI7XCIgK1xuICAgICAgXCJpZiAoIUFycmF5LmlzQXJyYXkoJCRleHApKXtcIiArXG4gICAgICAgIHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIgK1xuICAgICAgXCJlbHNleyQkZXhwLnNwbGljZSgkJGlkeCwgMSwgXCIgKyBhc3NpZ25tZW50ICsgXCIpfVwiXG4gIH1cbn1cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcbiAgICBpZHg6IHZhbC5zdWJzdHJpbmcoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgZHluYW1pY1R5cGUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPGlucHV0IDp0eXBlPVxcXCJcIiArIGR5bmFtaWNUeXBlICsgXCJcXFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OlxcblwiICtcbiAgICAgICAgXCJ2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBpbnB1dCB0eXBlcy4gVXNlIHYtaWYgYnJhbmNoZXMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlciB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBpZiAob25jZSQkMSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgdGVzdEVsO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICB0ZXN0RWwgPSB0ZXN0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBlbC5vcHRpb25zKTsgfSlcbiAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgZWwub3B0aW9ucyk7XG4gICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uc1tpXSksIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW92ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0JDEpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QkMS5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChleHByZXNzaW9uID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFszXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzKG5vZGUuaWZDb25kaXRpb25zLCBpc0luRm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIChjb25kaXRpb25CbG9ja3MsIGlzSW5Gb3IpIHtcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvbmRpdGlvbkJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG1hcmtTdGF0aWNSb290cyhjb25kaXRpb25CbG9ja3NbaV0uYmxvY2ssIGlzSW5Gb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcbiAgICAvLyAjNTMzMDogd2FybiBjbGljay5yaWdodCwgc2luY2UgcmlnaHQgY2xpY2tzIGRvIG5vdCBhY3R1YWxseSBmaXJlIGNsaWNrIGV2ZW50cy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbmFtZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLm1vZGlmaWVycyAmJiBoYW5kbGVyLm1vZGlmaWVycy5yaWdodFxuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJVc2UgXFxcImNvbnRleHRtZW51XFxcIiBpbnN0ZWFkIG9mIFxcXCJjbGljay5yaWdodFxcXCIgc2luY2UgcmlnaHQgY2xpY2tzIFwiICtcbiAgICAgICAgXCJkbyBub3QgYWN0dWFsbHkgZmlyZSBcXFwiY2xpY2tcXFwiIGV2ZW50cy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQzO1xudmFyIHRyYW5zZm9ybXMkMTtcbnZhciBkYXRhR2VuRm5zO1xudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxO1xudmFyIHN0YXRpY1JlbmRlckZucztcbnZhciBvbmNlQ291bnQ7XG52YXIgY3VycmVudE9wdGlvbnM7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuICB2YXIgcHJldlN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG4gIG9uY2VDb3VudCA9IDA7XG4gIGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgd2FybiQzID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0cmFuc2Zvcm1zJDEgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcbiAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgb25jZUNvdW50ID0gcHJldk9uY2VDb3VudDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbClcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMkMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDMoXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIixcIiArIChvbmNlQ291bnQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoZWwpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChjb25kaXRpb25zKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGVsLm9uY2UgPyBnZW5PbmNlKGVsKSA6IGdlbkVsZW1lbnQoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBtYXliZUNvbXBvbmVudChlbCkgJiYgZWwudGFnICE9PSAnc2xvdCcgJiYgZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5rZXlcbiAgKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgd2FybiQzKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCB3YXJuJDMpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHBsYXRmb3JtRGlyZWN0aXZlcyQxW2Rpci5uYW1lXSB8fCBiYXNlRGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgd2FybiQzKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHdhcm4kMygnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgY3VycmVudE9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKHNsb3RzKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSk7IH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbClcbiAgfVxuICByZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCkpICsgXCJ9fVwiXG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChjaGlsZHJlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG4gIHJldHVybiAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEoZWwudGFnKVxufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YShlbCkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG4gICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgdmFyIGZ1bmN0aW9uQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBjb21waWxlIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHRpcHMgPSBbXTtcbiAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCQkMSkge1xuICAgICAgKHRpcCQkMSA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID0gKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgfVxuICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcbiAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgfVxuICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICByZXR1cm4gY29tcGlsZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHZhciBsID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLmxlbmd0aDtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXMuc3RhdGljUmVuZGVyRm5zW2ldID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnN0YXRpY1JlbmRlckZuc1tpXSwgZm5HZW5FcnJvcnMpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0gPSByZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjb21waWxlVG9GdW5jdGlvbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDJcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKCh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUvZGlzdC92dWUuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_normalize_css__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_normalize_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_normalize_css__);\n\n\n\n/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__components_Viewer_vue___default.a);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL21haW4uanM/ZGQ2NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQSx5REFBZSw4REFBZiIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaWJjcm93ZHNWaWV3ZXIgZnJvbSAnLi9jb21wb25lbnRzL1ZpZXdlci52dWUnXG5pbXBvcnQgJ25vcm1hbGl6ZS5jc3MnXG5cbmV4cG9ydCBkZWZhdWx0IExpYmNyb3dkc1ZpZXdlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(42)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(21),\n  /* template */\n  __webpack_require__(37),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8zNWE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHNCQUFrSzs7QUFFbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDZlNzIwYjhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDZlNzIwYjhcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.3.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    } )); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (false) {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (false) {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.3.4';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (isUndef(value)) {\n    return ''\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((isDef(modifiers) && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^\x3c!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('--\x3e');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/\x3c!--([\\s\\S]*?)--\x3e/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (false\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    false\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, warn$3)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, warn$3)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (false) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}}\"\n}\n\nfunction genForScopedSlot (key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el)) +\n    '})'\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (false) {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(9)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanM/NjVkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUNBQWlDLEVBQUU7QUFDckYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjOztBQUVwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUMsd0JBQXdCLEVBQUU7QUFDakUsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFVBQVU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFx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QUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RCxtQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBNkM7QUFDOUU7QUFDQTtBQUNBLDZDQUE2Qyw0Q0FBNEM7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDJEQUEyRCwyQkFBMkIsRUFBRTtBQUN4RixLQUFLO0FBQ0w7QUFDQSwyREFBMkQsNEJBQTRCLEVBQUU7QUFDekY7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FB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bUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkVBQTZFO0FBQzdFLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEyQjtBQUMzQixlQUFlLHVDQUF1QztBQUN0RCxZQUFZLGtFQUFrRTtBQUM5RSxNQUFNLEtBQUssMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxzQkFBc0IsK0NBQStDO0FBQ3JFLGlEQUFpRDs7QUFFakQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEIsRUFBRTtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0IsRUFBRTtBQUM5RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMscUNBQXFDOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJDQUEyQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsY0FBYyxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLDBCQUEwQixFQUFFO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixFQUFFO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QixFQUFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixHQUFHLElBQUk7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuMy40XG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSApKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gRE9NIG5vZGVzIChwcmV2ZW50cyBsZWFrKVxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgaWYgKHRoaXMudXNlcikge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIHBvcFRhcmdldCgpO1xuICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cbn1cblxudmFyIGlzUmVzZXJ2ZWRQcm9wID0ge1xuICBrZXk6IDEsXG4gIHJlZjogMSxcbiAgc2xvdDogMVxufTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0gfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk5vIGdldHRlciBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICAgIGdldHRlciA9IG5vb3A7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3Bcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMSsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBjdXJyZW50LCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgaWYgKGNhY2hlZE5vZGUgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMy40JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKGlzVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICB2YXIgcmVzID0gJyc7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGlzRGVmKHZhbHVlW2ldKSkge1xuICAgICAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZikpIHtcbiAgICAgICAgaWYgKHJlZi5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXG4gICAgKTtcbiAgfVxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ2YXIgJCRleHAgPSBcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgJCRpZHggPSBcIiArIChtb2RlbFJzLmlkeCkgKyBcIjtcIiArXG4gICAgICBcImlmICghQXJyYXkuaXNBcnJheSgkJGV4cCkpe1wiICtcbiAgICAgICAgdmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQgKyBcIn1cIiArXG4gICAgICBcImVsc2V7JCRleHAuc3BsaWNlKCQkaWR4LCAxLCBcIiArIGFzc2lnbm1lbnQgKyBcIil9XCJcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGMpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmICgoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB8fCBlbG0udHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtsZXkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gIGFkZENsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0JyB8fCBlbC50eXBlID09PSAncGFzc3dvcmQnKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZzsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xuZnVuY3Rpb24gc2hvdWxkRGVjb2RlIChjb250ZW50LCBlbmNvZGVkKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBhPVxcXCJcIiArIGNvbnRlbnQgKyBcIlxcXCI+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoZW5jb2RlZCkgPiAwXG59XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbn1cblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBzaW5nbGVBdHRySWRlbnRpZmllciA9IC8oW15cXHNcIic8Pi89XSspLztcbnZhciBzaW5nbGVBdHRyQXNzaWduID0gLyg/Oj0pLztcbnZhciBzaW5nbGVBdHRyVmFsdWVzID0gW1xuICAvLyBhdHRyIHZhbHVlIGRvdWJsZSBxdW90ZXNcbiAgL1wiKFteXCJdKilcIisvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgc2luZ2xlIHF1b3Rlc1xuICAvJyhbXiddKiknKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBubyBxdW90ZXNcbiAgLyhbXlxcc1wiJz08PmBdKykvLnNvdXJjZVxuXTtcbnZhciBhdHRyaWJ1dGUgPSBuZXcgUmVnRXhwKFxuICAnXlxcXFxzKicgKyBzaW5nbGVBdHRySWRlbnRpZmllci5zb3VyY2UgK1xuICAnKD86XFxcXHMqKCcgKyBzaW5nbGVBdHRyQXNzaWduLnNvdXJjZSArICcpJyArXG4gICdcXFxccyooPzonICsgc2luZ2xlQXR0clZhbHVlcy5qb2luKCd8JykgKyAnKSk/J1xuKTtcblxuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXG4vLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xudmFyIHFuYW1lQ2FwdHVyZSA9ICcoKD86JyArIG5jbmFtZSArICdcXFxcOik/JyArIG5jbmFtZSArICcpJztcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKCdePCcgKyBxbmFtZUNhcHR1cmUpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKCdePFxcXFwvJyArIHFuYW1lQ2FwdHVyZSArICdbXj5dKj4nKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG52YXIgY29tbWVudCA9IC9ePCEtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMCk7L2c7XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QkMSA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QkMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdCQxLmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8IHRhZ05hbWUgPT09ICdodG1sJyAmJiBsYXN0VGFnID09PSAnaGVhZCcgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4O1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14sXSopLChbXixdKikoPzosKFteLF0qKSk/XFwpLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9O1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhYXR0cnMubGVuZ3RoO1xuXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMl0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3Mobm9kZS5pZkNvbmRpdGlvbnMsIGlzSW5Gb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3MgKGNvbmRpdGlvbkJsb2NrcywgaXNJbkZvcikge1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gY29uZGl0aW9uQmxvY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbWFya1N0YXRpY1Jvb3RzKGNvbmRpdGlvbkJsb2Nrc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW25hbWVdO1xuICAgIC8vICM1MzMwOiB3YXJuIGNsaWNrLnJpZ2h0LCBzaW5jZSByaWdodCBjbGlja3MgZG8gbm90IGFjdHVhbGx5IGZpcmUgY2xpY2sgZXZlbnRzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBuYW1lID09PSAnY2xpY2snICYmXG4gICAgICBoYW5kbGVyICYmIGhhbmRsZXIubW9kaWZpZXJzICYmIGhhbmRsZXIubW9kaWZpZXJzLnJpZ2h0XG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlVzZSBcXFwiY29udGV4dG1lbnVcXFwiIGluc3RlYWQgb2YgXFxcImNsaWNrLnJpZ2h0XFxcIiBzaW5jZSByaWdodCBjbGlja3MgXCIgK1xuICAgICAgICBcImRvIG5vdCBhY3R1YWxseSBmaXJlIFxcXCJjbGlja1xcXCIgZXZlbnRzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcikpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIHJldHVybiBpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgID8gaGFuZGxlci52YWx1ZVxuICAgICAgOiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwiKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIgYWxpYXMgPSBrZXlDb2Rlc1trZXldO1xuICByZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyAoYWxpYXMgPyAnLCcgKyBKU09OLnN0cmluZ2lmeShhbGlhcykgOiAnJykgKyBcIilcIilcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDM7XG52YXIgdHJhbnNmb3JtcyQxO1xudmFyIGRhdGFHZW5GbnM7XG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzJDE7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDE7XG52YXIgc3RhdGljUmVuZGVyRm5zO1xudmFyIG9uY2VDb3VudDtcbnZhciBjdXJyZW50T3B0aW9ucztcblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICAvLyBzYXZlIHByZXZpb3VzIHN0YXRpY1JlbmRlckZucyBzbyBnZW5lcmF0ZSBjYWxscyBjYW4gYmUgbmVzdGVkXG4gIHZhciBwcmV2U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuICB2YXIgY3VycmVudFN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucyA9IFtdO1xuICB2YXIgcHJldk9uY2VDb3VudCA9IG9uY2VDb3VudDtcbiAgb25jZUNvdW50ID0gMDtcbiAgY3VycmVudE9wdGlvbnMgPSBvcHRpb25zO1xuICB3YXJuJDMgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRyYW5zZm9ybXMkMSA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICBkYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHBsYXRmb3JtRGlyZWN0aXZlcyQxID0gb3B0aW9ucy5kaXJlY3RpdmVzIHx8IHt9O1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCkgOiAnX2MoXCJkaXZcIiknO1xuICBzdGF0aWNSZW5kZXJGbnMgPSBwcmV2U3RhdGljUmVuZGVyRm5zO1xuICBvbmNlQ291bnQgPSBwcmV2T25jZUNvdW50O1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogY3VycmVudFN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbClcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEoZWwpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtcyQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gdHJhbnNmb3JtcyQxW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMyhcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbClcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwiLFwiICsgKG9uY2VDb3VudCsrKSArIChrZXkgPyAoXCIsXCIgKyBrZXkpIDogXCJcIikgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChlbCkge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpKVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKGNvbmRpdGlvbnMpIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gZWwub25jZSA/IGdlbk9uY2UoZWwpIDogZ2VuRWxlbWVudChlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKGVsKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIG1heWJlQ29tcG9uZW50KGVsKSAmJiBlbC50YWcgIT09ICdzbG90JyAmJiBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLmtleVxuICApIHtcbiAgICB3YXJuJDMoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBkYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCB3YXJuJDMpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHdhcm4kMykpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cykpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gcGxhdGZvcm1EaXJlY3RpdmVzJDFbZGlyLm5hbWVdIHx8IGJhc2VEaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCB3YXJuJDMpO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgd2FybiQzKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBjdXJyZW50T3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoc2xvdHMpIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldKTsgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsKVxuICB9XG4gIHJldHVybiBcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsKSkgKyBcIn19XCJcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoZWwsIGNoZWNrU2tpcCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCQxKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbikgOiAwO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKGNoaWxkcmVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBvbmVudCAoZWwpIHtcbiAgcmV0dXJuICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMShlbC50YWcpXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChjb21wb25lbnROYW1lLCBlbCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhKGVsKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICB2YXIgZnVuY3Rpb25Db21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdGlwcyA9IFtdO1xuICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwJCQxKSB7XG4gICAgICAodGlwJCQxID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICB9XG4gICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgIHJldHVybiBjb21waWxlZFxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldLCBmbkdlbkVycm9ycyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSA9IHJlcylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGlsZTogY29tcGlsZSxcbiAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNvbXBpbGVUb0Z1bmN0aW9uc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlL2Rpc3QvdnVlLmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      options: {},\n      baseUrl: 'https://api.bl.uk/image/iiif',\n      tileId: 'ark:/81055/vdc_100022589157.0x000005',\n      manifest: 'https://api.bl.uk/metadata/iiif/ark:/81055/vdc_100022589158.0x000002/manifest.json'\n    };\n  },\n\n\n  methods: {\n    handleConfirm: function handleConfirm(obj) {\n      var jsonStr = JSON.stringify(obj, null, 2);\n      var msg = 'Selections confirmed:\\n\\n' + jsonStr;\n      alert(msg);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQXBwLnZ1ZT9jZDc2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBYUE7d0JBRUE7O2VBRUE7ZUFDQTtjQUNBO2dCQUVBO0FBTEE7QUFPQTs7OzsrQ0FFQTs4Q0FDQTs4Q0FDQTtZQUNBO0FBRUE7QUFOQTtBQVZBIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGlkPVwiYXBwXCI+XG4gICAgPGxjLXZpZXdlclxuICAgICAgOm9wdGlvbnM9XCJvcHRpb25zXCJcbiAgICAgIDpiYXNlVXJsPVwiYmFzZVVybFwiXG4gICAgICA6dGlsZUlkPVwidGlsZUlkXCJcbiAgICAgIDptYW5pZmVzdD1cIm1hbmlmZXN0XCJcbiAgICAgIEBjb25maXJtPVwiaGFuZGxlQ29uZmlybVwiPlxuICAgIDwvbGMtdmlld2VyPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIGJhc2VVcmw6ICdodHRwczovL2FwaS5ibC51ay9pbWFnZS9paWlmJyxcbiAgICAgIHRpbGVJZDogJ2FyazovODEwNTUvdmRjXzEwMDAyMjU4OTE1Ny4weDAwMDAwNScsXG4gICAgICBtYW5pZmVzdDogJ2h0dHBzOi8vYXBpLmJsLnVrL21ldGFkYXRhL2lpaWYvYXJrOi84MTA1NS92ZGNfMTAwMDIyNTg5MTU4LjB4MDAwMDAyL21hbmlmZXN0Lmpzb24nXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVDb25maXJtIChvYmopIHtcbiAgICAgIGNvbnN0IGpzb25TdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpXG4gICAgICBjb25zdCBtc2cgPSBgU2VsZWN0aW9ucyBjb25maXJtZWQ6XFxuXFxuJHtqc29uU3RyfWBcbiAgICAgIGFsZXJ0KG1zZylcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbiNhcHAge1xuICBtYXJnaW46IDA7XG4gIGhlaWdodDogMTAwdmg7XG59XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIEFwcC52dWU/MTE5NmM4M2IiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_libcrowds_viewer__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App_vue__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__App_vue__);\n\n\n/* eslint-enable */\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */].component(\'lc-viewer\', __WEBPACK_IMPORTED_MODULE_1_libcrowds_viewer__["a" /* default */]);\n\n/* eslint-disable no-new */\nnew __WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */]({\n  el: \'#app\',\n  render: function render(h) {\n    return h(__WEBPACK_IMPORTED_MODULE_2__App_vue___default.a);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCIsImVsIiwicmVuZGVyIiwiaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBQUEsQ0FBSUMsU0FBSixDQUFjLFdBQWQsRUFBMkIsaUVBQTNCOztBQUVBO0FBQ0EsSUFBSSxvREFBSixDQUFRO0FBQ05DLE1BQUksTUFERTtBQUVOQyxVQUFRO0FBQUEsV0FBS0MsRUFBRSxnREFBRixDQUFMO0FBQUE7QUFGRixDQUFSIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgTGliY3Jvd2RzVmlld2VyIGZyb20gJ2xpYmNyb3dkcy12aWV3ZXInXG4vKiBlc2xpbnQtZW5hYmxlICovXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwLnZ1ZSc7XG5cblZ1ZS5jb21wb25lbnQoJ2xjLXZpZXdlcicsIExpYmNyb3dkc1ZpZXdlcilcblxuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5uZXcgVnVlKHtcbiAgZWw6ICcjYXBwJyxcbiAgcmVuZGVyOiBoID0+IGgoQXBwKVxufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(7)();\n// imports\n\n\n// module\nexports.push([module.i, "#app{margin:0;height:100vh}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9mYzI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsOEJBQStCLFNBQVMsYUFBYTs7QUFFckQiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjYXBwe21hcmdpbjowO2hlaWdodDoxMDB2aH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00NmU3MjBiOFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(7)();\n// imports\n\n\n// module\nexports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}[hidden],template{display:none}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3M/ODMxYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLDBHQUEyRyxpQkFBaUIsMEJBQTBCLDhCQUE4QixLQUFLLFNBQVMsd0NBQXdDLGNBQWMsR0FBRyxjQUFjLGVBQWUsdUJBQXVCLGNBQWMsT0FBTyxnQkFBZ0IsR0FBRyx1QkFBdUIsU0FBUyxpQkFBaUIsSUFBSSxnQ0FBZ0MsY0FBYyxFQUFFLDZCQUE2QixxQ0FBcUMsWUFBWSxtQkFBbUIsMEJBQTBCLGlDQUFpQyxTQUFTLG9CQUFvQixtQkFBbUIsY0FBYyxnQ0FBZ0MsY0FBYyxJQUFJLGtCQUFrQixLQUFLLHNCQUFzQixXQUFXLE1BQU0sY0FBYyxRQUFRLGNBQWMsY0FBYyxrQkFBa0Isd0JBQXdCLElBQUksY0FBYyxJQUFJLFVBQVUsWUFBWSxxQkFBcUIsc0JBQXNCLGFBQWEsU0FBUyxJQUFJLGtCQUFrQixlQUFlLGdCQUFnQixzQ0FBc0MsdUJBQXVCLGVBQWUsaUJBQWlCLFNBQVMsYUFBYSxpQkFBaUIsY0FBYyxvQkFBb0IscURBQXFELDBCQUEwQix3SEFBd0gsa0JBQWtCLFVBQVUsNEdBQTRHLDhCQUE4QixTQUFTLDJCQUEyQixPQUFPLHNCQUFzQixjQUFjLGNBQWMsZUFBZSxVQUFVLG1CQUFtQixTQUFTLHFCQUFxQix3QkFBd0IsU0FBUyxjQUFjLDZCQUE2QixzQkFBc0IsVUFBVSxrRkFBa0YsWUFBWSxjQUFjLDZCQUE2QixvQkFBb0IscUZBQXFGLHdCQUF3Qiw2QkFBNkIsMEJBQTBCLGFBQWEsYUFBYSxjQUFjLFFBQVEsa0JBQWtCLE9BQU8scUJBQXFCLGtCQUFrQixhQUFhOztBQUV4dUUiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBub3JtYWxpemUuY3NzIHY3LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9odG1se2xpbmUtaGVpZ2h0OjEuMTU7LW1zLXRleHQtc2l6ZS1hZGp1c3Q6MTAwJTstd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6MTAwJX1ib2R5e21hcmdpbjowfWFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9ZmlnY2FwdGlvbixmaWd1cmUsbWFpbntkaXNwbGF5OmJsb2NrfWZpZ3VyZXttYXJnaW46MWVtIDQwcHh9aHJ7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MDtvdmVyZmxvdzp2aXNpYmxlfXByZXtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXA6b2JqZWN0c31hYmJyW3RpdGxlXXtib3JkZXItYm90dG9tOm5vbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lIGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDppbmhlcml0O2ZvbnQtd2VpZ2h0OmJvbGRlcn1jb2RlLGtiZCxzYW1we2ZvbnQtZmFtaWx5Om1vbm9zcGFjZSxtb25vc3BhY2U7Zm9udC1zaXplOjFlbX1kZm57Zm9udC1zdHlsZTppdGFsaWN9bWFya3tiYWNrZ3JvdW5kLWNvbG9yOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1Yntib3R0b206LS4yNWVtfXN1cHt0b3A6LS41ZW19YXVkaW8sdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2t9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1pbWd7Ym9yZGVyLXN0eWxlOm5vbmV9c3ZnOm5vdCg6cm9vdCl7b3ZlcmZsb3c6aGlkZGVufWJ1dHRvbixpbnB1dCxvcHRncm91cCxzZWxlY3QsdGV4dGFyZWF7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXNpemU6MTAwJTtsaW5lLWhlaWdodDoxLjE1O21hcmdpbjowfWJ1dHRvbixpbnB1dHtvdmVyZmxvdzp2aXNpYmxlfWJ1dHRvbixzZWxlY3R7dGV4dC10cmFuc2Zvcm06bm9uZX1bdHlwZT1yZXNldF0sW3R5cGU9c3VibWl0XSxidXR0b24saHRtbCBbdHlwZT1idXR0b25dey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b259W3R5cGU9YnV0dG9uXTo6LW1vei1mb2N1cy1pbm5lcixbdHlwZT1yZXNldF06Oi1tb3otZm9jdXMtaW5uZXIsW3R5cGU9c3VibWl0XTo6LW1vei1mb2N1cy1pbm5lcixidXR0b246Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyLXN0eWxlOm5vbmU7cGFkZGluZzowfVt0eXBlPWJ1dHRvbl06LW1vei1mb2N1c3JpbmcsW3R5cGU9cmVzZXRdOi1tb3otZm9jdXNyaW5nLFt0eXBlPXN1Ym1pdF06LW1vei1mb2N1c3JpbmcsYnV0dG9uOi1tb3otZm9jdXNyaW5ne291dGxpbmU6MXB4IGRvdHRlZCBCdXR0b25UZXh0fWZpZWxkc2V0e3BhZGRpbmc6LjM1ZW0gLjc1ZW0gLjYyNWVtfWxlZ2VuZHtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6aW5oZXJpdDtkaXNwbGF5OnRhYmxlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6MDt3aGl0ZS1zcGFjZTpub3JtYWx9cHJvZ3Jlc3N7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9dGV4dGFyZWF7b3ZlcmZsb3c6YXV0b31bdHlwZT1jaGVja2JveF0sW3R5cGU9cmFkaW9de2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjB9W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfVt0eXBlPXNlYXJjaF17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDtvdXRsaW5lLW9mZnNldDotMnB4fVt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sW3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbnstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX06Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247Zm9udDppbmhlcml0fWRldGFpbHMsbWVudXtkaXNwbGF5OmJsb2NrfXN1bW1hcnl7ZGlzcGxheTpsaXN0LWl0ZW19Y2FudmFze2Rpc3BsYXk6aW5saW5lLWJsb2NrfVtoaWRkZW5dLHRlbXBsYXRle2Rpc3BsYXk6bm9uZX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuLi9+L25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(24);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(27)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../demo/node_modules/css-loader/index.js!./normalize.css\", function() {\n\t\t\tvar newContent = require(\"!!../../demo/node_modules/css-loader/index.js!./normalize.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3M/ZWQ3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ub3JtYWxpemUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ub3JtYWxpemUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbm9ybWFsaXplLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === "undefined") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(28);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\toptions.attrs.type = "text/css";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\toptions.attrs.type = "text/css";\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzP2I3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85YzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(88)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(63),\n  /* template */\n  __webpack_require__(36),\n  /* scopeId */\n  "data-v-33163bc3",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlPzdjODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQXlLOztBQUV6SztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTMzMTYzYmMzXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vQ29udHJvbHMudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9Db250cm9scy52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzMxNjNiYzNcXFwifSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9Db250cm9scy52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtMzMxNjNiYzNcIixcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL0NvbnRyb2xzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(93)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(64),\n  /* template */\n  __webpack_require__(41),\n  /* scopeId */\n  "data-v-dfc627fe",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWU/YTA0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSxzQkFBa0w7O0FBRWxMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP21pbmltaXplIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZGZjNjI3ZmVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9NZXRhZGF0YU1vZGFsLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWV0YWRhdGFNb2RhbC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZGZjNjI3ZmVcXFwifSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9NZXRhZGF0YU1vZGFsLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi1kZmM2MjdmZVwiLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWVcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(89)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(66),\n  /* template */\n  __webpack_require__(38),\n  /* scopeId */\n  "data-v-4f491fdf",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/NDk1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSxzQkFBeUs7O0FBRXpLO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGY0OTFmZGZcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TaWRlYmFyLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vU2lkZWJhci52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGY0OTFmZGZcXFwifSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TaWRlYmFyLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi00ZjQ5MWZkZlwiLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWVcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("\n/* styles */\n__webpack_require__(91)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(67),\n  /* template */\n  __webpack_require__(40),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT8yODg1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHNCQUEwSzs7QUFFMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1hYWQ0MWI0MlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IXNhc3MtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9WaWV3ZXIudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9WaWV3ZXIudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWFhZDQxYjQyXFxcIn0hLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vVmlld2VyLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(90)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(68),\n  /* template */\n  __webpack_require__(39),\n  /* scopeId */\n  "data-v-76bf11a1",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT8yYThhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHNCQUE0Szs7QUFFNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03NmJmMTFhMVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc2Fzcy1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1NlbGVjdGlvbi52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1NlbGVjdGlvbi52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzZiZjExYTFcXFwifSEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TZWxlY3Rpb24udnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIFwiZGF0YS12LTc2YmYxMWExXCIsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zcmMvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'transition\', {\n    attrs: {\n      "name": "modal"\n    }\n  }, [_c(\'div\', {\n    directives: [{\n      name: "show",\n      rawName: "v-show",\n      value: (_vm.show),\n      expression: "show"\n    }],\n    staticClass: "modal",\n    attrs: {\n      "id": _vm.id\n    }\n  }, [_c(\'div\', {\n    staticClass: "modal-mask",\n    on: {\n      "click": function($event) {\n        _vm.show = false\n      },\n      "keyup": function($event) {\n        if (!(\'button\' in $event) && _vm._k($event.keyCode, "esc", 27)) { return null; }\n        _vm.show = false\n      }\n    }\n  }, [_c(\'div\', {\n    staticClass: "modal-wrapper"\n  }, [_c(\'div\', {\n    staticClass: "modal-container"\n  }, [_c(\'div\', {\n    staticClass: "modal-header"\n  }, [_vm._t("header", [_c(\'h3\', [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _c(\'span\', {\n    staticClass: "close",\n    on: {\n      "click": function($event) {\n        _vm.show = false\n      }\n    }\n  }, [_vm._v("×")])])], 2), _vm._v(" "), _c(\'div\', {\n    staticClass: "modal-body"\n  }, [_vm._t("default")], 2), _vm._v(" "), _c(\'div\', {\n    staticClass: "modal-footer"\n  }, [_vm._t("footer", [_c(\'button\', {\n    on: {\n      "click": function($event) {\n        _vm.show = false\n      }\n    }\n  }, [_vm._v("\\n                OK\\n              ")])])], 2)])])])])])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlPzJiYzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3RyYW5zaXRpb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwibmFtZVwiOiBcIm1vZGFsXCJcbiAgICB9XG4gIH0sIFtfYygnZGl2Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICB2YWx1ZTogKF92bS5zaG93KSxcbiAgICAgIGV4cHJlc3Npb246IFwic2hvd1wiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWxcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBfdm0uaWRcbiAgICB9XG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLW1hc2tcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLnNob3cgPSBmYWxzZVxuICAgICAgfSxcbiAgICAgIFwia2V5dXBcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICghKCdidXR0b24nIGluICRldmVudCkgJiYgX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcImVzY1wiLCAyNykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgX3ZtLnNob3cgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtd3JhcHBlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNvbnRhaW5lclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWhlYWRlclwiXG4gIH0sIFtfdm0uX3QoXCJoZWFkZXJcIiwgW19jKCdoMycsIFtfdm0uX3YoX3ZtLl9zKF92bS50aXRsZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNsb3NlXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zaG93ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLDl1wiKV0pXSldLCAyKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1ib2R5XCJcbiAgfSwgW192bS5fdChcImRlZmF1bHRcIildLCAyKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1mb290ZXJcIlxuICB9LCBbX3ZtLl90KFwiZm9vdGVyXCIsIFtfYygnYnV0dG9uJywge1xuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2hvdyA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgICAgIE9LXFxuICAgICAgICAgICAgICBcIildKV0pXSwgMildKV0pXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDYwYzA1MjBcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9Nb2RhbC52dWVcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'svg\', {\n    class: _vm.clazz,\n    style: (_vm.style),\n    attrs: {\n      "version": "1.1",\n      "role": _vm.label ? \'img\' : \'presentation\',\n      "aria-label": _vm.label,\n      "x": _vm.x,\n      "y": _vm.y,\n      "width": _vm.width,\n      "height": _vm.height,\n      "viewBox": _vm.box\n    }\n  }, [_vm._t("default", [(_vm.icon && _vm.icon.paths) ? _vm._l((_vm.icon.paths), function(path) {\n    return _c(\'path\', _vm._b({}, \'path\', path))\n  }) : _vm._e(), _vm._v(" "), (_vm.icon && _vm.icon.polygons) ? _vm._l((_vm.icon.polygons), function(polygon) {\n    return _c(\'polygon\', _vm._b({}, \'polygon\', polygon))\n  }) : _vm._e(), _vm._v("\\b\\n    "), (_vm.icon && _vm.icon.raw) ? [_c(\'g\', {\n    domProps: {\n      "innerHTML": _vm._s(_vm.icon.raw)\n    }\n  })] : _vm._e()])], 2)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlPzAwODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0I7QUFDL0IsR0FBRztBQUNILGtDQUFrQztBQUNsQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3N2ZycsIHtcbiAgICBjbGFzczogX3ZtLmNsYXp6LFxuICAgIHN0eWxlOiAoX3ZtLnN0eWxlKSxcbiAgICBhdHRyczoge1xuICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS4xXCIsXG4gICAgICBcInJvbGVcIjogX3ZtLmxhYmVsID8gJ2ltZycgOiAncHJlc2VudGF0aW9uJyxcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiBfdm0ubGFiZWwsXG4gICAgICBcInhcIjogX3ZtLngsXG4gICAgICBcInlcIjogX3ZtLnksXG4gICAgICBcIndpZHRoXCI6IF92bS53aWR0aCxcbiAgICAgIFwiaGVpZ2h0XCI6IF92bS5oZWlnaHQsXG4gICAgICBcInZpZXdCb3hcIjogX3ZtLmJveFxuICAgIH1cbiAgfSwgW192bS5fdChcImRlZmF1bHRcIiwgWyhfdm0uaWNvbiAmJiBfdm0uaWNvbi5wYXRocykgPyBfdm0uX2woKF92bS5pY29uLnBhdGhzKSwgZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBfYygncGF0aCcsIF92bS5fYih7fSwgJ3BhdGgnLCBwYXRoKSlcbiAgfSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKF92bS5pY29uICYmIF92bS5pY29uLnBvbHlnb25zKSA/IF92bS5fbCgoX3ZtLmljb24ucG9seWdvbnMpLCBmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgcmV0dXJuIF9jKCdwb2x5Z29uJywgX3ZtLl9iKHt9LCAncG9seWdvbicsIHBvbHlnb24pKVxuICB9KSA6IF92bS5fZSgpLCBfdm0uX3YoXCJcXGJcXG4gICAgXCIpLCAoX3ZtLmljb24gJiYgX3ZtLmljb24ucmF3KSA/IFtfYygnZycsIHtcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKF92bS5pY29uLnJhdylcbiAgICB9XG4gIH0pXSA6IF92bS5fZSgpXSldLCAyKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTA2NjU5NzBiXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lc-controls"\n    }\n  }, _vm._l((_vm.buttons), function(b) {\n    return _c(\'button\', {\n      staticClass: "hint--right hint--no-animate",\n      attrs: {\n        "id": b.id,\n        "aria-label": b.tooltip\n      },\n      on: {\n        "click": function($event) {\n          _vm.handleClick(b.click)\n        }\n      }\n    }, [_c(\'icon\', {\n      attrs: {\n        "name": b.icon\n      }\n    })], 1)\n  }))\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlP2M3NjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsYy1jb250cm9sc1wiXG4gICAgfVxuICB9LCBfdm0uX2woKF92bS5idXR0b25zKSwgZnVuY3Rpb24oYikge1xuICAgIHJldHVybiBfYygnYnV0dG9uJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiaGludC0tcmlnaHQgaGludC0tbm8tYW5pbWF0ZVwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJpZFwiOiBiLmlkLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogYi50b29sdGlwXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICBfdm0uaGFuZGxlQ2xpY2soYi5jbGljaylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygnaWNvbicsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwibmFtZVwiOiBiLmljb25cbiAgICAgIH1cbiAgICB9KV0sIDEpXG4gIH0pKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTMzMTYzYmMzXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "app"\n    }\n  }, [_c(\'lc-viewer\', {\n    attrs: {\n      "options": _vm.options,\n      "baseUrl": _vm.baseUrl,\n      "tileId": _vm.tileId,\n      "manifest": _vm.manifest\n    },\n    on: {\n      "confirm": _vm.handleConfirm\n    }\n  })], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9lNmJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwiYXBwXCJcbiAgICB9XG4gIH0sIFtfYygnbGMtdmlld2VyJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm9wdGlvbnNcIjogX3ZtLm9wdGlvbnMsXG4gICAgICBcImJhc2VVcmxcIjogX3ZtLmJhc2VVcmwsXG4gICAgICBcInRpbGVJZFwiOiBfdm0udGlsZUlkLFxuICAgICAgXCJtYW5pZmVzdFwiOiBfdm0ubWFuaWZlc3RcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNvbmZpcm1cIjogX3ZtLmhhbmRsZUNvbmZpcm1cbiAgICB9XG4gIH0pXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00NmU3MjBiOFwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "lv-sidebar"\n  }, [_c(\'div\', {\n    staticClass: "lv-sidebar-wrapper"\n  }, [_c(\'div\', {\n    staticClass: "lv-sidebar-container"\n  }, [_c(\'div\', {\n    staticClass: "lv-sidebar-header"\n  }, [_c(\'h4\', [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _c(\'span\', {\n    class: _vm.toggleClassObj,\n    on: {\n      "click": _vm.toggleCollapse\n    }\n  }, [_vm._v("\\n          ▲\\n        ")])]), _vm._v(" "), _c(\'div\', {\n    directives: [{\n      name: "show",\n      rawName: "v-show",\n      value: (!_vm.contentCollapsed),\n      expression: "!contentCollapsed"\n    }],\n    staticClass: "lv-sidebar-content"\n  }, [_vm._t("default")], 2)])])])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/M2RiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibHYtc2lkZWJhclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImx2LXNpZGViYXItd3JhcHBlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImx2LXNpZGViYXItY29udGFpbmVyXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibHYtc2lkZWJhci1oZWFkZXJcIlxuICB9LCBbX2MoJ2g0JywgW192bS5fdihfdm0uX3MoX3ZtLnRpdGxlKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgY2xhc3M6IF92bS50b2dnbGVDbGFzc09iaixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0udG9nZ2xlQ29sbGFwc2VcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJcXG4gICAgICAgICAg4payXFxuICAgICAgICBcIildKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICB2YWx1ZTogKCFfdm0uY29udGVudENvbGxhcHNlZCksXG4gICAgICBleHByZXNzaW9uOiBcIiFjb250ZW50Q29sbGFwc2VkXCJcbiAgICB9XSxcbiAgICBzdGF0aWNDbGFzczogXCJsdi1zaWRlYmFyLWNvbnRlbnRcIlxuICB9LCBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sIDIpXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNGY0OTFmZGZcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9TaWRlYmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lv-selection-sidebar"\n    }\n  }, [_c(\'sidebar\', {\n    attrs: {\n      "title": "Selections"\n    }\n  }, [_c(\'ul\', _vm._l((_vm.selections), function(s) {\n    return _c(\'li\', {\n      key: s.id\n    }, [_vm._v("\\n        " + _vm._s(s.id) + "\\n        "), _c(\'div\', [_c(\'span\', {\n      on: {\n        "click": function($event) {\n          _vm.editSelection(s)\n        }\n      }\n    }, [_c(\'icon\', {\n      attrs: {\n        "name": "pencil"\n      }\n    })], 1), _vm._v(" "), _c(\'span\', {\n      on: {\n        "click": function($event) {\n          _vm.deleteSelection(s)\n        }\n      }\n    }, [_c(\'icon\', {\n      attrs: {\n        "name": "times-circle"\n      }\n    })], 1)])])\n  })), _vm._v(" "), _c(\'button\', {\n    on: {\n      "click": _vm.confirm\n    }\n  }, [_vm._v("\\n      Confirm\\n    ")])])], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT9lZmI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsdi1zZWxlY3Rpb24tc2lkZWJhclwiXG4gICAgfVxuICB9LCBbX2MoJ3NpZGViYXInLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidGl0bGVcIjogXCJTZWxlY3Rpb25zXCJcbiAgICB9XG4gIH0sIFtfYygndWwnLCBfdm0uX2woKF92bS5zZWxlY3Rpb25zKSwgZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBfYygnbGknLCB7XG4gICAgICBrZXk6IHMuaWRcbiAgICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICBcIiArIF92bS5fcyhzLmlkKSArIFwiXFxuICAgICAgICBcIiksIF9jKCdkaXYnLCBbX2MoJ3NwYW4nLCB7XG4gICAgICBvbjoge1xuICAgICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIF92bS5lZGl0U2VsZWN0aW9uKHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbX2MoJ2ljb24nLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcIm5hbWVcIjogXCJwZW5jaWxcIlxuICAgICAgfVxuICAgIH0pXSwgMSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgICAgb246IHtcbiAgICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICBfdm0uZGVsZXRlU2VsZWN0aW9uKHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbX2MoJ2ljb24nLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcIm5hbWVcIjogXCJ0aW1lcy1jaXJjbGVcIlxuICAgICAgfVxuICAgIH0pXSwgMSldKV0pXG4gIH0pKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2J1dHRvbicsIHtcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uY29uZmlybVxuICAgIH1cbiAgfSwgW192bS5fdihcIlxcbiAgICAgIENvbmZpcm1cXG4gICAgXCIpXSldKV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNzZiZjExYTFcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lc-viewer"\n    }\n  }, [_c(\'controls\', {\n    ref: "controls",\n    attrs: {\n      "buttons": _vm.controlButtons\n    }\n  }), _vm._v(" "), (_vm.manifest) ? _c(\'metadata-modal\', {\n    attrs: {\n      "id": _vm.metadataModalId,\n      "manifest": _vm.manifest\n    }\n  }) : _vm._e(), _vm._v(" "), (_vm.mode === \'selection\') ? _c(\'selection-sidebar\', {\n    on: {\n      "confirm": _vm.confirm\n    }\n  }) : _vm._e(), _vm._v(" "), _c(\'div\', {\n    ref: "confirmSelection",\n    staticClass: "selection-btn",\n    attrs: {\n      "id": "confirm-selection"\n    }\n  }, [_c(\'icon\', {\n    attrs: {\n      "name": "check-circle"\n    }\n  })], 1), _vm._v(" "), _c(\'div\', {\n    ref: "cancelSelection",\n    staticClass: "selection-btn",\n    attrs: {\n      "id": "cancel-selection"\n    }\n  }, [_c(\'icon\', {\n    attrs: {\n      "name": "times-circle"\n    }\n  })], 1), _vm._v(" "), _c(\'div\', {\n    ref: "viewer"\n  })], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT8xODYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImxjLXZpZXdlclwiXG4gICAgfVxuICB9LCBbX2MoJ2NvbnRyb2xzJywge1xuICAgIHJlZjogXCJjb250cm9sc1wiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImJ1dHRvbnNcIjogX3ZtLmNvbnRyb2xCdXR0b25zXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgKF92bS5tYW5pZmVzdCkgPyBfYygnbWV0YWRhdGEtbW9kYWwnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogX3ZtLm1ldGFkYXRhTW9kYWxJZCxcbiAgICAgIFwibWFuaWZlc3RcIjogX3ZtLm1hbmlmZXN0XG4gICAgfVxuICB9KSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLm1vZGUgPT09ICdzZWxlY3Rpb24nKSA/IF9jKCdzZWxlY3Rpb24tc2lkZWJhcicsIHtcbiAgICBvbjoge1xuICAgICAgXCJjb25maXJtXCI6IF92bS5jb25maXJtXG4gICAgfVxuICB9KSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHJlZjogXCJjb25maXJtU2VsZWN0aW9uXCIsXG4gICAgc3RhdGljQ2xhc3M6IFwic2VsZWN0aW9uLWJ0blwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwiY29uZmlybS1zZWxlY3Rpb25cIlxuICAgIH1cbiAgfSwgW19jKCdpY29uJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJjaGVjay1jaXJjbGVcIlxuICAgIH1cbiAgfSldLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICByZWY6IFwiY2FuY2VsU2VsZWN0aW9uXCIsXG4gICAgc3RhdGljQ2xhc3M6IFwic2VsZWN0aW9uLWJ0blwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwiY2FuY2VsLXNlbGVjdGlvblwiXG4gICAgfVxuICB9LCBbX2MoJ2ljb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwibmFtZVwiOiBcInRpbWVzLWNpcmNsZVwiXG4gICAgfVxuICB9KV0sIDEpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHJlZjogXCJ2aWV3ZXJcIlxuICB9KV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYWFkNDFiNDJcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    attrs: {\n      "id": "lc-metadata"\n    }\n  }, [_c(\'modal\', {\n    attrs: {\n      "id": _vm.id,\n      "title": "Metadata"\n    }\n  }, [_vm._l((_vm.manifestData.metadata), function(m) {\n    return _c(\'ul\', {\n      attrs: {\n        "id": "manifest-md"\n      }\n    }, [_c(\'li\', [_c(\'strong\', [_vm._v(_vm._s(m.label) + ":")]), _vm._v("\\n         \\n        "), _c(\'span\', {\n      domProps: {\n        "innerHTML": _vm._s(m.value)\n      }\n    })])])\n  }), _vm._v(" "), _c(\'div\', {\n    attrs: {\n      "id": "rights"\n    }\n  }, [_c(\'img\', {\n    attrs: {\n      "src": _vm.manifestData.logo\n    }\n  }), _vm._v(" "), _c(\'p\', [_vm._v(_vm._s(_vm.manifestData.attribution))]), _vm._v(" "), _c(\'p\', [_vm._v(_vm._s(_vm.manifestData.license))])])], 2)], 1)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWU/MDI2MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjQxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsYy1tZXRhZGF0YVwiXG4gICAgfVxuICB9LCBbX2MoJ21vZGFsJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IF92bS5pZCxcbiAgICAgIFwidGl0bGVcIjogXCJNZXRhZGF0YVwiXG4gICAgfVxuICB9LCBbX3ZtLl9sKChfdm0ubWFuaWZlc3REYXRhLm1ldGFkYXRhKSwgZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBfYygndWwnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcImlkXCI6IFwibWFuaWZlc3QtbWRcIlxuICAgICAgfVxuICAgIH0sIFtfYygnbGknLCBbX2MoJ3N0cm9uZycsIFtfdm0uX3YoX3ZtLl9zKG0ubGFiZWwpICsgXCI6XCIpXSksIF92bS5fdihcIlxcbiAgICAgICAgwqBcXG4gICAgICAgIFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgICBkb21Qcm9wczoge1xuICAgICAgICBcImlubmVySFRNTFwiOiBfdm0uX3MobS52YWx1ZSlcbiAgICAgIH1cbiAgICB9KV0pXSlcbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJyaWdodHNcIlxuICAgIH1cbiAgfSwgW19jKCdpbWcnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwic3JjXCI6IF92bS5tYW5pZmVzdERhdGEubG9nb1xuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdwJywgW192bS5fdihfdm0uX3MoX3ZtLm1hbmlmZXN0RGF0YS5hdHRyaWJ1dGlvbikpXSksIF92bS5fdihcIiBcIiksIF9jKCdwJywgW192bS5fdihfdm0uX3MoX3ZtLm1hbmlmZXN0RGF0YS5saWNlbnNlKSldKV0pXSwgMildLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWRmYzYyN2ZlXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWVcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(23);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(43)(\"e61d7c06\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT82MjlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0Esb0NBQTJMO0FBQzNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTQ2ZTcyMGI4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BcHAudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJlNjFkN2MwNlwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00NmU3MjBiOFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(44)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz82YjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcz9lNmFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\nvar bind = __webpack_require__(15);\nvar Axios = __webpack_require__(47);\nvar defaults = __webpack_require__(5);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(12);\naxios.CancelToken = __webpack_require__(46);\naxios.isCancel = __webpack_require__(13);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(61);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvYXhpb3MuanM/ODgyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvYXhpb3MuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Cancel = __webpack_require__(12);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzPzdjZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar defaults = __webpack_require__(5);\nvar utils = __webpack_require__(1);\nvar InterceptorManager = __webpack_require__(48);\nvar dispatchRequest = __webpack_require__(49);\nvar isAbsoluteURL = __webpack_require__(57);\nvar combineURLs = __webpack_require__(55);\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);\n  config.method = config.method.toLowerCase();\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9BeGlvcy5qcz8yZDM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaURBQWlELGdCQUFnQjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCB7IG1ldGhvZDogJ2dldCcgfSwgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NvcmUvQXhpb3MuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanM/MzcxYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\nvar transformData = __webpack_require__(52);\nvar isCancel = __webpack_require__(13);\nvar defaults = __webpack_require__(5);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanM/MWJiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnMgfHwge31cbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanM/ZjA4NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar createError = __webpack_require__(14);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanM/YjYzYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzPzE2NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsImZpbGUiOiI1Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9idG9hLmpzPzI1YzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI1My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      }\n\n      if (!utils.isArray(val)) {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcz9jOTdlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcz8wMmYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzP2UzNmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QyxPQUFPOztBQUVQO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw2QkFBNkIsYUFBYSxFQUFFO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzPzcyNTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanM/ZTc1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzPzI2OGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(1);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanM/NGNmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanM/MGU3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(17);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\nvar icons = {};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'icon',\n  props: {\n    name: {\n      type: String,\n      validator: function validator(val) {\n        if (val) {\n          if (!(val in icons)) {\n            __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */].util.warn('Invalid prop: prop \"icon\" is referring to an unregistered icon \"' + val + '\".' + '\\nPlesase make sure you have imported this icon before using it.', this);\n            return false;\n          }\n          return true;\n        }\n        return null;\n      }\n    },\n    scale: [Number, String],\n    spin: Boolean,\n    inverse: Boolean,\n    flip: {\n      validator: function validator(val) {\n        return val === 'horizontal' || val === 'vertical';\n      }\n    },\n    label: String\n  },\n  data: function data() {\n    return {\n      x: false,\n      y: false,\n      childrenWidth: 0,\n      childrenHeight: 0,\n      outerScale: 1\n    };\n  },\n\n  computed: {\n    normalizedScale: function normalizedScale() {\n      var scale = this.scale;\n      scale = typeof scale === 'undefined' ? 1 : Number(scale);\n      if (isNaN(scale) || scale <= 0) {\n        __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */].util.warn('Invalid prop: prop \"scale\" should be a number over 0.', this);\n        return this.outerScale;\n      }\n      return scale * this.outerScale;\n    },\n    clazz: function clazz() {\n      return {\n        'fa-icon': true,\n        'fa-spin': this.spin,\n        'fa-flip-horizontal': this.flip === 'horizontal',\n        'fa-flip-vertical': this.flip === 'vertical',\n        'fa-inverse': this.inverse\n      };\n    },\n    icon: function icon() {\n      if (this.name) {\n        return icons[this.name];\n      }\n      return null;\n    },\n    box: function box() {\n      if (this.icon) {\n        return '0 0 ' + this.icon.width + ' ' + this.icon.height;\n      }\n      return '0 0 ' + this.width + ' ' + this.height;\n    },\n    ratio: function ratio() {\n      if (!this.icon) {\n        return 1;\n      }\n      var _icon = this.icon,\n          width = _icon.width,\n          height = _icon.height;\n\n      return Math.max(width, height) / 16;\n    },\n    width: function width() {\n      return this.childrenWidth || this.icon && this.icon.width / this.ratio * this.normalizedScale || 0;\n    },\n    height: function height() {\n      return this.childrenHeight || this.icon && this.icon.height / this.ratio * this.normalizedScale || 0;\n    },\n    style: function style() {\n      if (this.normalizedScale === 1) {\n        return false;\n      }\n      return {\n        fontSize: this.normalizedScale + 'em'\n      };\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    if (this.icon) {\n      return;\n    }\n    this.$children.forEach(function (child) {\n      child.outerScale = _this.normalizedScale;\n    });\n    var width = 0;\n    var height = 0;\n    this.$children.forEach(function (child) {\n      width = Math.max(width, child.width);\n      height = Math.max(height, child.height);\n    });\n    this.childrenWidth = width;\n    this.childrenHeight = height;\n    this.$children.forEach(function (child) {\n      child.x = (width - child.width) / 2;\n      child.y = (height - child.height) / 2;\n    });\n  },\n  register: function register(data) {\n    for (var name in data) {\n      var icon = data[name];\n\n      if (!icon.paths) {\n        icon.paths = [];\n      }\n      if (icon.d) {\n        icon.paths.push({ d: icon.d });\n      }\n\n      if (!icon.polygons) {\n        icon.polygons = [];\n      }\n      if (icon.points) {\n        icon.polygons.push({ points: icon.points });\n      }\n\n      icons[name] = icon;\n    }\n  },\n\n  icons: icons\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vSWNvbi52dWU/NDBhMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBOztBQUVBOztBQUVBO1FBRUE7OztZQUdBO3lDQUNBO2lCQUNBOytCQUNBO2dKQUNBLGlGQUNBO21CQUNBO0FBQ0E7aUJBQ0E7QUFDQTtlQUNBO0FBRUE7QUFiQTtvQkFjQTtVQUNBO2FBQ0E7O3lDQUVBOytDQUNBO0FBRUE7QUFKQTtXQU1BO0FBeEJBO3dCQXlCQTs7U0FFQTtTQUNBO3FCQUNBO3NCQUNBO2tCQUVBO0FBTkE7QUFPQTs7O2dEQUVBO3VCQUNBO3dEQUNBO3NDQUNBO2dJQUNBO29CQUNBO0FBQ0E7MEJBQ0E7QUFDQTs0QkFDQTs7bUJBRUE7d0JBQ0E7NENBQ0E7MENBQ0E7MkJBRUE7QUFOQTtBQU9BOzBCQUNBO3FCQUNBOzBCQUNBO0FBQ0E7YUFDQTtBQUNBO3dCQUNBO3FCQUNBOzBEQUNBO0FBQ0E7OENBQ0E7QUFDQTs7c0JBRUE7ZUFDQTtBQUNBO0FBSEEsdUJBSUE7Ozs7dUNBQ0E7QUFDQTs0QkFDQTt1R0FDQTtBQUNBOzhCQUNBO3lHQUNBO0FBQ0E7NEJBQ0E7c0NBQ0E7ZUFDQTtBQUNBOzt5Q0FHQTtBQUZBO0FBSUE7QUFwREE7O0FBcURBOzttQkFDQTtBQUNBO0FBQ0E7NENBQ0E7K0JBQ0E7QUFDQTtnQkFDQTtpQkFDQTs0Q0FDQTtvQ0FDQTtzQ0FDQTtBQUNBO3lCQUNBOzBCQUNBOzRDQUNBO3dDQUNBOzBDQUNBO0FBQ0E7QUFDQTtvQ0FDQTsyQkFDQTtzQkFFQTs7dUJBQ0E7cUJBQ0E7QUFDQTtrQkFDQTtrQ0FDQTtBQUVBOzswQkFDQTt3QkFDQTtBQUNBO3VCQUNBOzBDQUNBO0FBRUE7O29CQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQWxJQSIsImZpbGUiOiI2Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgOmNsYXNzPVwiY2xhenpcIiA6cm9sZT1cImxhYmVsID8gJ2ltZycgOiAncHJlc2VudGF0aW9uJ1wiIDphcmlhLWxhYmVsPVwibGFiZWxcIiA6eD1cInhcIiA6eT1cInlcIiA6d2lkdGg9XCJ3aWR0aFwiIDpoZWlnaHQ9XCJoZWlnaHRcIiA6dmlld0JveD1cImJveFwiIDpzdHlsZT1cInN0eWxlXCI+XG4gICAgPHNsb3Q+XG4gICAgICA8dGVtcGxhdGUgdi1pZj1cImljb24gJiYgaWNvbi5wYXRoc1wiPlxuICAgICAgICA8cGF0aCB2LWZvcj1cInBhdGggaW4gaWNvbi5wYXRoc1wiIHYtYmluZD1cInBhdGhcIi8+XG4gICAgICA8L3RlbXBsYXRlPlxuICAgICAgPHRlbXBsYXRlIHYtaWY9XCJpY29uICYmIGljb24ucG9seWdvbnNcIj5cbiAgICAgICAgPHBvbHlnb24gdi1mb3I9XCJwb2x5Z29uIGluIGljb24ucG9seWdvbnNcIiB2LWJpbmQ9XCJwb2x5Z29uXCIvPlxuICAgICAgPC90ZW1wbGF0ZT5cYlxuICAgICAgPHRlbXBsYXRlIHYtaWY9XCJpY29uICYmIGljb24ucmF3XCI+PGcgdi1odG1sPVwiaWNvbi5yYXdcIj48L2c+PC90ZW1wbGF0ZT5cbiAgICA8L3Nsb3Q+XG4gIDwvc3ZnPlxuPC90ZW1wbGF0ZT5cblxuPHN0eWxlPlxuLmZhLWljb24ge1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGZpbGw6IGN1cnJlbnRDb2xvcjtcbn1cblxuLmZhLWZsaXAtaG9yaXpvbnRhbCB7XG4gIHRyYW5zZm9ybTogc2NhbGUoLTEsIDEpO1xufVxuXG4uZmEtZmxpcC12ZXJ0aWNhbCB7XG4gIHRyYW5zZm9ybTogc2NhbGUoMSwgLTEpO1xufVxuXG4uZmEtc3BpbiB7XG4gIGFuaW1hdGlvbjogZmEtc3BpbiAxcyAwcyBpbmZpbml0ZSBsaW5lYXI7XG59XG5cbi5mYS1pbnZlcnNlIHtcbiAgY29sb3I6ICNmZmY7XG59XG5cbkBrZXlmcmFtZXMgZmEtc3BpbiB7XG4gIDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgfVxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICB9XG59XG48L3N0eWxlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5cbmxldCBpY29ucyA9IHt9XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ljb24nLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbGlkYXRvciAodmFsKSB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICBpZiAoISh2YWwgaW4gaWNvbnMpKSB7XG4gICAgICAgICAgICBWdWUudXRpbC53YXJuKGBJbnZhbGlkIHByb3A6IHByb3AgXCJpY29uXCIgaXMgcmVmZXJyaW5nIHRvIGFuIHVucmVnaXN0ZXJlZCBpY29uIFwiJHt2YWx9XCIuYCArXG4gICAgICAgICAgICAgIGBcXG5QbGVzYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSBpbXBvcnRlZCB0aGlzIGljb24gYmVmb3JlIHVzaW5nIGl0LmAsIHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgc3BpbjogQm9vbGVhbixcbiAgICBpbnZlcnNlOiBCb29sZWFuLFxuICAgIGZsaXA6IHtcbiAgICAgIHZhbGlkYXRvciAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09ICdob3Jpem9udGFsJyB8fCB2YWwgPT09ICd2ZXJ0aWNhbCdcbiAgICAgIH1cbiAgICB9LFxuICAgIGxhYmVsOiBTdHJpbmdcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGZhbHNlLFxuICAgICAgeTogZmFsc2UsXG4gICAgICBjaGlsZHJlbldpZHRoOiAwLFxuICAgICAgY2hpbGRyZW5IZWlnaHQ6IDAsXG4gICAgICBvdXRlclNjYWxlOiAxXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG5vcm1hbGl6ZWRTY2FsZSAoKSB7XG4gICAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlXG4gICAgICBzY2FsZSA9IHR5cGVvZiBzY2FsZSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogTnVtYmVyKHNjYWxlKVxuICAgICAgaWYgKGlzTmFOKHNjYWxlKSB8fCBzY2FsZSA8PSAwKSB7XG4gICAgICAgIFZ1ZS51dGlsLndhcm4oYEludmFsaWQgcHJvcDogcHJvcCBcInNjYWxlXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG92ZXIgMC5gLCB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5vdXRlclNjYWxlXG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGUgKiB0aGlzLm91dGVyU2NhbGVcbiAgICB9LFxuICAgIGNsYXp6ICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdmYS1pY29uJzogdHJ1ZSxcbiAgICAgICAgJ2ZhLXNwaW4nOiB0aGlzLnNwaW4sXG4gICAgICAgICdmYS1mbGlwLWhvcml6b250YWwnOiB0aGlzLmZsaXAgPT09ICdob3Jpem9udGFsJyxcbiAgICAgICAgJ2ZhLWZsaXAtdmVydGljYWwnOiB0aGlzLmZsaXAgPT09ICd2ZXJ0aWNhbCcsXG4gICAgICAgICdmYS1pbnZlcnNlJzogdGhpcy5pbnZlcnNlXG4gICAgICB9XG4gICAgfSxcbiAgICBpY29uICgpIHtcbiAgICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGljb25zW3RoaXMubmFtZV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSxcbiAgICBib3ggKCkge1xuICAgICAgaWYgKHRoaXMuaWNvbikge1xuICAgICAgICByZXR1cm4gYDAgMCAke3RoaXMuaWNvbi53aWR0aH0gJHt0aGlzLmljb24uaGVpZ2h0fWBcbiAgICAgIH1cbiAgICAgIHJldHVybiBgMCAwICR7dGhpcy53aWR0aH0gJHt0aGlzLmhlaWdodH1gXG4gICAgfSxcbiAgICByYXRpbyAoKSB7XG4gICAgICBpZiAoIXRoaXMuaWNvbikge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5pY29uXG4gICAgICByZXR1cm4gTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgLyAxNlxuICAgIH0sXG4gICAgd2lkdGggKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5XaWR0aCB8fCB0aGlzLmljb24gJiYgdGhpcy5pY29uLndpZHRoIC8gdGhpcy5yYXRpbyAqIHRoaXMubm9ybWFsaXplZFNjYWxlIHx8IDBcbiAgICB9LFxuICAgIGhlaWdodCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbkhlaWdodCB8fCB0aGlzLmljb24gJiYgdGhpcy5pY29uLmhlaWdodCAvIHRoaXMucmF0aW8gKiB0aGlzLm5vcm1hbGl6ZWRTY2FsZSB8fCAwXG4gICAgfSxcbiAgICBzdHlsZSAoKSB7XG4gICAgICBpZiAodGhpcy5ub3JtYWxpemVkU2NhbGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb250U2l6ZTogdGhpcy5ub3JtYWxpemVkU2NhbGUgKyAnZW0nXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICBpZiAodGhpcy5pY29uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC5vdXRlclNjYWxlID0gdGhpcy5ub3JtYWxpemVkU2NhbGVcbiAgICB9KVxuICAgIGxldCB3aWR0aCA9IDBcbiAgICBsZXQgaGVpZ2h0ID0gMFxuICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY2hpbGQud2lkdGgpXG4gICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGNoaWxkLmhlaWdodClcbiAgICB9KVxuICAgIHRoaXMuY2hpbGRyZW5XaWR0aCA9IHdpZHRoXG4gICAgdGhpcy5jaGlsZHJlbkhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY2hpbGQueCA9ICh3aWR0aCAtIGNoaWxkLndpZHRoKSAvIDJcbiAgICAgIGNoaWxkLnkgPSAoaGVpZ2h0IC0gY2hpbGQuaGVpZ2h0KSAvIDJcbiAgICB9KVxuICB9LFxuICByZWdpc3RlciAoZGF0YSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gZGF0YSkge1xuICAgICAgbGV0IGljb24gPSBkYXRhW25hbWVdXG5cbiAgICAgIGlmICghaWNvbi5wYXRocykge1xuICAgICAgICBpY29uLnBhdGhzID0gW11cbiAgICAgIH1cbiAgICAgIGlmIChpY29uLmQpIHtcbiAgICAgICAgaWNvbi5wYXRocy5wdXNoKHsgZDogaWNvbi5kIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICghaWNvbi5wb2x5Z29ucykge1xuICAgICAgICBpY29uLnBvbHlnb25zID0gW11cbiAgICAgIH1cbiAgICAgIGlmIChpY29uLnBvaW50cykge1xuICAgICAgICBpY29uLnBvbHlnb25zLnB1c2goeyBwb2ludHM6IGljb24ucG9pbnRzIH0pXG4gICAgICB9XG5cbiAgICAgIGljb25zW25hbWVdID0gaWNvblxuICAgIH1cbiAgfSxcbiAgaWNvbnNcbn1cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIEljb24udnVlPzhhMzQ3MmJjIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_icons_plus_circle__ = __webpack_require__(84);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_awesome_icons_minus_circle__ = __webpack_require__(82);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_awesome_icons_refresh__ = __webpack_require__(86);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_vue_awesome_icons_expand__ = __webpack_require__(80);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue_awesome_icons_question_circle__ = __webpack_require__(85);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_awesome_icons_info_circle__ = __webpack_require__(81);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_axios__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Modal_vue__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Modal_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__Modal_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  data: function data() {\n    return {\n      manifestData: {}\n    };\n  },\n\n  props: {\n    buttons: {\n      type: Array,\n      required: true\n    }\n  },\n\n  components: {\n    Icon: __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default.a\n  },\n\n  methods: {\n    handleClick: function handleClick(func) {\n      if (typeof func !== \'undefined\') {\n        func();\n      }\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQ29udHJvbHMudnVlP2Q2ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO3dCQUVBOztvQkFHQTtBQUZBO0FBSUE7Ozs7WUFHQTtnQkFJQTtBQUxBO0FBREE7OztBQVVBO0FBSEE7Ozs0Q0FLQTt1Q0FDQTtBQUNBO0FBQ0E7QUFFQTtBQU5BO0FBbEJBIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGlkPVwibGMtY29udHJvbHNcIj5cblxuICAgICAgPGJ1dHRvblxuICAgICAgICA6aWQ9XCJiLmlkXCJcbiAgICAgICAgdi1mb3I9XCJiIGluIGJ1dHRvbnNcIlxuICAgICAgICBjbGFzcz1cImhpbnQtLXJpZ2h0IGhpbnQtLW5vLWFuaW1hdGVcIlxuICAgICAgICA6YXJpYS1sYWJlbD1cImIudG9vbHRpcFwiXG4gICAgICAgIEBjbGljaz1cImhhbmRsZUNsaWNrKGIuY2xpY2spXCI+XG4gICAgICAgIDxpY29uIDpuYW1lPVwiYi5pY29uXCI+PC9pY29uPlxuICAgICAgPC9idXR0b24+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEljb24gZnJvbSAndnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvcGx1cy1jaXJjbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL21pbnVzLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvcmVmcmVzaCdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvZXhwYW5kJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9xdWVzdGlvbi1jaXJjbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2luZm8tY2lyY2xlJ1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vTW9kYWwudnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFuaWZlc3REYXRhOiB7fVxuICAgIH1cbiAgfSxcblxuICBwcm9wczoge1xuICAgIGJ1dHRvbnM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIEljb25cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlQ2xpY2sgKGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZnVuYygpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCAnfmhpbnQuY3NzJztcblxuI2xjLWNvbnRyb2xzIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgbWFyZ2luOiAxcmVtO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHotaW5kZXg6IDI7XG4gIGJvcmRlci1yYWRpdXM6IDI1cHg7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIHBhZGRpbmc6IDAgMC41cmVtO1xuXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDk5MnB4KSB7XG4gICAgcGFkZGluZzogMDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICB9XG5cbiAgYnV0dG9uIHtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgIGNvbG9yOiAjRkZGRkZGO1xuICAgIG9wYWNpdHk6IDAuODtcbiAgICB0ZXh0LXNoYWRvdzogMCAwIDVweCAjMDAwMDAwO1xuICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcbiAgICBwYWRkaW5nOiAuNzVyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBvdXRsaW5lOiBub25lICFpbXBvcnRhbnQ7XG4gICAgb3BhY2l0eTogMC42NTtcblxuICAgICY6aG92ZXIsXG4gICAgJjpmb2N1cyB7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBDb250cm9scy52dWU/MDI0Njg0MjMiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Modal_vue__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Modal_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__Modal_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  data: function data() {\n    return {\n      manifestData: {}\n    };\n  },\n\n  methods: {\n    fetchManifest: function fetchManifest() {\n      var _this = this;\n\n      __WEBPACK_IMPORTED_MODULE_0_axios___default.a.get(this.manifest).then(function (r) {\n        _this.manifestData = r.data;\n      }).catch(function (error) {\n        console.log(error);\n      });\n    }\n  },\n\n  props: {\n    manifest: {\n      type: String,\n      requried: true\n    },\n    id: {\n      type: String,\n      requried: true\n    }\n  },\n\n  components: {\n    Modal: __WEBPACK_IMPORTED_MODULE_1__Modal_vue___default.a\n  },\n\n  created: function created() {\n    this.fetchManifest();\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vTWV0YWRhdGFNb2RhbC52dWU/NDkyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBOztBQUVBO3dCQUVBOztvQkFHQTtBQUZBO0FBSUE7Ozs7QUFFQTs7eUZBQ0E7K0JBQ0E7Z0NBQ0E7b0JBQ0E7QUFDQTtBQUdBO0FBVEE7Ozs7WUFZQTtnQkFFQTtBQUhBOztZQUtBO2dCQUlBO0FBTEE7QUFMQTs7O0FBY0E7QUFIQTs7OEJBSUE7U0FDQTtBQUNBO0FBbENBIiwiZmlsZSI6IjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGlkPVwibGMtbWV0YWRhdGFcIj5cbiAgICA8bW9kYWxcbiAgICAgIDppZD1cImlkXCJcbiAgICAgIHRpdGxlPVwiTWV0YWRhdGFcIj5cbiAgICAgIDx1bCBpZD1cIm1hbmlmZXN0LW1kXCIgdi1mb3I9XCJtIGluIG1hbmlmZXN0RGF0YS5tZXRhZGF0YVwiPlxuICAgICAgICA8bGk+XG4gICAgICAgICAgPHN0cm9uZz57eyBtLmxhYmVsIH19Ojwvc3Ryb25nPlxuICAgICAgICAgICZuYnNwO1xuICAgICAgICAgIDxzcGFuIHYtaHRtbD1cIm0udmFsdWVcIj48L3NwYW4+PC9saT5cbiAgICAgIDwvdWw+XG4gICAgICA8ZGl2IGlkPVwicmlnaHRzXCI+XG4gICAgICAgIDxpbWcgOnNyYz1cIm1hbmlmZXN0RGF0YS5sb2dvXCIgLz5cbiAgICAgICAgPHA+e3sgbWFuaWZlc3REYXRhLmF0dHJpYnV0aW9uIH19PC9wPlxuICAgICAgICA8cD57eyBtYW5pZmVzdERhdGEubGljZW5zZSB9fTwvcD5cbiAgICAgPC9kaXY+XG4gICAgPC9tb2RhbD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vTW9kYWwudnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFuaWZlc3REYXRhOiB7fVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgZmV0Y2hNYW5pZmVzdCAoKSB7XG4gICAgICBheGlvcy5nZXQodGhpcy5tYW5pZmVzdCkudGhlbigocikgPT4ge1xuICAgICAgICB0aGlzLm1hbmlmZXN0RGF0YSA9IHIuZGF0YVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgbWFuaWZlc3Q6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVyaWVkOiB0cnVlXG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdXJpZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIE1vZGFsXG4gIH0sXG5cbiAgY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5mZXRjaE1hbmlmZXN0KClcbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG4jbWFuaWZlc3QtbWQge1xuICBsaXN0LXN0eWxlOiBub25lO1xufVxuXG4jcmlnaHRzIHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBtYXJnaW46IDJyZW07XG59XG5cbmxpIHtcbiAgbWFyZ2luOiAwO1xufVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBNZXRhZGF0YU1vZGFsLnZ1ZT8yZDU3YTk5NyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      show: false\n    };\n  },\n\n  props: {\n    title: String,\n    id: {\n      type: String,\n      requried: true\n    }\n  },\n\n  created: function created() {\n    var _this = this;\n\n    this.$root.$on('show::modal', function (id, triggerEl) {\n      if (id === _this.id) {\n        _this.show = true;\n      }\n    });\n    this.$root.$on('hide::modal', function (id) {\n      if (id === _this.id) {\n        _this.show = false;\n      }\n    });\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vTW9kYWwudnVlP2ZiYTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0E7d0JBRUE7O1lBR0E7QUFGQTtBQUlBOzs7V0FFQTs7WUFFQTtnQkFJQTtBQUxBO0FBRkE7OztBQVFBOzsyREFDQTsyQkFDQTtxQkFDQTtBQUNBO0FBQ0E7Z0RBQ0E7MkJBQ0E7cUJBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQkEiLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDx0cmFuc2l0aW9uIG5hbWU9XCJtb2RhbFwiPlxuICA8ZGl2IDppZD1cImlkXCIgY2xhc3M9XCJtb2RhbFwiIHYtc2hvdz1cInNob3dcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1tYXNrXCJcbiAgICAgICAgQGNsaWNrPVwic2hvdyA9IGZhbHNlXCJcbiAgICAgICAgQGtleXVwLmVzYz1cInNob3cgPSBmYWxzZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtd3JhcHBlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250YWluZXJcIj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgPGgzPnt7IHRpdGxlIH19PC9oMz5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNsb3NlXCIgQGNsaWNrPVwic2hvdyA9IGZhbHNlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XG4gICAgICAgICAgICAgIDxzbG90PlxuICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZm9vdGVyXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBAY2xpY2s9XCJzaG93ID0gZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgIE9LXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8L3RyYW5zaXRpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3c6IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdXJpZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlZCgpIHtcbiAgICB0aGlzLiRyb290LiRvbignc2hvdzo6bW9kYWwnLCAoaWQsIHRyaWdnZXJFbCkgPT4ge1xuICAgICAgaWYgKGlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgIHRoaXMuc2hvdyA9IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiRyb290LiRvbignaGlkZTo6bW9kYWwnLCBpZCA9PiB7XG4gICAgICBpZiAoaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCAnLi4vYXNzZXRzL3N0eWxlL3NldHRpbmdzJztcbkBpbXBvcnQgJy4uL2Fzc2V0cy9zdHlsZS9wYXJ0aWFscy9idXR0b25zJztcblxuLm1vZGFsIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHdpZHRoOiAxMDAlO1xuXG4gIC5tb2RhbC1tYXNrIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgei1pbmRleDogOTk5ODtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAuNSk7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuM3MgZWFzZTtcbiAgfVxuXG4gIC5tb2RhbC13cmFwcGVyIHtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gIH1cblxuICAubW9kYWwtY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgY29sb3I6ICNmZmY7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGdyYXktZGFyaztcbiAgICBtYXJnaW4tdG9wOiAyZW07XG4gICAgbWF4LWhlaWdodDogNTAwcHg7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgbWFyZ2luOiAwcHggYXV0bztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAuMzMpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICRncmF5LWxpZ2h0O1xuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcblxuICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDU3NnB4KSB7XG4gICAgICBtYXgtd2lkdGg6IDUwMHB4O1xuICAgICAgbWFyZ2luOiAzMHB4IGF1dG87XG4gICAgfVxuXG4gICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcbiAgICAgIG1heC13aWR0aDogODAwcHg7XG4gICAgfVxuICB9XG5cbiAgLm1vZGFsLWhlYWRlciB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBwYWRkaW5nOiAyMHB4IDMwcHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICRncmF5LWxpZ2h0O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xuICAgICAgbWFyZ2luOiAwO1xuICAgIH1cblxuICAgIC5jbG9zZSB7XG4gICAgICBwYWRkaW5nOiAwO1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgYmFja2dyb3VuZDogMCAwO1xuICAgICAgYm9yZGVyOiAwO1xuICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgZm9udC1zaXplOiAxLjVyZW07XG4gICAgICBmb250LXdlaWdodDogMjAwO1xuICAgICAgbGluZS1oZWlnaHQ6IDE7XG4gICAgfVxuICB9XG5cbiAgLm1vZGFsLWJvZHkge1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gIH1cblxuICAubW9kYWwtZm9vdGVyIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIHBhZGRpbmc6IDIwcHggMzBweDtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgJGdyYXktbGlnaHQ7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxufVxuXG4ubW9kYWwtZW50ZXIge1xuICBvcGFjaXR5OiAwO1xufVxuXG4ubW9kYWwtbGVhdmUtYWN0aXZlIHtcbiAgb3BhY2l0eTogMDtcbn1cblxuLm1vZGFsLWVudGVyIC5tb2RhbC1jb250YWluZXIsXG4ubW9kYWwtbGVhdmUtYWN0aXZlIC5tb2RhbC1jb250YWluZXIge1xuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4xKTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMHB4KSBzY2FsZSgwLjkpO1xufVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBNb2RhbC52dWU/YzEyNmJjZTgiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  data: function data() {\n    return {\n      contentCollapsed: false\n    };\n  },\n\n  props: {\n    title: {\n      type: String,\n      required: true\n    }\n  },\n\n  computed: {\n    toggleClassObj: function toggleClassObj() {\n      return {\n        toggle: true,\n        active: this.contentCollapsed\n      };\n    }\n  },\n\n  methods: {\n    toggleCollapse: function toggleCollapse() {\n      this.contentCollapsed = !this.contentCollapsed;\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vU2lkZWJhci52dWU/MjZkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO3dCQUVBOzt3QkFHQTtBQUZBO0FBSUE7Ozs7WUFHQTtnQkFJQTtBQUxBO0FBREE7Ozs4Q0FRQTs7Z0JBRUE7cUJBRUE7QUFIQTtBQU1BO0FBUkE7Ozs4Q0FVQTtvQ0FDQTtBQUVBO0FBSkE7QUF2QkEiLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJsdi1zaWRlYmFyXCI+XG4gICAgPGRpdiBjbGFzcz1cImx2LXNpZGViYXItd3JhcHBlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImx2LXNpZGViYXItY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsdi1zaWRlYmFyLWhlYWRlclwiPlxuICAgICAgICAgIDxoND57eyB0aXRsZSB9fTwvaDQ+XG4gICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIDpjbGFzcz1cInRvZ2dsZUNsYXNzT2JqXCJcbiAgICAgICAgICAgIEBjbGljaz1cInRvZ2dsZUNvbGxhcHNlXCI+XG4gICAgICAgICAgICAmI3gyNUIyO1xuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsdi1zaWRlYmFyLWNvbnRlbnRcIiB2LXNob3c9XCIhY29udGVudENvbGxhcHNlZFwiPlxuICAgICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnRDb2xsYXBzZWQ6IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9nZ2xlQ2xhc3NPYmo6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICAgICAgYWN0aXZlOiB0aGlzLmNvbnRlbnRDb2xsYXBzZWRcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHRvZ2dsZUNvbGxhcHNlICgpIHtcbiAgICAgIHRoaXMuY29udGVudENvbGxhcHNlZCA9ICF0aGlzLmNvbnRlbnRDb2xsYXBzZWRcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0ICcuLi9hc3NldHMvc3R5bGUvcGFydGlhbHMvYnV0dG9ucyc7XG5cbi5sdi1zaWRlYmFyIHtcbiAgLmx2LXNpZGViYXItd3JhcHBlciB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHotaW5kZXg6IDI7XG4gICAgcmlnaHQ6IDA7XG4gICAgd2lkdGg6IDM1JTtcbiAgICBtYXJnaW46IDAuOHJlbTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcbiAgICAgIHdpZHRoOiAyNSU7XG4gICAgfVxuXG4gICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcbiAgICAgICAgd2lkdGg6IDI1JTtcbiAgICB9XG4gIH1cblxuICAubHYtc2lkZWJhci1jb250YWluZXIge1xuICAgIGNvbG9yOiAjRkZGRkZGO1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgcGFkZGluZzogMC44cmVtO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiKDg1LCA4NSwgODUpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG5cbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA5OTJweCkge1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICB9XG4gIH1cblxuICAubHYtc2lkZWJhci1oZWFkZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cbiAgICBoNCB7XG4gICAgICBmb250LXNpemU6IDFyZW07XG4gICAgICBmb250LXdlaWdodDogNzAwO1xuICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICB9XG4gIH1cblxuICAudG9nZ2xlIHtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgY29sb3I6ICNGRkZGRkY7XG4gICAgZmxvYXQ6IHJpZ2h0O1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSA1MDBtcztcblxuICAgICYuYWN0aXZlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XG4gICAgfVxuICB9XG59XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFNpZGViYXIudnVlPzQ5NzAxZDNjIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_icons_times_circle__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_awesome_icons_check_circle__ = __webpack_require__(79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_openseadragon__ = __webpack_require__(77);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_openseadragon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_openseadragon__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_openseadragonselection_dist_openseadragonselection__ = __webpack_require__(78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_openseadragonselection_dist_openseadragonselection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_openseadragonselection_dist_openseadragonselection__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_MetadataModal_vue__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_MetadataModal_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__components_MetadataModal_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_Controls_vue__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_Controls_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__components_Controls_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_sidebars_Selection_vue__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_sidebars_Selection_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__components_sidebars_Selection_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__store_js__ = __webpack_require__(6);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      metadataModalId: 'lc-metadata-modal',\n      showMetadataModal: false\n    };\n  },\n\n  props: {\n    viewerOpts: Object,\n    mode: {\n      type: String,\n      default: 'selection'\n    },\n    selectionOpts: Object,\n    baseUrl: {\n      type: String,\n      required: true\n    },\n    tileId: {\n      type: String,\n      required: true\n    },\n    manifest: {\n      type: String,\n      default: null\n    },\n    confirmBeforeUnload: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  components: {\n    MetadataModal: __WEBPACK_IMPORTED_MODULE_5__components_MetadataModal_vue___default.a,\n    Controls: __WEBPACK_IMPORTED_MODULE_6__components_Controls_vue___default.a,\n    SelectionSidebar: __WEBPACK_IMPORTED_MODULE_7__components_sidebars_Selection_vue___default.a,\n    Icon: __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default.a\n  },\n\n  computed: {\n    normalizedViewerOpts: function normalizedViewerOpts() {\n      var defaultOpts = {\n        zoomInButton: 'zoom-in',\n        zoomOutButton: 'zoom-out',\n        homeButton: 'reset-zoom',\n        fullPageButton: 'fullscreen',\n        helpButton: 'show-help-modal',\n        infoButton: 'show-info-modal',\n        gestureSettingsMouse: {\n          clickToZoom: false\n        },\n        gestureSettingsTouch: {\n          dblClickToZoom: false\n        },\n        gestureSettingsPen: {\n          dblClickToZoom: false\n        },\n        selectionEnabled: false\n      };\n      return Object.assign(defaultOpts, this.viewerOpts);\n    },\n    controlButtons: function controlButtons() {\n      var _this = this;\n\n      var buttons = [{\n        id: this.normalizedViewerOpts.zoomInButton,\n        tooltip: 'Zoom in',\n        icon: 'plus-circle'\n      }, {\n        id: this.normalizedViewerOpts.zoomOutButton,\n        tooltip: 'Zoom out',\n        icon: 'minus-circle'\n      }, {\n        id: this.normalizedViewerOpts.homeButton,\n        tooltip: 'Reset Zoom',\n        icon: 'refresh'\n      }, {\n        id: this.normalizedViewerOpts.fullPageButton,\n        tooltip: 'Fullscreen',\n        icon: 'expand'\n      }, {\n        id: this.normalizedViewerOpts.helpButton,\n        tooltip: 'Help',\n        icon: 'question-circle'\n      }];\n\n      // If\n      if (this.manifest) {\n        buttons.push({\n          id: this.normalizedViewerOpts.infoButton,\n          tooltip: 'Details',\n          icon: 'info-circle',\n          click: function click() {\n            _this.$root.$emit('show::modal', _this.metadataModalId);\n          }\n        });\n      }\n      return buttons;\n    }\n  },\n\n  methods: {\n    loadTileSource: function loadTileSource() {\n      var viewer = __WEBPACK_IMPORTED_MODULE_8__store_js__[\"a\" /* store */].state.viewer;\n      var tileSource = this.baseUrl + '/' + this.tileId + '/info.json';\n      viewer.open({\n        type: 'image',\n        tileSource: tileSource,\n        buildPyramid: false\n      });\n    },\n    attachControls: function attachControls() {\n      // TODO: this works for fullscreen controls but should possibly use\n      // https://openseadragon.github.io/docs/OpenSeadragon.Control.html\n      var viewer = __WEBPACK_IMPORTED_MODULE_8__store_js__[\"a\" /* store */].state.viewer;\n      viewer.container.prepend(this.$refs.controls.$el);\n    },\n    setupHandlers: function setupHandlers() {\n      var _this2 = this;\n\n      // Draw an overlay on selection confirmed\n      var viewer = __WEBPACK_IMPORTED_MODULE_8__store_js__[\"a\" /* store */].state.viewer;\n      viewer.addHandler('selection', function (s) {\n        // Convert Viewport to Image rect\n        var rect = new __WEBPACK_IMPORTED_MODULE_3_openseadragon___default.a.Rect(s.x, s.y, s.width, s.height);\n        _this2.addOverlay(rect, 'selection');\n      });\n\n      // Hide loading icon after tile drawn\n      // this.viewer.addHandler('tile-drawn', () => {\n      //   this.loading(false)\n      // })\n\n      window.addEventListener('click', function () {});\n\n      // Don't focus on HUD after fullscreen toggled\n      viewer.addHandler('full-screen', function (evt) {\n        document.querySelector('.openseadragon-canvas').focus();\n      });\n\n      // Confirm before leaving if any overlays have been drawn or forms filled\n      window.onbeforeunload = function () {\n        var msg = 'Unsaved changes will be lost.';\n        if (!_this2.confirmBeforeUnload) {\n          return null;\n        }\n\n        // TODO: Check for selection overlays only\n        if (viewer.currentOverlays.length) {\n          return msg;\n        }\n\n        [].forEach.call(document.querySelectorAll('input'), function (input) {\n          if (input.value.length) {\n            return msg;\n          }\n        });\n      };\n    },\n    addOverlay: function addOverlay(rect, cls) {\n      var viewer = __WEBPACK_IMPORTED_MODULE_8__store_js__[\"a\" /* store */].state.viewer;\n      var el = document.createElement('div');\n      el.id = 'overlay-' + Date.now();\n      el.classList.add('overlay');\n      el.classList.add(cls);\n      viewer.addOverlay({ element: el, location: rect });\n    },\n    editSelection: function editSelection() {},\n    handleOverlayClick: function handleOverlayClick(evt) {\n      var viewer = __WEBPACK_IMPORTED_MODULE_8__store_js__[\"a\" /* store */].state.viewer;\n      if (this.selection) {\n        viewer.removeOverlay(this.id);\n      }\n      evt.preventDefault();\n    },\n    confirm: function confirm(obj) {\n      console.log(obj);\n      this.$emit('confirm', obj);\n    }\n  },\n\n  watch: {\n    tileId: function tileId() {\n      this.loadTileSource();\n    }\n  },\n\n  mounted: function mounted() {\n    var opts = this.normalizedViewerOpts;\n    opts.element = this.$refs.viewer;\n\n    var viewer = __WEBPACK_IMPORTED_MODULE_3_openseadragon___default()(opts);\n    __WEBPACK_IMPORTED_MODULE_8__store_js__[\"a\" /* store */].commit('SET_ITEM', { key: 'viewer', value: viewer });\n\n    // Exposing these options would complicate things\n    var selector = viewer.selection({\n      showConfirmDenyButtons: false,\n      restrictToImage: true,\n      returnPixelCoordinates: false,\n      navImages: {\n        selection: {\n          REST: null,\n          GROUP: null,\n          HOVER: null,\n          DOWN: null\n        }\n      }\n    });\n    __WEBPACK_IMPORTED_MODULE_8__store_js__[\"a\" /* store */].commit('SET_ITEM', { key: 'selector', value: selector });\n    selector.enable();\n    var confirmBtn = new __WEBPACK_IMPORTED_MODULE_3_openseadragon___default.a.Button({\n      element: this.$refs.confirmSelection,\n      clickTimeThreshold: viewer.clickTimeThreshold,\n      clickDistThreshold: viewer.clickDistThreshold,\n      tooltip: 'Comfirm',\n      onRelease: selector.confirm.bind(selector)\n    });\n    selector.element.appendChild(this.$refs.confirmSelection);\n    var cancelBtn = new __WEBPACK_IMPORTED_MODULE_3_openseadragon___default.a.Button({\n      element: this.$refs.cancelSelection,\n      clickTimeThreshold: viewer.clickTimeThreshold,\n      clickDistThreshold: viewer.clickDistThreshold,\n      tooltip: 'Delete',\n      onRelease: selector.cancel.bind(selector)\n    });\n    selector.element.appendChild(this.$refs.cancelSelection);\n\n    this.loadTileSource();\n    this.attachControls();\n    this.setupHandlers();\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vVmlld2VyLnZ1ZT80ZTA4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO3dCQUVBOzt1QkFFQTt5QkFFQTtBQUhBO0FBS0E7OztnQkFFQTs7WUFFQTtlQUVBO0FBSEE7bUJBSUE7O1lBRUE7Z0JBRUE7QUFIQTs7WUFLQTtnQkFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUlBO0FBTEE7QUFuQkE7OztBQTBCQTtBQUNBO0FBQ0E7QUFHQTtBQU5BOzs7MERBUUE7O3NCQUVBO3VCQUNBO29CQUNBO3dCQUNBO29CQUNBO29CQUNBOzt1QkFHQTtBQUZBOzswQkFLQTtBQUZBOzswQkFLQTtBQUZBOzBCQUlBO0FBakJBOzZDQWtCQTtBQUNBOztBQUNBOzs7c0NBRUE7aUJBQ0E7Y0FFQTtBQUpBO3NDQU1BO2lCQUNBO2NBRUE7QUFKQTtzQ0FNQTtpQkFDQTtjQUVBO0FBSkE7c0NBTUE7aUJBQ0E7Y0FFQTtBQUpBO3NDQU1BO2lCQUNBO2NBR0E7QUFMQTs7QUFNQTt5QkFDQTs7d0NBRUE7bUJBQ0E7Z0JBQ0E7a0NBQ0E7bURBQ0E7QUFFQTtBQVBBO0FBUUE7YUFDQTtBQUdBO0FBL0RBOzs7OENBaUVBO2tGQUNBO2lEQUNBOztjQUVBO29CQUNBO3NCQUVBO0FBSkE7QUFLQTs4Q0FDQTtBQUNBO0FBQ0E7a0ZBQ0E7bURBQ0E7QUFDQTs7QUFDQTs7QUFDQTtrRkFDQTtrREFDQTtBQUNBO3VHQUNBO2dDQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O21EQUVBLENBRUE7O0FBQ0E7c0RBQ0E7d0RBQ0E7QUFFQTs7QUFDQTswQ0FDQTtrQkFDQTt5Q0FDQTtpQkFDQTtBQUVBOztBQUNBOzJDQUNBO2lCQUNBO0FBRUE7OzZFQUNBO2tDQUNBO21CQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7K0NBQ0E7a0ZBQ0E7c0NBQ0E7Z0NBQ0E7dUJBQ0E7dUJBQ0E7aURBQ0E7QUFDQTs0Q0FFQSxDQUNBO3lEQUNBO2tGQUNBOzBCQUNBO2tDQUNBO0FBQ0E7VUFDQTtBQUNBO21DQUNBO2tCQUNBOzRCQUNBO0FBR0E7QUFqRkE7Ozs4QkFtRkE7V0FDQTtBQUdBO0FBTEE7OzhCQU1BO29CQUNBOzhCQUVBOzt1RUFDQTt3R0FFQTs7QUFDQTs7OEJBRUE7dUJBQ0E7OEJBQ0E7OztnQkFHQTtpQkFDQTtpQkFDQTtnQkFJQTtBQVBBO0FBREE7QUFKQTswR0FhQTthQUNBOzswQkFFQTtpQ0FDQTtpQ0FDQTtlQUNBO3VDQUVBO0FBTkE7NENBT0E7OzBCQUVBO2lDQUNBO2lDQUNBO2VBQ0E7c0NBRUE7QUFOQTs0Q0FRQTs7U0FDQTtTQUNBO1NBQ0E7QUFDQTtBQTNPQSIsImZpbGUiOiI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBpZD1cImxjLXZpZXdlclwiPlxuXG4gICAgPGNvbnRyb2xzXG4gICAgICByZWY9XCJjb250cm9sc1wiXG4gICAgICA6YnV0dG9ucz1cImNvbnRyb2xCdXR0b25zXCI+XG4gICAgPC9jb250cm9scz5cblxuICAgIDxtZXRhZGF0YS1tb2RhbFxuICAgICAgdi1pZj1cIm1hbmlmZXN0XCJcbiAgICAgIDppZD1cIm1ldGFkYXRhTW9kYWxJZFwiXG4gICAgICA6bWFuaWZlc3Q9XCJtYW5pZmVzdFwiPlxuICAgIDwvbWV0YWRhdGEtbW9kYWw+XG5cbiAgICA8c2VsZWN0aW9uLXNpZGViYXJcbiAgICAgIHYtaWY9XCJtb2RlID09PSAnc2VsZWN0aW9uJ1wiXG4gICAgICBAY29uZmlybT1cImNvbmZpcm1cIj5cbiAgICA8L3NlbGVjdGlvbi1zaWRlYmFyPlxuXG4gICAgPGRpdlxuICAgICAgY2xhc3M9XCJzZWxlY3Rpb24tYnRuXCJcbiAgICAgIGlkPVwiY29uZmlybS1zZWxlY3Rpb25cIlxuICAgICAgcmVmPVwiY29uZmlybVNlbGVjdGlvblwiPlxuICAgICAgPGljb24gbmFtZT1cImNoZWNrLWNpcmNsZVwiPjwvaWNvbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cInNlbGVjdGlvbi1idG5cIlxuICAgICAgaWQ9XCJjYW5jZWwtc2VsZWN0aW9uXCJcbiAgICAgIHJlZj1cImNhbmNlbFNlbGVjdGlvblwiPlxuICAgICAgPGljb24gbmFtZT1cInRpbWVzLWNpcmNsZVwiPjwvaWNvbj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gUmVuZGVyIHZpZXdlciBhZnRlciBhbGwgb3RoZXIgY29tcG9uZW50cyAtLT5cbiAgICA8ZGl2IHJlZj1cInZpZXdlclwiPjwvZGl2PlxuXG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBJY29uIGZyb20gJ3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL3RpbWVzLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvY2hlY2stY2lyY2xlJ1xuaW1wb3J0IE9wZW5TZWFkcmFnb24gZnJvbSAnb3BlbnNlYWRyYWdvbidcbmltcG9ydCAnb3BlbnNlYWRyYWdvbnNlbGVjdGlvbi9kaXN0L29wZW5zZWFkcmFnb25zZWxlY3Rpb24nXG5pbXBvcnQgTWV0YWRhdGFNb2RhbCBmcm9tICdAL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWUnXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnQC9jb21wb25lbnRzL0NvbnRyb2xzLnZ1ZSdcbmltcG9ydCBTZWxlY3Rpb25TaWRlYmFyIGZyb20gJ0AvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlJ1xuaW1wb3J0IHsgc3RvcmUgfSBmcm9tICdAL3N0b3JlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGFNb2RhbElkOiAnbGMtbWV0YWRhdGEtbW9kYWwnLFxuICAgICAgc2hvd01ldGFkYXRhTW9kYWw6IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgdmlld2VyT3B0czogT2JqZWN0LFxuICAgIG1vZGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdzZWxlY3Rpb24nXG4gICAgfSxcbiAgICBzZWxlY3Rpb25PcHRzOiBPYmplY3QsXG4gICAgYmFzZVVybDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHRpbGVJZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIG1hbmlmZXN0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBjb25maXJtQmVmb3JlVW5sb2FkIDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZXRhZGF0YU1vZGFsLFxuICAgIENvbnRyb2xzLFxuICAgIFNlbGVjdGlvblNpZGViYXIsXG4gICAgSWNvblxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgbm9ybWFsaXplZFZpZXdlck9wdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRzID0ge1xuICAgICAgICB6b29tSW5CdXR0b246ICd6b29tLWluJyxcbiAgICAgICAgem9vbU91dEJ1dHRvbjogJ3pvb20tb3V0JyxcbiAgICAgICAgaG9tZUJ1dHRvbjogJ3Jlc2V0LXpvb20nLFxuICAgICAgICBmdWxsUGFnZUJ1dHRvbjogJ2Z1bGxzY3JlZW4nLFxuICAgICAgICBoZWxwQnV0dG9uOiAnc2hvdy1oZWxwLW1vZGFsJyxcbiAgICAgICAgaW5mb0J1dHRvbjogJ3Nob3ctaW5mby1tb2RhbCcsXG4gICAgICAgIGdlc3R1cmVTZXR0aW5nc01vdXNlOiB7XG4gICAgICAgICAgY2xpY2tUb1pvb206IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGdlc3R1cmVTZXR0aW5nc1RvdWNoOiB7XG4gICAgICAgICAgZGJsQ2xpY2tUb1pvb206IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGdlc3R1cmVTZXR0aW5nc1Blbjoge1xuICAgICAgICAgIGRibENsaWNrVG9ab29tOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Rpb25FbmFibGVkOiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdHMsIHRoaXMudmlld2VyT3B0cylcbiAgICB9LFxuICAgIGNvbnRyb2xCdXR0b25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgYnV0dG9ucyA9IFt7XG4gICAgICAgIGlkOiB0aGlzLm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLnpvb21JbkJ1dHRvbixcbiAgICAgICAgdG9vbHRpcDogJ1pvb20gaW4nLFxuICAgICAgICBpY29uOiAncGx1cy1jaXJjbGUnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogdGhpcy5ub3JtYWxpemVkVmlld2VyT3B0cy56b29tT3V0QnV0dG9uLFxuICAgICAgICB0b29sdGlwOiAnWm9vbSBvdXQnLFxuICAgICAgICBpY29uOiAnbWludXMtY2lyY2xlJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IHRoaXMubm9ybWFsaXplZFZpZXdlck9wdHMuaG9tZUJ1dHRvbixcbiAgICAgICAgdG9vbHRpcDogJ1Jlc2V0IFpvb20nLFxuICAgICAgICBpY29uOiAncmVmcmVzaCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiB0aGlzLm5vcm1hbGl6ZWRWaWV3ZXJPcHRzLmZ1bGxQYWdlQnV0dG9uLFxuICAgICAgICB0b29sdGlwOiAnRnVsbHNjcmVlbicsXG4gICAgICAgIGljb246ICdleHBhbmQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogdGhpcy5ub3JtYWxpemVkVmlld2VyT3B0cy5oZWxwQnV0dG9uLFxuICAgICAgICB0b29sdGlwOiAnSGVscCcsXG4gICAgICAgIGljb246ICdxdWVzdGlvbi1jaXJjbGUnXG4gICAgICB9XVxuXG4gICAgICAvLyBJZlxuICAgICAgaWYgKHRoaXMubWFuaWZlc3QpIHtcbiAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogdGhpcy5ub3JtYWxpemVkVmlld2VyT3B0cy5pbmZvQnV0dG9uLFxuICAgICAgICAgIHRvb2x0aXA6ICdEZXRhaWxzJyxcbiAgICAgICAgICBpY29uOiAnaW5mby1jaXJjbGUnLFxuICAgICAgICAgIGNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiRyb290LiRlbWl0KCdzaG93Ojptb2RhbCcsIHRoaXMubWV0YWRhdGFNb2RhbElkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBidXR0b25zXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBsb2FkVGlsZVNvdXJjZSAoKSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIGNvbnN0IHRpbGVTb3VyY2UgPSBgJHt0aGlzLmJhc2VVcmx9LyR7dGhpcy50aWxlSWR9L2luZm8uanNvbmBcbiAgICAgIHZpZXdlci5vcGVuKHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgdGlsZVNvdXJjZTogdGlsZVNvdXJjZSxcbiAgICAgICAgYnVpbGRQeXJhbWlkOiBmYWxzZVxuICAgICAgfSlcbiAgICB9LFxuICAgIGF0dGFjaENvbnRyb2xzICgpIHtcbiAgICAgIC8vIFRPRE86IHRoaXMgd29ya3MgZm9yIGZ1bGxzY3JlZW4gY29udHJvbHMgYnV0IHNob3VsZCBwb3NzaWJseSB1c2VcbiAgICAgIC8vIGh0dHBzOi8vb3BlbnNlYWRyYWdvbi5naXRodWIuaW8vZG9jcy9PcGVuU2VhZHJhZ29uLkNvbnRyb2wuaHRtbFxuICAgICAgY29uc3Qgdmlld2VyID0gc3RvcmUuc3RhdGUudmlld2VyXG4gICAgICB2aWV3ZXIuY29udGFpbmVyLnByZXBlbmQodGhpcy4kcmVmcy5jb250cm9scy4kZWwpXG4gICAgfSxcbiAgICBzZXR1cEhhbmRsZXJzICgpIHtcbiAgICAgIC8vIERyYXcgYW4gb3ZlcmxheSBvbiBzZWxlY3Rpb24gY29uZmlybWVkXG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIHZpZXdlci5hZGRIYW5kbGVyKCdzZWxlY3Rpb24nLCAocykgPT4ge1xuICAgICAgICAvLyBDb252ZXJ0IFZpZXdwb3J0IHRvIEltYWdlIHJlY3RcbiAgICAgICAgY29uc3QgcmVjdCA9IG5ldyBPcGVuU2VhZHJhZ29uLlJlY3Qocy54LCBzLnksIHMud2lkdGgsIHMuaGVpZ2h0KVxuICAgICAgICB0aGlzLmFkZE92ZXJsYXkocmVjdCwgJ3NlbGVjdGlvbicpXG4gICAgICB9KVxuXG4gICAgICAvLyBIaWRlIGxvYWRpbmcgaWNvbiBhZnRlciB0aWxlIGRyYXduXG4gICAgICAvLyB0aGlzLnZpZXdlci5hZGRIYW5kbGVyKCd0aWxlLWRyYXduJywgKCkgPT4ge1xuICAgICAgLy8gICB0aGlzLmxvYWRpbmcoZmFsc2UpXG4gICAgICAvLyB9KVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIH0pXG5cbiAgICAgIC8vIERvbid0IGZvY3VzIG9uIEhVRCBhZnRlciBmdWxsc2NyZWVuIHRvZ2dsZWRcbiAgICAgIHZpZXdlci5hZGRIYW5kbGVyKCdmdWxsLXNjcmVlbicsIChldnQpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9wZW5zZWFkcmFnb24tY2FudmFzJykuZm9jdXMoKVxuICAgICAgfSlcblxuICAgICAgLy8gQ29uZmlybSBiZWZvcmUgbGVhdmluZyBpZiBhbnkgb3ZlcmxheXMgaGF2ZSBiZWVuIGRyYXduIG9yIGZvcm1zIGZpbGxlZFxuICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBtc2cgPSAnVW5zYXZlZCBjaGFuZ2VzIHdpbGwgYmUgbG9zdC4nXG4gICAgICAgIGlmICghdGhpcy5jb25maXJtQmVmb3JlVW5sb2FkKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBDaGVjayBmb3Igc2VsZWN0aW9uIG92ZXJsYXlzIG9ubHlcbiAgICAgICAgaWYgKHZpZXdlci5jdXJyZW50T3ZlcmxheXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG1zZ1xuICAgICAgICB9XG5cbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JyksIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZ1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBhZGRPdmVybGF5KHJlY3QsIGNscykge1xuICAgICAgY29uc3Qgdmlld2VyID0gc3RvcmUuc3RhdGUudmlld2VyXG4gICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBlbC5pZCA9IGBvdmVybGF5LSR7RGF0ZS5ub3coKX1gXG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKCdvdmVybGF5JylcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKVxuICAgICAgdmlld2VyLmFkZE92ZXJsYXkoeyBlbGVtZW50OiBlbCwgbG9jYXRpb246IHJlY3QgfSlcbiAgICB9LFxuICAgIGVkaXRTZWxlY3Rpb24oKSB7XG5cbiAgICB9LFxuICAgIGhhbmRsZU92ZXJsYXlDbGljayAoZXZ0KSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICB2aWV3ZXIucmVtb3ZlT3ZlcmxheSh0aGlzLmlkKVxuICAgICAgfVxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICB9LFxuICAgIGNvbmZpcm0gKG9iaikge1xuICAgICAgY29uc29sZS5sb2cob2JqKVxuICAgICAgdGhpcy4kZW1pdCgnY29uZmlybScsIG9iailcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICB0aWxlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubG9hZFRpbGVTb3VyY2UoKVxuICAgIH1cbiAgfSxcblxuICBtb3VudGVkICgpIHtcbiAgICBsZXQgb3B0cyA9IHRoaXMubm9ybWFsaXplZFZpZXdlck9wdHNcbiAgICBvcHRzLmVsZW1lbnQgPSB0aGlzLiRyZWZzLnZpZXdlclxuXG4gICAgY29uc3Qgdmlld2VyID0gT3BlblNlYWRyYWdvbihvcHRzKVxuICAgIHN0b3JlLmNvbW1pdCgnU0VUX0lURU0nLCB7IGtleTogJ3ZpZXdlcicsIHZhbHVlOiB2aWV3ZXIgfSlcblxuICAgIC8vIEV4cG9zaW5nIHRoZXNlIG9wdGlvbnMgd291bGQgY29tcGxpY2F0ZSB0aGluZ3NcbiAgICBjb25zdCBzZWxlY3RvciA9IHZpZXdlci5zZWxlY3Rpb24oe1xuICAgICAgc2hvd0NvbmZpcm1EZW55QnV0dG9uczogZmFsc2UsXG4gICAgICByZXN0cmljdFRvSW1hZ2U6IHRydWUsXG4gICAgICByZXR1cm5QaXhlbENvb3JkaW5hdGVzOiBmYWxzZSxcbiAgICAgIG5hdkltYWdlczoge1xuICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICBSRVNUOiBudWxsLFxuICAgICAgICAgIEdST1VQOiBudWxsLFxuICAgICAgICAgIEhPVkVSOiBudWxsLFxuICAgICAgICAgIERPV046IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgc3RvcmUuY29tbWl0KCdTRVRfSVRFTScsIHsga2V5OiAnc2VsZWN0b3InLCB2YWx1ZTogc2VsZWN0b3IgfSlcbiAgICBzZWxlY3Rvci5lbmFibGUoKVxuICAgIGNvbnN0IGNvbmZpcm1CdG4gPSBuZXcgT3BlblNlYWRyYWdvbi5CdXR0b24oe1xuICAgICAgZWxlbWVudDogdGhpcy4kcmVmcy5jb25maXJtU2VsZWN0aW9uLFxuICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB2aWV3ZXIuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB2aWV3ZXIuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgdG9vbHRpcDogJ0NvbWZpcm0nLFxuICAgICAgb25SZWxlYXNlOiBzZWxlY3Rvci5jb25maXJtLmJpbmQoc2VsZWN0b3IpXG4gICAgfSlcbiAgICBzZWxlY3Rvci5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuJHJlZnMuY29uZmlybVNlbGVjdGlvbik7XG4gICAgY29uc3QgY2FuY2VsQnRuID0gbmV3IE9wZW5TZWFkcmFnb24uQnV0dG9uKHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuJHJlZnMuY2FuY2VsU2VsZWN0aW9uLFxuICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB2aWV3ZXIuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB2aWV3ZXIuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgdG9vbHRpcDogJ0RlbGV0ZScsXG4gICAgICBvblJlbGVhc2U6IHNlbGVjdG9yLmNhbmNlbC5iaW5kKHNlbGVjdG9yKVxuICAgIH0pXG4gICAgc2VsZWN0b3IuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLiRyZWZzLmNhbmNlbFNlbGVjdGlvbik7XG5cbiAgICB0aGlzLmxvYWRUaWxlU291cmNlKClcbiAgICB0aGlzLmF0dGFjaENvbnRyb2xzKClcbiAgICB0aGlzLnNldHVwSGFuZGxlcnMoKVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5cbiNsYy12aWV3ZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHdpZHRoOiBhdXRvO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwMDAwO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4ub3BlbnNlYWRyYWdvbi1jb250YWluZXIge1xuICBoZWlnaHQ6IDEwMHZoO1xuICBtaW4taGVpZ2h0OiA2MDBweDtcblxuICAub3BlbnNlYWRyYWdvbi1tZXNzYWdlIHtcbiAgICBjb2xvcjogI0ZGRkZGRjtcbiAgfVxuXG4gIC52aWV3ZXItaGludCB7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdG9wOiA4MHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMzAwbXM7XG5cbiAgICAmLnNob3cge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG5cbiAgICAudmlld2VyLWhpbnQtdGV4dCB7XG4gICAgICBwYWRkaW5nOiAuNXJlbTtcbiAgICAgIGNvbG9yOiAjRkZGRkZGO1xuICAgICAgd2lkdGg6IDQwMHB4O1xuICAgICAgbWFyZ2luOjBweCBhdXRvO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICB9XG4gIH1cblxuICAuc2VsZWN0aW9uLWJveCB7XG4gICAgdHJhbnNmb3JtOiBub25lICFpbXBvcnRhbnQ7ICAvKiogRGlzYWJsZSByb3RhdGlvbiAqL1xuICAgIG91dGxpbmU6IDk5OTlweCBzb2xpZCByZ2JhKCMwMDAwMDAsIC42KTtcblxuICAgIC5zZWxlY3Rpb24tYnRuIHtcbiAgICAgIGNvbG9yOiAjZmZmO1xuICAgICAgZGlzcGxheTogZmxleCAhaW1wb3J0YW50O1xuICAgICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XG4gICAgICByaWdodDogMDtcblxuICAgICAgJiNjb25maXJtLXNlbGVjdGlvbiB7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpIHRyYW5zbGF0ZVkoMTVweCk7XG4gICAgICB9XG5cbiAgICAgICYjY2FuY2VsLXNlbGVjdGlvbiB7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIwcHgpIHRyYW5zbGF0ZVkoLTE1cHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC5vdmVybGF5IHtcbiAgICB6LWluZGV4OiA1MDtcblxuICAgICYuc2VsZWN0aW9uIHtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkICMzNDk4REI7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCMzNDk4REIsIDAuMik7XG4gICAgICBvcGFjaXR5OiAuNjtcblxuICAgICAgJjpob3ZlcixcbiAgICAgICY6Zm9jdXMge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFZpZXdlci52dWU/MTcxYzYxYTQiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_awesome_icons_times_circle__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_awesome_icons_pencil__ = __webpack_require__(83);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__store_js__ = __webpack_require__(6);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  computed: {\n    selections: function selections() {\n      var viewer = __WEBPACK_IMPORTED_MODULE_4__store_js__["a" /* store */].state.viewer;\n      var overlays = typeof viewer.currentOverlays !== \'undefined\' ? viewer.currentOverlays : [];\n      var selections = overlays.filter(function (overlay) {\n        return overlay.element.classList.contains(\'selection\');\n      });\n      return selections.map(function (s) {\n        var bounds = s.getBounds(viewer.viewport);\n        var vpRect = new OpenSeadragon.SelectionRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        return {\n          id: s.element.id,\n          rect: viewer.viewport.viewportToImageRectangle(vpRect)\n        };\n      });\n    }\n  },\n\n  components: {\n    Icon: __WEBPACK_IMPORTED_MODULE_0_vue_awesome_components_Icon_vue___default.a,\n    Sidebar: __WEBPACK_IMPORTED_MODULE_3__components_Sidebar_vue___default.a\n  },\n\n  methods: {\n    deleteSelection: function deleteSelection(selection) {\n      var viewer = __WEBPACK_IMPORTED_MODULE_4__store_js__["a" /* store */].state.viewer;\n      viewer.removeOverlay(selection.id);\n    },\n    editSelection: function editSelection(selection) {\n      var viewer = __WEBPACK_IMPORTED_MODULE_4__store_js__["a" /* store */].state.viewer;\n      var selector = __WEBPACK_IMPORTED_MODULE_4__store_js__["a" /* store */].state.selector;\n      var overlay = viewer.getOverlayById(selection.id);\n      var bounds = overlay.getBounds(viewer.viewport);\n      this.deleteSelection(selection);\n      selector.rect = new OpenSeadragon.SelectionRect(bounds.x, bounds.y, bounds.width, bounds.height);\n      selector.draw();\n      selector.enable();\n    },\n    confirm: function confirm() {\n      var viewer = __WEBPACK_IMPORTED_MODULE_4__store_js__["a" /* store */].state.viewer;\n      this.$emit(\'confirm\', this.selections);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vU2VsZWN0aW9uLnZ1ZT82YjkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7c0NBR0E7a0ZBQ0E7dURBQ0EscUJBQ0Esa0JBQ0E7MERBQ0E7a0RBQ0E7QUFDQTt5Q0FDQTt3Q0FDQTs0REFDQSxVQUNBLFVBQ0EsY0FDQTs7d0JBRUE7eURBRUE7QUFIQTtBQUlBO0FBR0E7QUF0QkE7OztBQXdCQTtBQUdBO0FBSkE7Ozt5REFNQTtrRkFDQTtxQ0FDQTtBQUNBO3FEQUNBO2tGQUNBO29GQUNBO29EQUNBOzRDQUNBOzJCQUNBOzZEQUNBLFVBQ0EsVUFDQSxjQUNBO2VBQ0E7ZUFDQTtBQUNBO2dDQUNBO2tGQUNBO2lDQUNBO0FBRUE7QUF0QkE7QUE3QkEiLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJsdi1zZWxlY3Rpb24tc2lkZWJhclwiPlxuICAgIDxzaWRlYmFyIHRpdGxlPVwiU2VsZWN0aW9uc1wiPlxuICAgICAgPHVsPlxuICAgICAgICA8bGlcbiAgICAgICAgICB2LWZvcj1cInMgaW4gc2VsZWN0aW9uc1wiXG4gICAgICAgICAgOmtleT1cInMuaWRcIj5cbiAgICAgICAgICB7eyBzLmlkIH19XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxzcGFuIEBjbGljaz1cImVkaXRTZWxlY3Rpb24ocylcIj5cbiAgICAgICAgICAgICAgPGljb24gbmFtZT1cInBlbmNpbFwiPjwvaWNvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIEBjbGljaz1cImRlbGV0ZVNlbGVjdGlvbihzKVwiPlxuICAgICAgICAgICAgICA8aWNvbiBuYW1lPVwidGltZXMtY2lyY2xlXCI+PC9pY29uPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2xpPlxuICAgICAgPC91bD5cbiAgICAgIDxidXR0b24gQGNsaWNrPVwiY29uZmlybVwiPlxuICAgICAgICBDb25maXJtXG4gICAgICA8L2J1dHRvbj5cbiAgICA8L3NpZGViYXI+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBJY29uIGZyb20gJ3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL3RpbWVzLWNpcmNsZSdcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvcGVuY2lsJ1xuaW1wb3J0IFNpZGViYXIgZnJvbSAnQC9jb21wb25lbnRzL1NpZGViYXIudnVlJ1xuaW1wb3J0IHsgc3RvcmUgfSBmcm9tICdAL3N0b3JlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXB1dGVkOiB7XG4gICAgc2VsZWN0aW9ucyAoKSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIGNvbnN0IG92ZXJsYXlzID0gdHlwZW9mIHZpZXdlci5jdXJyZW50T3ZlcmxheXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyB2aWV3ZXIuY3VycmVudE92ZXJsYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiBbXVxuICAgICAgY29uc3Qgc2VsZWN0aW9ucyAgPSBvdmVybGF5cy5maWx0ZXIoZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXkuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGlvbicpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHNlbGVjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHMuZ2V0Qm91bmRzKHZpZXdlci52aWV3cG9ydClcbiAgICAgICAgY29uc3QgdnBSZWN0ID0gbmV3IE9wZW5TZWFkcmFnb24uU2VsZWN0aW9uUmVjdChib3VuZHMueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLmhlaWdodClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogcy5lbGVtZW50LmlkLFxuICAgICAgICAgIHJlY3Q6IHZpZXdlci52aWV3cG9ydC52aWV3cG9ydFRvSW1hZ2VSZWN0YW5nbGUodnBSZWN0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgSWNvbixcbiAgICBTaWRlYmFyXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGRlbGV0ZVNlbGVjdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIHZpZXdlci5yZW1vdmVPdmVybGF5KHNlbGVjdGlvbi5pZClcbiAgICB9LFxuICAgIGVkaXRTZWxlY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgY29uc3Qgdmlld2VyID0gc3RvcmUuc3RhdGUudmlld2VyXG4gICAgICBjb25zdCBzZWxlY3RvciA9IHN0b3JlLnN0YXRlLnNlbGVjdG9yXG4gICAgICBjb25zdCBvdmVybGF5ID0gdmlld2VyLmdldE92ZXJsYXlCeUlkKHNlbGVjdGlvbi5pZClcbiAgICAgIGNvbnN0IGJvdW5kcyA9IG92ZXJsYXkuZ2V0Qm91bmRzKHZpZXdlci52aWV3cG9ydClcbiAgICAgIHRoaXMuZGVsZXRlU2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgICAgIHNlbGVjdG9yLnJlY3QgPSBuZXcgT3BlblNlYWRyYWdvbi5TZWxlY3Rpb25SZWN0KGJvdW5kcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuaGVpZ2h0KVxuICAgICAgc2VsZWN0b3IuZHJhdygpXG4gICAgICBzZWxlY3Rvci5lbmFibGUoKVxuICAgIH0sXG4gICAgY29uZmlybSAoKSB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBzdG9yZS5zdGF0ZS52aWV3ZXJcbiAgICAgIHRoaXMuJGVtaXQoJ2NvbmZpcm0nLCB0aGlzLnNlbGVjdGlvbnMpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCAnLi4vLi4vYXNzZXRzL3N0eWxlL3NldHRpbmdzJztcblxuI2x2LXNlbGVjdGlvbi1zaWRlYmFyIHtcbiAgdWwge1xuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgICBoZWlnaHQ6IDMwMHB4O1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgcGFkZGluZzogMC44cmVtO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICRncmF5O1xuXG4gICAgbGkge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XG5cbiAgICAgICY6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDAuNzVyZW07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3ZnIHtcbiAgICBtYXJnaW4tbGVmdDogNXB4O1xuICB9XG5cbiAgYnV0dG9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1hcmdpbi1yaWdodDogYXV0bztcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgfVxufVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBTZWxlY3Rpb24udnVlPzBkMTJmYzYwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, "button[data-v-060c0520]{font-size:.85em;background-color:transparent;border:1px solid #fff;color:#fff;padding:8px 26px;text-align:center;text-decoration:none;display:inline-block;touch-action:manipulation}.modal[data-v-060c0520]{position:absolute;height:100%;width:100%}.modal .modal-mask[data-v-060c0520]{position:fixed;z-index:9998;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);display:table;transition:opacity .3s ease}.modal .modal-wrapper[data-v-060c0520]{display:table-cell;vertical-align:middle}.modal .modal-container[data-v-060c0520]{display:flex;flex-direction:column;color:#fff;background-color:#111;margin-top:2em;max-height:500px;width:auto;margin:0 auto;overflow:hidden;font-size:14px;box-shadow:0 2px 8px rgba(0,0,0,.33);border:1px solid #ddd;transition:all .3s ease}@media screen and (min-width:576px){.modal .modal-container[data-v-060c0520]{max-width:500px;margin:30px auto}}@media screen and (min-width:992px){.modal .modal-container[data-v-060c0520]{max-width:800px}}.modal .modal-header[data-v-060c0520]{margin-top:0;padding:20px 30px;border-bottom:1px solid #ddd;flex-direction:row;display:flex;justify-content:space-between;align-items:center}.modal .modal-header h1[data-v-060c0520],.modal .modal-header h2[data-v-060c0520],.modal .modal-header h3[data-v-060c0520],.modal .modal-header h4[data-v-060c0520],.modal .modal-header h5[data-v-060c0520],.modal .modal-header h6[data-v-060c0520]{margin:0}.modal .modal-header .close[data-v-060c0520]{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none;float:right;font-size:1.5rem;font-weight:200;line-height:1}.modal .modal-body[data-v-060c0520]{padding:20px;overflow:auto}.modal .modal-footer[data-v-060c0520]{margin-top:0;padding:20px 30px;border-top:1px solid #ddd;flex-direction:row;display:flex;justify-content:flex-end;align-items:center}.modal-enter[data-v-060c0520],.modal-leave-active[data-v-060c0520]{opacity:0}.modal-enter .modal-container[data-v-060c0520],.modal-leave-active .modal-container[data-v-060c0520]{-webkit-transform:scale(1.1);transform:translateY(-10px) scale(.9)}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlP2U4MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxpREFBa0QsZ0JBQWdCLDZCQUE2QixzQkFBc0IsV0FBVyxpQkFBaUIsa0JBQWtCLHFCQUFxQixxQkFBcUIsMEJBQTBCLHdCQUF3QixrQkFBa0IsWUFBWSxXQUFXLG9DQUFvQyxlQUFlLGFBQWEsTUFBTSxPQUFPLFdBQVcsWUFBWSxnQ0FBZ0MsY0FBYyw0QkFBNEIsdUNBQXVDLG1CQUFtQixzQkFBc0IseUNBQXlDLGFBQWEsc0JBQXNCLFdBQVcsc0JBQXNCLGVBQWUsaUJBQWlCLFdBQVcsY0FBYyxnQkFBZ0IsZUFBZSxxQ0FBcUMsc0JBQXNCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGdCQUFnQixrQkFBa0Isb0NBQW9DLHlDQUF5QyxpQkFBaUIsc0NBQXNDLGFBQWEsa0JBQWtCLDZCQUE2QixtQkFBbUIsYUFBYSw4QkFBOEIsbUJBQW1CLHNQQUFzUCxTQUFTLDZDQUE2QyxVQUFVLGVBQWUsZUFBZSxTQUFTLHdCQUF3QixZQUFZLGlCQUFpQixnQkFBZ0IsY0FBYyxvQ0FBb0MsYUFBYSxjQUFjLHNDQUFzQyxhQUFhLGtCQUFrQiwwQkFBMEIsbUJBQW1CLGFBQWEseUJBQXlCLG1CQUFtQixtRUFBbUUsVUFBVSxxR0FBcUcsNkJBQTZCLHNDQUFzQzs7QUFFN2tFIiwiZmlsZSI6IjY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYnV0dG9uW2RhdGEtdi0wNjBjMDUyMF17Zm9udC1zaXplOi44NWVtO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjFweCBzb2xpZCAjZmZmO2NvbG9yOiNmZmY7cGFkZGluZzo4cHggMjZweDt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jazt0b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9ufS5tb2RhbFtkYXRhLXYtMDYwYzA1MjBde3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCV9Lm1vZGFsIC5tb2RhbC1tYXNrW2RhdGEtdi0wNjBjMDUyMF17cG9zaXRpb246Zml4ZWQ7ei1pbmRleDo5OTk4O3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuNSk7ZGlzcGxheTp0YWJsZTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGVhc2V9Lm1vZGFsIC5tb2RhbC13cmFwcGVyW2RhdGEtdi0wNjBjMDUyMF17ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubW9kYWwgLm1vZGFsLWNvbnRhaW5lcltkYXRhLXYtMDYwYzA1MjBde2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMxMTE7bWFyZ2luLXRvcDoyZW07bWF4LWhlaWdodDo1MDBweDt3aWR0aDphdXRvO21hcmdpbjowIGF1dG87b3ZlcmZsb3c6aGlkZGVuO2ZvbnQtc2l6ZToxNHB4O2JveC1zaGFkb3c6MCAycHggOHB4IHJnYmEoMCwwLDAsLjMzKTtib3JkZXI6MXB4IHNvbGlkICNkZGQ7dHJhbnNpdGlvbjphbGwgLjNzIGVhc2V9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo1NzZweCl7Lm1vZGFsIC5tb2RhbC1jb250YWluZXJbZGF0YS12LTA2MGMwNTIwXXttYXgtd2lkdGg6NTAwcHg7bWFyZ2luOjMwcHggYXV0b319QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo5OTJweCl7Lm1vZGFsIC5tb2RhbC1jb250YWluZXJbZGF0YS12LTA2MGMwNTIwXXttYXgtd2lkdGg6ODAwcHh9fS5tb2RhbCAubW9kYWwtaGVhZGVyW2RhdGEtdi0wNjBjMDUyMF17bWFyZ2luLXRvcDowO3BhZGRpbmc6MjBweCAzMHB4O2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNkZGQ7ZmxleC1kaXJlY3Rpb246cm93O2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXJ9Lm1vZGFsIC5tb2RhbC1oZWFkZXIgaDFbZGF0YS12LTA2MGMwNTIwXSwubW9kYWwgLm1vZGFsLWhlYWRlciBoMltkYXRhLXYtMDYwYzA1MjBdLC5tb2RhbCAubW9kYWwtaGVhZGVyIGgzW2RhdGEtdi0wNjBjMDUyMF0sLm1vZGFsIC5tb2RhbC1oZWFkZXIgaDRbZGF0YS12LTA2MGMwNTIwXSwubW9kYWwgLm1vZGFsLWhlYWRlciBoNVtkYXRhLXYtMDYwYzA1MjBdLC5tb2RhbCAubW9kYWwtaGVhZGVyIGg2W2RhdGEtdi0wNjBjMDUyMF17bWFyZ2luOjB9Lm1vZGFsIC5tb2RhbC1oZWFkZXIgLmNsb3NlW2RhdGEtdi0wNjBjMDUyMF17cGFkZGluZzowO2N1cnNvcjpwb2ludGVyO2JhY2tncm91bmQ6MCAwO2JvcmRlcjowOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2Zsb2F0OnJpZ2h0O2ZvbnQtc2l6ZToxLjVyZW07Zm9udC13ZWlnaHQ6MjAwO2xpbmUtaGVpZ2h0OjF9Lm1vZGFsIC5tb2RhbC1ib2R5W2RhdGEtdi0wNjBjMDUyMF17cGFkZGluZzoyMHB4O292ZXJmbG93OmF1dG99Lm1vZGFsIC5tb2RhbC1mb290ZXJbZGF0YS12LTA2MGMwNTIwXXttYXJnaW4tdG9wOjA7cGFkZGluZzoyMHB4IDMwcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2RkZDtmbGV4LWRpcmVjdGlvbjpyb3c7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZDthbGlnbi1pdGVtczpjZW50ZXJ9Lm1vZGFsLWVudGVyW2RhdGEtdi0wNjBjMDUyMF0sLm1vZGFsLWxlYXZlLWFjdGl2ZVtkYXRhLXYtMDYwYzA1MjBde29wYWNpdHk6MH0ubW9kYWwtZW50ZXIgLm1vZGFsLWNvbnRhaW5lcltkYXRhLXYtMDYwYzA1MjBdLC5tb2RhbC1sZWF2ZS1hY3RpdmUgLm1vZGFsLWNvbnRhaW5lcltkYXRhLXYtMDYwYzA1MjBdey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEuMSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpIHNjYWxlKC45KX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDYwYzA1MjBcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL01vZGFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, "/*! Hint.css - v2.5.0 - 2017-04-23\\n* http://kushagragour.in/lab/hint/\\n* Copyright (c) 2017 Kushagra Gour */[class*=hint--][data-v-33163bc3]{position:relative;display:inline-block}[class*=hint--][data-v-33163bc3]:after,[class*=hint--][data-v-33163bc3]:before{position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);visibility:hidden;opacity:0;z-index:1000000;pointer-events:none;transition:.3s ease;transition-delay:0ms}[class*=hint--][data-v-33163bc3]:hover:after,[class*=hint--][data-v-33163bc3]:hover:before{visibility:visible;opacity:1;transition-delay:.1s}[class*=hint--][data-v-33163bc3]:before{content:\\"\\";position:absolute;background:transparent;border:6px solid transparent;z-index:1000001}[class*=hint--][data-v-33163bc3]:after{background:#383838;color:#fff;padding:8px 10px;font-size:12px;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;line-height:12px;white-space:nowrap}[class*=hint--][aria-label][data-v-33163bc3]:after{content:attr(aria-label)}[class*=hint--][data-hint][data-v-33163bc3]:after{content:attr(data-hint)}[aria-label=\\"\\"][data-v-33163bc3]:after,[aria-label=\\"\\"][data-v-33163bc3]:before,[data-hint=\\"\\"][data-v-33163bc3]:after,[data-hint=\\"\\"][data-v-33163bc3]:before{display:none!important}.hint--top-left[data-v-33163bc3]:before,.hint--top-right[data-v-33163bc3]:before,.hint--top[data-v-33163bc3]:before{border-top-color:#383838}.hint--bottom-left[data-v-33163bc3]:before,.hint--bottom-right[data-v-33163bc3]:before,.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#383838}.hint--left[data-v-33163bc3]:before{border-left-color:#383838}.hint--right[data-v-33163bc3]:before{border-right-color:#383838}.hint--top[data-v-33163bc3]:before{margin-bottom:-11px}.hint--top[data-v-33163bc3]:after,.hint--top[data-v-33163bc3]:before{bottom:100%;left:50%}.hint--top[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--top[data-v-33163bc3]:after{-webkit-transform:translateX(-50%);transform:translateX(-50%)}.hint--top[data-v-33163bc3]:hover:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--top[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-50%) translateY(-8px);transform:translateX(-50%) translateY(-8px)}.hint--bottom[data-v-33163bc3]:before{margin-top:-11px}.hint--bottom[data-v-33163bc3]:after,.hint--bottom[data-v-33163bc3]:before{top:100%;left:50%}.hint--bottom[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--bottom[data-v-33163bc3]:after{-webkit-transform:translateX(-50%);transform:translateX(-50%)}.hint--bottom[data-v-33163bc3]:hover:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--bottom[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-50%) translateY(8px);transform:translateX(-50%) translateY(8px)}.hint--right[data-v-33163bc3]:before{margin-left:-11px;margin-bottom:-6px}.hint--right[data-v-33163bc3]:after{margin-bottom:-14px}.hint--right[data-v-33163bc3]:after,.hint--right[data-v-33163bc3]:before{left:100%;bottom:50%}.hint--right[data-v-33163bc3]:hover:after,.hint--right[data-v-33163bc3]:hover:before{-webkit-transform:translateX(8px);transform:translateX(8px)}.hint--left[data-v-33163bc3]:before{margin-right:-11px;margin-bottom:-6px}.hint--left[data-v-33163bc3]:after{margin-bottom:-14px}.hint--left[data-v-33163bc3]:after,.hint--left[data-v-33163bc3]:before{right:100%;bottom:50%}.hint--left[data-v-33163bc3]:hover:after,.hint--left[data-v-33163bc3]:hover:before{-webkit-transform:translateX(-8px);transform:translateX(-8px)}.hint--top-left[data-v-33163bc3]:before{margin-bottom:-11px}.hint--top-left[data-v-33163bc3]:after,.hint--top-left[data-v-33163bc3]:before{bottom:100%;left:50%}.hint--top-left[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--top-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%);transform:translateX(-100%);margin-left:12px}.hint--top-left[data-v-33163bc3]:hover:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--top-left[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-100%) translateY(-8px);transform:translateX(-100%) translateY(-8px)}.hint--top-right[data-v-33163bc3]:before{margin-bottom:-11px}.hint--top-right[data-v-33163bc3]:after,.hint--top-right[data-v-33163bc3]:before{bottom:100%;left:50%}.hint--top-right[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--top-right[data-v-33163bc3]:after{-webkit-transform:translateX(0);transform:translateX(0);margin-left:-12px}.hint--top-right[data-v-33163bc3]:hover:after,.hint--top-right[data-v-33163bc3]:hover:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--bottom-left[data-v-33163bc3]:before{margin-top:-11px}.hint--bottom-left[data-v-33163bc3]:after,.hint--bottom-left[data-v-33163bc3]:before{top:100%;left:50%}.hint--bottom-left[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--bottom-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%);transform:translateX(-100%);margin-left:12px}.hint--bottom-left[data-v-33163bc3]:hover:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--bottom-left[data-v-33163bc3]:hover:after{-webkit-transform:translateX(-100%) translateY(8px);transform:translateX(-100%) translateY(8px)}.hint--bottom-right[data-v-33163bc3]:before{margin-top:-11px}.hint--bottom-right[data-v-33163bc3]:after,.hint--bottom-right[data-v-33163bc3]:before{top:100%;left:50%}.hint--bottom-right[data-v-33163bc3]:before{left:calc(50% - 6px)}.hint--bottom-right[data-v-33163bc3]:after{-webkit-transform:translateX(0);transform:translateX(0);margin-left:-12px}.hint--bottom-right[data-v-33163bc3]:hover:after,.hint--bottom-right[data-v-33163bc3]:hover:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--large[data-v-33163bc3]:after,.hint--medium[data-v-33163bc3]:after,.hint--small[data-v-33163bc3]:after{white-space:normal;line-height:1.4em;word-wrap:break-word}.hint--small[data-v-33163bc3]:after{width:80px}.hint--medium[data-v-33163bc3]:after{width:150px}.hint--large[data-v-33163bc3]:after{width:300px}[class*=hint--][data-v-33163bc3]:after{text-shadow:0 -1px 0 #000;box-shadow:4px 4px 8px rgba(0,0,0,.3)}.hint--error[data-v-33163bc3]:after{background-color:#b34e4d;text-shadow:0 -1px 0 #592726}.hint--error.hint--top-left[data-v-33163bc3]:before,.hint--error.hint--top-right[data-v-33163bc3]:before,.hint--error.hint--top[data-v-33163bc3]:before{border-top-color:#b34e4d}.hint--error.hint--bottom-left[data-v-33163bc3]:before,.hint--error.hint--bottom-right[data-v-33163bc3]:before,.hint--error.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#b34e4d}.hint--error.hint--left[data-v-33163bc3]:before{border-left-color:#b34e4d}.hint--error.hint--right[data-v-33163bc3]:before{border-right-color:#b34e4d}.hint--warning[data-v-33163bc3]:after{background-color:#c09854;text-shadow:0 -1px 0 #6c5328}.hint--warning.hint--top-left[data-v-33163bc3]:before,.hint--warning.hint--top-right[data-v-33163bc3]:before,.hint--warning.hint--top[data-v-33163bc3]:before{border-top-color:#c09854}.hint--warning.hint--bottom-left[data-v-33163bc3]:before,.hint--warning.hint--bottom-right[data-v-33163bc3]:before,.hint--warning.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#c09854}.hint--warning.hint--left[data-v-33163bc3]:before{border-left-color:#c09854}.hint--warning.hint--right[data-v-33163bc3]:before{border-right-color:#c09854}.hint--info[data-v-33163bc3]:after{background-color:#3986ac;text-shadow:0 -1px 0 #1a3c4d}.hint--info.hint--top-left[data-v-33163bc3]:before,.hint--info.hint--top-right[data-v-33163bc3]:before,.hint--info.hint--top[data-v-33163bc3]:before{border-top-color:#3986ac}.hint--info.hint--bottom-left[data-v-33163bc3]:before,.hint--info.hint--bottom-right[data-v-33163bc3]:before,.hint--info.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#3986ac}.hint--info.hint--left[data-v-33163bc3]:before{border-left-color:#3986ac}.hint--info.hint--right[data-v-33163bc3]:before{border-right-color:#3986ac}.hint--success[data-v-33163bc3]:after{background-color:#458746;text-shadow:0 -1px 0 #1a321a}.hint--success.hint--top-left[data-v-33163bc3]:before,.hint--success.hint--top-right[data-v-33163bc3]:before,.hint--success.hint--top[data-v-33163bc3]:before{border-top-color:#458746}.hint--success.hint--bottom-left[data-v-33163bc3]:before,.hint--success.hint--bottom-right[data-v-33163bc3]:before,.hint--success.hint--bottom[data-v-33163bc3]:before{border-bottom-color:#458746}.hint--success.hint--left[data-v-33163bc3]:before{border-left-color:#458746}.hint--success.hint--right[data-v-33163bc3]:before{border-right-color:#458746}.hint--always[data-v-33163bc3]:after,.hint--always[data-v-33163bc3]:before{opacity:1;visibility:visible}.hint--always.hint--top[data-v-33163bc3]:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--always.hint--top[data-v-33163bc3]:after{-webkit-transform:translateX(-50%) translateY(-8px);transform:translateX(-50%) translateY(-8px)}.hint--always.hint--top-left[data-v-33163bc3]:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--always.hint--top-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%) translateY(-8px);transform:translateX(-100%) translateY(-8px)}.hint--always.hint--top-right[data-v-33163bc3]:after,.hint--always.hint--top-right[data-v-33163bc3]:before{-webkit-transform:translateY(-8px);transform:translateY(-8px)}.hint--always.hint--bottom[data-v-33163bc3]:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--always.hint--bottom[data-v-33163bc3]:after{-webkit-transform:translateX(-50%) translateY(8px);transform:translateX(-50%) translateY(8px)}.hint--always.hint--bottom-left[data-v-33163bc3]:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--always.hint--bottom-left[data-v-33163bc3]:after{-webkit-transform:translateX(-100%) translateY(8px);transform:translateX(-100%) translateY(8px)}.hint--always.hint--bottom-right[data-v-33163bc3]:after,.hint--always.hint--bottom-right[data-v-33163bc3]:before{-webkit-transform:translateY(8px);transform:translateY(8px)}.hint--always.hint--left[data-v-33163bc3]:after,.hint--always.hint--left[data-v-33163bc3]:before{-webkit-transform:translateX(-8px);transform:translateX(-8px)}.hint--always.hint--right[data-v-33163bc3]:after,.hint--always.hint--right[data-v-33163bc3]:before{-webkit-transform:translateX(8px);transform:translateX(8px)}.hint--rounded[data-v-33163bc3]:after{border-radius:4px}.hint--no-animate[data-v-33163bc3]:after,.hint--no-animate[data-v-33163bc3]:before{transition-duration:0ms}.hint--bounce[data-v-33163bc3]:after,.hint--bounce[data-v-33163bc3]:before{transition:opacity .3s ease,visibility .3s ease,transform .3s cubic-bezier(.71,1.7,.77,1.24)}#lc-controls[data-v-33163bc3]{display:flex;flex-direction:row;margin:1rem;position:absolute;z-index:2;border-radius:25px;background-color:rgba(0,0,0,.75);padding:0 .5rem}@media screen and (min-width:992px){#lc-controls[data-v-33163bc3]{padding:0;flex-direction:column}}#lc-controls button[data-v-33163bc3]{background:none;color:#fff;opacity:.8;text-shadow:0 0 5px #000;font-size:1.25rem;padding:.75rem;cursor:pointer;border:none;outline:none!important;opacity:.65}#lc-controls button[data-v-33163bc3]:focus,#lc-controls button[data-v-33163bc3]:hover{opacity:1}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlPzI1ZjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSx1S0FBd0ssa0JBQWtCLHFCQUFxQiwrRUFBK0Usa0JBQWtCLGdDQUFnQyx3QkFBd0Isa0JBQWtCLFVBQVUsZ0JBQWdCLG9CQUFvQixvQkFBb0IscUJBQXFCLDJGQUEyRixtQkFBbUIsVUFBVSxxQkFBcUIsd0NBQXdDLGFBQWEsa0JBQWtCLHVCQUF1Qiw2QkFBNkIsZ0JBQWdCLHVDQUF1QyxtQkFBbUIsV0FBVyxpQkFBaUIsZUFBZSxzREFBc0QsaUJBQWlCLG1CQUFtQixtREFBbUQseUJBQXlCLGtEQUFrRCx3QkFBd0Isb0tBQW9LLHVCQUF1QixvSEFBb0gseUJBQXlCLDZIQUE2SCw0QkFBNEIsb0NBQW9DLDBCQUEwQixxQ0FBcUMsMkJBQTJCLG1DQUFtQyxvQkFBb0IscUVBQXFFLFlBQVksU0FBUyxtQ0FBbUMscUJBQXFCLGtDQUFrQyxtQ0FBbUMsMkJBQTJCLHlDQUF5QyxtQ0FBbUMsMkJBQTJCLHdDQUF3QyxvREFBb0QsNENBQTRDLHNDQUFzQyxpQkFBaUIsMkVBQTJFLFNBQVMsU0FBUyxzQ0FBc0MscUJBQXFCLHFDQUFxQyxtQ0FBbUMsMkJBQTJCLDRDQUE0QyxrQ0FBa0MsMEJBQTBCLDJDQUEyQyxtREFBbUQsMkNBQTJDLHFDQUFxQyxrQkFBa0IsbUJBQW1CLG9DQUFvQyxvQkFBb0IseUVBQXlFLFVBQVUsV0FBVyxxRkFBcUYsa0NBQWtDLDBCQUEwQixvQ0FBb0MsbUJBQW1CLG1CQUFtQixtQ0FBbUMsb0JBQW9CLHVFQUF1RSxXQUFXLFdBQVcsbUZBQW1GLG1DQUFtQywyQkFBMkIsd0NBQXdDLG9CQUFvQiwrRUFBK0UsWUFBWSxTQUFTLHdDQUF3QyxxQkFBcUIsdUNBQXVDLG9DQUFvQyw0QkFBNEIsaUJBQWlCLDhDQUE4QyxtQ0FBbUMsMkJBQTJCLDZDQUE2QyxxREFBcUQsNkNBQTZDLHlDQUF5QyxvQkFBb0IsaUZBQWlGLFlBQVksU0FBUyx5Q0FBeUMscUJBQXFCLHdDQUF3QyxnQ0FBZ0Msd0JBQXdCLGtCQUFrQiw2RkFBNkYsbUNBQW1DLDJCQUEyQiwyQ0FBMkMsaUJBQWlCLHFGQUFxRixTQUFTLFNBQVMsMkNBQTJDLHFCQUFxQiwwQ0FBMEMsb0NBQW9DLDRCQUE0QixpQkFBaUIsaURBQWlELGtDQUFrQywwQkFBMEIsZ0RBQWdELG9EQUFvRCw0Q0FBNEMsNENBQTRDLGlCQUFpQix1RkFBdUYsU0FBUyxTQUFTLDRDQUE0QyxxQkFBcUIsMkNBQTJDLGdDQUFnQyx3QkFBd0Isa0JBQWtCLG1HQUFtRyxrQ0FBa0MsMEJBQTBCLDZHQUE2RyxtQkFBbUIsa0JBQWtCLHFCQUFxQixvQ0FBb0MsV0FBVyxxQ0FBcUMsWUFBWSxvQ0FBb0MsWUFBWSx1Q0FBdUMsMEJBQTBCLHNDQUFzQyxvQ0FBb0MseUJBQXlCLDZCQUE2Qix3SkFBd0oseUJBQXlCLGlLQUFpSyw0QkFBNEIsZ0RBQWdELDBCQUEwQixpREFBaUQsMkJBQTJCLHNDQUFzQyx5QkFBeUIsNkJBQTZCLDhKQUE4Six5QkFBeUIsdUtBQXVLLDRCQUE0QixrREFBa0QsMEJBQTBCLG1EQUFtRCwyQkFBMkIsbUNBQW1DLHlCQUF5Qiw2QkFBNkIscUpBQXFKLHlCQUF5Qiw4SkFBOEosNEJBQTRCLCtDQUErQywwQkFBMEIsZ0RBQWdELDJCQUEyQixzQ0FBc0MseUJBQXlCLDZCQUE2Qiw4SkFBOEoseUJBQXlCLHVLQUF1Syw0QkFBNEIsa0RBQWtELDBCQUEwQixtREFBbUQsMkJBQTJCLDJFQUEyRSxVQUFVLG1CQUFtQixnREFBZ0QsbUNBQW1DLDJCQUEyQiwrQ0FBK0Msb0RBQW9ELDRDQUE0QyxxREFBcUQsbUNBQW1DLDJCQUEyQixvREFBb0QscURBQXFELDZDQUE2QywyR0FBMkcsbUNBQW1DLDJCQUEyQixtREFBbUQsa0NBQWtDLDBCQUEwQixrREFBa0QsbURBQW1ELDJDQUEyQyx3REFBd0Qsa0NBQWtDLDBCQUEwQix1REFBdUQsb0RBQW9ELDRDQUE0QyxpSEFBaUgsa0NBQWtDLDBCQUEwQixpR0FBaUcsbUNBQW1DLDJCQUEyQixtR0FBbUcsa0NBQWtDLDBCQUEwQixzQ0FBc0Msa0JBQWtCLG1GQUFtRix3QkFBd0IsMkVBQTJFLDZGQUE2Riw4QkFBOEIsYUFBYSxtQkFBbUIsWUFBWSxrQkFBa0IsVUFBVSxtQkFBbUIsaUNBQWlDLGdCQUFnQixvQ0FBb0MsOEJBQThCLFVBQVUsdUJBQXVCLHFDQUFxQyxnQkFBZ0IsV0FBVyxXQUFXLHlCQUF5QixrQkFBa0IsZUFBZSxlQUFlLFlBQVksdUJBQXVCLFlBQVksc0ZBQXNGLFVBQVU7O0FBRXBnVyIsImZpbGUiOiI3MC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBIaW50LmNzcyAtIHYyLjUuMCAtIDIwMTctMDQtMjNcXG4qIGh0dHA6Ly9rdXNoYWdyYWdvdXIuaW4vbGFiL2hpbnQvXFxuKiBDb3B5cmlnaHQgKGMpIDIwMTcgS3VzaGFncmEgR291ciAqL1tjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNde3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWJsb2NrfVtjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLFtjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3Zpc2liaWxpdHk6aGlkZGVuO29wYWNpdHk6MDt6LWluZGV4OjEwMDAwMDA7cG9pbnRlci1ldmVudHM6bm9uZTt0cmFuc2l0aW9uOi4zcyBlYXNlO3RyYW5zaXRpb24tZGVsYXk6MG1zfVtjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyLFtjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmJlZm9yZXt2aXNpYmlsaXR5OnZpc2libGU7b3BhY2l0eToxO3RyYW5zaXRpb24tZGVsYXk6LjFzfVtjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ym9yZGVyOjZweCBzb2xpZCB0cmFuc3BhcmVudDt6LWluZGV4OjEwMDAwMDF9W2NsYXNzKj1oaW50LS1dW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7YmFja2dyb3VuZDojMzgzODM4O2NvbG9yOiNmZmY7cGFkZGluZzo4cHggMTBweDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtsaW5lLWhlaWdodDoxMnB4O3doaXRlLXNwYWNlOm5vd3JhcH1bY2xhc3MqPWhpbnQtLV1bYXJpYS1sYWJlbF1bZGF0YS12LTMzMTYzYmMzXTphZnRlcntjb250ZW50OmF0dHIoYXJpYS1sYWJlbCl9W2NsYXNzKj1oaW50LS1dW2RhdGEtaGludF1bZGF0YS12LTMzMTYzYmMzXTphZnRlcntjb250ZW50OmF0dHIoZGF0YS1oaW50KX1bYXJpYS1sYWJlbD1cXFwiXFxcIl1bZGF0YS12LTMzMTYzYmMzXTphZnRlcixbYXJpYS1sYWJlbD1cXFwiXFxcIl1bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsW2RhdGEtaGludD1cXFwiXFxcIl1bZGF0YS12LTMzMTYzYmMzXTphZnRlcixbZGF0YS1oaW50PVxcXCJcXFwiXVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tdG9wLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXRvcC1jb2xvcjojMzgzODM4fS5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tYm90dG9tLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWJvdHRvbS1jb2xvcjojMzgzODM4fS5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1sZWZ0LWNvbG9yOiMzODM4Mzh9LmhpbnQtLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1yaWdodC1jb2xvcjojMzgzODM4fS5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bWFyZ2luLWJvdHRvbTotMTFweH0uaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLXRvcFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3R0b206MTAwJTtsZWZ0OjUwJX0uaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2xlZnQ6Y2FsYyg1MCUgLSA2cHgpfS5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KX0uaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXttYXJnaW4tdG9wOi0xMXB4fS5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle3RvcDoxMDAlO2xlZnQ6NTAlfS5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bGVmdDpjYWxjKDUwJSAtIDZweCl9LmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSl9LmhpbnQtLWJvdHRvbVtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoOHB4KX0uaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSg4cHgpfS5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXttYXJnaW4tbGVmdDotMTFweDttYXJnaW4tYm90dG9tOi02cHh9LmhpbnQtLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7bWFyZ2luLWJvdHRvbTotMTRweH0uaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bGVmdDoxMDAlO2JvdHRvbTo1MCV9LmhpbnQtLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YWZ0ZXIsLmhpbnQtLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg4cHgpfS5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle21hcmdpbi1yaWdodDotMTFweDttYXJnaW4tYm90dG9tOi02cHh9LmhpbnQtLWxlZnRbZGF0YS12LTMzMTYzYmMzXTphZnRlcnttYXJnaW4tYm90dG9tOi0xNHB4fS5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7cmlnaHQ6MTAwJTtib3R0b206NTAlfS5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YWZ0ZXIsLmhpbnQtLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtOHB4KX0uaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bWFyZ2luLWJvdHRvbTotMTFweH0uaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym90dG9tOjEwMCU7bGVmdDo1MCV9LmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2xlZnQ6Y2FsYyg1MCUgLSA2cHgpfS5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTttYXJnaW4tbGVmdDoxMnB4fS5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpfS5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXttYXJnaW4tYm90dG9tOi0xMXB4fS5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tdG9wLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvdHRvbToxMDAlO2xlZnQ6NTAlfS5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bGVmdDpjYWxjKDUwJSAtIDZweCl9LmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7bWFyZ2luLWxlZnQ6LTEycHh9LmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmFmdGVyLC5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KX0uaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7bWFyZ2luLXRvcDotMTFweH0uaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7dG9wOjEwMCU7bGVmdDo1MCV9LmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2xlZnQ6Y2FsYyg1MCUgLSA2cHgpfS5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTttYXJnaW4tbGVmdDoxMnB4fS5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoOHB4KX0uaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpob3ZlcjphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoOHB4KX0uaGludC0tYm90dG9tLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle21hcmdpbi10b3A6LTExcHh9LmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7dG9wOjEwMCU7bGVmdDo1MCV9LmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtsZWZ0OmNhbGMoNTAlIC0gNnB4KX0uaGludC0tYm90dG9tLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKTttYXJnaW4tbGVmdDotMTJweH0uaGludC0tYm90dG9tLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106aG92ZXI6YWZ0ZXIsLmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmhvdmVyOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoOHB4KX0uaGludC0tbGFyZ2VbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tbWVkaXVtW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLXNtYWxsW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7d2hpdGUtc3BhY2U6bm9ybWFsO2xpbmUtaGVpZ2h0OjEuNGVtO3dvcmQtd3JhcDpicmVhay13b3JkfS5oaW50LS1zbWFsbFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVye3dpZHRoOjgwcHh9LmhpbnQtLW1lZGl1bVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVye3dpZHRoOjE1MHB4fS5oaW50LS1sYXJnZVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVye3dpZHRoOjMwMHB4fVtjbGFzcyo9aGludC0tXVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVye3RleHQtc2hhZG93OjAgLTFweCAwICMwMDA7Ym94LXNoYWRvdzo0cHggNHB4IDhweCByZ2JhKDAsMCwwLC4zKX0uaGludC0tZXJyb3JbZGF0YS12LTMzMTYzYmMzXTphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiNiMzRlNGQ7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzU5MjcyNn0uaGludC0tZXJyb3IuaGludC0tdG9wLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLWVycm9yLmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tZXJyb3IuaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci10b3AtY29sb3I6I2IzNGU0ZH0uaGludC0tZXJyb3IuaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmUsLmhpbnQtLWVycm9yLmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tZXJyb3IuaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle2JvcmRlci1ib3R0b20tY29sb3I6I2IzNGU0ZH0uaGludC0tZXJyb3IuaGludC0tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItbGVmdC1jb2xvcjojYjM0ZTRkfS5oaW50LS1lcnJvci5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItcmlnaHQtY29sb3I6I2IzNGU0ZH0uaGludC0td2FybmluZ1tkYXRhLXYtMzMxNjNiYzNdOmFmdGVye2JhY2tncm91bmQtY29sb3I6I2MwOTg1NDt0ZXh0LXNoYWRvdzowIC0xcHggMCAjNmM1MzI4fS5oaW50LS13YXJuaW5nLmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS13YXJuaW5nLmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0td2FybmluZy5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXRvcC1jb2xvcjojYzA5ODU0fS5oaW50LS13YXJuaW5nLmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS13YXJuaW5nLmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0td2FybmluZy5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWJvdHRvbS1jb2xvcjojYzA5ODU0fS5oaW50LS13YXJuaW5nLmhpbnQtLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWxlZnQtY29sb3I6I2MwOTg1NH0uaGludC0td2FybmluZy5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItcmlnaHQtY29sb3I6I2MwOTg1NH0uaGludC0taW5mb1tkYXRhLXYtMzMxNjNiYzNdOmFmdGVye2JhY2tncm91bmQtY29sb3I6IzM5ODZhYzt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMWEzYzRkfS5oaW50LS1pbmZvLmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS1pbmZvLmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0taW5mby5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXRvcC1jb2xvcjojMzk4NmFjfS5oaW50LS1pbmZvLmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS1pbmZvLmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0taW5mby5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWJvdHRvbS1jb2xvcjojMzk4NmFjfS5oaW50LS1pbmZvLmhpbnQtLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWxlZnQtY29sb3I6IzM5ODZhY30uaGludC0taW5mby5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItcmlnaHQtY29sb3I6IzM5ODZhY30uaGludC0tc3VjY2Vzc1tkYXRhLXYtMzMxNjNiYzNdOmFmdGVye2JhY2tncm91bmQtY29sb3I6IzQ1ODc0Njt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMWEzMjFhfS5oaW50LS1zdWNjZXNzLmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS1zdWNjZXNzLmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tc3VjY2Vzcy5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLXRvcC1jb2xvcjojNDU4NzQ2fS5oaW50LS1zdWNjZXNzLmhpbnQtLWJvdHRvbS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3JlLC5oaW50LS1zdWNjZXNzLmhpbnQtLWJvdHRvbS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZSwuaGludC0tc3VjY2Vzcy5oaW50LS1ib3R0b21bZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWJvdHRvbS1jb2xvcjojNDU4NzQ2fS5oaW50LS1zdWNjZXNzLmhpbnQtLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7Ym9yZGVyLWxlZnQtY29sb3I6IzQ1ODc0Nn0uaGludC0tc3VjY2Vzcy5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtib3JkZXItcmlnaHQtY29sb3I6IzQ1ODc0Nn0uaGludC0tYWx3YXlzW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWFsd2F5c1tkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXtvcGFjaXR5OjE7dmlzaWJpbGl0eTp2aXNpYmxlfS5oaW50LS1hbHdheXMuaGludC0tdG9wW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLWFsd2F5cy5oaW50LS10b3BbZGF0YS12LTMzMTYzYmMzXTphZnRlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtOHB4KX0uaGludC0tYWx3YXlzLmhpbnQtLXRvcC1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLWFsd2F5cy5oaW50LS10b3AtbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoLThweCl9LmhpbnQtLWFsd2F5cy5oaW50LS10b3AtcmlnaHRbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tYWx3YXlzLmhpbnQtLXRvcC1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpfS5oaW50LS1hbHdheXMuaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpfS5oaW50LS1hbHdheXMuaGludC0tYm90dG9tW2RhdGEtdi0zMzE2M2JjM106YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDhweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSg4cHgpfS5oaW50LS1hbHdheXMuaGludC0tYm90dG9tLWxlZnRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCl9LmhpbnQtLWFsd2F5cy5oaW50LS1ib3R0b20tbGVmdFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSkgdHJhbnNsYXRlWSg4cHgpfS5oaW50LS1hbHdheXMuaGludC0tYm90dG9tLXJpZ2h0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWFsd2F5cy5oaW50LS1ib3R0b20tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDhweCl9LmhpbnQtLWFsd2F5cy5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YWZ0ZXIsLmhpbnQtLWFsd2F5cy5oaW50LS1sZWZ0W2RhdGEtdi0zMzE2M2JjM106YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLThweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLThweCl9LmhpbnQtLWFsd2F5cy5oaW50LS1yaWdodFtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1hbHdheXMuaGludC0tcmlnaHRbZGF0YS12LTMzMTYzYmMzXTpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCg4cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDhweCl9LmhpbnQtLXJvdW5kZWRbZGF0YS12LTMzMTYzYmMzXTphZnRlcntib3JkZXItcmFkaXVzOjRweH0uaGludC0tbm8tYW5pbWF0ZVtkYXRhLXYtMzMxNjNiYzNdOmFmdGVyLC5oaW50LS1uby1hbmltYXRlW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle3RyYW5zaXRpb24tZHVyYXRpb246MG1zfS5oaW50LS1ib3VuY2VbZGF0YS12LTMzMTYzYmMzXTphZnRlciwuaGludC0tYm91bmNlW2RhdGEtdi0zMzE2M2JjM106YmVmb3Jle3RyYW5zaXRpb246b3BhY2l0eSAuM3MgZWFzZSx2aXNpYmlsaXR5IC4zcyBlYXNlLHRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC43MSwxLjcsLjc3LDEuMjQpfSNsYy1jb250cm9sc1tkYXRhLXYtMzMxNjNiYzNde2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7bWFyZ2luOjFyZW07cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoyO2JvcmRlci1yYWRpdXM6MjVweDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjc1KTtwYWRkaW5nOjAgLjVyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo5OTJweCl7I2xjLWNvbnRyb2xzW2RhdGEtdi0zMzE2M2JjM117cGFkZGluZzowO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn19I2xjLWNvbnRyb2xzIGJ1dHRvbltkYXRhLXYtMzMxNjNiYzNde2JhY2tncm91bmQ6bm9uZTtjb2xvcjojZmZmO29wYWNpdHk6Ljg7dGV4dC1zaGFkb3c6MCAwIDVweCAjMDAwO2ZvbnQtc2l6ZToxLjI1cmVtO3BhZGRpbmc6Ljc1cmVtO2N1cnNvcjpwb2ludGVyO2JvcmRlcjpub25lO291dGxpbmU6bm9uZSFpbXBvcnRhbnQ7b3BhY2l0eTouNjV9I2xjLWNvbnRyb2xzIGJ1dHRvbltkYXRhLXYtMzMxNjNiYzNdOmZvY3VzLCNsYy1jb250cm9scyBidXR0b25bZGF0YS12LTMzMTYzYmMzXTpob3ZlcntvcGFjaXR5OjF9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTMzMTYzYmMzXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9Db250cm9scy52dWVcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, "button[data-v-4f491fdf]{font-size:.85em;background-color:transparent;border:1px solid #fff;color:#fff;padding:8px 26px;text-align:center;text-decoration:none;display:inline-block;touch-action:manipulation}.lv-sidebar .lv-sidebar-wrapper[data-v-4f491fdf]{position:fixed;z-index:2;right:0;width:35%;margin:.8rem;overflow:hidden}@media screen and (min-width:992px){.lv-sidebar .lv-sidebar-wrapper[data-v-4f491fdf]{width:25%}}.lv-sidebar .lv-sidebar-container[data-v-4f491fdf]{color:#fff;overflow-y:auto;padding:.8rem;max-height:100%;border:2px solid #555;background-color:rgba(0,0,0,.75)}@media screen and (min-width:992px){.lv-sidebar .lv-sidebar-container[data-v-4f491fdf]{flex-direction:column}}.lv-sidebar .lv-sidebar-header[data-v-4f491fdf]{display:flex;flex-direction:row;justify-content:space-between}.lv-sidebar .lv-sidebar-header h4[data-v-4f491fdf]{font-size:1rem;font-weight:700;text-transform:uppercase;margin-bottom:0;margin-top:0;flex-direction:row}.lv-sidebar .toggle[data-v-4f491fdf]{cursor:default;background:none;border:none;color:#fff;float:right;transition:transform .5s}.lv-sidebar .toggle.active[data-v-4f491fdf]{transform:rotate(180deg)}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/OTE2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLGlEQUFrRCxnQkFBZ0IsNkJBQTZCLHNCQUFzQixXQUFXLGlCQUFpQixrQkFBa0IscUJBQXFCLHFCQUFxQiwwQkFBMEIsaURBQWlELGVBQWUsVUFBVSxRQUFRLFVBQVUsYUFBYSxnQkFBZ0Isb0NBQW9DLGlEQUFpRCxXQUFXLG1EQUFtRCxXQUFXLGdCQUFnQixjQUFjLGdCQUFnQixzQkFBc0IsaUNBQWlDLG9DQUFvQyxtREFBbUQsdUJBQXVCLGdEQUFnRCxhQUFhLG1CQUFtQiw4QkFBOEIsbURBQW1ELGVBQWUsZ0JBQWdCLHlCQUF5QixnQkFBZ0IsYUFBYSxtQkFBbUIscUNBQXFDLGVBQWUsZ0JBQWdCLFlBQVksV0FBVyxZQUFZLHlCQUF5Qiw0Q0FBNEMseUJBQXlCOztBQUUvcEMiLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJidXR0b25bZGF0YS12LTRmNDkxZmRmXXtmb250LXNpemU6Ljg1ZW07YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MXB4IHNvbGlkICNmZmY7Y29sb3I6I2ZmZjtwYWRkaW5nOjhweCAyNnB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RvdWNoLWFjdGlvbjptYW5pcHVsYXRpb259Lmx2LXNpZGViYXIgLmx2LXNpZGViYXItd3JhcHBlcltkYXRhLXYtNGY0OTFmZGZde3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MjtyaWdodDowO3dpZHRoOjM1JTttYXJnaW46LjhyZW07b3ZlcmZsb3c6aGlkZGVufUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6OTkycHgpey5sdi1zaWRlYmFyIC5sdi1zaWRlYmFyLXdyYXBwZXJbZGF0YS12LTRmNDkxZmRmXXt3aWR0aDoyNSV9fS5sdi1zaWRlYmFyIC5sdi1zaWRlYmFyLWNvbnRhaW5lcltkYXRhLXYtNGY0OTFmZGZde2NvbG9yOiNmZmY7b3ZlcmZsb3cteTphdXRvO3BhZGRpbmc6LjhyZW07bWF4LWhlaWdodDoxMDAlO2JvcmRlcjoycHggc29saWQgIzU1NTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjc1KX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjk5MnB4KXsubHYtc2lkZWJhciAubHYtc2lkZWJhci1jb250YWluZXJbZGF0YS12LTRmNDkxZmRmXXtmbGV4LWRpcmVjdGlvbjpjb2x1bW59fS5sdi1zaWRlYmFyIC5sdi1zaWRlYmFyLWhlYWRlcltkYXRhLXYtNGY0OTFmZGZde2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59Lmx2LXNpZGViYXIgLmx2LXNpZGViYXItaGVhZGVyIGg0W2RhdGEtdi00ZjQ5MWZkZl17Zm9udC1zaXplOjFyZW07Zm9udC13ZWlnaHQ6NzAwO3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZTttYXJnaW4tYm90dG9tOjA7bWFyZ2luLXRvcDowO2ZsZXgtZGlyZWN0aW9uOnJvd30ubHYtc2lkZWJhciAudG9nZ2xlW2RhdGEtdi00ZjQ5MWZkZl17Y3Vyc29yOmRlZmF1bHQ7YmFja2dyb3VuZDpub25lO2JvcmRlcjpub25lO2NvbG9yOiNmZmY7ZmxvYXQ6cmlnaHQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzfS5sdi1zaWRlYmFyIC50b2dnbGUuYWN0aXZlW2RhdGEtdi00ZjQ5MWZkZl17dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00ZjQ5MWZkZlwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWVcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, "#lv-selection-sidebar ul[data-v-76bf11a1]{overflow-y:scroll;height:300px;list-style:none;padding:.8rem;border:1px solid #777}#lv-selection-sidebar ul li[data-v-76bf11a1]{display:flex;flex-direction:row;justify-content:space-between;align-content:center}#lv-selection-sidebar ul li[data-v-76bf11a1]:not(:last-child){margin-bottom:.75rem}#lv-selection-sidebar svg[data-v-76bf11a1]{margin-left:5px}#lv-selection-sidebar button[data-v-76bf11a1]{display:flex;margin-right:auto;margin-left:auto}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT8zZGE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsbUVBQW9FLGtCQUFrQixhQUFhLGdCQUFnQixjQUFjLHNCQUFzQiw2Q0FBNkMsYUFBYSxtQkFBbUIsOEJBQThCLHFCQUFxQiw4REFBOEQscUJBQXFCLDJDQUEyQyxnQkFBZ0IsOENBQThDLGFBQWEsa0JBQWtCLGlCQUFpQjs7QUFFbmdCIiwiZmlsZSI6IjcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiI2x2LXNlbGVjdGlvbi1zaWRlYmFyIHVsW2RhdGEtdi03NmJmMTFhMV17b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjMwMHB4O2xpc3Qtc3R5bGU6bm9uZTtwYWRkaW5nOi44cmVtO2JvcmRlcjoxcHggc29saWQgIzc3N30jbHYtc2VsZWN0aW9uLXNpZGViYXIgdWwgbGlbZGF0YS12LTc2YmYxMWExXXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWNvbnRlbnQ6Y2VudGVyfSNsdi1zZWxlY3Rpb24tc2lkZWJhciB1bCBsaVtkYXRhLXYtNzZiZjExYTFdOm5vdCg6bGFzdC1jaGlsZCl7bWFyZ2luLWJvdHRvbTouNzVyZW19I2x2LXNlbGVjdGlvbi1zaWRlYmFyIHN2Z1tkYXRhLXYtNzZiZjExYTFde21hcmdpbi1sZWZ0OjVweH0jbHYtc2VsZWN0aW9uLXNpZGViYXIgYnV0dG9uW2RhdGEtdi03NmJmMTFhMV17ZGlzcGxheTpmbGV4O21hcmdpbi1yaWdodDphdXRvO21hcmdpbi1sZWZ0OmF1dG99XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTc2YmYxMWExXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, "#lc-viewer{display:flex;flex-direction:column;height:100%;width:auto;background-color:#000;overflow:hidden}.openseadragon-container{height:100vh;min-height:600px}.openseadragon-container .openseadragon-message{color:#fff}.openseadragon-container .viewer-hint{white-space:nowrap;position:absolute;pointer-events:none;top:80px;width:100%;text-align:center;opacity:0;transition:opacity .3s}.openseadragon-container .viewer-hint.show{opacity:1}.openseadragon-container .viewer-hint .viewer-hint-text{padding:.5rem;color:#fff;width:400px;margin:0 auto;background-color:rgba(0,0,0,.75);border-radius:6px}.openseadragon-container .selection-box{transform:none!important;outline:9999px solid rgba(0,0,0,.6)}.openseadragon-container .selection-box .selection-btn{color:#fff;display:flex!important;position:absolute!important;right:0}.openseadragon-container .selection-box .selection-btn#confirm-selection{bottom:0;transform:translateX(20px) translateY(15px)}.openseadragon-container .selection-box .selection-btn#cancel-selection{top:0;transform:translateX(20px) translateY(-15px)}.openseadragon-container .overlay{z-index:50}.openseadragon-container .overlay.selection{border:2px solid #3498db;background-color:rgba(52,152,219,.2);opacity:.6}.openseadragon-container .overlay.selection:focus,.openseadragon-container .overlay.selection:hover{opacity:1}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT9iMTU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0Esb0NBQXFDLGFBQWEsc0JBQXNCLFlBQVksV0FBVyxzQkFBc0IsZ0JBQWdCLHlCQUF5QixhQUFhLGlCQUFpQixnREFBZ0QsV0FBVyxzQ0FBc0MsbUJBQW1CLGtCQUFrQixvQkFBb0IsU0FBUyxXQUFXLGtCQUFrQixVQUFVLHVCQUF1QiwyQ0FBMkMsVUFBVSx3REFBd0QsY0FBYyxXQUFXLFlBQVksY0FBYyxpQ0FBaUMsa0JBQWtCLHdDQUF3Qyx5QkFBeUIsb0NBQW9DLHVEQUF1RCxXQUFXLHVCQUF1Qiw0QkFBNEIsUUFBUSx5RUFBeUUsU0FBUyw0Q0FBNEMsd0VBQXdFLE1BQU0sNkNBQTZDLGtDQUFrQyxXQUFXLDRDQUE0Qyx5QkFBeUIscUNBQXFDLFdBQVcsb0dBQW9HLFVBQVU7O0FBRTMxQyIsImZpbGUiOiI3My5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIiNsYy12aWV3ZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtoZWlnaHQ6MTAwJTt3aWR0aDphdXRvO2JhY2tncm91bmQtY29sb3I6IzAwMDtvdmVyZmxvdzpoaWRkZW59Lm9wZW5zZWFkcmFnb24tY29udGFpbmVye2hlaWdodDoxMDB2aDttaW4taGVpZ2h0OjYwMHB4fS5vcGVuc2VhZHJhZ29uLWNvbnRhaW5lciAub3BlbnNlYWRyYWdvbi1tZXNzYWdle2NvbG9yOiNmZmZ9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC52aWV3ZXItaGludHt3aGl0ZS1zcGFjZTpub3dyYXA7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6bm9uZTt0b3A6ODBweDt3aWR0aDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzfS5vcGVuc2VhZHJhZ29uLWNvbnRhaW5lciAudmlld2VyLWhpbnQuc2hvd3tvcGFjaXR5OjF9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC52aWV3ZXItaGludCAudmlld2VyLWhpbnQtdGV4dHtwYWRkaW5nOi41cmVtO2NvbG9yOiNmZmY7d2lkdGg6NDAwcHg7bWFyZ2luOjAgYXV0bztiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjc1KTtib3JkZXItcmFkaXVzOjZweH0ub3BlbnNlYWRyYWdvbi1jb250YWluZXIgLnNlbGVjdGlvbi1ib3h7dHJhbnNmb3JtOm5vbmUhaW1wb3J0YW50O291dGxpbmU6OTk5OXB4IHNvbGlkIHJnYmEoMCwwLDAsLjYpfS5vcGVuc2VhZHJhZ29uLWNvbnRhaW5lciAuc2VsZWN0aW9uLWJveCAuc2VsZWN0aW9uLWJ0bntjb2xvcjojZmZmO2Rpc3BsYXk6ZmxleCFpbXBvcnRhbnQ7cG9zaXRpb246YWJzb2x1dGUhaW1wb3J0YW50O3JpZ2h0OjB9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC5zZWxlY3Rpb24tYm94IC5zZWxlY3Rpb24tYnRuI2NvbmZpcm0tc2VsZWN0aW9ue2JvdHRvbTowO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDIwcHgpIHRyYW5zbGF0ZVkoMTVweCl9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC5zZWxlY3Rpb24tYm94IC5zZWxlY3Rpb24tYnRuI2NhbmNlbC1zZWxlY3Rpb257dG9wOjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjBweCkgdHJhbnNsYXRlWSgtMTVweCl9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC5vdmVybGF5e3otaW5kZXg6NTB9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC5vdmVybGF5LnNlbGVjdGlvbntib3JkZXI6MnB4IHNvbGlkICMzNDk4ZGI7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDUyLDE1MiwyMTksLjIpO29wYWNpdHk6LjZ9Lm9wZW5zZWFkcmFnb24tY29udGFpbmVyIC5vdmVybGF5LnNlbGVjdGlvbjpmb2N1cywub3BlbnNlYWRyYWdvbi1jb250YWluZXIgLm92ZXJsYXkuc2VsZWN0aW9uOmhvdmVye29wYWNpdHk6MX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYWFkNDFiNDJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, ".fa-icon{display:inline-block;fill:currentColor}.fa-flip-horizontal{transform:scaleX(-1)}.fa-flip-vertical{transform:scaleY(-1)}.fa-spin{animation:fa-spin 1s 0s infinite linear}.fa-inverse{color:#fff}@keyframes fa-spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlP2MxZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxrQ0FBbUMscUJBQXFCLGtCQUFrQixvQkFBb0IscUJBQXFCLGtCQUFrQixxQkFBcUIsU0FBUyx3Q0FBd0MsWUFBWSxXQUFXLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5Qjs7QUFFM1MiLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5mYS1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZpbGw6Y3VycmVudENvbG9yfS5mYS1mbGlwLWhvcml6b250YWx7dHJhbnNmb3JtOnNjYWxlWCgtMSl9LmZhLWZsaXAtdmVydGljYWx7dHJhbnNmb3JtOnNjYWxlWSgtMSl9LmZhLXNwaW57YW5pbWF0aW9uOmZhLXNwaW4gMXMgMHMgaW5maW5pdGUgbGluZWFyfS5mYS1pbnZlcnNle2NvbG9yOiNmZmZ9QGtleWZyYW1lcyBmYS1zcGluezAle3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9dG97dHJhbnNmb3JtOnJvdGF0ZSgxdHVybil9fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlcj9taW5pbWl6ZSEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0wNjY1OTcwYlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, "#manifest-md[data-v-dfc627fe]{list-style:none}#rights[data-v-dfc627fe]{text-align:center;margin:2rem}li[data-v-dfc627fe]{margin:0}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWU/YmMzOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLHVEQUF3RCxnQkFBZ0IseUJBQXlCLGtCQUFrQixZQUFZLG9CQUFvQixTQUFTOztBQUU1SiIsImZpbGUiOiI3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIiNtYW5pZmVzdC1tZFtkYXRhLXYtZGZjNjI3ZmVde2xpc3Qtc3R5bGU6bm9uZX0jcmlnaHRzW2RhdGEtdi1kZmM2MjdmZV17dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luOjJyZW19bGlbZGF0YS12LWRmYzYyN2ZlXXttYXJnaW46MH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/bWluaW1pemUhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZGZjNjI3ZmVcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWVcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9pcy1idWZmZXIvaW5kZXguanM/NzQ1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2lzLWJ1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;//! openseadragon 2.2.1\n//! Built on 2016-07-01\n//! Git commit: v2.2.1-0-babdefd\n//! http://openseadragon.github.io\n//! License: http://openseadragon.github.io/license/\n\n/*\n * OpenSeadragon\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Portions of this source file taken from jQuery:\n *\n * Copyright 2011 John Resig\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * "Software"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*\n * Portions of this source file taken from mattsnider.com:\n *\n * Copyright (c) 2006-2013 Matt Snider\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n/**\n * @namespace OpenSeadragon\n * @version openseadragon 2.2.1\n * @classdesc The root namespace for OpenSeadragon.  All utility methods\n * and classes are defined on or below this namespace.\n *\n */\n\n\n// Typedefs\n\n /**\n  * All required and optional settings for instantiating a new instance of an OpenSeadragon image viewer.\n  *\n  * @typedef {Object} Options\n  * @memberof OpenSeadragon\n  *\n  * @property {String} id\n  *     Id of the element to append the viewer\'s container element to. If not provided, the \'element\' property must be provided.\n  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.\n  *\n  * @property {Element} element\n  *     The element to append the viewer\'s container element to. If not provided, the \'id\' property must be provided.\n  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.\n  *\n  * @property {Array|String|Function|Object} [tileSources=null]\n  *     Tile source(s) to open initially. This is a complex parameter; see\n  *     {@link OpenSeadragon.Viewer#open} for details.\n  *\n  * @property {Number} [tabIndex=0]\n  *     Tabbing order index to assign to the viewer element. Positive values are selected in increasing order. When tabIndex is 0\n  *     source order is used. A negative value omits the viewer from the tabbing order.\n  *\n  * @property {Array} overlays Array of objects defining permanent overlays of\n  *     the viewer. The overlays added via this option and later removed with\n  *     {@link OpenSeadragon.Viewer#removeOverlay} will be added back when a new\n  *     image is opened.\n  *     To add overlays which can be definitively removed, one must use\n  *     {@link OpenSeadragon.Viewer#addOverlay}\n  *     If displaying a sequence of images, the overlays can be associated\n  *     with a specific page by passing the overlays array to the page\'s\n  *     tile source configuration.\n  *     Expected properties:\n  *     * x, y, (or px, py for pixel coordinates) to define the location.\n  *     * width, height in point if using x,y or in pixels if using px,py. If width\n  *       and height are specified, the overlay size is adjusted when zooming,\n  *       otherwise the size stays the size of the content (or the size defined by CSS).\n  *     * className to associate a class to the overlay\n  *     * id to set the overlay element. If an element with this id already exists,\n  *       it is reused, otherwise it is created. If not specified, a new element is\n  *       created.\n  *     * placement a string to define the relative position to the viewport.\n  *       Only used if no width and height are specified. Default: \'TOP_LEFT\'.\n  *       See {@link OpenSeadragon.Placement} for possible values.\n  *\n  * @property {String} [xmlPath=null]\n  *     <strong>DEPRECATED</strong>. A relative path to load a DZI file from the server.\n  *     Prefer the newer Options.tileSources.\n  *\n  * @property {String} [prefixUrl=\'/images/\']\n  *     Prepends the prefixUrl to navImages paths, which is very useful\n  *     since the default paths are rarely useful for production\n  *     environments.\n  *\n  * @property {OpenSeadragon.NavImages} [navImages]\n  *     An object with a property for each button or other built-in navigation\n  *     control, eg the current \'zoomIn\', \'zoomOut\', \'home\', and \'fullpage\'.\n  *     Each of those in turn provides an image path for each state of the button\n  *     or navigation control, eg \'REST\', \'GROUP\', \'HOVER\', \'PRESS\'. Finally the\n  *     image paths, by default assume there is a folder on the servers root path\n  *     called \'/images\', eg \'/images/zoomin_rest.png\'.  If you need to adjust\n  *     these paths, prefer setting the option.prefixUrl rather than overriding\n  *     every image path directly through this setting.\n  *\n  * @property {Boolean} [debugMode=false]\n  *     TODO: provide an in-screen panel providing event detail feedback.\n  *\n  * @property {String} [debugGridColor=\'#437AB2\']\n  *\n  * @property {Number} [blendTime=0]\n  *     Specifies the duration of animation as higher or lower level tiles are\n  *     replacing the existing tile.\n  *\n  * @property {Boolean} [alwaysBlend=false]\n  *     Forces the tile to always blend.  By default the tiles skip blending\n  *     when the blendTime is surpassed and the current animation frame would\n  *     not complete the blend.\n  *\n  * @property {Boolean} [autoHideControls=true]\n  *     If the user stops interacting with the viewport, fade the navigation\n  *     controls.  Useful for presentation since the controls are by default\n  *     floated on top of the image the user is viewing.\n  *\n  * @property {Boolean} [immediateRender=false]\n  *     Render the best closest level first, ignoring the lowering levels which\n  *     provide the effect of very blurry to sharp. It is recommended to change\n  *     setting to true for mobile devices.\n  *\n  * @property {Number} [defaultZoomLevel=0]\n  *     Zoom level to use when image is first opened or the home button is clicked.\n  *     If 0, adjusts to fit viewer.\n  *\n  * @property {Number} [opacity=1]\n  *     Default opacity of the tiled images (1=opaque, 0=transparent)\n  *\n  * @property {String} [compositeOperation=null]\n  *     Valid values are \'source-over\', \'source-atop\', \'source-in\', \'source-out\',\n  *     \'destination-over\', \'destination-atop\', \'destination-in\',\n  *     \'destination-out\', \'lighter\', \'copy\' or \'xor\'\n  *\n  * @property {String|CanvasGradient|CanvasPattern|Function} [placeholderFillStyle=null]\n  *     Draws a colored rectangle behind the tile if it is not loaded yet.\n  *     You can pass a CSS color value like "#FF8800".\n  *     When passing a function the tiledImage and canvas context are available as argument which is useful when you draw a gradient or pattern.\n  *\n  * @property {Number} [degrees=0]\n  *     Initial rotation.\n  *\n  * @property {Number} [minZoomLevel=null]\n  *\n  * @property {Number} [maxZoomLevel=null]\n  *\n  * @property {Boolean} [homeFillsViewer=false]\n  *     Make the \'home\' button fill the viewer and clip the image, instead\n  *     of fitting the image to the viewer and letterboxing.\n  *\n  * @property {Boolean} [panHorizontal=true]\n  *     Allow horizontal pan.\n  *\n  * @property {Boolean} [panVertical=true]\n  *     Allow vertical pan.\n  *\n  * @property {Boolean} [constrainDuringPan=false]\n  *\n  * @property {Boolean} [wrapHorizontal=false]\n  *     Set to true to force the image to wrap horizontally within the viewport.\n  *     Useful for maps or images representing the surface of a sphere or cylinder.\n  *\n  * @property {Boolean} [wrapVertical=false]\n  *     Set to true to force the image to wrap vertically within the viewport.\n  *     Useful for maps or images representing the surface of a sphere or cylinder.\n  *\n  * @property {Number} [minZoomImageRatio=0.9]\n  *     The minimum percentage ( expressed as a number between 0 and 1 ) of\n  *     the viewport height or width at which the zoom out will be constrained.\n  *     Setting it to 0, for example will allow you to zoom out infinity.\n  *\n  * @property {Number} [maxZoomPixelRatio=1.1]\n  *     The maximum ratio to allow a zoom-in to affect the highest level pixel\n  *     ratio. This can be set to Infinity to allow \'infinite\' zooming into the\n  *     image though it is less effective visually if the HTML5 Canvas is not\n  *     availble on the viewing device.\n  *\n  * @property {Number} [smoothTileEdgesMinZoom=1.1]\n  *     A zoom percentage ( where 1 is 100% ) of the highest resolution level.\n  *     When zoomed in beyond this value alternative compositing will be used to\n  *     smooth out the edges between tiles. This will have a performance impact.\n  *     Can be set to Infinity to turn it off.\n  *     Note: This setting is ignored on iOS devices due to a known bug (See {@link https://github.com/openseadragon/openseadragon/issues/952})\n  *\n  * @property {Boolean} [iOSDevice=?]\n  *     True if running on an iOS device, false otherwise.\n  *     Used to disable certain features that behave differently on iOS devices.\n  *\n  * @property {Boolean} [autoResize=true]\n  *     Set to false to prevent polling for viewer size changes. Useful for providing custom resize behavior.\n  *\n  * @property {Boolean} [preserveImageSizeOnResize=false]\n  *     Set to true to have the image size preserved when the viewer is resized. This requires autoResize=true (default).\n  *\n  * @property {Number} [minScrollDeltaTime=50]\n  *     Number of milliseconds between canvas-scroll events. This value helps normalize the rate of canvas-scroll\n  *     events between different devices, causing the faster devices to slow down enough to make the zoom control\n  *     more manageable.\n  *\n  * @property {Number} [pixelsPerWheelLine=40]\n  *     For pixel-resolution scrolling devices, the number of pixels equal to one scroll line.\n  *\n  * @property {Number} [visibilityRatio=0.5]\n  *     The percentage ( as a number from 0 to 1 ) of the source image which\n  *     must be kept within the viewport.  If the image is dragged beyond that\n  *     limit, it will \'bounce\' back until the minimum visibility ratio is\n  *     achieved.  Setting this to 0 and wrapHorizontal ( or wrapVertical ) to\n  *     true will provide the effect of an infinitely scrolling viewport.\n  *\n  * @property {Object} [viewportMargins={}]\n  *     Pushes the "home" region in from the sides by the specified amounts.\n  *     Possible subproperties (Numbers, in screen coordinates): left, top, right, bottom.\n  *\n  * @property {Number} [imageLoaderLimit=0]\n  *     The maximum number of image requests to make concurrently. By default\n  *     it is set to 0 allowing the browser to make the maximum number of\n  *     image requests in parallel as allowed by the browsers policy.\n  *\n  * @property {Number} [clickTimeThreshold=300]\n  *      The number of milliseconds within which a pointer down-up event combination\n  *      will be treated as a click gesture.\n  *\n  * @property {Number} [clickDistThreshold=5]\n  *      The maximum distance allowed between a pointer down event and a pointer up event\n  *      to be treated as a click gesture.\n  *\n  * @property {Number} [dblClickTimeThreshold=300]\n  *      The number of milliseconds within which two pointer down-up event combinations\n  *      will be treated as a double-click gesture.\n  *\n  * @property {Number} [dblClickDistThreshold=20]\n  *      The maximum distance allowed between two pointer click events\n  *      to be treated as a double-click gesture.\n  *\n  * @property {Number} [springStiffness=6.5]\n  *\n  * @property {Number} [animationTime=1.2]\n  *     Specifies the animation duration per each {@link OpenSeadragon.Spring}\n  *     which occur when the image is dragged or zoomed.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsMouse]\n  *     Settings for gestures generated by a mouse pointer device. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsMouse.scrollToZoom=true] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsMouse.clickToZoom=true] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsMouse.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsMouse.pinchToZoom=false] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsMouse.flickEnabled=false] - Enable flick gesture\n  * @property {Number} [gestureSettingsMouse.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsMouse.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsMouse.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsTouch]\n  *     Settings for gestures generated by a touch pointer device. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsTouch.scrollToZoom=false] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsTouch.clickToZoom=false] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsTouch.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsTouch.pinchToZoom=true] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsTouch.flickEnabled=true] - Enable flick gesture\n  * @property {Number} [gestureSettingsTouch.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsTouch.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsTouch.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsPen]\n  *     Settings for gestures generated by a pen pointer device. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsPen.scrollToZoom=false] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsPen.clickToZoom=true] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsPen.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsPen.pinchToZoom=false] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsPen.flickEnabled=false] - Enable flick gesture\n  * @property {Number} [gestureSettingsPen.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsPen.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsPen.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {OpenSeadragon.GestureSettings} [gestureSettingsUnknown]\n  *     Settings for gestures generated by unknown pointer devices. (See {@link OpenSeadragon.GestureSettings})\n  * @property {Boolean} [gestureSettingsUnknown.scrollToZoom=true] - Zoom on scroll gesture\n  * @property {Boolean} [gestureSettingsUnknown.clickToZoom=false] - Zoom on click gesture\n  * @property {Boolean} [gestureSettingsUnknown.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  * @property {Boolean} [gestureSettingsUnknown.pinchToZoom=true] - Zoom on pinch gesture\n  * @property {Boolean} [gestureSettingsUnknown.flickEnabled=true] - Enable flick gesture\n  * @property {Number} [gestureSettingsUnknown.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)\n  * @property {Number} [gestureSettingsUnknown.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture\n  * @property {Boolean} [gestureSettingsUnknown.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.\n  *\n  * @property {Number} [zoomPerClick=2.0]\n  *     The "zoom distance" per mouse click or touch tap. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the click-to-zoom feature (also see gestureSettings[Mouse|Touch|Pen].clickToZoom/dblClickToZoom).</em>\n  *\n  * @property {Number} [zoomPerScroll=1.2]\n  *     The "zoom distance" per mouse scroll or touch pinch. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the mouse-wheel zoom feature (also see gestureSettings[Mouse|Touch|Pen].scrollToZoom}).</em>\n  *\n  * @property {Number} [zoomPerSecond=1.0]\n  *     The number of seconds to animate a single zoom event over.\n  *\n  * @property {Boolean} [showNavigator=false]\n  *     Set to true to make the navigator minimap appear.\n  *\n  * @property {String} [navigatorId=navigator-GENERATED DATE]\n  *     The ID of a div to hold the navigator minimap.\n  *     If an ID is specified, the navigatorPosition, navigatorSizeRatio, navigatorMaintainSizeRatio, navigator[Top|Left|Height|Width] and navigatorAutoFade options will be ignored.\n  *     If an ID is not specified, a div element will be generated and placed on top of the main image.\n  *\n  * @property {String} [navigatorPosition=\'TOP_RIGHT\']\n  *     Valid values are \'TOP_LEFT\', \'TOP_RIGHT\', \'BOTTOM_LEFT\', \'BOTTOM_RIGHT\', or \'ABSOLUTE\'.<br>\n  *     If \'ABSOLUTE\' is specified, then navigator[Top|Left|Height|Width] determines the size and position of the navigator minimap in the viewer, and navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.<br>\n  *     For \'TOP_LEFT\', \'TOP_RIGHT\', \'BOTTOM_LEFT\', and \'BOTTOM_RIGHT\', the navigatorSizeRatio or navigator[Height|Width] values determine the size of the navigator minimap.\n  *\n  * @property {Number} [navigatorSizeRatio=0.2]\n  *     Ratio of navigator size to viewer size. Ignored if navigator[Height|Width] are specified.\n  *\n  * @property {Boolean} [navigatorMaintainSizeRatio=false]\n  *     If true, the navigator minimap is resized (using navigatorSizeRatio) when the viewer size changes.\n  *\n  * @property {Number|String} [navigatorTop=null]\n  *     Specifies the location of the navigator minimap (see navigatorPosition).\n  *\n  * @property {Number|String} [navigatorLeft=null]\n  *     Specifies the location of the navigator minimap (see navigatorPosition).\n  *\n  * @property {Number|String} [navigatorHeight=null]\n  *     Specifies the size of the navigator minimap (see navigatorPosition).\n  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.\n  *\n  * @property {Number|String} [navigatorWidth=null]\n  *     Specifies the size of the navigator minimap (see navigatorPosition).\n  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.\n  *\n  * @property {Boolean} [navigatorAutoResize=true]\n  *     Set to false to prevent polling for navigator size changes. Useful for providing custom resize behavior.\n  *     Setting to false can also improve performance when the navigator is configured to a fixed size.\n  *\n  * @property {Boolean} [navigatorAutoFade=true]\n  *     If the user stops interacting with the viewport, fade the navigator minimap.\n  *     Setting to false will make the navigator minimap always visible.\n  *\n  * @property {Boolean} [navigatorRotate=true]\n  *     If true, the navigator will be rotated together with the viewer.\n  *\n  * @property {Number} [controlsFadeDelay=2000]\n  *     The number of milliseconds to wait once the user has stopped interacting\n  *     with the interface before begining to fade the controls. Assumes\n  *     showNavigationControl and autoHideControls are both true.\n  *\n  * @property {Number} [controlsFadeLength=1500]\n  *     The number of milliseconds to animate the controls fading out.\n  *\n  * @property {Number} [maxImageCacheCount=200]\n  *     The max number of images we should keep in memory (per drawer).\n  *\n  * @property {Number} [timeout=30000]\n  *\n  * @property {Boolean} [useCanvas=true]\n  *     Set to false to not use an HTML canvas element for image rendering even if canvas is supported.\n  *\n  * @property {Number} [minPixelRatio=0.5]\n  *     The higher the minPixelRatio, the lower the quality of the image that\n  *     is considered sufficient to stop rendering a given zoom level.  For\n  *     example, if you are targeting mobile devices with less bandwith you may\n  *     try setting this to 1.5 or higher.\n  *\n  * @property {Boolean} [mouseNavEnabled=true]\n  *     Is the user able to interact with the image via mouse or touch. Default\n  *     interactions include draging the image in a plane, and zooming in toward\n  *     and away from the image.\n  *\n  * @property {Boolean} [showNavigationControl=true]\n  *     Set to false to prevent the appearance of the default navigation controls.<br>\n  *     Note that if set to false, the customs buttons set by the options\n  *     zoomInButton, zoomOutButton etc, are rendered inactive.\n  *\n  * @property {OpenSeadragon.ControlAnchor} [navigationControlAnchor=TOP_LEFT]\n  *     Placement of the default navigation controls.\n  *     To set the placement of the sequence controls, see the\n  *     sequenceControlAnchor option.\n  *\n  * @property {Boolean} [showZoomControl=true]\n  *     If true then + and - buttons to zoom in and out are displayed.<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showHomeControl=true]\n  *     If true then the \'Go home\' button is displayed to go back to the original\n  *     zoom and pan.<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showFullPageControl=true]\n  *     If true then the \'Toggle full page\' button is displayed to switch\n  *     between full page and normal mode.<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showRotationControl=false]\n  *     If true then the rotate left/right controls will be displayed as part of the\n  *     standard controls. This is also subject to the browser support for rotate\n  *     (e.g. viewer.drawer.canRotate()).<br>\n  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding\n  *     this setting when set to false.\n  *\n  * @property {Boolean} [showSequenceControl=true]\n  *     If sequenceMode is true, then provide buttons for navigating forward and\n  *     backward through the images.\n  *\n  * @property {OpenSeadragon.ControlAnchor} [sequenceControlAnchor=TOP_LEFT]\n  *     Placement of the default sequence controls.\n  *\n  * @property {Boolean} [navPrevNextWrap=false]\n  *     If true then the \'previous\' button will wrap to the last image when\n  *     viewing the first image and the \'next\' button will wrap to the first\n  *     image when viewing the last image.\n  *\n  * @property {String} zoomInButton\n  *     Set the id of the custom \'Zoom in\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} zoomOutButton\n  *     Set the id of the custom \'Zoom out\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} homeButton\n  *     Set the id of the custom \'Go home\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} fullPageButton\n  *     Set the id of the custom \'Toggle full page\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} rotateLeftButton\n  *     Set the id of the custom \'Rotate left\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} rotateRightButton\n  *     Set the id of the custom \'Rotate right\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} previousButton\n  *     Set the id of the custom \'Previous page\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {String} nextButton\n  *     Set the id of the custom \'Next page\' button to use.\n  *     This is useful to have a custom button anywhere in the web page.<br>\n  *     To only change the button images, consider using\n  *     {@link OpenSeadragon.Options.navImages}\n  *\n  * @property {Boolean} [sequenceMode=false]\n  *     Set to true to have the viewer treat your tilesources as a sequence of images to\n  *     be opened one at a time rather than all at once.\n  *\n  * @property {Number} [initialPage=0]\n  *     If sequenceMode is true, display this page initially.\n  *\n  * @property {Boolean} [preserveViewport=false]\n  *     If sequenceMode is true, then normally navigating through each image resets the\n  *     viewport to \'home\' position.  If preserveViewport is set to true, then the viewport\n  *     position is preserved when navigating between images in the sequence.\n  *\n  * @property {Boolean} [preserveOverlays=false]\n  *     If sequenceMode is true, then normally navigating through each image\n  *     resets the overlays.\n  *     If preserveOverlays is set to true, then the overlays added with {@link OpenSeadragon.Viewer#addOverlay}\n  *     are preserved when navigating between images in the sequence.\n  *     Note: setting preserveOverlays overrides any overlays specified in the global\n  *     "overlays" option for the Viewer. It\'s also not compatible with specifying\n  *     per-tileSource overlays via the options, as those overlays will persist\n  *     even after the tileSource is closed.\n  *\n  * @property {Boolean} [showReferenceStrip=false]\n  *     If sequenceMode is true, then display a scrolling strip of image thumbnails for\n  *     navigating through the images.\n  *\n  * @property {String} [referenceStripScroll=\'horizontal\']\n  *\n  * @property {Element} [referenceStripElement=null]\n  *\n  * @property {Number} [referenceStripHeight=null]\n  *\n  * @property {Number} [referenceStripWidth=null]\n  *\n  * @property {String} [referenceStripPosition=\'BOTTOM_LEFT\']\n  *\n  * @property {Number} [referenceStripSizeRatio=0.2]\n  *\n  * @property {Boolean} [collectionMode=false]\n  *     Set to true to have the viewer arrange your TiledImages in a grid or line.\n  *\n  * @property {Number} [collectionRows=3]\n  *     If collectionMode is true, specifies how many rows the grid should have. Use 1 to make a line.\n  *     If collectionLayout is \'vertical\', specifies how many columns instead.\n  *\n  * @property {Number} [collectionColumns=0]\n  *     If collectionMode is true, specifies how many columns the grid should have. Use 1 to make a line.\n  *     If collectionLayout is \'vertical\', specifies how many rows instead. Ignored if collectionRows is not set to a falsy value.\n  *\n  * @property {String} [collectionLayout=\'horizontal\']\n  *     If collectionMode is true, specifies whether to arrange vertically or horizontally.\n  *\n  * @property {Number} [collectionTileSize=800]\n  *     If collectionMode is true, specifies the size, in viewport coordinates, for each TiledImage to fit into.\n  *     The TiledImage will be centered within a square of the specified size.\n  *\n  * @property {Number} [collectionTileMargin=80]\n  *     If collectionMode is true, specifies the margin, in viewport coordinates, between each TiledImage.\n  *\n  * @property {String|Boolean} [crossOriginPolicy=false]\n  *     Valid values are \'Anonymous\', \'use-credentials\', and false. If false, canvas requests will\n  *     not use CORS, and the canvas will be tainted.\n  *\n  * @property {Boolean} [ajaxWithCredentials=false]\n  *     Whether to set the withCredentials XHR flag for AJAX requests (when loading tile sources).\n  *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.\n  *\n  */\n\n /**\n  * Settings for gestures generated by a pointer device.\n  *\n  * @typedef {Object} GestureSettings\n  * @memberof OpenSeadragon\n  *\n  * @property {Boolean} scrollToZoom\n  *     Set to false to disable zooming on scroll gestures.\n  *\n  * @property {Boolean} clickToZoom\n  *     Set to false to disable zooming on click gestures.\n  *\n  * @property {Boolean} dblClickToZoom\n  *     Set to false to disable zooming on double-click gestures. Note: If set to true\n  *     then clickToZoom should be set to false to prevent multiple zooms.\n  *\n  * @property {Boolean} pinchToZoom\n  *     Set to false to disable zooming on pinch gestures.\n  *\n  * @property {Boolean} flickEnabled\n  *     Set to false to disable the kinetic panning effect (flick) at the end of a drag gesture.\n  *\n  * @property {Number} flickMinSpeed\n  *     If flickEnabled is true, the minimum speed (in pixels-per-second) required to cause the kinetic panning effect (flick) at the end of a drag gesture.\n  *\n  * @property {Number} flickMomentum\n  *     If flickEnabled is true, a constant multiplied by the velocity to determine the distance of the kinetic panning effect (flick) at the end of a drag gesture.\n  *     A larger value will make the flick feel "lighter", while a smaller value will make the flick feel "heavier".\n  *     Note: springStiffness and animationTime also affect the "spring" used to stop the flick animation.\n  *\n  */\n\n/**\n  * The names for the image resources used for the image navigation buttons.\n  *\n  * @typedef {Object} NavImages\n  * @memberof OpenSeadragon\n  *\n  * @property {Object} zoomIn - Images for the zoom-in button.\n  * @property {String} zoomIn.REST\n  * @property {String} zoomIn.GROUP\n  * @property {String} zoomIn.HOVER\n  * @property {String} zoomIn.DOWN\n  *\n  * @property {Object} zoomOut - Images for the zoom-out button.\n  * @property {String} zoomOut.REST\n  * @property {String} zoomOut.GROUP\n  * @property {String} zoomOut.HOVER\n  * @property {String} zoomOut.DOWN\n  *\n  * @property {Object} home - Images for the home button.\n  * @property {String} home.REST\n  * @property {String} home.GROUP\n  * @property {String} home.HOVER\n  * @property {String} home.DOWN\n  *\n  * @property {Object} fullpage - Images for the full-page button.\n  * @property {String} fullpage.REST\n  * @property {String} fullpage.GROUP\n  * @property {String} fullpage.HOVER\n  * @property {String} fullpage.DOWN\n  *\n  * @property {Object} rotateleft - Images for the rotate left button.\n  * @property {String} rotateleft.REST\n  * @property {String} rotateleft.GROUP\n  * @property {String} rotateleft.HOVER\n  * @property {String} rotateleft.DOWN\n  *\n  * @property {Object} rotateright - Images for the rotate right button.\n  * @property {String} rotateright.REST\n  * @property {String} rotateright.GROUP\n  * @property {String} rotateright.HOVER\n  * @property {String} rotateright.DOWN\n  *\n  * @property {Object} previous - Images for the previous button.\n  * @property {String} previous.REST\n  * @property {String} previous.GROUP\n  * @property {String} previous.HOVER\n  * @property {String} previous.DOWN\n  *\n  * @property {Object} next - Images for the next button.\n  * @property {String} next.REST\n  * @property {String} next.GROUP\n  * @property {String} next.HOVER\n  * @property {String} next.DOWN\n  *\n  */\n\n\n /**\n  * This function serves as a single point of instantiation for an {@link OpenSeadragon.Viewer}, including all\n  * combinations of out-of-the-box configurable features.\n  *\n  * @param {OpenSeadragon.Options} options - Viewer options.\n  * @returns {OpenSeadragon.Viewer}\n  */\nwindow.OpenSeadragon = window.OpenSeadragon || function( options ){\n\n    return new OpenSeadragon.Viewer( options );\n\n};\n\nif (true) {\n   !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n       return (window.OpenSeadragon);\n   }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n(function( $ ){\n\n\n    /**\n     * The OpenSeadragon version.\n     *\n     * @member {Object} OpenSeadragon.version\n     * @property {String} versionStr - The version number as a string (\'major.minor.revision\').\n     * @property {Number} major - The major version number.\n     * @property {Number} minor - The minor version number.\n     * @property {Number} revision - The revision number.\n     * @since 1.0.0\n     */\n    $.version = {\n        versionStr: \'2.2.1\',\n        major: parseInt(\'2\', 10),\n        minor: parseInt(\'2\', 10),\n        revision: parseInt(\'1\', 10)\n    };\n\n\n    /**\n     * Taken from jquery 1.6.1\n     * [[Class]] -> type pairs\n     * @private\n     */\n    var class2type = {\n            \'[object Boolean]\':     \'boolean\',\n            \'[object Number]\':      \'number\',\n            \'[object String]\':      \'string\',\n            \'[object Function]\':    \'function\',\n            \'[object Array]\':       \'array\',\n            \'[object Date]\':        \'date\',\n            \'[object RegExp]\':      \'regexp\',\n            \'[object Object]\':      \'object\'\n        },\n        // Save a reference to some core methods\n        toString    = Object.prototype.toString,\n        hasOwn      = Object.prototype.hasOwnProperty;\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isFunction\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isFunction = function( obj ) {\n        return $.type(obj) === "function";\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isArray\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isArray = Array.isArray || function( obj ) {\n        return $.type(obj) === "array";\n    };\n\n\n    /**\n     * A crude way of determining if an object is a window.\n     * Taken from jQuery 1.6.1\n     * @function isWindow\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isWindow = function( obj ) {\n        return obj && typeof obj === "object" && "setInterval" in obj;\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function type\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.type = function( obj ) {\n        return ( obj === null ) || ( obj === undefined ) ?\n            String( obj ) :\n            class2type[ toString.call(obj) ] || "object";\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isPlainObject\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isPlainObject = function( obj ) {\n        // Must be an Object.\n        // Because of IE, we also have to check the presence of the constructor property.\n        // Make sure that DOM nodes and window objects don\'t pass through, as well\n        if ( !obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow( obj ) ) {\n            return false;\n        }\n\n        // Not own constructor property must be Object\n        if ( obj.constructor &&\n            !hasOwn.call(obj, "constructor") &&\n            !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {\n            return false;\n        }\n\n        // Own properties are enumerated firstly, so to speed up,\n        // if last one is own, then all properties are own.\n\n        var lastKey;\n        for (var key in obj ) {\n            lastKey = key;\n        }\n\n        return lastKey === undefined || hasOwn.call( obj, lastKey );\n    };\n\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function isEmptyObject\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.isEmptyObject = function( obj ) {\n        for ( var name in obj ) {\n            return false;\n        }\n        return true;\n    };\n\n    /**\n     * Shim around Object.freeze. Does nothing if Object.freeze is not supported.\n     * @param {Object} obj The object to freeze.\n     * @return {Object} obj The frozen object.\n     */\n    $.freezeObject = function(obj) {\n        if (Object.freeze) {\n            $.freezeObject = Object.freeze;\n        } else {\n            $.freezeObject = function(obj) {\n                return obj;\n            };\n        }\n        return $.freezeObject(obj);\n    };\n\n    /**\n     * True if the browser supports the HTML5 canvas element\n     * @member {Boolean} supportsCanvas\n     * @memberof OpenSeadragon\n     */\n    $.supportsCanvas = (function () {\n        var canvasElement = document.createElement( \'canvas\' );\n        return !!( $.isFunction( canvasElement.getContext ) &&\n                    canvasElement.getContext( \'2d\' ) );\n    }());\n\n    /**\n     * Test whether the submitted canvas is tainted or not.\n     * @argument {Canvas} canvas The canvas to test.\n     * @returns {Boolean} True if the canvas is tainted.\n     */\n    $.isCanvasTainted = function(canvas) {\n        var isTainted = false;\n        try {\n            // We test if the canvas is tainted by retrieving data from it.\n            // An exception will be raised if the canvas is tainted.\n            var data = canvas.getContext(\'2d\').getImageData(0, 0, 1, 1);\n        } catch (e) {\n            isTainted = true;\n        }\n        return isTainted;\n    };\n\n    /**\n     * A ratio comparing the device screen\'s pixel density to the canvas\'s backing store pixel density. Defaults to 1 if canvas isn\'t supported by the browser.\n     * @member {Number} pixelDensityRatio\n     * @memberof OpenSeadragon\n     */\n    $.pixelDensityRatio = (function () {\n        if ( $.supportsCanvas ) {\n            var context = document.createElement(\'canvas\').getContext(\'2d\');\n            var devicePixelRatio = window.devicePixelRatio || 1;\n            var backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                                    context.mozBackingStorePixelRatio ||\n                                    context.msBackingStorePixelRatio ||\n                                    context.oBackingStorePixelRatio ||\n                                    context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        } else {\n            return 1;\n        }\n    }());\n\n}( OpenSeadragon ));\n\n/**\n *  This closure defines all static methods available to the OpenSeadragon\n *  namespace.  Many, if not most, are taked directly from jQuery for use\n *  to simplify and reduce common programming patterns.  More static methods\n *  from jQuery may eventually make their way into this though we are\n *  attempting to avoid an explicit dependency on jQuery only because\n *  OpenSeadragon is a broadly useful code base and would be made less broad\n *  by requiring jQuery fully.\n *\n *  Some static methods have also been refactored from the original OpenSeadragon\n *  project.\n */\n(function( $ ){\n\n    /**\n     * Taken from jQuery 1.6.1\n     * @function extend\n     * @memberof OpenSeadragon\n     * @see {@link http://www.jquery.com/ jQuery}\n     */\n    $.extend = function() {\n        var options,\n            name,\n            src,\n            copy,\n            copyIsArray,\n            clone,\n            target  = arguments[ 0 ] || {},\n            length  = arguments.length,\n            deep    = false,\n            i       = 1;\n\n        // Handle a deep copy situation\n        if ( typeof target === "boolean" ) {\n            deep    = target;\n            target  = arguments[ 1 ] || {};\n            // skip the boolean and the target\n            i = 2;\n        }\n\n        // Handle case when target is a string or something (possible in deep copy)\n        if ( typeof target !== "object" && !OpenSeadragon.isFunction( target ) ) {\n            target = {};\n        }\n\n        // extend jQuery itself if only one argument is passed\n        if ( length === i ) {\n            target = this;\n            --i;\n        }\n\n        for ( ; i < length; i++ ) {\n            // Only deal with non-null/undefined values\n            options = arguments[ i ];\n            if ( options !== null || options !== undefined ) {\n                // Extend the base object\n                for ( name in options ) {\n                    src = target[ name ];\n                    copy = options[ name ];\n\n                    // Prevent never-ending loop\n                    if ( target === copy ) {\n                        continue;\n                    }\n\n                    // Recurse if we\'re merging plain objects or arrays\n                    if ( deep && copy && ( OpenSeadragon.isPlainObject( copy ) || ( copyIsArray = OpenSeadragon.isArray( copy ) ) ) ) {\n                        if ( copyIsArray ) {\n                            copyIsArray = false;\n                            clone = src && OpenSeadragon.isArray( src ) ? src : [];\n\n                        } else {\n                            clone = src && OpenSeadragon.isPlainObject( src ) ? src : {};\n                        }\n\n                        // Never move original objects, clone them\n                        target[ name ] = OpenSeadragon.extend( deep, clone, copy );\n\n                    // Don\'t bring in undefined values\n                    } else if ( copy !== undefined ) {\n                        target[ name ] = copy;\n                    }\n                }\n            }\n        }\n\n        // Return the modified object\n        return target;\n    };\n\n    var isIOSDevice = function () {\n        if (typeof navigator !== \'object\') {\n            return false;\n        }\n        var userAgent = navigator.userAgent;\n        if (typeof userAgent !== \'string\') {\n            return false;\n        }\n        return userAgent.indexOf(\'iPhone\') !== -1 ||\n               userAgent.indexOf(\'iPad\') !== -1 ||\n               userAgent.indexOf(\'iPod\') !== -1;\n    };\n\n    $.extend( $, /** @lends OpenSeadragon */{\n        /**\n         * The default values for the optional settings documented at {@link OpenSeadragon.Options}.\n         * @static\n         * @type {Object}\n         */\n        DEFAULT_SETTINGS: {\n            //DATA SOURCE DETAILS\n            xmlPath:                null,\n            tileSources:            null,\n            tileHost:               null,\n            initialPage:            0,\n            crossOriginPolicy:      false,\n            ajaxWithCredentials:    false,\n\n            //PAN AND ZOOM SETTINGS AND CONSTRAINTS\n            panHorizontal:          true,\n            panVertical:            true,\n            constrainDuringPan:     false,\n            wrapHorizontal:         false,\n            wrapVertical:           false,\n            visibilityRatio:        0.5, //-> how much of the viewer can be negative space\n            minPixelRatio:          0.5, //->closer to 0 draws tiles meant for a higher zoom at this zoom\n            defaultZoomLevel:       0,\n            minZoomLevel:           null,\n            maxZoomLevel:           null,\n            homeFillsViewer:        false,\n\n            //UI RESPONSIVENESS AND FEEL\n            clickTimeThreshold:     300,\n            clickDistThreshold:     5,\n            dblClickTimeThreshold:  300,\n            dblClickDistThreshold:  20,\n            springStiffness:        6.5,\n            animationTime:          1.2,\n            gestureSettingsMouse:   { scrollToZoom: true,  clickToZoom: true,  dblClickToZoom: false, pinchToZoom: false, flickEnabled: false, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            gestureSettingsTouch:   { scrollToZoom: false, clickToZoom: false, dblClickToZoom: true,  pinchToZoom: true,  flickEnabled: true,  flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            gestureSettingsPen:     { scrollToZoom: false, clickToZoom: true,  dblClickToZoom: false, pinchToZoom: false, flickEnabled: false, flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            gestureSettingsUnknown: { scrollToZoom: false, clickToZoom: false, dblClickToZoom: true,  pinchToZoom: true,  flickEnabled: true,  flickMinSpeed: 120, flickMomentum: 0.25, pinchRotate: false },\n            zoomPerClick:           2,\n            zoomPerScroll:          1.2,\n            zoomPerSecond:          1.0,\n            blendTime:              0,\n            alwaysBlend:            false,\n            autoHideControls:       true,\n            immediateRender:        false,\n            minZoomImageRatio:      0.9, //-> closer to 0 allows zoom out to infinity\n            maxZoomPixelRatio:      1.1, //-> higher allows \'over zoom\' into pixels\n            smoothTileEdgesMinZoom: 1.1, //-> higher than maxZoomPixelRatio disables it\n            iOSDevice:              isIOSDevice(),\n            pixelsPerWheelLine:     40,\n            autoResize:             true,\n            preserveImageSizeOnResize: false, // requires autoResize=true\n            minScrollDeltaTime:     50,\n\n            //DEFAULT CONTROL SETTINGS\n            showSequenceControl:     true,  //SEQUENCE\n            sequenceControlAnchor:   null,  //SEQUENCE\n            preserveViewport:        false, //SEQUENCE\n            preserveOverlays:        false, //SEQUENCE\n            navPrevNextWrap:         false, //SEQUENCE\n            showNavigationControl:   true,  //ZOOM/HOME/FULL/ROTATION\n            navigationControlAnchor: null,  //ZOOM/HOME/FULL/ROTATION\n            showZoomControl:         true,  //ZOOM\n            showHomeControl:         true,  //HOME\n            showFullPageControl:     true,  //FULL\n            showRotationControl:     false, //ROTATION\n            controlsFadeDelay:       2000,  //ZOOM/HOME/FULL/SEQUENCE\n            controlsFadeLength:      1500,  //ZOOM/HOME/FULL/SEQUENCE\n            mouseNavEnabled:         true,  //GENERAL MOUSE INTERACTIVITY\n\n            //VIEWPORT NAVIGATOR SETTINGS\n            showNavigator:              false,\n            navigatorId:                null,\n            navigatorPosition:          null,\n            navigatorSizeRatio:         0.2,\n            navigatorMaintainSizeRatio: false,\n            navigatorTop:               null,\n            navigatorLeft:              null,\n            navigatorHeight:            null,\n            navigatorWidth:             null,\n            navigatorAutoResize:        true,\n            navigatorAutoFade:          true,\n            navigatorRotate:            true,\n\n            // INITIAL ROTATION\n            degrees:                    0,\n\n            // APPEARANCE\n            opacity:                    1,\n            compositeOperation:         null,\n            placeholderFillStyle:       null,\n\n            //REFERENCE STRIP SETTINGS\n            showReferenceStrip:          false,\n            referenceStripScroll:       \'horizontal\',\n            referenceStripElement:       null,\n            referenceStripHeight:        null,\n            referenceStripWidth:         null,\n            referenceStripPosition:      \'BOTTOM_LEFT\',\n            referenceStripSizeRatio:     0.2,\n\n            //COLLECTION VISUALIZATION SETTINGS\n            collectionRows:         3, //or columns depending on layout\n            collectionColumns:      0, //columns in horizontal layout, rows in vertical layout\n            collectionLayout:       \'horizontal\', //vertical\n            collectionMode:         false,\n            collectionTileSize:     800,\n            collectionTileMargin:   80,\n\n            //PERFORMANCE SETTINGS\n            imageLoaderLimit:       0,\n            maxImageCacheCount:     200,\n            timeout:                30000,\n            useCanvas:              true,  // Use canvas element for drawing if available\n\n            //INTERFACE RESOURCE SETTINGS\n            prefixUrl:              "/images/",\n            navImages: {\n                zoomIn: {\n                    REST:   \'zoomin_rest.png\',\n                    GROUP:  \'zoomin_grouphover.png\',\n                    HOVER:  \'zoomin_hover.png\',\n                    DOWN:   \'zoomin_pressed.png\'\n                },\n                zoomOut: {\n                    REST:   \'zoomout_rest.png\',\n                    GROUP:  \'zoomout_grouphover.png\',\n                    HOVER:  \'zoomout_hover.png\',\n                    DOWN:   \'zoomout_pressed.png\'\n                },\n                home: {\n                    REST:   \'home_rest.png\',\n                    GROUP:  \'home_grouphover.png\',\n                    HOVER:  \'home_hover.png\',\n                    DOWN:   \'home_pressed.png\'\n                },\n                fullpage: {\n                    REST:   \'fullpage_rest.png\',\n                    GROUP:  \'fullpage_grouphover.png\',\n                    HOVER:  \'fullpage_hover.png\',\n                    DOWN:   \'fullpage_pressed.png\'\n                },\n                rotateleft: {\n                    REST:   \'rotateleft_rest.png\',\n                    GROUP:  \'rotateleft_grouphover.png\',\n                    HOVER:  \'rotateleft_hover.png\',\n                    DOWN:   \'rotateleft_pressed.png\'\n                },\n                rotateright: {\n                    REST:   \'rotateright_rest.png\',\n                    GROUP:  \'rotateright_grouphover.png\',\n                    HOVER:  \'rotateright_hover.png\',\n                    DOWN:   \'rotateright_pressed.png\'\n                },\n                previous: {\n                    REST:   \'previous_rest.png\',\n                    GROUP:  \'previous_grouphover.png\',\n                    HOVER:  \'previous_hover.png\',\n                    DOWN:   \'previous_pressed.png\'\n                },\n                next: {\n                    REST:   \'next_rest.png\',\n                    GROUP:  \'next_grouphover.png\',\n                    HOVER:  \'next_hover.png\',\n                    DOWN:   \'next_pressed.png\'\n                }\n            },\n\n            //DEVELOPER SETTINGS\n            debugMode:              false,\n            debugGridColor:         \'#437AB2\'\n        },\n\n\n        /**\n         * TODO: get rid of this.  I can\'t see how it\'s required at all.  Looks\n         *       like an early legacy code artifact.\n         * @static\n         * @ignore\n         */\n        SIGNAL: "----seadragon----",\n\n\n        /**\n         * Returns a function which invokes the method as if it were a method belonging to the object.\n         * @function\n         * @param {Object} object\n         * @param {Function} method\n         * @returns {Function}\n         */\n        delegate: function( object, method ) {\n            return function(){\n                var args = arguments;\n                if ( args === undefined ){\n                    args = [];\n                }\n                return method.apply( object, args );\n            };\n        },\n\n\n        /**\n         * An enumeration of Browser vendors.\n         * @static\n         * @type {Object}\n         * @property {Number} UNKNOWN\n         * @property {Number} IE\n         * @property {Number} FIREFOX\n         * @property {Number} SAFARI\n         * @property {Number} CHROME\n         * @property {Number} OPERA\n         */\n        BROWSERS: {\n            UNKNOWN:    0,\n            IE:         1,\n            FIREFOX:    2,\n            SAFARI:     3,\n            CHROME:     4,\n            OPERA:      5\n        },\n\n\n        /**\n         * Returns a DOM Element for the given id or element.\n         * @function\n         * @param {String|Element} element Accepts an id or element.\n         * @returns {Element} The element with the given id, null, or the element itself.\n         */\n        getElement: function( element ) {\n            if ( typeof ( element ) == "string" ) {\n                element = document.getElementById( element );\n            }\n            return element;\n        },\n\n\n        /**\n         * Determines the position of the upper-left corner of the element.\n         * @function\n         * @param {Element|String} element - the elemenet we want the position for.\n         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.\n         */\n        getElementPosition: function( element ) {\n            var result = new $.Point(),\n                isFixed,\n                offsetParent;\n\n            element      = $.getElement( element );\n            isFixed      = $.getElementStyle( element ).position == "fixed";\n            offsetParent = getOffsetParent( element, isFixed );\n\n            while ( offsetParent ) {\n\n                result.x += element.offsetLeft;\n                result.y += element.offsetTop;\n\n                if ( isFixed ) {\n                    result = result.plus( $.getPageScroll() );\n                }\n\n                element = offsetParent;\n                isFixed = $.getElementStyle( element ).position == "fixed";\n                offsetParent = getOffsetParent( element, isFixed );\n            }\n\n            return result;\n        },\n\n\n        /**\n         * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.\n         * @function\n         * @param {Element|String} element - the element we want the position for.\n         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.\n         */\n        getElementOffset: function( element ) {\n            element = $.getElement( element );\n\n            var doc = element && element.ownerDocument,\n                docElement,\n                win,\n                boundingRect = { top: 0, left: 0 };\n\n            if ( !doc ) {\n                return new $.Point();\n            }\n\n            docElement = doc.documentElement;\n\n            if ( typeof element.getBoundingClientRect !== typeof undefined ) {\n                boundingRect = element.getBoundingClientRect();\n            }\n\n            win = ( doc == doc.window ) ?\n                doc :\n                ( doc.nodeType === 9 ) ?\n                    doc.defaultView || doc.parentWindow :\n                    false;\n\n            return new $.Point(\n                boundingRect.left + ( win.pageXOffset || docElement.scrollLeft ) - ( docElement.clientLeft || 0 ),\n                boundingRect.top + ( win.pageYOffset || docElement.scrollTop ) - ( docElement.clientTop || 0 )\n            );\n        },\n\n\n        /**\n         * Determines the height and width of the given element.\n         * @function\n         * @param {Element|String} element\n         * @returns {OpenSeadragon.Point}\n         */\n        getElementSize: function( element ) {\n            element = $.getElement( element );\n\n            return new $.Point(\n                element.clientWidth,\n                element.clientHeight\n            );\n        },\n\n\n        /**\n         * Returns the CSSStyle object for the given element.\n         * @function\n         * @param {Element|String} element\n         * @returns {CSSStyle}\n         */\n        getElementStyle:\n            document.documentElement.currentStyle ?\n            function( element ) {\n                element = $.getElement( element );\n                return element.currentStyle;\n            } :\n            function( element ) {\n                element = $.getElement( element );\n                return window.getComputedStyle( element, "" );\n            },\n\n        /**\n         * Returns the property with the correct vendor prefix appended.\n         * @param {String} property the property name\n         * @returns {String} the property with the correct prefix or null if not\n         * supported.\n         */\n        getCssPropertyWithVendorPrefix: function(property) {\n            var memo = {};\n\n            $.getCssPropertyWithVendorPrefix = function(property) {\n                if (memo[property] !== undefined) {\n                    return memo[property];\n                }\n                var style = document.createElement(\'div\').style;\n                var result = null;\n                if (style[property] !== undefined) {\n                    result = property;\n                } else {\n                    var prefixes = [\'Webkit\', \'Moz\', \'MS\', \'O\',\n                        \'webkit\', \'moz\', \'ms\', \'o\'];\n                    var suffix = $.capitalizeFirstLetter(property);\n                    for (var i = 0; i < prefixes.length; i++) {\n                        var prop = prefixes[i] + suffix;\n                        if (style[prop] !== undefined) {\n                            result = prop;\n                            break;\n                        }\n                    }\n                }\n                memo[property] = result;\n                return result;\n            };\n            return $.getCssPropertyWithVendorPrefix(property);\n        },\n\n        /**\n         * Capitalizes the first letter of a string\n         * @param {String} string\n         * @returns {String} The string with the first letter capitalized\n         */\n        capitalizeFirstLetter: function(string) {\n            return string.charAt(0).toUpperCase() + string.slice(1);\n        },\n\n        /**\n         * Determines if a point is within the bounding rectangle of the given element (hit-test).\n         * @function\n         * @param {Element|String} element\n         * @param {OpenSeadragon.Point} point\n         * @returns {Boolean}\n         */\n        pointInElement: function( element, point ) {\n            element = $.getElement( element );\n            var offset = $.getElementOffset( element ),\n                size = $.getElementSize( element );\n            return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;\n        },\n\n\n        /**\n         * Gets the latest event, really only useful internally since its\n         * specific to IE behavior.\n         * @function\n         * @param {Event} [event]\n         * @returns {Event}\n         * @deprecated For internal use only\n         * @private\n         */\n        getEvent: function( event ) {\n            if( event ){\n                $.getEvent = function( event ) {\n                    return event;\n                };\n            } else {\n                $.getEvent = function() {\n                    return window.event;\n                };\n            }\n            return $.getEvent( event );\n        },\n\n\n        /**\n         * Gets the position of the mouse on the screen for a given event.\n         * @function\n         * @param {Event} [event]\n         * @returns {OpenSeadragon.Point}\n         */\n        getMousePosition: function( event ) {\n\n            if ( typeof( event.pageX ) == "number" ) {\n                $.getMousePosition = function( event ){\n                    var result = new $.Point();\n\n                    event = $.getEvent( event );\n                    result.x = event.pageX;\n                    result.y = event.pageY;\n\n                    return result;\n                };\n            } else if ( typeof( event.clientX ) == "number" ) {\n                $.getMousePosition = function( event ){\n                    var result = new $.Point();\n\n                    event = $.getEvent( event );\n                    result.x =\n                        event.clientX +\n                        document.body.scrollLeft +\n                        document.documentElement.scrollLeft;\n                    result.y =\n                        event.clientY +\n                        document.body.scrollTop +\n                        document.documentElement.scrollTop;\n\n                    return result;\n                };\n            } else {\n                throw new Error(\n                    "Unknown event mouse position, no known technique."\n                );\n            }\n\n            return $.getMousePosition( event );\n        },\n\n\n        /**\n         * Determines the page\'s current scroll position.\n         * @function\n         * @returns {OpenSeadragon.Point}\n         */\n        getPageScroll: function() {\n            var docElement  = document.documentElement || {},\n                body        = document.body || {};\n\n            if ( typeof( window.pageXOffset ) == "number" ) {\n                $.getPageScroll = function(){\n                    return new $.Point(\n                        window.pageXOffset,\n                        window.pageYOffset\n                    );\n                };\n            } else if ( body.scrollLeft || body.scrollTop ) {\n                $.getPageScroll = function(){\n                    return new $.Point(\n                        document.body.scrollLeft,\n                        document.body.scrollTop\n                    );\n                };\n            } else if ( docElement.scrollLeft || docElement.scrollTop ) {\n                $.getPageScroll = function(){\n                    return new $.Point(\n                        document.documentElement.scrollLeft,\n                        document.documentElement.scrollTop\n                    );\n                };\n            } else {\n                // We can\'t reassign the function yet, as there was no scroll.\n                return new $.Point(0,0);\n            }\n\n            return $.getPageScroll();\n        },\n\n        /**\n         * Set the page scroll position.\n         * @function\n         * @returns {OpenSeadragon.Point}\n         */\n        setPageScroll: function( scroll ) {\n            if ( typeof ( window.scrollTo ) !== "undefined" ) {\n                $.setPageScroll = function( scroll ) {\n                    window.scrollTo( scroll.x, scroll.y );\n                };\n            } else {\n                var originalScroll = $.getPageScroll();\n                if ( originalScroll.x === scroll.x &&\n                    originalScroll.y === scroll.y ) {\n                    // We are already correctly positioned and there\n                    // is no way to detect the correct method.\n                    return;\n                }\n\n                document.body.scrollLeft = scroll.x;\n                document.body.scrollTop = scroll.y;\n                var currentScroll = $.getPageScroll();\n                if ( currentScroll.x !== originalScroll.x &&\n                    currentScroll.y !== originalScroll.y ) {\n                    $.setPageScroll = function( scroll ) {\n                        document.body.scrollLeft = scroll.x;\n                        document.body.scrollTop = scroll.y;\n                    };\n                    return;\n                }\n\n                document.documentElement.scrollLeft = scroll.x;\n                document.documentElement.scrollTop = scroll.y;\n                currentScroll = $.getPageScroll();\n                if ( currentScroll.x !== originalScroll.x &&\n                    currentScroll.y !== originalScroll.y ) {\n                    $.setPageScroll = function( scroll ) {\n                        document.documentElement.scrollLeft = scroll.x;\n                        document.documentElement.scrollTop = scroll.y;\n                    };\n                    return;\n                }\n\n                // We can\'t find anything working, so we do nothing.\n                $.setPageScroll = function( scroll ) {\n                };\n            }\n\n            return $.setPageScroll( scroll );\n        },\n\n        /**\n         * Determines the size of the browsers window.\n         * @function\n         * @returns {OpenSeadragon.Point}\n         */\n        getWindowSize: function() {\n            var docElement = document.documentElement || {},\n                body    = document.body || {};\n\n            if ( typeof( window.innerWidth ) == \'number\' ) {\n                $.getWindowSize = function(){\n                    return new $.Point(\n                        window.innerWidth,\n                        window.innerHeight\n                    );\n                };\n            } else if ( docElement.clientWidth || docElement.clientHeight ) {\n                $.getWindowSize = function(){\n                    return new $.Point(\n                        document.documentElement.clientWidth,\n                        document.documentElement.clientHeight\n                    );\n                };\n            } else if ( body.clientWidth || body.clientHeight ) {\n                $.getWindowSize = function(){\n                    return new $.Point(\n                        document.body.clientWidth,\n                        document.body.clientHeight\n                    );\n                };\n            } else {\n                throw new Error("Unknown window size, no known technique.");\n            }\n\n            return $.getWindowSize();\n        },\n\n\n        /**\n         * Wraps the given element in a nest of divs so that the element can\n         * be easily centered using CSS tables\n         * @function\n         * @param {Element|String} element\n         * @returns {Element} outermost wrapper element\n         */\n        makeCenteredNode: function( element ) {\n            // Convert a possible ID to an actual HTMLElement\n            element = $.getElement( element );\n\n            /*\n                CSS tables require you to have a display:table/row/cell hierarchy so we need to create\n                three nested wrapper divs:\n             */\n\n            var wrappers = [\n                $.makeNeutralElement( \'div\' ),\n                $.makeNeutralElement( \'div\' ),\n                $.makeNeutralElement( \'div\' )\n            ];\n\n            // It feels like we should be able to pass style dicts to makeNeutralElement:\n            $.extend(wrappers[0].style, {\n                display: "table",\n                height: "100%",\n                width: "100%"\n            });\n\n            $.extend(wrappers[1].style, {\n                display: "table-row"\n            });\n\n            $.extend(wrappers[2].style, {\n                display: "table-cell",\n                verticalAlign: "middle",\n                textAlign: "center"\n            });\n\n            wrappers[0].appendChild(wrappers[1]);\n            wrappers[1].appendChild(wrappers[2]);\n            wrappers[2].appendChild(element);\n\n            return wrappers[0];\n        },\n\n\n        /**\n         * Creates an easily positionable element of the given type that therefor\n         * serves as an excellent container element.\n         * @function\n         * @param {String} tagName\n         * @returns {Element}\n         */\n        makeNeutralElement: function( tagName ) {\n            var element = document.createElement( tagName ),\n                style   = element.style;\n\n            style.background = "transparent none";\n            style.border     = "none";\n            style.margin     = "0px";\n            style.padding    = "0px";\n            style.position   = "static";\n\n            return element;\n        },\n\n\n        /**\n         * Returns the current milliseconds, using Date.now() if available\n         * @function\n         */\n        now: function( ) {\n          if (Date.now) {\n            $.now = Date.now;\n          } else {\n            $.now = function() { return new Date().getTime(); };\n          }\n\n          return $.now();\n        },\n\n\n        /**\n         * Ensures an image is loaded correctly to support alpha transparency.\n         * Generally only IE has issues doing this correctly for formats like\n         * png.\n         * @function\n         * @param {String} src\n         * @returns {Element}\n         */\n        makeTransparentImage: function( src ) {\n\n            $.makeTransparentImage = function( src ){\n                var img = $.makeNeutralElement( "img" );\n\n                img.src = src;\n\n                return img;\n            };\n\n            if ( $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 7 ) {\n\n                $.makeTransparentImage = function( src ){\n                    var img     = $.makeNeutralElement( "img" ),\n                        element = null;\n\n                    element = $.makeNeutralElement("span");\n                    element.style.display = "inline-block";\n\n                    img.onload = function() {\n                        element.style.width  = element.style.width || img.width + "px";\n                        element.style.height = element.style.height || img.height + "px";\n\n                        img.onload = null;\n                        img = null;     // to prevent memory leaks in IE\n                    };\n\n                    img.src = src;\n                    element.style.filter =\n                        "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'" +\n                        src +\n                        "\', sizingMethod=\'scale\')";\n\n                    return element;\n                };\n\n            }\n\n            return $.makeTransparentImage( src );\n        },\n\n\n        /**\n         * Sets the opacity of the specified element.\n         * @function\n         * @param {Element|String} element\n         * @param {Number} opacity\n         * @param {Boolean} [usesAlpha]\n         */\n        setElementOpacity: function( element, opacity, usesAlpha ) {\n\n            var ieOpacity,\n                ieFilter;\n\n            element = $.getElement( element );\n\n            if ( usesAlpha && !$.Browser.alpha ) {\n                opacity = Math.round( opacity );\n            }\n\n            if ( $.Browser.opacity ) {\n                element.style.opacity = opacity < 1 ? opacity : "";\n            } else {\n                if ( opacity < 1 ) {\n                    ieOpacity = Math.round( 100 * opacity );\n                    ieFilter  = "alpha(opacity=" + ieOpacity + ")";\n                    element.style.filter = ieFilter;\n                } else {\n                    element.style.filter = "";\n                }\n            }\n        },\n\n\n        /**\n         * Sets the specified element\'s touch-action style attribute to \'none\'.\n         * @function\n         * @param {Element|String} element\n         */\n        setElementTouchActionNone: function( element ) {\n            element = $.getElement( element );\n            if ( typeof element.style.touchAction !== \'undefined\' ) {\n                element.style.touchAction = \'none\';\n            } else if ( typeof element.style.msTouchAction !== \'undefined\' ) {\n                element.style.msTouchAction = \'none\';\n            }\n        },\n\n\n        /**\n         * Add the specified CSS class to the element if not present.\n         * @function\n         * @param {Element|String} element\n         * @param {String} className\n         */\n        addClass: function( element, className ) {\n            element = $.getElement( element );\n\n            if ( ! element.className ) {\n                element.className = className;\n            } else if ( ( \' \' + element.className + \' \' ).\n                indexOf( \' \' + className + \' \' ) === -1 ) {\n                element.className += \' \' + className;\n            }\n        },\n\n        /**\n         * Find the first index at which an element is found in an array or -1\n         * if not present.\n         *\n         * Code taken and adapted from\n         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility\n         *\n         * @function\n         * @param {Array} array The array from which to find the element\n         * @param {Object} searchElement The element to find\n         * @param {Number} [fromIndex=0] Index to start research.\n         * @returns {Number} The index of the element in the array.\n         */\n        indexOf: function( array, searchElement, fromIndex ) {\n            if ( Array.prototype.indexOf ) {\n                this.indexOf = function( array, searchElement, fromIndex ) {\n                    return array.indexOf( searchElement, fromIndex );\n                };\n            } else {\n                this.indexOf = function( array, searchElement, fromIndex ) {\n                    var i,\n                        pivot = ( fromIndex ) ? fromIndex : 0,\n                        length;\n                    if ( !array ) {\n                        throw new TypeError( );\n                    }\n\n                    length = array.length;\n                    if ( length === 0 || pivot >= length ) {\n                        return -1;\n                    }\n\n                    if ( pivot < 0 ) {\n                        pivot = length - Math.abs( pivot );\n                    }\n\n                    for ( i = pivot; i < length; i++ ) {\n                        if ( array[i] === searchElement ) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                };\n            }\n            return this.indexOf( array, searchElement, fromIndex );\n        },\n\n        /**\n         * Remove the specified CSS class from the element.\n         * @function\n         * @param {Element|String} element\n         * @param {String} className\n         */\n        removeClass: function( element, className ) {\n            var oldClasses,\n                newClasses = [],\n                i;\n\n            element = $.getElement( element );\n            oldClasses = element.className.split( /\\s+/ );\n            for ( i = 0; i < oldClasses.length; i++ ) {\n                if ( oldClasses[ i ] && oldClasses[ i ] !== className ) {\n                    newClasses.push( oldClasses[ i ] );\n                }\n            }\n            element.className = newClasses.join(\' \');\n        },\n\n\n        /**\n         * Adds an event listener for the given element, eventName and handler.\n         * @function\n         * @param {Element|String} element\n         * @param {String} eventName\n         * @param {Function} handler\n         * @param {Boolean} [useCapture]\n         */\n        addEvent: (function () {\n            if ( window.addEventListener ) {\n                return function ( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.addEventListener( eventName, handler, useCapture );\n                };\n            } else if ( window.attachEvent ) {\n                return function ( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.attachEvent( \'on\' + eventName, handler );\n                };\n            } else {\n                throw new Error( "No known event model." );\n            }\n        }()),\n\n\n        /**\n         * Remove a given event listener for the given element, event type and\n         * handler.\n         * @function\n         * @param {Element|String} element\n         * @param {String} eventName\n         * @param {Function} handler\n         * @param {Boolean} [useCapture]\n         */\n        removeEvent: (function () {\n            if ( window.removeEventListener ) {\n                return function ( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.removeEventListener( eventName, handler, useCapture );\n                };\n            } else if ( window.detachEvent ) {\n                return function( element, eventName, handler, useCapture ) {\n                    element = $.getElement( element );\n                    element.detachEvent( \'on\' + eventName, handler );\n                };\n            } else {\n                throw new Error( "No known event model." );\n            }\n        }()),\n\n\n        /**\n         * Cancels the default browser behavior had the event propagated all\n         * the way up the DOM to the window object.\n         * @function\n         * @param {Event} [event]\n         */\n        cancelEvent: function( event ) {\n            event = $.getEvent( event );\n\n            if ( event.preventDefault ) {\n                $.cancelEvent = function( event ){\n                    // W3C for preventing default\n                    event.preventDefault();\n                };\n            } else {\n                $.cancelEvent = function( event ){\n                    event = $.getEvent( event );\n                    // legacy for preventing default\n                    event.cancel = true;\n                    // IE for preventing default\n                    event.returnValue = false;\n                };\n            }\n            $.cancelEvent( event );\n        },\n\n\n        /**\n         * Stops the propagation of the event up the DOM.\n         * @function\n         * @param {Event} [event]\n         */\n        stopEvent: function( event ) {\n            event = $.getEvent( event );\n\n            if ( event.stopPropagation ) {\n                // W3C for stopping propagation\n                $.stopEvent = function( event ){\n                    event.stopPropagation();\n                };\n            } else {\n                // IE for stopping propagation\n                $.stopEvent = function( event ){\n                    event = $.getEvent( event );\n                    event.cancelBubble = true;\n                };\n\n            }\n\n            $.stopEvent( event );\n        },\n\n\n        /**\n         * Similar to OpenSeadragon.delegate, but it does not immediately call\n         * the method on the object, returning a function which can be called\n         * repeatedly to delegate the method. It also allows additonal arguments\n         * to be passed during construction which will be added during each\n         * invocation, and each invocation can add additional arguments as well.\n         *\n         * @function\n         * @param {Object} object\n         * @param {Function} method\n         * @param [args] any additional arguments are passed as arguments to the\n         *  created callback\n         * @returns {Function}\n         */\n        createCallback: function( object, method ) {\n            //TODO: This pattern is painful to use and debug.  It\'s much cleaner\n            //      to use pinning plus anonymous functions.  Get rid of this\n            //      pattern!\n            var initialArgs = [],\n                i;\n            for ( i = 2; i < arguments.length; i++ ) {\n                initialArgs.push( arguments[ i ] );\n            }\n\n            return function() {\n                var args = initialArgs.concat( [] ),\n                    i;\n                for ( i = 0; i < arguments.length; i++ ) {\n                    args.push( arguments[ i ] );\n                }\n\n                return method.apply( object, args );\n            };\n        },\n\n\n        /**\n         * Retreives the value of a url parameter from the window.location string.\n         * @function\n         * @param {String} key\n         * @returns {String} The value of the url parameter or null if no param matches.\n         */\n        getUrlParameter: function( key ) {\n            var value = URLPARAMS[ key ];\n            return value ? value : null;\n        },\n\n        /**\n         * Retrieves the protocol used by the url. The url can either be absolute\n         * or relative.\n         * @function\n         * @private\n         * @param {String} url The url to retrieve the protocol from.\n         * @return {String} The protocol (http:, https:, file:, ftp: ...)\n         */\n        getUrlProtocol: function( url ) {\n            var match = url.match(/^([a-z]+:)\\/\\//i);\n            if ( match === null ) {\n                // Relative URL, retrive the protocol from window.location\n                return window.location.protocol;\n            }\n            return match[1].toLowerCase();\n        },\n\n        /**\n         * Create an XHR object\n         * @private\n         * @param {type} [local] If set to true, the XHR will be file: protocol\n         * compatible if possible (but may raise a warning in the browser).\n         * @returns {XMLHttpRequest}\n         */\n        createAjaxRequest: function( local ) {\n            // IE11 does not support window.ActiveXObject so we just try to\n            // create one to see if it is supported.\n            // See: http://msdn.microsoft.com/en-us/library/ie/dn423948%28v=vs.85%29.aspx\n            var supportActiveX;\n            try {\n                /* global ActiveXObject:true */\n                supportActiveX = !!new ActiveXObject( "Microsoft.XMLHTTP" );\n            } catch( e ) {\n                supportActiveX = false;\n            }\n\n            if ( supportActiveX ) {\n                if ( window.XMLHttpRequest ) {\n                    $.createAjaxRequest = function( local ) {\n                        if ( local ) {\n                            return new ActiveXObject( "Microsoft.XMLHTTP" );\n                        }\n                        return new XMLHttpRequest();\n                    };\n                } else {\n                    $.createAjaxRequest = function() {\n                        return new ActiveXObject( "Microsoft.XMLHTTP" );\n                    };\n                }\n            } else if ( window.XMLHttpRequest ) {\n                $.createAjaxRequest = function() {\n                    return new XMLHttpRequest();\n                };\n            } else {\n                throw new Error( "Browser doesn\'t support XMLHttpRequest." );\n            }\n            return $.createAjaxRequest( local );\n        },\n\n        /**\n         * Makes an AJAX request.\n         * @param {Object} options\n         * @param {String} options.url - the url to request\n         * @param {Function} options.success - a function to call on a successful response\n         * @param {Function} options.error - a function to call on when an error occurs\n         * @param {Boolean} [options.withCredentials=false] - whether to set the XHR\'s withCredentials\n         * @throws {Error}\n         */\n        makeAjaxRequest: function( url, onSuccess, onError ) {\n            var withCredentials;\n\n            // Note that our preferred API is that you pass in a single object; the named\n            // arguments are for legacy support.\n            if( $.isPlainObject( url ) ){\n                onSuccess = url.success;\n                onError = url.error;\n                withCredentials = url.withCredentials;\n                url = url.url;\n            }\n\n            var protocol = $.getUrlProtocol( url );\n            var request = $.createAjaxRequest( protocol === "file:" );\n\n            if ( !$.isFunction( onSuccess ) ) {\n                throw new Error( "makeAjaxRequest requires a success callback" );\n            }\n\n            request.onreadystatechange = function() {\n                // 4 = DONE (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Properties)\n                if ( request.readyState == 4 ) {\n                    request.onreadystatechange = function(){};\n\n                    // With protocols other than http/https, the status is 200\n                    // on Firefox and 0 on other browsers\n                    if ( request.status === 200 ||\n                        ( request.status === 0 &&\n                          protocol !== "http:" &&\n                          protocol !== "https:" )) {\n                        onSuccess( request );\n                    } else {\n                        $.console.log( "AJAX request returned %d: %s", request.status, url );\n\n                        if ( $.isFunction( onError ) ) {\n                            onError( request );\n                        }\n                    }\n                }\n            };\n\n            if (withCredentials) {\n                request.withCredentials = true;\n            }\n\n            try {\n                request.open( "GET", url, true );\n                request.send( null );\n            } catch (e) {\n                var msg = e.message;\n\n                /*\n                    IE < 10 does not support CORS and an XHR request to a different origin will fail as soon\n                    as send() is called. This is particularly easy to miss during development and appear in\n                    production if you use a CDN or domain sharding and the security policy is likely to break\n                    exception handlers since any attempt to access a property of the request object will\n                    raise an access denied TypeError inside the catch block.\n\n                    To be friendlier, we\'ll check for this specific error and add a documentation pointer\n                    to point developers in the right direction. We test the exception number because IE\'s\n                    error messages are localized.\n                */\n                var oldIE = $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 10;\n                if ( oldIE && typeof( e.number ) != "undefined" && e.number == -2147024891 ) {\n                    msg += "\\nSee http://msdn.microsoft.com/en-us/library/ms537505(v=vs.85).aspx#xdomain";\n                }\n\n                $.console.log( "%s while making AJAX request: %s", e.name, msg );\n\n                request.onreadystatechange = function(){};\n\n                if (window.XDomainRequest) { // IE9 or IE8 might as well try to use XDomainRequest\n                    var xdr = new XDomainRequest();\n                    if (xdr) {\n                        xdr.onload = function (e) {\n                            if ( $.isFunction( onSuccess ) ) {\n                                onSuccess({ // Faking an xhr object\n                                    responseText: xdr.responseText,\n                                    status: 200, // XDomainRequest doesn\'t support status codes, so we just fake one! :/\n                                    statusText: \'OK\'\n                                });\n                            }\n                        };\n                        xdr.onerror = function (e) {\n                            if ( $.isFunction ( onError ) ) {\n                                onError({ // Faking an xhr object\n                                    responseText: xdr.responseText,\n                                    status: 444, // 444 No Response\n                                    statusText: \'An error happened. Due to an XDomainRequest deficiency we can not extract any information about this error. Upgrade your browser.\'\n                                });\n                            }\n                        };\n                        try {\n                            xdr.open(\'GET\', url);\n                            xdr.send();\n                        } catch (e2) {\n                            if ( $.isFunction( onError ) ) {\n                                onError( request, e );\n                            }\n                        }\n                    }\n                } else {\n                    if ( $.isFunction( onError ) ) {\n                        onError( request, e );\n                    }\n                }\n            }\n        },\n\n        /**\n         * Taken from jQuery 1.6.1\n         * @function\n         * @param {Object} options\n         * @param {String} options.url\n         * @param {Function} options.callback\n         * @param {String} [options.param=\'callback\'] The name of the url parameter\n         *      to request the jsonp provider with.\n         * @param {String} [options.callbackName=] The name of the callback to\n         *      request the jsonp provider with.\n         */\n        jsonp: function( options ){\n            var script,\n                url     = options.url,\n                head    = document.head ||\n                    document.getElementsByTagName( "head" )[ 0 ] ||\n                    document.documentElement,\n                jsonpCallback = options.callbackName || \'openseadragon\' + $.now(),\n                previous      = window[ jsonpCallback ],\n                replace       = "$1" + jsonpCallback + "$2",\n                callbackParam = options.param || \'callback\',\n                callback      = options.callback;\n\n            url = url.replace( /(\\=)\\?(&|$)|\\?\\?/i, replace );\n            // Add callback manually\n            url += (/\\?/.test( url ) ? "&" : "?") + callbackParam + "=" + jsonpCallback;\n\n            // Install callback\n            window[ jsonpCallback ] = function( response ) {\n                if ( !previous ){\n                    try{\n                        delete window[ jsonpCallback ];\n                    }catch(e){\n                        //swallow\n                    }\n                } else {\n                    window[ jsonpCallback ] = previous;\n                }\n                if( callback && $.isFunction( callback ) ){\n                    callback( response );\n                }\n            };\n\n            script = document.createElement( "script" );\n\n            //TODO: having an issue with async info requests\n            if( undefined !== options.async || false !== options.async ){\n                script.async = "async";\n            }\n\n            if ( options.scriptCharset ) {\n                script.charset = options.scriptCharset;\n            }\n\n            script.src = url;\n\n            // Attach handlers for all browsers\n            script.onload = script.onreadystatechange = function( _, isAbort ) {\n\n                if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n                    // Handle memory leak in IE\n                    script.onload = script.onreadystatechange = null;\n\n                    // Remove the script\n                    if ( head && script.parentNode ) {\n                        head.removeChild( script );\n                    }\n\n                    // Dereference the script\n                    script = undefined;\n                }\n            };\n            // Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n            // This arises when a base node is used (#2709 and #4378).\n            head.insertBefore( script, head.firstChild );\n\n        },\n\n\n        /**\n         * Fully deprecated. Will throw an error.\n         * @function\n         * @deprecated use {@link OpenSeadragon.Viewer#open}\n         */\n        createFromDZI: function() {\n            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";\n        },\n\n        /**\n         * Parses an XML string into a DOM Document.\n         * @function\n         * @param {String} string\n         * @returns {Document}\n         */\n        parseXml: function( string ) {\n            if ( window.DOMParser ) {\n\n                $.parseXml = function( string ) {\n                    var xmlDoc = null,\n                        parser;\n\n                    parser = new DOMParser();\n                    xmlDoc = parser.parseFromString( string, "text/xml" );\n                    return xmlDoc;\n                };\n\n            } else if ( window.ActiveXObject ) {\n\n                $.parseXml = function( string ) {\n                    var xmlDoc = null;\n\n                    xmlDoc = new ActiveXObject( "Microsoft.XMLDOM" );\n                    xmlDoc.async = false;\n                    xmlDoc.loadXML( string );\n                    return xmlDoc;\n                };\n\n            } else {\n                throw new Error( "Browser doesn\'t support XML DOM." );\n            }\n\n            return $.parseXml( string );\n        },\n\n        /**\n         * Parses a JSON string into a Javascript object.\n         * @function\n         * @param {String} string\n         * @returns {Object}\n         */\n        parseJSON: function(string) {\n            if (window.JSON && window.JSON.parse) {\n                $.parseJSON = window.JSON.parse;\n            } else {\n                // Should only be used by IE8 in non standards mode\n                $.parseJSON = function(string) {\n                    /*jshint evil:true*/\n                    return eval(\'(\' + string + \')\');\n                };\n            }\n            return $.parseJSON(string);\n        },\n\n        /**\n         * Reports whether the image format is supported for tiling in this\n         * version.\n         * @function\n         * @param {String} [extension]\n         * @returns {Boolean}\n         */\n        imageFormatSupported: function( extension ) {\n            extension = extension ? extension : "";\n            return !!FILEFORMATS[ extension.toLowerCase() ];\n        }\n\n    });\n\n\n    /**\n     * The current browser vendor, version, and related information regarding detected features.\n     * @member {Object} Browser\n     * @memberof OpenSeadragon\n     * @static\n     * @type {Object}\n     * @property {OpenSeadragon.BROWSERS} vendor - One of the {@link OpenSeadragon.BROWSERS} enumeration values.\n     * @property {Number} version\n     * @property {Boolean} alpha - Does the browser support image alpha transparency.\n     */\n    $.Browser = {\n        vendor:     $.BROWSERS.UNKNOWN,\n        version:    0,\n        alpha:      true\n    };\n\n\n    var FILEFORMATS = {\n            "bmp":  false,\n            "jpeg": true,\n            "jpg":  true,\n            "png":  true,\n            "tif":  false,\n            "wdp":  false\n        },\n        URLPARAMS = {};\n\n    (function() {\n        //A small auto-executing routine to determine the browser vendor,\n        //version and supporting feature sets.\n        var app = navigator.appName,\n            ver = navigator.appVersion,\n            ua  = navigator.userAgent,\n            regex;\n\n        //console.error( \'appName: \' + navigator.appName );\n        //console.error( \'appVersion: \' + navigator.appVersion );\n        //console.error( \'userAgent: \' + navigator.userAgent );\n\n        switch( navigator.appName ){\n            case "Microsoft Internet Explorer":\n                if( !!window.attachEvent &&\n                    !!window.ActiveXObject ) {\n\n                    $.Browser.vendor = $.BROWSERS.IE;\n                    $.Browser.version = parseFloat(\n                        ua.substring(\n                            ua.indexOf( "MSIE" ) + 5,\n                            ua.indexOf( ";", ua.indexOf( "MSIE" ) ) )\n                        );\n                }\n                break;\n            case "Netscape":\n                if( !!window.addEventListener ){\n                    if ( ua.indexOf( "Firefox" ) >= 0 ) {\n                        $.Browser.vendor = $.BROWSERS.FIREFOX;\n                        $.Browser.version = parseFloat(\n                            ua.substring( ua.indexOf( "Firefox" ) + 8 )\n                        );\n                    } else if ( ua.indexOf( "Safari" ) >= 0 ) {\n                        $.Browser.vendor = ua.indexOf( "Chrome" ) >= 0 ?\n                            $.BROWSERS.CHROME :\n                            $.BROWSERS.SAFARI;\n                        $.Browser.version = parseFloat(\n                            ua.substring(\n                                ua.substring( 0, ua.indexOf( "Safari" ) ).lastIndexOf( "/" ) + 1,\n                                ua.indexOf( "Safari" )\n                            )\n                        );\n                    } else {\n                        regex = new RegExp( "Trident/.*rv:([0-9]{1,}[.0-9]{0,})");\n                        if ( regex.exec( ua ) !== null ) {\n                            $.Browser.vendor = $.BROWSERS.IE;\n                            $.Browser.version = parseFloat( RegExp.$1 );\n                        }\n                    }\n                }\n                break;\n            case "Opera":\n                $.Browser.vendor = $.BROWSERS.OPERA;\n                $.Browser.version = parseFloat( ver );\n                break;\n        }\n\n            // ignore \'?\' portion of query string\n        var query = window.location.search.substring( 1 ),\n            parts = query.split(\'&\'),\n            part,\n            sep,\n            i;\n\n        for ( i = 0; i < parts.length; i++ ) {\n            part = parts[ i ];\n            sep  = part.indexOf( \'=\' );\n\n            if ( sep > 0 ) {\n                URLPARAMS[ part.substring( 0, sep ) ] =\n                    decodeURIComponent( part.substring( sep + 1 ) );\n            }\n        }\n\n        //determine if this browser supports image alpha transparency\n        $.Browser.alpha = !(\n            (\n                $.Browser.vendor == $.BROWSERS.IE &&\n                $.Browser.version < 9\n            ) || (\n                $.Browser.vendor == $.BROWSERS.CHROME &&\n                $.Browser.version < 2\n            )\n        );\n\n        //determine if this browser supports element.style.opacity\n        $.Browser.opacity = !(\n            $.Browser.vendor == $.BROWSERS.IE &&\n            $.Browser.version < 9\n        );\n\n    })();\n\n\n    //TODO: $.console is often used inside a try/catch block which generally\n    //      prevents allowings errors to occur with detection until a debugger\n    //      is attached.  Although I\'ve been guilty of the same anti-pattern\n    //      I eventually was convinced that errors should naturally propogate in\n    //      all but the most special cases.\n    /**\n     * A convenient alias for console when available, and a simple null\n     * function when console is unavailable.\n     * @static\n     * @private\n     */\n    var nullfunction = function( msg ){\n            //document.location.hash = msg;\n        };\n\n    $.console = window.console || {\n        log:    nullfunction,\n        debug:  nullfunction,\n        info:   nullfunction,\n        warn:   nullfunction,\n        error:  nullfunction,\n        assert: nullfunction\n    };\n\n\n    // Adding support for HTML5\'s requestAnimationFrame as suggested by acdha.\n    // Implementation taken from matt synder\'s post here:\n    // http://mattsnider.com/cross-browser-and-legacy-supported-requestframeanimation/\n    (function( w ) {\n\n        // most browsers have an implementation\n        var requestAnimationFrame = w.requestAnimationFrame ||\n            w.mozRequestAnimationFrame ||\n            w.webkitRequestAnimationFrame ||\n            w.msRequestAnimationFrame;\n\n        var cancelAnimationFrame = w.cancelAnimationFrame ||\n            w.mozCancelAnimationFrame ||\n            w.webkitCancelAnimationFrame ||\n            w.msCancelAnimationFrame;\n\n        // polyfill, when necessary\n        if ( requestAnimationFrame && cancelAnimationFrame ) {\n            // We can\'t assign these window methods directly to $ because they\n            // expect their "this" to be "window", so we call them in wrappers.\n            $.requestAnimationFrame = function(){\n                return requestAnimationFrame.apply( w, arguments );\n            };\n            $.cancelAnimationFrame = function(){\n                return cancelAnimationFrame.apply( w, arguments );\n            };\n        } else {\n            var aAnimQueue = [],\n                processing = [],\n                iRequestId = 0,\n                iIntervalId;\n\n            // create a mock requestAnimationFrame function\n            $.requestAnimationFrame = function( callback ) {\n                aAnimQueue.push( [ ++iRequestId, callback ] );\n\n                if ( !iIntervalId ) {\n                    iIntervalId = setInterval( function() {\n                        if ( aAnimQueue.length ) {\n                            var time = $.now();\n                            // Process all of the currently outstanding frame\n                            // requests, but none that get added during the\n                            // processing.\n                            // Swap the arrays so we don\'t have to create a new\n                            // array every frame.\n                            var temp = processing;\n                            processing = aAnimQueue;\n                            aAnimQueue = temp;\n                            while ( processing.length ) {\n                                processing.shift()[ 1 ]( time );\n                            }\n                        } else {\n                            // don\'t continue the interval, if unnecessary\n                            clearInterval( iIntervalId );\n                            iIntervalId = undefined;\n                        }\n                    }, 1000 / 50);  // estimating support for 50 frames per second\n                }\n\n                return iRequestId;\n            };\n\n            // create a mock cancelAnimationFrame function\n            $.cancelAnimationFrame = function( requestId ) {\n                // find the request ID and remove it\n                var i, j;\n                for ( i = 0, j = aAnimQueue.length; i < j; i += 1 ) {\n                    if ( aAnimQueue[ i ][ 0 ] === requestId ) {\n                        aAnimQueue.splice( i, 1 );\n                        return;\n                    }\n                }\n\n                // If it\'s not in the queue, it may be in the set we\'re currently\n                // processing (if cancelAnimationFrame is called from within a\n                // requestAnimationFrame callback).\n                for ( i = 0, j = processing.length; i < j; i += 1 ) {\n                    if ( processing[ i ][ 0 ] === requestId ) {\n                        processing.splice( i, 1 );\n                        return;\n                    }\n                }\n            };\n        }\n    })( window );\n\n    /**\n     * @private\n     * @inner\n     * @function\n     * @param {Element} element\n     * @param {Boolean} [isFixed]\n     * @returns {Element}\n     */\n    function getOffsetParent( element, isFixed ) {\n        if ( isFixed && element != document.body ) {\n            return document.body;\n        } else {\n            return element.offsetParent;\n        }\n    }\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - full-screen support functions\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ) {\n    /**\n     * Determine native full screen support we can get from the browser.\n     * @member fullScreenApi\n     * @memberof OpenSeadragon\n     * @type {object}\n     * @property {Boolean} supportsFullScreen Return true if full screen API is supported.\n     * @property {Function} isFullScreen Return true if currently in full screen mode.\n     * @property {Function} getFullScreenElement Return the element currently in full screen mode.\n     * @property {Function} requestFullScreen Make a request to go in full screen mode.\n     * @property {Function} exitFullScreen Make a request to exit full screen mode.\n     * @property {Function} cancelFullScreen Deprecated, use exitFullScreen instead.\n     * @property {String} fullScreenEventName Event fired when the full screen mode change.\n     * @property {String} fullScreenErrorEventName Event fired when a request to go\n     * in full screen mode failed.\n     */\n    var fullScreenApi = {\n        supportsFullScreen: false,\n        isFullScreen: function() { return false; },\n        getFullScreenElement: function() { return null; },\n        requestFullScreen: function() {},\n        exitFullScreen: function() {},\n        cancelFullScreen: function() {},\n        fullScreenEventName: \'\',\n        fullScreenErrorEventName: \'\'\n    };\n\n    // check for native support\n    if ( document.exitFullscreen ) {\n        // W3C standard\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.fullscreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.requestFullscreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.exitFullscreen();\n        };\n        fullScreenApi.fullScreenEventName = "fullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "fullscreenerror";\n    } else if ( document.msExitFullscreen ) {\n        // IE 11\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.msFullscreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.msRequestFullscreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.msExitFullscreen();\n        };\n        fullScreenApi.fullScreenEventName = "MSFullscreenChange";\n        fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";\n    } else if ( document.webkitExitFullscreen ) {\n        // Recent webkit\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.webkitFullscreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.webkitRequestFullscreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.webkitExitFullscreen();\n        };\n        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";\n    } else if ( document.webkitCancelFullScreen ) {\n        // Old webkit\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.webkitCurrentFullScreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.webkitRequestFullScreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.webkitCancelFullScreen();\n        };\n        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";\n    } else if ( document.mozCancelFullScreen ) {\n        // Firefox\n        fullScreenApi.supportsFullScreen = true;\n        fullScreenApi.getFullScreenElement = function() {\n            return document.mozFullScreenElement;\n        };\n        fullScreenApi.requestFullScreen = function( element ) {\n            return element.mozRequestFullScreen();\n        };\n        fullScreenApi.exitFullScreen = function() {\n            document.mozCancelFullScreen();\n        };\n        fullScreenApi.fullScreenEventName = "mozfullscreenchange";\n        fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";\n    }\n    fullScreenApi.isFullScreen = function() {\n        return fullScreenApi.getFullScreenElement() !== null;\n    };\n    fullScreenApi.cancelFullScreen = function() {\n        $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");\n        fullScreenApi.exitFullScreen();\n    };\n\n    // export api\n    $.extend( $, fullScreenApi );\n\n})( OpenSeadragon );\n\n/*\n * OpenSeadragon - EventSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($){\n\n/**\n * Event handler method signature used by all OpenSeadragon events.\n *\n * @callback EventHandler\n * @memberof OpenSeadragon\n * @param {Object} event - See individual events for event-specific properties.\n */\n\n\n/**\n * @class EventSource\n * @classdesc For use by classes which want to support custom, non-browser events.\n *\n * @memberof OpenSeadragon\n */\n$.EventSource = function() {\n    this.events = {};\n};\n\n/** @lends OpenSeadragon.EventSource.prototype */\n$.EventSource.prototype = {\n\n    /**\n     * Add an event handler to be triggered only once (or a given number of times)\n     * for a given event.\n     * @function\n     * @param {String} eventName - Name of event to register.\n     * @param {OpenSeadragon.EventHandler} handler - Function to call when event\n     * is triggered.\n     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged\n     * to the handler.\n     * @param {Number} [times=1] - The number of times to handle the event\n     * before removing it.\n     */\n    addOnceHandler: function(eventName, handler, userData, times) {\n        var self = this;\n        times = times || 1;\n        var count = 0;\n        var onceHandler = function(event) {\n            count++;\n            if (count === times) {\n                self.removeHandler(eventName, onceHandler);\n            }\n            handler(event);\n        };\n        this.addHandler(eventName, onceHandler, userData);\n    },\n\n    /**\n     * Add an event handler for a given event.\n     * @function\n     * @param {String} eventName - Name of event to register.\n     * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.\n     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.\n     */\n    addHandler: function ( eventName, handler, userData ) {\n        var events = this.events[ eventName ];\n        if ( !events ) {\n            this.events[ eventName ] = events = [];\n        }\n        if ( handler && $.isFunction( handler ) ) {\n            events[ events.length ] = { handler: handler, userData: userData || null };\n        }\n    },\n\n    /**\n     * Remove a specific event handler for a given event.\n     * @function\n     * @param {String} eventName - Name of event for which the handler is to be removed.\n     * @param {OpenSeadragon.EventHandler} handler - Function to be removed.\n     */\n    removeHandler: function ( eventName, handler ) {\n        var events = this.events[ eventName ],\n            handlers = [],\n            i;\n        if ( !events ) {\n            return;\n        }\n        if ( $.isArray( events ) ) {\n            for ( i = 0; i < events.length; i++ ) {\n                if ( events[i].handler !== handler ) {\n                    handlers.push( events[ i ] );\n                }\n            }\n            this.events[ eventName ] = handlers;\n        }\n    },\n\n\n    /**\n     * Remove all event handlers for a given event type. If no type is given all\n     * event handlers for every event type are removed.\n     * @function\n     * @param {String} eventName - Name of event for which all handlers are to be removed.\n     */\n    removeAllHandlers: function( eventName ) {\n        if ( eventName ){\n            this.events[ eventName ] = [];\n        } else{\n            for ( var eventType in this.events ) {\n                this.events[ eventType ] = [];\n            }\n        }\n    },\n\n    /**\n     * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.\n     * @function\n     * @param {String} eventName - Name of event to get handlers for.\n     */\n    getHandler: function ( eventName ) {\n        var events = this.events[ eventName ];\n        if ( !events || !events.length ) {\n            return null;\n        }\n        events = events.length === 1 ?\n            [ events[ 0 ] ] :\n            Array.apply( null, events );\n        return function ( source, args ) {\n            var i,\n                length = events.length;\n            for ( i = 0; i < length; i++ ) {\n                if ( events[ i ] ) {\n                    args.eventSource = source;\n                    args.userData = events[ i ].userData;\n                    events[ i ].handler( args );\n                }\n            }\n        };\n    },\n\n    /**\n     * Trigger an event, optionally passing additional information.\n     * @function\n     * @param {String} eventName - Name of event to register.\n     * @param {Object} eventArgs - Event-specific data.\n     */\n    raiseEvent: function( eventName, eventArgs ) {\n        //uncomment if you want to get a log of all events\n        //$.console.log( eventName );\n        var handler = this.getHandler( eventName );\n\n        if ( handler ) {\n            if ( !eventArgs ) {\n                eventArgs = {};\n            }\n\n            handler( this, eventArgs );\n        }\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - MouseTracker\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function ( $ ) {\n\n    // All MouseTracker instances\n    var MOUSETRACKERS  = [];\n\n    // dictionary from hash to private properties\n    var THIS           = {};\n\n\n    /**\n     * @class MouseTracker\n     * @classdesc Provides simplified handling of common pointer device (mouse, touch, pen, etc.) gestures\n     *            and keyboard events on a specified element.\n     * @memberof OpenSeadragon\n     * @param {Object} options\n     *      Allows configurable properties to be entirely specified by passing\n     *      an options object to the constructor.  The constructor also supports\n     *      the original positional arguments \'element\', \'clickTimeThreshold\',\n     *      and \'clickDistThreshold\' in that order.\n     * @param {Element|String} options.element\n     *      A reference to an element or an element id for which the pointer/key\n     *      events will be monitored.\n     * @param {Boolean} [options.startDisabled=false]\n     *      If true, event tracking on the element will not start until\n     *      {@link OpenSeadragon.MouseTracker.setTracking|setTracking} is called.\n     * @param {Number} options.clickTimeThreshold\n     *      The number of milliseconds within which a pointer down-up event combination\n     *      will be treated as a click gesture.\n     * @param {Number} options.clickDistThreshold\n     *      The maximum distance allowed between a pointer down event and a pointer up event\n     *      to be treated as a click gesture.\n     * @param {Number} options.dblClickTimeThreshold\n     *      The number of milliseconds within which two pointer down-up event combinations\n     *      will be treated as a double-click gesture.\n     * @param {Number} options.dblClickDistThreshold\n     *      The maximum distance allowed between two pointer click events\n     *      to be treated as a click gesture.\n     * @param {Number} [options.stopDelay=50]\n     *      The number of milliseconds without pointer move before the stop\n     *      event is fired.\n     * @param {OpenSeadragon.EventHandler} [options.enterHandler=null]\n     *      An optional handler for pointer enter.\n     * @param {OpenSeadragon.EventHandler} [options.exitHandler=null]\n     *      An optional handler for pointer exit.\n     * @param {OpenSeadragon.EventHandler} [options.pressHandler=null]\n     *      An optional handler for pointer press.\n     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryPressHandler=null]\n     *      An optional handler for pointer non-primary button press.\n     * @param {OpenSeadragon.EventHandler} [options.releaseHandler=null]\n     *      An optional handler for pointer release.\n     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryReleaseHandler=null]\n     *      An optional handler for pointer non-primary button release.\n     * @param {OpenSeadragon.EventHandler} [options.moveHandler=null]\n     *      An optional handler for pointer move.\n     * @param {OpenSeadragon.EventHandler} [options.scrollHandler=null]\n     *      An optional handler for mouse wheel scroll.\n     * @param {OpenSeadragon.EventHandler} [options.clickHandler=null]\n     *      An optional handler for pointer click.\n     * @param {OpenSeadragon.EventHandler} [options.dblClickHandler=null]\n     *      An optional handler for pointer double-click.\n     * @param {OpenSeadragon.EventHandler} [options.dragHandler=null]\n     *      An optional handler for the drag gesture.\n     * @param {OpenSeadragon.EventHandler} [options.dragEndHandler=null]\n     *      An optional handler for after a drag gesture.\n     * @param {OpenSeadragon.EventHandler} [options.pinchHandler=null]\n     *      An optional handler for the pinch gesture.\n     * @param {OpenSeadragon.EventHandler} [options.keyDownHandler=null]\n     *      An optional handler for keydown.\n     * @param {OpenSeadragon.EventHandler} [options.keyUpHandler=null]\n     *      An optional handler for keyup.\n     * @param {OpenSeadragon.EventHandler} [options.keyHandler=null]\n     *      An optional handler for keypress.\n     * @param {OpenSeadragon.EventHandler} [options.focusHandler=null]\n     *      An optional handler for focus.\n     * @param {OpenSeadragon.EventHandler} [options.blurHandler=null]\n     *      An optional handler for blur.\n     * @param {Object} [options.userData=null]\n     *      Arbitrary object to be passed unchanged to any attached handler methods.\n     */\n    $.MouseTracker = function ( options ) {\n\n        MOUSETRACKERS.push( this );\n\n        var args = arguments;\n\n        if ( !$.isPlainObject( options ) ) {\n            options = {\n                element:            args[ 0 ],\n                clickTimeThreshold: args[ 1 ],\n                clickDistThreshold: args[ 2 ]\n            };\n        }\n\n        this.hash               = Math.random(); // An unique hash for this tracker.\n        /**\n         * The element for which pointer events are being monitored.\n         * @member {Element} element\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.element            = $.getElement( options.element );\n        /**\n         * The number of milliseconds within which a pointer down-up event combination\n         * will be treated as a click gesture.\n         * @member {Number} clickTimeThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;\n        /**\n         * The maximum distance allowed between a pointer down event and a pointer up event\n         * to be treated as a click gesture.\n         * @member {Number} clickDistThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;\n        /**\n         * The number of milliseconds within which two pointer down-up event combinations\n         * will be treated as a double-click gesture.\n         * @member {Number} dblClickTimeThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.dblClickTimeThreshold = options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;\n        /**\n         * The maximum distance allowed between two pointer click events\n         * to be treated as a click gesture.\n         * @member {Number} clickDistThreshold\n         * @memberof OpenSeadragon.MouseTracker#\n         */\n        this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;\n        this.userData              = options.userData          || null;\n        this.stopDelay             = options.stopDelay         || 50;\n\n        this.enterHandler             = options.enterHandler             || null;\n        this.exitHandler              = options.exitHandler              || null;\n        this.pressHandler             = options.pressHandler             || null;\n        this.nonPrimaryPressHandler   = options.nonPrimaryPressHandler   || null;\n        this.releaseHandler           = options.releaseHandler           || null;\n        this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;\n        this.moveHandler              = options.moveHandler              || null;\n        this.scrollHandler            = options.scrollHandler            || null;\n        this.clickHandler             = options.clickHandler             || null;\n        this.dblClickHandler          = options.dblClickHandler          || null;\n        this.dragHandler              = options.dragHandler              || null;\n        this.dragEndHandler           = options.dragEndHandler           || null;\n        this.pinchHandler             = options.pinchHandler             || null;\n        this.stopHandler              = options.stopHandler              || null;\n        this.keyDownHandler           = options.keyDownHandler           || null;\n        this.keyUpHandler             = options.keyUpHandler             || null;\n        this.keyHandler               = options.keyHandler               || null;\n        this.focusHandler             = options.focusHandler             || null;\n        this.blurHandler              = options.blurHandler              || null;\n\n        //Store private properties in a scope sealed hash map\n        var _this = this;\n\n        /**\n         * @private\n         * @property {Boolean} tracking\n         *      Are we currently tracking pointer events for this element.\n         */\n        THIS[ this.hash ] = {\n            click:                 function ( event ) { onClick( _this, event ); },\n            dblclick:              function ( event ) { onDblClick( _this, event ); },\n            keydown:               function ( event ) { onKeyDown( _this, event ); },\n            keyup:                 function ( event ) { onKeyUp( _this, event ); },\n            keypress:              function ( event ) { onKeyPress( _this, event ); },\n            focus:                 function ( event ) { onFocus( _this, event ); },\n            blur:                  function ( event ) { onBlur( _this, event ); },\n\n            wheel:                 function ( event ) { onWheel( _this, event ); },\n            mousewheel:            function ( event ) { onMouseWheel( _this, event ); },\n            DOMMouseScroll:        function ( event ) { onMouseWheel( _this, event ); },\n            MozMousePixelScroll:   function ( event ) { onMouseWheel( _this, event ); },\n\n            mouseenter:            function ( event ) { onMouseEnter( _this, event ); }, // Used on IE8 only\n            mouseleave:            function ( event ) { onMouseLeave( _this, event ); }, // Used on IE8 only\n            mouseover:             function ( event ) { onMouseOver( _this, event ); },\n            mouseout:              function ( event ) { onMouseOut( _this, event ); },\n            mousedown:             function ( event ) { onMouseDown( _this, event ); },\n            mouseup:               function ( event ) { onMouseUp( _this, event ); },\n            mouseupcaptured:       function ( event ) { onMouseUpCaptured( _this, event ); },\n            mousemove:             function ( event ) { onMouseMove( _this, event ); },\n            mousemovecaptured:     function ( event ) { onMouseMoveCaptured( _this, event ); },\n\n            touchstart:            function ( event ) { onTouchStart( _this, event ); },\n            touchend:              function ( event ) { onTouchEnd( _this, event ); },\n            touchendcaptured:      function ( event ) { onTouchEndCaptured( _this, event ); },\n            touchmove:             function ( event ) { onTouchMove( _this, event ); },\n            touchmovecaptured:     function ( event ) { onTouchMoveCaptured( _this, event ); },\n            touchcancel:           function ( event ) { onTouchCancel( _this, event ); },\n\n            gesturestart:          function ( event ) { onGestureStart( _this, event ); },\n            gesturechange:         function ( event ) { onGestureChange( _this, event ); },\n\n            pointerover:           function ( event ) { onPointerOver( _this, event ); },\n            MSPointerOver:         function ( event ) { onPointerOver( _this, event ); },\n            pointerout:            function ( event ) { onPointerOut( _this, event ); },\n            MSPointerOut:          function ( event ) { onPointerOut( _this, event ); },\n            pointerdown:           function ( event ) { onPointerDown( _this, event ); },\n            MSPointerDown:         function ( event ) { onPointerDown( _this, event ); },\n            pointerup:             function ( event ) { onPointerUp( _this, event ); },\n            MSPointerUp:           function ( event ) { onPointerUp( _this, event ); },\n            pointermove:           function ( event ) { onPointerMove( _this, event ); },\n            MSPointerMove:         function ( event ) { onPointerMove( _this, event ); },\n            pointercancel:         function ( event ) { onPointerCancel( _this, event ); },\n            MSPointerCancel:       function ( event ) { onPointerCancel( _this, event ); },\n            pointerupcaptured:     function ( event ) { onPointerUpCaptured( _this, event ); },\n            pointermovecaptured:   function ( event ) { onPointerMoveCaptured( _this, event ); },\n\n            tracking:              false,\n\n            // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.\n            // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).\n            // Active pointers are any pointer being tracked for this element which are in the hit-test area\n            //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.\n            activePointersLists:   [],\n\n            // Tracking for double-click gesture\n            lastClickPos:          null,\n            dblClickTimeOut:       null,\n\n            // Tracking for pinch gesture\n            pinchGPoints:          [],\n            lastPinchDist:         0,\n            currentPinchDist:      0,\n            lastPinchCenter:       null,\n            currentPinchCenter:    null\n        };\n\n        if ( !options.startDisabled ) {\n            this.setTracking( true );\n        }\n    };\n\n    /** @lends OpenSeadragon.MouseTracker.prototype */\n    $.MouseTracker.prototype = {\n\n        /**\n         * Clean up any events or objects created by the tracker.\n         * @function\n         */\n        destroy: function () {\n            var i;\n\n            stopTracking( this );\n            this.element = null;\n\n            for ( i = 0; i < MOUSETRACKERS.length; i++ ) {\n                if ( MOUSETRACKERS[ i ] === this ) {\n                    MOUSETRACKERS.splice( i, 1 );\n                    break;\n                }\n            }\n\n            THIS[ this.hash ] = null;\n            delete THIS[ this.hash ];\n        },\n\n        /**\n         * Are we currently tracking events on this element.\n         * @deprecated Just use this.tracking\n         * @function\n         * @returns {Boolean} Are we currently tracking events on this element.\n         */\n        isTracking: function () {\n            return THIS[ this.hash ].tracking;\n        },\n\n        /**\n         * Enable or disable whether or not we are tracking events on this element.\n         * @function\n         * @param {Boolean} track True to start tracking, false to stop tracking.\n         * @returns {OpenSeadragon.MouseTracker} Chainable.\n         */\n        setTracking: function ( track ) {\n            if ( track ) {\n                startTracking( this );\n            } else {\n                stopTracking( this );\n            }\n            //chain\n            return this;\n        },\n\n        /**\n         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,\n         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn\'t already exist for the type.\n         * @function\n         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.\n         * @returns {OpenSeadragon.MouseTracker.GesturePointList}\n         */\n        getActivePointersListByType: function ( type ) {\n            var delegate = THIS[ this.hash ],\n                i,\n                len = delegate.activePointersLists.length,\n                list;\n\n            for ( i = 0; i < len; i++ ) {\n                if ( delegate.activePointersLists[ i ].type === type ) {\n                    return delegate.activePointersLists[ i ];\n                }\n            }\n\n            list = new $.MouseTracker.GesturePointList( type );\n            delegate.activePointersLists.push( list );\n            return list;\n        },\n\n        /**\n         * Returns the total number of pointers currently active on the tracked element.\n         * @function\n         * @returns {Number}\n         */\n        getActivePointerCount: function () {\n            var delegate = THIS[ this.hash ],\n                i,\n                len = delegate.activePointersLists.length,\n                count = 0;\n\n            for ( i = 0; i < len; i++ ) {\n                count += delegate.activePointersLists[ i ].getLength();\n            }\n\n            return count;\n        },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Number} event.pointers\n         *      Number of pointers (all types) active in the tracked element.\n         * @param {Boolean} event.insideElementPressed\n         *      True if the left mouse button is currently being pressed and was\n         *      initiated inside the tracked element, otherwise false.\n         * @param {Boolean} event.buttonDownAny\n         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        enterHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Number} event.pointers\n         *      Number of pointers (all types) active in the tracked element.\n         * @param {Boolean} event.insideElementPressed\n         *      True if the left mouse button is currently being pressed and was\n         *      initiated inside the tracked element, otherwise false.\n         * @param {Boolean} event.buttonDownAny\n         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        exitHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        pressHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.button\n         *      Button which caused the event.\n         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        nonPrimaryPressHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.insideElementPressed\n         *      True if the left mouse button is currently being pressed and was\n         *      initiated inside the tracked element, otherwise false.\n         * @param {Boolean} event.insideElementReleased\n         *      True if the cursor inside the tracked element when the button was released.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        releaseHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.button\n         *      Button which caused the event.\n         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        nonPrimaryReleaseHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        moveHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.scroll\n         *      The scroll delta for the event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        scrollHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Boolean} event.quick\n         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        clickHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        dblClickHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {OpenSeadragon.Point} event.delta\n         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.\n         * @param {Number} event.speed\n         *     Current computed speed, in pixels per second.\n         * @param {Number} event.direction\n         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        dragHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.speed\n         *     Speed at the end of a drag gesture, in pixels per second.\n         * @param {Number} event.direction\n         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        dragEndHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints\n         *      Gesture points associated with the gesture. Velocity data can be found here.\n         * @param {OpenSeadragon.Point} event.lastCenter\n         *      The previous center point of the two pinch contact points relative to the tracked element.\n         * @param {OpenSeadragon.Point} event.center\n         *      The center point of the two pinch contact points relative to the tracked element.\n         * @param {Number} event.lastDistance\n         *      The previous distance between the two pinch contact points in CSS pixels.\n         * @param {Number} event.distance\n         *      The distance between the two pinch contact points in CSS pixels.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        pinchHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {String} event.pointerType\n         *     "mouse", "touch", "pen", etc.\n         * @param {OpenSeadragon.Point} event.position\n         *      The position of the event relative to the tracked element.\n         * @param {Number} event.buttons\n         *      Current buttons pressed.\n         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @param {Boolean} event.isTouchEvent\n         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        stopHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Number} event.keyCode\n         *      The key code that was pressed.\n         * @param {Boolean} event.ctrl\n         *      True if the ctrl key was pressed during this event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.alt\n         *      True if the alt key was pressed during this event.\n         * @param {Boolean} event.meta\n         *      True if the meta key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        keyDownHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Number} event.keyCode\n         *      The key code that was pressed.\n         * @param {Boolean} event.ctrl\n         *      True if the ctrl key was pressed during this event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.alt\n         *      True if the alt key was pressed during this event.\n         * @param {Boolean} event.meta\n         *      True if the meta key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        keyUpHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Number} event.keyCode\n         *      The key code that was pressed.\n         * @param {Boolean} event.ctrl\n         *      True if the ctrl key was pressed during this event.\n         * @param {Boolean} event.shift\n         *      True if the shift key was pressed during this event.\n         * @param {Boolean} event.alt\n         *      True if the alt key was pressed during this event.\n         * @param {Boolean} event.meta\n         *      True if the meta key was pressed during this event.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        keyHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        focusHandler: function () { },\n\n        /**\n         * Implement or assign implementation to these handlers during or after\n         * calling the constructor.\n         * @function\n         * @param {Object} event\n         * @param {OpenSeadragon.MouseTracker} event.eventSource\n         *      A reference to the tracker instance.\n         * @param {Object} event.originalEvent\n         *      The original event object.\n         * @param {Boolean} event.preventDefaultAction\n         *      Set to true to prevent the tracker subscriber from performing its default action (subscriber implementation dependent). Default: false.\n         * @param {Object} event.userData\n         *      Arbitrary user-defined object.\n         */\n        blurHandler: function () { }\n    };\n\n\n    /**\n     * Provides continuous computation of velocity (speed and direction) of active pointers.\n     * This is a singleton, used by all MouseTracker instances, as it is unlikely there will ever be more than\n     * two active gesture pointers at a time.\n     *\n     * @private\n     * @member gesturePointVelocityTracker\n     * @memberof OpenSeadragon.MouseTracker\n     */\n    $.MouseTracker.gesturePointVelocityTracker = (function () {\n        var trackerPoints = [],\n            intervalId = 0,\n            lastTime = 0;\n\n        // Generates a unique identifier for a tracked gesture point\n        var _generateGuid = function ( tracker, gPoint ) {\n            return tracker.hash.toString() + gPoint.type + gPoint.id.toString();\n        };\n\n        // Interval timer callback. Computes velocity for all tracked gesture points.\n        var _doTracking = function () {\n            var i,\n                len = trackerPoints.length,\n                trackPoint,\n                gPoint,\n                now = $.now(),\n                elapsedTime,\n                distance,\n                speed;\n\n            elapsedTime = now - lastTime;\n            lastTime = now;\n\n            for ( i = 0; i < len; i++ ) {\n                trackPoint = trackerPoints[ i ];\n                gPoint = trackPoint.gPoint;\n                // Math.atan2 gives us just what we need for a velocity vector, as we can simply\n                //   use cos()/sin() to extract the x/y velocity components.\n                gPoint.direction = Math.atan2( gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x );\n                // speed = distance / elapsed time\n                distance = trackPoint.lastPos.distanceTo( gPoint.currentPos );\n                trackPoint.lastPos = gPoint.currentPos;\n                speed = 1000 * distance / ( elapsedTime + 1 );\n                // Simple biased average, favors the most recent speed computation. Smooths out erratic gestures a bit.\n                gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;\n            }\n        };\n\n        // Public. Add a gesture point to be tracked\n        var addPoint = function ( tracker, gPoint ) {\n            var guid = _generateGuid( tracker, gPoint );\n\n            trackerPoints.push(\n                {\n                    guid: guid,\n                    gPoint: gPoint,\n                    lastPos: gPoint.currentPos\n                } );\n\n            // Only fire up the interval timer when there\'s gesture pointers to track\n            if ( trackerPoints.length === 1 ) {\n                lastTime = $.now();\n                intervalId = window.setInterval( _doTracking, 50 );\n            }\n        };\n\n        // Public. Stop tracking a gesture point\n        var removePoint = function ( tracker, gPoint ) {\n            var guid = _generateGuid( tracker, gPoint ),\n                i,\n                len = trackerPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( trackerPoints[ i ].guid === guid ) {\n                    trackerPoints.splice( i, 1 );\n                    // Only run the interval timer if theres gesture pointers to track\n                    len--;\n                    if ( len === 0 ) {\n                        window.clearInterval( intervalId );\n                    }\n                    break;\n                }\n            }\n        };\n\n        return {\n            addPoint:    addPoint,\n            removePoint: removePoint\n        };\n    } )();\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Pointer event model and feature detection\n///////////////////////////////////////////////////////////////////////////////\n\n    $.MouseTracker.captureElement = document;\n\n    /**\n     * Detect available mouse wheel event name.\n     */\n    $.MouseTracker.wheelEventName = ( $.Browser.vendor == $.BROWSERS.IE && $.Browser.version > 8 ) ||\n                                                ( \'onwheel\' in document.createElement( \'div\' ) ) ? \'wheel\' : // Modern browsers support \'wheel\'\n                                    document.onmousewheel !== undefined ? \'mousewheel\' :                     // Webkit and IE support at least \'mousewheel\'\n                                    \'DOMMouseScroll\';                                                        // Assume old Firefox\n\n    /**\n     * Detect legacy mouse capture support.\n     */\n    $.MouseTracker.supportsMouseCapture = (function () {\n        var divElement = document.createElement( \'div\' );\n        return $.isFunction( divElement.setCapture ) && $.isFunction( divElement.releaseCapture );\n    }());\n\n    /**\n     * Detect browser pointer device event model(s) and build appropriate list of events to subscribe to.\n     */\n    $.MouseTracker.subscribeEvents = [ "click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", $.MouseTracker.wheelEventName ];\n\n    if( $.MouseTracker.wheelEventName == "DOMMouseScroll" ) {\n        // Older Firefox\n        $.MouseTracker.subscribeEvents.push( "MozMousePixelScroll" );\n    }\n\n    // Note: window.navigator.pointerEnable is deprecated on IE 11 and not part of W3C spec.\n    if ( window.PointerEvent && ( window.navigator.pointerEnabled || $.Browser.vendor !== $.BROWSERS.IE ) ) {\n        // IE11 and other W3C Pointer Event implementations (see http://www.w3.org/TR/pointerevents)\n        $.MouseTracker.havePointerEvents = true;\n        $.MouseTracker.subscribeEvents.push( "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel" );\n        $.MouseTracker.unprefixedPointerEvents = true;\n        if( navigator.maxTouchPoints ) {\n            $.MouseTracker.maxTouchPoints = navigator.maxTouchPoints;\n        } else {\n            $.MouseTracker.maxTouchPoints = 0;\n        }\n        $.MouseTracker.haveMouseEnter = false;\n    } else if ( window.MSPointerEvent && window.navigator.msPointerEnabled ) {\n        // IE10\n        $.MouseTracker.havePointerEvents = true;\n        $.MouseTracker.subscribeEvents.push( "MSPointerOver", "MSPointerOut", "MSPointerDown", "MSPointerUp", "MSPointerMove", "MSPointerCancel" );\n        $.MouseTracker.unprefixedPointerEvents = false;\n        if( navigator.msMaxTouchPoints ) {\n            $.MouseTracker.maxTouchPoints = navigator.msMaxTouchPoints;\n        } else {\n            $.MouseTracker.maxTouchPoints = 0;\n        }\n        $.MouseTracker.haveMouseEnter = false;\n    } else {\n        // Legacy W3C mouse events\n        $.MouseTracker.havePointerEvents = false;\n        if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n            $.MouseTracker.subscribeEvents.push( "mouseenter", "mouseleave" );\n            $.MouseTracker.haveMouseEnter = true;\n        } else {\n            $.MouseTracker.subscribeEvents.push( "mouseover", "mouseout" );\n            $.MouseTracker.haveMouseEnter = false;\n        }\n        $.MouseTracker.subscribeEvents.push( "mousedown", "mouseup", "mousemove" );\n        if ( \'ontouchstart\' in window ) {\n            // iOS, Android, and other W3c Touch Event implementations\n            //    (see http://www.w3.org/TR/touch-events/)\n            //    (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)\n            //    (see https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)\n            $.MouseTracker.subscribeEvents.push( "touchstart", "touchend", "touchmove", "touchcancel" );\n        }\n        if ( \'ongesturestart\' in window ) {\n            // iOS (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)\n            //   Subscribe to these to prevent default gesture handling\n            $.MouseTracker.subscribeEvents.push( "gesturestart", "gesturechange" );\n        }\n        $.MouseTracker.mousePointerId = "legacy-mouse";\n        $.MouseTracker.maxTouchPoints = 10;\n    }\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Classes and typedefs\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Represents a point of contact on the screen made by a mouse cursor, pen, touch, or other pointer device.\n     *\n     * @typedef {Object} GesturePoint\n     * @memberof OpenSeadragon.MouseTracker\n     *\n     * @property {Number} id\n     *     Identifier unique from all other active GesturePoints for a given pointer device.\n     * @property {String} type\n     *     The pointer device type: "mouse", "touch", "pen", etc.\n     * @property {Boolean} captured\n     *     True if events for the gesture point are captured to the tracked element.\n     * @property {Boolean} isPrimary\n     *     True if the gesture point is a master pointer amongst the set of active pointers for each pointer type. True for mouse and primary (first) touch/pen pointers.\n     * @property {Boolean} insideElementPressed\n     *     True if button pressed or contact point initiated inside the screen area of the tracked element.\n     * @property {Boolean} insideElement\n     *     True if pointer or contact point is currently inside the bounds of the tracked element.\n     * @property {Number} speed\n     *     Current computed speed, in pixels per second.\n     * @property {Number} direction\n     *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n     * @property {OpenSeadragon.Point} contactPos\n     *     The initial pointer contact position, relative to the page including any scrolling. Only valid if the pointer has contact (pressed, touch contact, pen contact).\n     * @property {Number} contactTime\n     *     The initial pointer contact time, in milliseconds. Only valid if the pointer has contact (pressed, touch contact, pen contact).\n     * @property {OpenSeadragon.Point} lastPos\n     *     The last pointer position, relative to the page including any scrolling.\n     * @property {Number} lastTime\n     *     The last pointer contact time, in milliseconds.\n     * @property {OpenSeadragon.Point} currentPos\n     *     The current pointer position, relative to the page including any scrolling.\n     * @property {Number} currentTime\n     *     The current pointer contact time, in milliseconds.\n     */\n\n\n    /**\n     * @class GesturePointList\n     * @classdesc Provides an abstraction for a set of active {@link OpenSeadragon.MouseTracker.GesturePoint|GesturePoint} objects for a given pointer device type.\n     *            Active pointers are any pointer being tracked for this element which are in the hit-test area\n     *            of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.\n     * @memberof OpenSeadragon.MouseTracker\n     * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.\n     */\n    $.MouseTracker.GesturePointList = function ( type ) {\n        this._gPoints = [];\n        /**\n         * The pointer device type: "mouse", "touch", "pen", etc.\n         * @member {String} type\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.type = type;\n        /**\n         * Current buttons pressed for the device.\n         * Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n         * @member {Number} buttons\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.buttons = 0;\n        /**\n         * Current number of contact points (touch points, mouse down, etc.) for the device.\n         * @member {Number} contacts\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.contacts = 0;\n        /**\n         * Current number of clicks for the device. Used for multiple click gesture tracking.\n         * @member {Number} clicks\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.clicks = 0;\n        /**\n         * Current number of captured pointers for the device.\n         * @member {Number} captureCount\n         * @memberof OpenSeadragon.MouseTracker.GesturePointList#\n         */\n        this.captureCount = 0;\n    };\n\n    /** @lends OpenSeadragon.MouseTracker.GesturePointList.prototype */\n    $.MouseTracker.GesturePointList.prototype = {\n        /**\n         * @function\n         * @returns {Number} Number of gesture points in the list.\n         */\n        getLength: function () {\n            return this._gPoints.length;\n        },\n        /**\n         * @function\n         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).\n         */\n        asArray: function () {\n            return this._gPoints;\n        },\n        /**\n         * @function\n         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.\n         * @returns {Number} Number of gesture points in the list.\n         */\n        add: function ( gp ) {\n            return this._gPoints.push( gp );\n        },\n        /**\n         * @function\n         * @param {Number} id - The id of the gesture point to remove from the list.\n         * @returns {Number} Number of gesture points in the list.\n         */\n        removeById: function ( id ) {\n            var i,\n                len = this._gPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( this._gPoints[ i ].id === id ) {\n                    this._gPoints.splice( i, 1 );\n                    break;\n                }\n            }\n            return this._gPoints.length;\n        },\n        /**\n         * @function\n         * @param {Number} index - The index of the gesture point to retrieve from the list.\n         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.\n         */\n        getByIndex: function ( index ) {\n            if ( index < this._gPoints.length) {\n                return this._gPoints[ index ];\n            }\n\n            return null;\n        },\n        /**\n         * @function\n         * @param {Number} id - The id of the gesture point to retrieve from the list.\n         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.\n         */\n        getById: function ( id ) {\n            var i,\n                len = this._gPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( this._gPoints[ i ].id === id ) {\n                    return this._gPoints[ i ];\n                }\n            }\n            return null;\n        },\n        /**\n         * @function\n         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.\n         */\n        getPrimary: function ( id ) {\n            var i,\n                len = this._gPoints.length;\n            for ( i = 0; i < len; i++ ) {\n                if ( this._gPoints[ i ].isPrimary ) {\n                    return this._gPoints[ i ];\n                }\n            }\n            return null;\n        }\n    };\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Utility functions\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Removes all tracked pointers.\n     * @private\n     * @inner\n     */\n    function clearTrackedPointers( tracker ) {\n        var delegate = THIS[ tracker.hash ],\n            i,\n            pointerListCount = delegate.activePointersLists.length;\n\n        for ( i = 0; i < pointerListCount; i++ ) {\n            if ( delegate.activePointersLists[ i ].captureCount > 0 ) {\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'mousemove\',\n                    delegate.mousemovecaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'mouseup\',\n                    delegate.mouseupcaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    $.MouseTracker.unprefixedPointerEvents ? \'pointermove\' : \'MSPointerMove\',\n                    delegate.pointermovecaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    $.MouseTracker.unprefixedPointerEvents ? \'pointerup\' : \'MSPointerUp\',\n                    delegate.pointerupcaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'touchmove\',\n                    delegate.touchmovecaptured,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    \'touchend\',\n                    delegate.touchendcaptured,\n                    true\n                );\n\n                delegate.activePointersLists[ i ].captureCount = 0;\n            }\n        }\n\n        for ( i = 0; i < pointerListCount; i++ ) {\n            delegate.activePointersLists.pop();\n        }\n    }\n\n    /**\n     * Starts tracking pointer events on the tracked element.\n     * @private\n     * @inner\n     */\n    function startTracking( tracker ) {\n        var delegate = THIS[ tracker.hash ],\n            event,\n            i;\n\n        if ( !delegate.tracking ) {\n            for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {\n                event = $.MouseTracker.subscribeEvents[ i ];\n                $.addEvent(\n                    tracker.element,\n                    event,\n                    delegate[ event ],\n                    false\n                );\n            }\n\n            clearTrackedPointers( tracker );\n\n            delegate.tracking = true;\n        }\n    }\n\n    /**\n     * Stops tracking pointer events on the tracked element.\n     * @private\n     * @inner\n     */\n    function stopTracking( tracker ) {\n        var delegate = THIS[ tracker.hash ],\n            event,\n            i;\n\n        if ( delegate.tracking ) {\n            for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {\n                event = $.MouseTracker.subscribeEvents[ i ];\n                $.removeEvent(\n                    tracker.element,\n                    event,\n                    delegate[ event ],\n                    false\n                );\n            }\n\n            clearTrackedPointers( tracker );\n\n            delegate.tracking = false;\n        }\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getCaptureEventParams( tracker, pointerType ) {\n        var delegate = THIS[ tracker.hash ];\n\n        if ( pointerType === \'pointerevent\' ) {\n            return {\n                upName: $.MouseTracker.unprefixedPointerEvents ? \'pointerup\' : \'MSPointerUp\',\n                upHandler: delegate.pointerupcaptured,\n                moveName: $.MouseTracker.unprefixedPointerEvents ? \'pointermove\' : \'MSPointerMove\',\n                moveHandler: delegate.pointermovecaptured\n            };\n        } else if ( pointerType === \'mouse\' ) {\n            return {\n                upName: \'mouseup\',\n                upHandler: delegate.mouseupcaptured,\n                moveName: \'mousemove\',\n                moveHandler: delegate.mousemovecaptured\n            };\n        } else if ( pointerType === \'touch\' ) {\n            return {\n                upName: \'touchend\',\n                upHandler: delegate.touchendcaptured,\n                moveName: \'touchmove\',\n                moveHandler: delegate.touchmovecaptured\n            };\n        } else {\n            throw new Error( "MouseTracker.getCaptureEventParams: Unknown pointer type." );\n        }\n    }\n\n    /**\n     * Begin capturing pointer events to the tracked element.\n     * @private\n     * @inner\n     */\n    function capturePointer( tracker, pointerType, pointerCount ) {\n        var pointsList = tracker.getActivePointersListByType( pointerType ),\n            eventParams;\n\n        pointsList.captureCount += (pointerCount || 1);\n\n        if ( pointsList.captureCount === 1 ) {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                tracker.element.setCapture( true );\n            } else {\n                eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? \'pointerevent\' : pointerType );\n                // We emulate mouse capture by hanging listeners on the document object.\n                //    (Note we listen on the capture phase so the captured handlers will get called first)\n                if (isInIframe && canAccessEvents(window.top)) {\n                    $.addEvent(\n                        window.top,\n                        eventParams.upName,\n                        eventParams.upHandler,\n                        true\n                    );\n                }\n                $.addEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.upName,\n                    eventParams.upHandler,\n                    true\n                );\n                $.addEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.moveName,\n                    eventParams.moveHandler,\n                    true\n                );\n            }\n        }\n    }\n\n\n    /**\n     * Stop capturing pointer events to the tracked element.\n     * @private\n     * @inner\n     */\n    function releasePointer( tracker, pointerType, pointerCount ) {\n        var pointsList = tracker.getActivePointersListByType( pointerType ),\n            eventParams;\n\n        pointsList.captureCount -= (pointerCount || 1);\n\n        if ( pointsList.captureCount === 0 ) {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                tracker.element.releaseCapture();\n            } else {\n                eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? \'pointerevent\' : pointerType );\n                // We emulate mouse capture by hanging listeners on the document object.\n                //    (Note we listen on the capture phase so the captured handlers will get called first)\n                if (isInIframe && canAccessEvents(window.top)) {\n                    $.removeEvent(\n                        window.top,\n                        eventParams.upName,\n                        eventParams.upHandler,\n                        true\n                    );\n                }\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.moveName,\n                    eventParams.moveHandler,\n                    true\n                );\n                $.removeEvent(\n                    $.MouseTracker.captureElement,\n                    eventParams.upName,\n                    eventParams.upHandler,\n                    true\n                );\n            }\n        }\n    }\n\n\n    /**\n     * Gets a W3C Pointer Events model compatible pointer type string from a DOM pointer event.\n     * IE10 used a long integer value, but the W3C specification (and IE11+) use a string "mouse", "touch", "pen", etc.\n     * @private\n     * @inner\n     */\n    function getPointerType( event ) {\n        var pointerTypeStr;\n        if ( $.MouseTracker.unprefixedPointerEvents ) {\n            pointerTypeStr = event.pointerType;\n        } else {\n            // IE10\n            //  MSPOINTER_TYPE_TOUCH: 0x00000002\n            //  MSPOINTER_TYPE_PEN:   0x00000003\n            //  MSPOINTER_TYPE_MOUSE: 0x00000004\n            switch( event.pointerType )\n            {\n                case 0x00000002:\n                    pointerTypeStr = \'touch\';\n                    break;\n                case 0x00000003:\n                    pointerTypeStr = \'pen\';\n                    break;\n                case 0x00000004:\n                    pointerTypeStr = \'mouse\';\n                    break;\n                default:\n                    pointerTypeStr = \'\';\n            }\n        }\n        return pointerTypeStr;\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function getMouseAbsolute( event ) {\n        return $.getMousePosition( event );\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getMouseRelative( event, element ) {\n        return getPointRelativeToAbsolute( getMouseAbsolute( event ), element );\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getPointRelativeToAbsolute( point, element ) {\n        var offset = $.getElementOffset( element );\n        return point.minus( offset );\n    }\n\n    /**\n     * @private\n     * @inner\n     */\n    function getCenterPoint( point1, point2 ) {\n        return new $.Point( ( point1.x + point2.x ) / 2, ( point1.y + point2.y ) / 2 );\n    }\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Device-specific DOM event handlers\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @private\n     * @inner\n     */\n    function onClick( tracker, event ) {\n        if ( tracker.clickHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onDblClick( tracker, event ) {\n        if ( tracker.dblClickHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onKeyDown( tracker, event ) {\n        //$.console.log( "keydown %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );\n        var propagate;\n        if ( tracker.keyDownHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.keyDownHandler(\n                {\n                    eventSource:          tracker,\n                    keyCode:              event.keyCode ? event.keyCode : event.charCode,\n                    ctrl:                 event.ctrlKey,\n                    shift:                event.shiftKey,\n                    alt:                  event.altKey,\n                    meta:                 event.metaKey,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( !propagate ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onKeyUp( tracker, event ) {\n        //$.console.log( "keyup %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );\n        var propagate;\n        if ( tracker.keyUpHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.keyUpHandler(\n                {\n                    eventSource:          tracker,\n                    keyCode:              event.keyCode ? event.keyCode : event.charCode,\n                    ctrl:                 event.ctrlKey,\n                    shift:                event.shiftKey,\n                    alt:                  event.altKey,\n                    meta:                 event.metaKey,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( !propagate ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onKeyPress( tracker, event ) {\n        //$.console.log( "keypress %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );\n        var propagate;\n        if ( tracker.keyHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.keyHandler(\n                {\n                    eventSource:          tracker,\n                    keyCode:              event.keyCode ? event.keyCode : event.charCode,\n                    ctrl:                 event.ctrlKey,\n                    shift:                event.shiftKey,\n                    alt:                  event.altKey,\n                    meta:                 event.metaKey,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( !propagate ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onFocus( tracker, event ) {\n        //console.log( "focus %s", event );\n        var propagate;\n        if ( tracker.focusHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.focusHandler(\n                {\n                    eventSource:          tracker,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( propagate === false ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onBlur( tracker, event ) {\n        //console.log( "blur %s", event );\n        var propagate;\n        if ( tracker.blurHandler ) {\n            event = $.getEvent( event );\n            propagate = tracker.blurHandler(\n                {\n                    eventSource:          tracker,\n                    originalEvent:        event,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( propagate === false ) {\n                $.cancelEvent( event );\n            }\n        }\n    }\n\n\n    /**\n     * Handler for \'wheel\' events\n     *\n     * @private\n     * @inner\n     */\n    function onWheel( tracker, event ) {\n        handleWheelEvent( tracker, event, event );\n    }\n\n\n    /**\n     * Handler for \'mousewheel\', \'DOMMouseScroll\', and \'MozMousePixelScroll\' events\n     *\n     * @private\n     * @inner\n     */\n    function onMouseWheel( tracker, event ) {\n        event = $.getEvent( event );\n\n        // Simulate a \'wheel\' event\n        var simulatedEvent = {\n            target:     event.target || event.srcElement,\n            type:       "wheel",\n            shiftKey:   event.shiftKey || false,\n            clientX:    event.clientX,\n            clientY:    event.clientY,\n            pageX:      event.pageX ? event.pageX : event.clientX,\n            pageY:      event.pageY ? event.pageY : event.clientY,\n            deltaMode:  event.type == "MozMousePixelScroll" ? 0 : 1, // 0=pixel, 1=line, 2=page\n            deltaX:     0,\n            deltaZ:     0\n        };\n\n        // Calculate deltaY\n        if ( $.MouseTracker.wheelEventName == "mousewheel" ) {\n            simulatedEvent.deltaY = - 1 / $.DEFAULT_SETTINGS.pixelsPerWheelLine * event.wheelDelta;\n        } else {\n            simulatedEvent.deltaY = event.detail;\n        }\n\n        handleWheelEvent( tracker, simulatedEvent, event );\n    }\n\n\n    /**\n     * Handles \'wheel\' events.\n     * The event may be simulated by the legacy mouse wheel event handler (onMouseWheel()).\n     *\n     * @private\n     * @inner\n     */\n    function handleWheelEvent( tracker, event, originalEvent ) {\n        var nDelta = 0,\n            propagate;\n\n        // The nDelta variable is gated to provide smooth z-index scrolling\n        //   since the mouse wheel allows for substantial deltas meant for rapid\n        //   y-index scrolling.\n        // event.deltaMode: 0=pixel, 1=line, 2=page\n        // TODO: Deltas in pixel mode should be accumulated then a scroll value computed after $.DEFAULT_SETTINGS.pixelsPerWheelLine threshold reached\n        nDelta = event.deltaY < 0 ? 1 : -1;\n\n        if ( tracker.scrollHandler ) {\n            propagate = tracker.scrollHandler(\n                {\n                    eventSource:          tracker,\n                    pointerType:          \'mouse\',\n                    position:             getMouseRelative( event, tracker.element ),\n                    scroll:               nDelta,\n                    shift:                event.shiftKey,\n                    isTouchEvent:         false,\n                    originalEvent:        originalEvent,\n                    preventDefaultAction: false,\n                    userData:             tracker.userData\n                }\n            );\n            if ( propagate === false ) {\n                $.cancelEvent( originalEvent );\n            }\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function isParentChild( parent, child )\n    {\n       if ( parent === child ) {\n           return false;\n       }\n       while ( child && child !== parent ) {\n           child = child.parentNode;\n       }\n       return child === parent;\n    }\n\n\n    /**\n     * Only used on IE 8\n     *\n     * @private\n     * @inner\n     */\n    function onMouseEnter( tracker, event ) {\n        event = $.getEvent( event );\n\n        handleMouseEnter( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseOver( tracker, event ) {\n        event = $.getEvent( event );\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        handleMouseEnter( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseEnter( tracker, event ) {\n        var gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersEnter( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * Only used on IE 8\n     *\n     * @private\n     * @inner\n     */\n    function onMouseLeave( tracker, event ) {\n        event = $.getEvent( event );\n\n        handleMouseExit( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseOut( tracker, event ) {\n        event = $.getEvent( event );\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        handleMouseExit( tracker, event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseExit( tracker, event ) {\n        var gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersExit( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * Returns a W3C DOM level 3 standard button value given an event.button property:\n     *   -1 == none, 0 == primary/left, 1 == middle, 2 == secondary/right, 3 == X1/back, 4 == X2/forward, 5 == eraser (pen)\n     * @private\n     * @inner\n     */\n    function getStandardizedButton( button ) {\n        if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n            // On IE 8, 0 == none, 1 == left, 2 == right, 3 == left and right, 4 == middle, 5 == left and middle, 6 == right and middle, 7 == all three\n            // TODO: Support chorded (multiple) button presses on IE 8?\n            if ( button === 1 ) {\n                return 0;\n            } else if ( button === 2 ) {\n                return 2;\n            } else if ( button === 4 ) {\n                return 1;\n            } else {\n                return -1;\n            }\n        } else {\n            return button;\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseDown( tracker, event ) {\n        var gPoint;\n\n        event = $.getEvent( event );\n\n        gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersDown( tracker, event, [ gPoint ], getStandardizedButton( event.button ) ) ) {\n            $.stopEvent( event );\n            capturePointer( tracker, \'mouse\' );\n        }\n\n        if ( tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseUp( tracker, event ) {\n        handleMouseUp( tracker, event );\n    }\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onMouseUp is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onMouseUpCaptured( tracker, event ) {\n        handleMouseUp( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseUp( tracker, event ) {\n        var gPoint;\n\n        event = $.getEvent( event );\n\n        gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersUp( tracker, event, [ gPoint ], getStandardizedButton( event.button ) ) ) {\n            releasePointer( tracker, \'mouse\' );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onMouseMove( tracker, event ) {\n        handleMouseMove( tracker, event );\n   }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onMouseMove is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onMouseMoveCaptured( tracker, event ) {\n        handleMouseMove( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleMouseMove( tracker, event ) {\n        var gPoint;\n\n        event = $.getEvent( event );\n\n        gPoint = {\n            id: $.MouseTracker.mousePointerId,\n            type: \'mouse\',\n            isPrimary: true,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersMove( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function abortTouchContacts( tracker, event, pointsList ) {\n        var i,\n            gPointCount = pointsList.getLength(),\n            abortGPoints = [];\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            abortGPoints.push( pointsList.getByIndex( i ) );\n        }\n\n        if ( abortGPoints.length > 0 ) {\n            // simulate touchend\n            updatePointersUp( tracker, event, abortGPoints, 0 ); // 0 means primary button press/release or touch contact\n            // release pointer capture\n            pointsList.captureCount = 1;\n            releasePointer( tracker, \'touch\' );\n            // simulate touchleave\n            updatePointersExit( tracker, event, abortGPoints );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchStart( tracker, event ) {\n        var time,\n            i,\n            j,\n            touchCount = event.changedTouches.length,\n            gPoints = [],\n            parentGPoints,\n            pointsList = tracker.getActivePointersListByType( \'touch\' );\n\n        time = $.now();\n\n        if ( pointsList.getLength() > event.touches.length - touchCount ) {\n            $.console.warn(\'Tracked touch contact count doesn\\\'t match event.touches.length. Removing all tracked touch pointers.\');\n            abortTouchContacts( tracker, event, pointsList );\n        }\n\n        for ( i = 0; i < touchCount; i++ ) {\n            gPoints.push( {\n                id: event.changedTouches[ i ].identifier,\n                type: \'touch\',\n                // isPrimary not set - let the updatePointers functions determine it\n                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),\n                currentTime: time\n            } );\n        }\n\n        // simulate touchenter on our tracked element\n        updatePointersEnter( tracker, event, gPoints );\n\n        // simulate touchenter on our tracked element\'s tracked ancestor elements\n        for ( i = 0; i < MOUSETRACKERS.length; i++ ) {\n            if ( MOUSETRACKERS[ i ] !== tracker && MOUSETRACKERS[ i ].isTracking() && isParentChild( MOUSETRACKERS[ i ].element, tracker.element ) ) {\n                parentGPoints = [];\n                for ( j = 0; j < touchCount; j++ ) {\n                    parentGPoints.push( {\n                        id: event.changedTouches[ j ].identifier,\n                        type: \'touch\',\n                        // isPrimary not set - let the updatePointers functions determine it\n                        currentPos: getMouseAbsolute( event.changedTouches[ j ] ),\n                        currentTime: time\n                    } );\n                }\n                updatePointersEnter( MOUSETRACKERS[ i ], event, parentGPoints );\n            }\n        }\n\n        if ( updatePointersDown( tracker, event, gPoints, 0 ) ) { // 0 means primary button press/release or touch contact\n            $.stopEvent( event );\n            capturePointer( tracker, \'touch\', touchCount );\n        }\n\n        $.cancelEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchEnd( tracker, event ) {\n        handleTouchEnd( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate pointer capture.\n     * onTouchEnd is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onTouchEndCaptured( tracker, event ) {\n        handleTouchEnd( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleTouchEnd( tracker, event ) {\n        var time,\n            i,\n            j,\n            touchCount = event.changedTouches.length,\n            gPoints = [],\n            parentGPoints;\n\n        time = $.now();\n\n        for ( i = 0; i < touchCount; i++ ) {\n            gPoints.push( {\n                id: event.changedTouches[ i ].identifier,\n                type: \'touch\',\n                // isPrimary not set - let the updatePointers functions determine it\n                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),\n                currentTime: time\n            } );\n        }\n\n        if ( updatePointersUp( tracker, event, gPoints, 0 ) ) {\n            releasePointer( tracker, \'touch\', touchCount );\n        }\n\n        // simulate touchleave on our tracked element\n        updatePointersExit( tracker, event, gPoints );\n\n        // simulate touchleave on our tracked element\'s tracked ancestor elements\n        for ( i = 0; i < MOUSETRACKERS.length; i++ ) {\n            if ( MOUSETRACKERS[ i ] !== tracker && MOUSETRACKERS[ i ].isTracking() && isParentChild( MOUSETRACKERS[ i ].element, tracker.element ) ) {\n                parentGPoints = [];\n                for ( j = 0; j < touchCount; j++ ) {\n                    parentGPoints.push( {\n                        id: event.changedTouches[ j ].identifier,\n                        type: \'touch\',\n                        // isPrimary not set - let the updatePointers functions determine it\n                        currentPos: getMouseAbsolute( event.changedTouches[ j ] ),\n                        currentTime: time\n                    } );\n                }\n                updatePointersExit( MOUSETRACKERS[ i ], event, parentGPoints );\n            }\n        }\n\n        $.cancelEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchMove( tracker, event ) {\n        handleTouchMove( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate pointer capture.\n     * onTouchMove is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onTouchMoveCaptured( tracker, event ) {\n        handleTouchMove( tracker, event );\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handleTouchMove( tracker, event ) {\n        var i,\n            touchCount = event.changedTouches.length,\n            gPoints = [];\n\n        for ( i = 0; i < touchCount; i++ ) {\n            gPoints.push( {\n                id: event.changedTouches[ i ].identifier,\n                type: \'touch\',\n                // isPrimary not set - let the updatePointers functions determine it\n                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),\n                currentTime: $.now()\n            } );\n        }\n\n        updatePointersMove( tracker, event, gPoints );\n\n        $.cancelEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onTouchCancel( tracker, event ) {\n        var i,\n            touchCount = event.changedTouches.length,\n            gPoints = [],\n            pointsList = tracker.getActivePointersListByType( \'touch\' );\n        \n        abortTouchContacts( tracker, event, pointsList );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onGestureStart( tracker, event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        return false;\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onGestureChange( tracker, event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        return false;\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerOver( tracker, event ) {\n        var gPoint;\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersEnter( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerOut( tracker, event ) {\n        var gPoint;\n\n        if ( event.currentTarget === event.relatedTarget || isParentChild( event.currentTarget, event.relatedTarget ) ) {\n            return;\n        }\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersExit( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerDown( tracker, event ) {\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersDown( tracker, event, [ gPoint ], event.button ) ) {\n            $.stopEvent( event );\n            capturePointer( tracker, gPoint.type );\n        }\n\n        if ( tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {\n            $.cancelEvent( event );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerUp( tracker, event ) {\n        handlePointerUp( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onPointerUp is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onPointerUpCaptured( tracker, event ) {\n        var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );\n        if ( pointsList.getById( event.pointerId ) ) {\n            handlePointerUp( tracker, event );\n        }\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handlePointerUp( tracker, event ) {\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        if ( updatePointersUp( tracker, event, [ gPoint ], event.button ) ) {\n            releasePointer( tracker, gPoint.type );\n        }\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerMove( tracker, event ) {\n        handlePointerMove( tracker, event );\n    }\n\n\n    /**\n     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.\n     * onPointerMove is still attached to the tracked element, so stop propagation to avoid processing twice.\n     *\n     * @private\n     * @inner\n     */\n    function onPointerMoveCaptured( tracker, event ) {\n        var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );\n        if ( pointsList.getById( event.pointerId ) ) {\n            handlePointerMove( tracker, event );\n        }\n        $.stopEvent( event );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handlePointerMove( tracker, event ) {\n        // Pointer changed coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event ),\n            isPrimary: event.isPrimary,\n            currentPos: getMouseAbsolute( event ),\n            currentTime: $.now()\n        };\n\n        updatePointersMove( tracker, event, [ gPoint ] );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function onPointerCancel( tracker, event ) {\n        var gPoint;\n\n        gPoint = {\n            id: event.pointerId,\n            type: getPointerType( event )\n        };\n\n        updatePointersCancel( tracker, event, [ gPoint ] );\n    }\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Device-agnostic DOM event handlers\n///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList\n     *     The GesturePointList to track the pointer in.\n     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint\n     *      Gesture point to track.\n     * @returns {Number} Number of gesture points in pointsList.\n     */\n    function startTrackingPointer( pointsList, gPoint ) {\n\n        // If isPrimary is not known for the pointer then set it according to our rules:\n        //    true if the first pointer in the gesture, otherwise false\n        if ( !gPoint.hasOwnProperty( \'isPrimary\' ) ) {\n            if ( pointsList.getLength() === 0 ) {\n                gPoint.isPrimary = true;\n            } else {\n                gPoint.isPrimary = false;\n            }\n        }\n        gPoint.speed = 0;\n        gPoint.direction = 0;\n        gPoint.contactPos = gPoint.currentPos;\n        gPoint.contactTime = gPoint.currentTime;\n        gPoint.lastPos = gPoint.currentPos;\n        gPoint.lastTime = gPoint.currentTime;\n\n        return pointsList.add( gPoint );\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList\n     *     The GesturePointList to stop tracking the pointer on.\n     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint\n     *      Gesture point to stop tracking.\n     * @returns {Number} Number of gesture points in pointsList.\n     */\n    function stopTrackingPointer( pointsList, gPoint ) {\n        var listLength,\n            primaryPoint;\n\n        if ( pointsList.getById( gPoint.id ) ) {\n            listLength = pointsList.removeById( gPoint.id );\n\n            // If isPrimary is not known for the pointer and we just removed the primary pointer from the list then we need to set another pointer as primary\n            if ( !gPoint.hasOwnProperty( \'isPrimary\' ) ) {\n                primaryPoint = pointsList.getPrimary();\n                if ( !primaryPoint ) {\n                    primaryPoint = pointsList.getByIndex( 0 );\n                    if ( primaryPoint ) {\n                        primaryPoint.isPrimary = true;\n                    }\n                }\n            }\n        } else {\n            listLength = pointsList.getLength();\n        }\n\n        return listLength;\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersEnter( tracker, event, gPoints ) {\n        var pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            propagate;\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer...update it\n                updateGPoint.insideElement = true;\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n\n                curGPoint = updateGPoint;\n            } else {\n                // Initialize for tracking and add to the tracking list\n                curGPoint.captured = false;\n                curGPoint.insideElementPressed = false;\n                curGPoint.insideElement = true;\n                startTrackingPointer( pointsList, curGPoint );\n            }\n\n            // Enter\n            if ( tracker.enterHandler ) {\n                propagate = tracker.enterHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          curGPoint.type,\n                        position:             getPointRelativeToAbsolute( curGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        pointers:             tracker.getActivePointerCount(),\n                        insideElementPressed: curGPoint.insideElementPressed,\n                        buttonDownAny:        pointsList.buttons !== 0,\n                        isTouchEvent:         curGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        }\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersExit( tracker, event, gPoints ) {\n        var delegate = THIS[ tracker.hash ],\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            propagate;\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer. If captured then update it, else stop tracking it\n                if ( updateGPoint.captured ) {\n                    updateGPoint.insideElement = false;\n                    updateGPoint.lastPos = updateGPoint.currentPos;\n                    updateGPoint.lastTime = updateGPoint.currentTime;\n                    updateGPoint.currentPos = curGPoint.currentPos;\n                    updateGPoint.currentTime = curGPoint.currentTime;\n                } else {\n                    stopTrackingPointer( pointsList, updateGPoint );\n                }\n\n                curGPoint = updateGPoint;\n            }\n\n            // Exit\n            if ( tracker.exitHandler ) {\n                propagate = tracker.exitHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          curGPoint.type,\n                        position:             getPointRelativeToAbsolute( curGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        pointers:             tracker.getActivePointerCount(),\n                        insideElementPressed: updateGPoint ? updateGPoint.insideElementPressed : false,\n                        buttonDownAny:        pointsList.buttons !== 0,\n                        isTouchEvent:         curGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        }\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     * @param {Number} buttonChanged\n     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,\n     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.\n     *\n     * @returns {Boolean} True if pointers should be captured to the tracked element, otherwise false.\n     */\n    function updatePointersDown( tracker, event, gPoints, buttonChanged ) {\n        var delegate = THIS[ tracker.hash ],\n            propagate,\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint;\n\n        if ( typeof event.buttons !== \'undefined\' ) {\n            pointsList.buttons = event.buttons;\n        } else {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons += 1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons += 4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons += 2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons += 8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons += 16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons += 32;\n                }\n            } else {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons |= 1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons |= 4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons |= 2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons |= 8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons |= 16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons |= 32;\n                }\n            }\n        }\n\n        // Only capture and track primary button, pen, and touch contacts\n        if ( buttonChanged !== 0 ) {\n            // Aux Press\n            if ( tracker.nonPrimaryPressHandler ) {\n                propagate = tracker.nonPrimaryPressHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          gPoints[ 0 ].type,\n                        position:             getPointRelativeToAbsolute( gPoints[ 0 ].currentPos, tracker.element ),\n                        button:               buttonChanged,\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         gPoints[ 0 ].type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            return false;\n        }\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer...update it\n                updateGPoint.captured = true;\n                updateGPoint.insideElementPressed = true;\n                updateGPoint.insideElement = true;\n                updateGPoint.contactPos = curGPoint.currentPos;\n                updateGPoint.contactTime = curGPoint.currentTime;\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n\n                curGPoint = updateGPoint;\n            } else {\n                // Initialize for tracking and add to the tracking list (no pointerover or pointermove event occurred before this)\n                curGPoint.captured = true;\n                curGPoint.insideElementPressed = true;\n                curGPoint.insideElement = true;\n                startTrackingPointer( pointsList, curGPoint );\n            }\n\n            pointsList.contacts++;\n            //$.console.log(\'contacts++ \', pointsList.contacts);\n\n            if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {\n                $.MouseTracker.gesturePointVelocityTracker.addPoint( tracker, curGPoint );\n            }\n\n            if ( pointsList.contacts === 1 ) {\n                // Press\n                if ( tracker.pressHandler ) {\n                    propagate = tracker.pressHandler(\n                        {\n                            eventSource:          tracker,\n                            pointerType:          curGPoint.type,\n                            position:             getPointRelativeToAbsolute( curGPoint.contactPos, tracker.element ),\n                            buttons:              pointsList.buttons,\n                            isTouchEvent:         curGPoint.type === \'touch\',\n                            originalEvent:        event,\n                            preventDefaultAction: false,\n                            userData:             tracker.userData\n                        }\n                    );\n                    if ( propagate === false ) {\n                        $.cancelEvent( event );\n                    }\n                }\n            } else if ( pointsList.contacts === 2 ) {\n                if ( tracker.pinchHandler && curGPoint.type === \'touch\' ) {\n                    // Initialize for pinch\n                    delegate.pinchGPoints = pointsList.asArray();\n                    delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );\n                    delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );\n                }\n            }\n        }\n\n        return true;\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     * @param {Number} buttonChanged\n     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,\n     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.\n     *\n     * @returns {Boolean} True if pointer capture should be released from the tracked element, otherwise false.\n     */\n    function updatePointersUp( tracker, event, gPoints, buttonChanged ) {\n        var delegate = THIS[ tracker.hash ],\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            propagate,\n            insideElementReleased,\n            releasePoint,\n            releaseTime,\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            releaseCapture = false,\n            wasCaptured = false,\n            quick;\n\n        if ( typeof event.buttons !== \'undefined\' ) {\n            pointsList.buttons = event.buttons;\n        } else {\n            if ( $.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 9 ) {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons -= 1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons -= 4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons -= 2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons -= 8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons -= 16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons -= 32;\n                }\n            } else {\n                if ( buttonChanged === 0 ) {\n                    // Primary\n                    pointsList.buttons ^= ~1;\n                } else if ( buttonChanged === 1 ) {\n                    // Aux\n                    pointsList.buttons ^= ~4;\n                } else if ( buttonChanged === 2 ) {\n                    // Secondary\n                    pointsList.buttons ^= ~2;\n                } else if ( buttonChanged === 3 ) {\n                    // X1 (Back)\n                    pointsList.buttons ^= ~8;\n                } else if ( buttonChanged === 4 ) {\n                    // X2 (Forward)\n                    pointsList.buttons ^= ~16;\n                } else if ( buttonChanged === 5 ) {\n                    // Pen Eraser\n                    pointsList.buttons ^= ~32;\n                }\n            }\n        }\n\n        // Only capture and track primary button, pen, and touch contacts\n        if ( buttonChanged !== 0 ) {\n            // Aux Release\n            if ( tracker.nonPrimaryReleaseHandler ) {\n                propagate = tracker.nonPrimaryReleaseHandler(\n                    {\n                        eventSource:           tracker,\n                        pointerType:           gPoints[ 0 ].type,\n                        position:              getPointRelativeToAbsolute(  gPoints[ 0 ].currentPos, tracker.element ),\n                        button:                buttonChanged,\n                        buttons:               pointsList.buttons,\n                        isTouchEvent:          gPoints[ 0 ].type === \'touch\',\n                        originalEvent:         event,\n                        preventDefaultAction:  false,\n                        userData:              tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            return false;\n        }\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Update the pointer, stop tracking it if not still in this element\n                if ( updateGPoint.captured ) {\n                    updateGPoint.captured = false;\n                    releaseCapture = true;\n                    wasCaptured = true;\n                }\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n                if ( !updateGPoint.insideElement ) {\n                    stopTrackingPointer( pointsList, updateGPoint );\n                }\n\n                releasePoint = updateGPoint.currentPos;\n                releaseTime = updateGPoint.currentTime;\n\n                if ( wasCaptured ) {\n                    // Pointer was activated in our element but could have been removed in any element since events are captured to our element\n\n                    pointsList.contacts--;\n                    //$.console.log(\'contacts-- \', pointsList.contacts);\n\n                    if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {\n                        $.MouseTracker.gesturePointVelocityTracker.removePoint( tracker, updateGPoint );\n                    }\n\n                    if ( pointsList.contacts === 0 ) {\n\n                        // Release (pressed in our element)\n                        if ( tracker.releaseHandler ) {\n                            propagate = tracker.releaseHandler(\n                                {\n                                    eventSource:           tracker,\n                                    pointerType:           updateGPoint.type,\n                                    position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),\n                                    buttons:               pointsList.buttons,\n                                    insideElementPressed:  updateGPoint.insideElementPressed,\n                                    insideElementReleased: updateGPoint.insideElement,\n                                    isTouchEvent:          updateGPoint.type === \'touch\',\n                                    originalEvent:         event,\n                                    preventDefaultAction:  false,\n                                    userData:              tracker.userData\n                                }\n                            );\n                            if ( propagate === false ) {\n                                $.cancelEvent( event );\n                            }\n                        }\n\n                        // Drag End\n                        if ( tracker.dragEndHandler && !updateGPoint.currentPos.equals( updateGPoint.contactPos ) ) {\n                            propagate = tracker.dragEndHandler(\n                                {\n                                    eventSource:          tracker,\n                                    pointerType:          updateGPoint.type,\n                                    position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                                    speed:                updateGPoint.speed,\n                                    direction:            updateGPoint.direction,\n                                    shift:                event.shiftKey,\n                                    isTouchEvent:         updateGPoint.type === \'touch\',\n                                    originalEvent:        event,\n                                    preventDefaultAction: false,\n                                    userData:             tracker.userData\n                                }\n                            );\n                            if ( propagate === false ) {\n                                $.cancelEvent( event );\n                            }\n                        }\n\n                        // Click / Double-Click\n                        if ( ( tracker.clickHandler || tracker.dblClickHandler ) && updateGPoint.insideElement ) {\n                            quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold &&\n                                            updateGPoint.contactPos.distanceTo( releasePoint ) <= tracker.clickDistThreshold;\n\n                            // Click\n                            if ( tracker.clickHandler ) {\n                                propagate = tracker.clickHandler(\n                                    {\n                                        eventSource:          tracker,\n                                        pointerType:          updateGPoint.type,\n                                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                                        quick:                quick,\n                                        shift:                event.shiftKey,\n                                        isTouchEvent:         updateGPoint.type === \'touch\',\n                                        originalEvent:        event,\n                                        preventDefaultAction: false,\n                                        userData:             tracker.userData\n                                    }\n                                );\n                                if ( propagate === false ) {\n                                    $.cancelEvent( event );\n                                }\n                            }\n\n                            // Double-Click\n                            if ( tracker.dblClickHandler && quick ) {\n                                pointsList.clicks++;\n                                if ( pointsList.clicks === 1 ) {\n                                    delegate.lastClickPos = releasePoint;\n                                    /*jshint loopfunc:true*/\n                                    delegate.dblClickTimeOut = setTimeout( function() {\n                                        pointsList.clicks = 0;\n                                    }, tracker.dblClickTimeThreshold );\n                                    /*jshint loopfunc:false*/\n                                } else if ( pointsList.clicks === 2 ) {\n                                    clearTimeout( delegate.dblClickTimeOut );\n                                    pointsList.clicks = 0;\n                                    if ( delegate.lastClickPos.distanceTo( releasePoint ) <= tracker.dblClickDistThreshold ) {\n                                        propagate = tracker.dblClickHandler(\n                                            {\n                                                eventSource:          tracker,\n                                                pointerType:          updateGPoint.type,\n                                                position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                                                shift:                event.shiftKey,\n                                                isTouchEvent:         updateGPoint.type === \'touch\',\n                                                originalEvent:        event,\n                                                preventDefaultAction: false,\n                                                userData:             tracker.userData\n                                            }\n                                        );\n                                        if ( propagate === false ) {\n                                            $.cancelEvent( event );\n                                        }\n                                    }\n                                    delegate.lastClickPos = null;\n                                }\n                            }\n                        }\n                    } else if ( pointsList.contacts === 2 ) {\n                        if ( tracker.pinchHandler && updateGPoint.type === \'touch\' ) {\n                            // Reset for pinch\n                            delegate.pinchGPoints = pointsList.asArray();\n                            delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );\n                            delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );\n                        }\n                    }\n                } else {\n                    // Pointer was activated in another element but removed in our element\n\n                    // Release (pressed in another element)\n                    if ( tracker.releaseHandler ) {\n                        propagate = tracker.releaseHandler(\n                            {\n                                eventSource:           tracker,\n                                pointerType:           updateGPoint.type,\n                                position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),\n                                buttons:               pointsList.buttons,\n                                insideElementPressed:  updateGPoint.insideElementPressed,\n                                insideElementReleased: updateGPoint.insideElement,\n                                isTouchEvent:          updateGPoint.type === \'touch\',\n                                originalEvent:         event,\n                                preventDefaultAction:  false,\n                                userData:              tracker.userData\n                            }\n                        );\n                        if ( propagate === false ) {\n                            $.cancelEvent( event );\n                        }\n                    }\n                }\n            }\n        }\n\n        return releaseCapture;\n    }\n\n\n    /**\n     * Call when pointer(s) change coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)\n     *\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersMove( tracker, event, gPoints ) {\n        var delegate = THIS[ tracker.hash ],\n            pointsList = tracker.getActivePointersListByType( gPoints[ 0 ].type ),\n            i,\n            gPointCount = gPoints.length,\n            curGPoint,\n            updateGPoint,\n            gPointArray,\n            delta,\n            propagate;\n\n        if ( typeof event.buttons !== \'undefined\' ) {\n            pointsList.buttons = event.buttons;\n        }\n\n        for ( i = 0; i < gPointCount; i++ ) {\n            curGPoint = gPoints[ i ];\n            updateGPoint = pointsList.getById( curGPoint.id );\n\n            if ( updateGPoint ) {\n                // Already tracking the pointer...update it\n                if ( curGPoint.hasOwnProperty( \'isPrimary\' ) ) {\n                    updateGPoint.isPrimary = curGPoint.isPrimary;\n                }\n                updateGPoint.lastPos = updateGPoint.currentPos;\n                updateGPoint.lastTime = updateGPoint.currentTime;\n                updateGPoint.currentPos = curGPoint.currentPos;\n                updateGPoint.currentTime = curGPoint.currentTime;\n            } else {\n                // Initialize for tracking and add to the tracking list (no pointerover or pointerdown event occurred before this)\n                curGPoint.captured = false;\n                curGPoint.insideElementPressed = false;\n                curGPoint.insideElement = true;\n                startTrackingPointer( pointsList, curGPoint );\n            }\n        }\n\n        // Stop (mouse only)\n        if ( tracker.stopHandler && gPoints[ 0 ].type === \'mouse\' ) {\n            clearTimeout( tracker.stopTimeOut );\n            tracker.stopTimeOut = setTimeout( function() {\n                handlePointerStop( tracker, event, gPoints[ 0 ].type );\n            }, tracker.stopDelay );\n        }\n\n        if ( pointsList.contacts === 0 ) {\n            // Move (no contacts: hovering mouse or other hover-capable device)\n            if ( tracker.moveHandler ) {\n                propagate = tracker.moveHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          gPoints[ 0 ].type,\n                        position:             getPointRelativeToAbsolute( gPoints[ 0 ].currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         gPoints[ 0 ].type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        } else if ( pointsList.contacts === 1 ) {\n            // Move (1 contact)\n            if ( tracker.moveHandler ) {\n                updateGPoint = pointsList.asArray()[ 0 ];\n                propagate = tracker.moveHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          updateGPoint.type,\n                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         updateGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            // Drag\n            if ( tracker.dragHandler ) {\n                updateGPoint = pointsList.asArray()[ 0 ];\n                delta = updateGPoint.currentPos.minus( updateGPoint.lastPos );\n                propagate = tracker.dragHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          updateGPoint.type,\n                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),\n                        buttons:              pointsList.buttons,\n                        delta:                delta,\n                        speed:                updateGPoint.speed,\n                        direction:            updateGPoint.direction,\n                        shift:                event.shiftKey,\n                        isTouchEvent:         updateGPoint.type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n        } else if ( pointsList.contacts === 2 ) {\n            // Move (2 contacts, use center)\n            if ( tracker.moveHandler ) {\n                gPointArray = pointsList.asArray();\n                propagate = tracker.moveHandler(\n                    {\n                        eventSource:          tracker,\n                        pointerType:          gPointArray[ 0 ].type,\n                        position:             getPointRelativeToAbsolute( getCenterPoint( gPointArray[ 0 ].currentPos, gPointArray[ 1 ].currentPos ), tracker.element ),\n                        buttons:              pointsList.buttons,\n                        isTouchEvent:         gPointArray[ 0 ].type === \'touch\',\n                        originalEvent:        event,\n                        preventDefaultAction: false,\n                        userData:             tracker.userData\n                    }\n                );\n                if ( propagate === false ) {\n                    $.cancelEvent( event );\n                }\n            }\n\n            // Pinch\n            if ( tracker.pinchHandler && gPoints[ 0 ].type === \'touch\' ) {\n                delta = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );\n                if ( delta != delegate.currentPinchDist ) {\n                    delegate.lastPinchDist = delegate.currentPinchDist;\n                    delegate.currentPinchDist = delta;\n                    delegate.lastPinchCenter = delegate.currentPinchCenter;\n                    delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );\n                    propagate = tracker.pinchHandler(\n                        {\n                            eventSource:          tracker,\n                            pointerType:          \'touch\',\n                            gesturePoints:        delegate.pinchGPoints,\n                            lastCenter:           getPointRelativeToAbsolute( delegate.lastPinchCenter, tracker.element ),\n                            center:               getPointRelativeToAbsolute( delegate.currentPinchCenter, tracker.element ),\n                            lastDistance:         delegate.lastPinchDist,\n                            distance:             delegate.currentPinchDist,\n                            shift:                event.shiftKey,\n                            originalEvent:        event,\n                            preventDefaultAction: false,\n                            userData:             tracker.userData\n                        }\n                    );\n                    if ( propagate === false ) {\n                        $.cancelEvent( event );\n                    }\n                }\n            }\n        }\n    }\n\n\n    /**\n     * @function\n     * @private\n     * @inner\n     * @param {OpenSeadragon.MouseTracker} tracker\n     *     A reference to the MouseTracker instance.\n     * @param {Object} event\n     *     A reference to the originating DOM event.\n     * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gPoints\n     *      Gesture points associated with the event.\n     */\n    function updatePointersCancel( tracker, event, gPoints ) {\n        updatePointersUp( tracker, event, gPoints, 0 );\n        updatePointersExit( tracker, event, gPoints );\n    }\n\n\n    /**\n     * @private\n     * @inner\n     */\n    function handlePointerStop( tracker, originalMoveEvent, pointerType ) {\n        if ( tracker.stopHandler ) {\n            tracker.stopHandler( {\n                eventSource:          tracker,\n                pointerType:          pointerType,\n                position:             getMouseRelative( originalMoveEvent, tracker.element ),\n                buttons:              tracker.getActivePointersListByType( pointerType ).buttons,\n                isTouchEvent:         pointerType === \'touch\',\n                originalEvent:        originalMoveEvent,\n                preventDefaultAction: false,\n                userData:             tracker.userData\n            } );\n        }\n    }\n    \n    // True if inside an iframe, otherwise false.\n    // @member {Boolean} isInIframe\n    // @private\n    // @inner\n    var isInIframe = (function() {\n        try {\n            return window.self !== window.top;\n        } catch (e) {\n            return true;\n        }\n    })();\n \n    // @function\n    // @private\n    // @inner\n    // @returns {Boolean} True if the target has access rights to events, otherwise false.\n    function canAccessEvents (target) {\n        try {\n            return target.addEventListener && target.removeEventListener;\n        } catch (e) {\n            return false;\n        }\n    }\n\n} ( OpenSeadragon ) );\n\n/*\n * OpenSeadragon - Control\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * An enumeration of supported locations where controls can be anchored.\n * The anchoring is always relative to the container.\n * @member ControlAnchor\n * @memberof OpenSeadragon\n * @static\n * @type {Object}\n * @property {Number} NONE\n * @property {Number} TOP_LEFT\n * @property {Number} TOP_RIGHT\n * @property {Number} BOTTOM_LEFT\n * @property {Number} BOTTOM_RIGHT\n * @property {Number} ABSOLUTE\n */\n$.ControlAnchor = {\n    NONE: 0,\n    TOP_LEFT: 1,\n    TOP_RIGHT: 2,\n    BOTTOM_RIGHT: 3,\n    BOTTOM_LEFT: 4,\n    ABSOLUTE: 5\n};\n\n/**\n * @class Control\n * @classdesc A Control represents any interface element which is meant to allow the user\n * to interact with the zoomable interface. Any control can be anchored to any\n * element.\n *\n * @memberof OpenSeadragon\n * @param {Element} element - the control element to be anchored in the container.\n * @param {Object } options - All required and optional settings for configuring a control element.\n * @param {OpenSeadragon.ControlAnchor} [options.anchor=OpenSeadragon.ControlAnchor.NONE] - the position of the control\n *  relative to the container.\n * @param {Boolean} [options.attachToViewer=true] - Whether the control should be added directly to the viewer, or\n *  directly to the container\n * @param {Boolean} [options.autoFade=true] - Whether the control should have the autofade behavior\n * @param {Element} container - the element to control will be anchored too.\n */\n$.Control = function ( element, options, container ) {\n    var parent = element.parentNode;\n    if (typeof options === \'number\')\n    {\n        $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; " +\n                        "please use an options object instead.  " +\n                        "Support for this deprecated variant is scheduled for removal in December 2013");\n         options = {anchor: options};\n    }\n    options.attachToViewer = (typeof options.attachToViewer === \'undefined\') ? true : options.attachToViewer;\n    /**\n     * True if the control should have autofade behavior.\n     * @member {Boolean} autoFade\n     * @memberof OpenSeadragon.Control#\n     */\n    this.autoFade = (typeof options.autoFade === \'undefined\') ? true : options.autoFade;\n    /**\n     * The element providing the user interface with some type of control (e.g. a zoom-in button).\n     * @member {Element} element\n     * @memberof OpenSeadragon.Control#\n     */\n    this.element    = element;\n    /**\n     * The position of the Control relative to its container.\n     * @member {OpenSeadragon.ControlAnchor} anchor\n     * @memberof OpenSeadragon.Control#\n     */\n    this.anchor     = options.anchor;\n    /**\n     * The Control\'s containing element.\n     * @member {Element} container\n     * @memberof OpenSeadragon.Control#\n     */\n    this.container  = container;\n    /**\n     * A neutral element surrounding the control element.\n     * @member {Element} wrapper\n     * @memberof OpenSeadragon.Control#\n     */\n    if ( this.anchor == $.ControlAnchor.ABSOLUTE ) {\n        this.wrapper    = $.makeNeutralElement( "div" );\n        this.wrapper.style.position = "absolute";\n        this.wrapper.style.top = typeof ( options.top )  == "number" ? ( options.top + \'px\' ) : options.top;\n        this.wrapper.style.left  = typeof ( options.left )  == "number" ?  (options.left + \'px\' ) : options.left;\n        this.wrapper.style.height = typeof ( options.height )  == "number" ? ( options.height + \'px\' ) : options.height;\n        this.wrapper.style.width  = typeof ( options.width )  == "number" ? ( options.width + \'px\' ) : options.width;\n        this.wrapper.style.margin = "0px";\n        this.wrapper.style.padding = "0px";\n\n        this.element.style.position = "relative";\n        this.element.style.top = "0px";\n        this.element.style.left = "0px";\n        this.element.style.height = "100%";\n        this.element.style.width = "100%";\n    } else {\n        this.wrapper    = $.makeNeutralElement( "div" );\n        this.wrapper.style.display = "inline-block";\n        if ( this.anchor == $.ControlAnchor.NONE ) {\n            // IE6 fix\n            this.wrapper.style.width = this.wrapper.style.height = "100%";\n        }\n    }\n    this.wrapper.appendChild( this.element );\n\n    if (options.attachToViewer ) {\n        if ( this.anchor == $.ControlAnchor.TOP_RIGHT ||\n             this.anchor == $.ControlAnchor.BOTTOM_RIGHT ) {\n            this.container.insertBefore(\n                this.wrapper,\n                this.container.firstChild\n            );\n        } else {\n            this.container.appendChild( this.wrapper );\n        }\n    } else {\n        parent.appendChild( this.wrapper );\n    }\n};\n\n/** @lends OpenSeadragon.Control.prototype */\n$.Control.prototype = {\n\n    /**\n     * Removes the control from the container.\n     * @function\n     */\n    destroy: function() {\n        this.wrapper.removeChild( this.element );\n        this.container.removeChild( this.wrapper );\n    },\n\n    /**\n     * Determines if the control is currently visible.\n     * @function\n     * @return {Boolean} true if currenly visible, false otherwise.\n     */\n    isVisible: function() {\n        return this.wrapper.style.display != "none";\n    },\n\n    /**\n     * Toggles the visibility of the control.\n     * @function\n     * @param {Boolean} visible - true to make visible, false to hide.\n     */\n    setVisible: function( visible ) {\n        this.wrapper.style.display = visible ?\n            ( this.anchor == $.ControlAnchor.ABSOLUTE ? \'block\' : \'inline-block\' ) :\n            "none";\n    },\n\n    /**\n     * Sets the opacity level for the control.\n     * @function\n     * @param {Number} opactiy - a value between 1 and 0 inclusively.\n     */\n    setOpacity: function( opacity ) {\n        if ( this.element[ $.SIGNAL ] && $.Browser.vendor == $.BROWSERS.IE ) {\n            $.setElementOpacity( this.element, opacity, true );\n        } else {\n            $.setElementOpacity( this.wrapper, opacity, true );\n        }\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ControlDock\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n    /**\n     * @class ControlDock\n     * @classdesc Provides a container element (a &lt;form&gt; element) with support for the layout of control elements.\n     *\n     * @memberof OpenSeadragon\n     */\n    $.ControlDock = function( options ){\n        var layouts = [ \'topleft\', \'topright\', \'bottomright\', \'bottomleft\'],\n            layout,\n            i;\n\n        $.extend( true, this, {\n            id: \'controldock-\'+$.now()+\'-\'+Math.floor(Math.random()*1000000),\n            container: $.makeNeutralElement( \'div\' ),\n            controls: []\n        }, options );\n\n        // Disable the form\'s submit; otherwise button clicks and return keys\n        // can trigger it.\n        this.container.onsubmit = function() {\n            return false;\n        };\n\n        if( this.element ){\n            this.element = $.getElement( this.element );\n            this.element.appendChild( this.container );\n            this.element.style.position = \'relative\';\n            this.container.style.width = \'100%\';\n            this.container.style.height = \'100%\';\n        }\n\n        for( i = 0; i < layouts.length; i++ ){\n            layout = layouts[ i ];\n            this.controls[ layout ] = $.makeNeutralElement( "div" );\n            this.controls[ layout ].style.position = \'absolute\';\n            if ( layout.match( \'left\' ) ){\n                this.controls[ layout ].style.left = \'0px\';\n            }\n            if ( layout.match( \'right\' ) ){\n                this.controls[ layout ].style.right = \'0px\';\n            }\n            if ( layout.match( \'top\' ) ){\n                this.controls[ layout ].style.top = \'0px\';\n            }\n            if ( layout.match( \'bottom\' ) ){\n                this.controls[ layout ].style.bottom = \'0px\';\n            }\n        }\n\n        this.container.appendChild( this.controls.topleft );\n        this.container.appendChild( this.controls.topright );\n        this.container.appendChild( this.controls.bottomright );\n        this.container.appendChild( this.controls.bottomleft );\n    };\n\n    /** @lends OpenSeadragon.ControlDock.prototype */\n    $.ControlDock.prototype = {\n\n        /**\n         * @function\n         */\n        addControl: function ( element, controlOptions ) {\n            element = $.getElement( element );\n            var div = null;\n\n            if ( getControlIndex( this, element ) >= 0 ) {\n                return;     // they\'re trying to add a duplicate control\n            }\n\n            switch ( controlOptions.anchor ) {\n                case $.ControlAnchor.TOP_RIGHT:\n                    div = this.controls.topright;\n                    element.style.position = "relative";\n                    element.style.paddingRight = "0px";\n                    element.style.paddingTop = "0px";\n                    break;\n                case $.ControlAnchor.BOTTOM_RIGHT:\n                    div = this.controls.bottomright;\n                    element.style.position = "relative";\n                    element.style.paddingRight = "0px";\n                    element.style.paddingBottom = "0px";\n                    break;\n                case $.ControlAnchor.BOTTOM_LEFT:\n                    div = this.controls.bottomleft;\n                    element.style.position = "relative";\n                    element.style.paddingLeft = "0px";\n                    element.style.paddingBottom = "0px";\n                    break;\n                case $.ControlAnchor.TOP_LEFT:\n                    div = this.controls.topleft;\n                    element.style.position = "relative";\n                    element.style.paddingLeft = "0px";\n                    element.style.paddingTop = "0px";\n                    break;\n                case $.ControlAnchor.ABSOLUTE:\n                    div = this.container;\n                    element.style.margin = "0px";\n                    element.style.padding = "0px";\n                    break;\n                default:\n                case $.ControlAnchor.NONE:\n                    div = this.container;\n                    element.style.margin = "0px";\n                    element.style.padding = "0px";\n                    break;\n            }\n\n            this.controls.push(\n                new $.Control( element, controlOptions, div )\n            );\n            element.style.display = "inline-block";\n        },\n\n\n        /**\n         * @function\n         * @return {OpenSeadragon.ControlDock} Chainable.\n         */\n        removeControl: function ( element ) {\n            element = $.getElement( element );\n            var i = getControlIndex( this, element );\n\n            if ( i >= 0 ) {\n                this.controls[ i ].destroy();\n                this.controls.splice( i, 1 );\n            }\n\n            return this;\n        },\n\n        /**\n         * @function\n         * @return {OpenSeadragon.ControlDock} Chainable.\n         */\n        clearControls: function () {\n            while ( this.controls.length > 0 ) {\n                this.controls.pop().destroy();\n            }\n\n            return this;\n        },\n\n\n        /**\n         * @function\n         * @return {Boolean}\n         */\n        areControlsEnabled: function () {\n            var i;\n\n            for ( i = this.controls.length - 1; i >= 0; i-- ) {\n                if ( this.controls[ i ].isVisible() ) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n\n        /**\n         * @function\n         * @return {OpenSeadragon.ControlDock} Chainable.\n         */\n        setControlsEnabled: function( enabled ) {\n            var i;\n\n            for ( i = this.controls.length - 1; i >= 0; i-- ) {\n                this.controls[ i ].setVisible( enabled );\n            }\n\n            return this;\n        }\n\n    };\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Utility methods\n    ///////////////////////////////////////////////////////////////////////////////\n    function getControlIndex( dock, element ) {\n        var controls = dock.controls,\n            i;\n\n        for ( i = controls.length - 1; i >= 0; i-- ) {\n            if ( controls[ i ].element == element ) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Placement\n *\n * Copyright (C) 2010-2016 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($) {\n\n    /**\n     * An enumeration of positions to anchor an element.\n     * @member Placement\n     * @memberOf OpenSeadragon\n     * @static\n     * @readonly\n     * @property {OpenSeadragon.Placement} CENTER\n     * @property {OpenSeadragon.Placement} TOP_LEFT\n     * @property {OpenSeadragon.Placement} TOP\n     * @property {OpenSeadragon.Placement} TOP_RIGHT\n     * @property {OpenSeadragon.Placement} RIGHT\n     * @property {OpenSeadragon.Placement} BOTTOM_RIGHT\n     * @property {OpenSeadragon.Placement} BOTTOM\n     * @property {OpenSeadragon.Placement} BOTTOM_LEFT\n     * @property {OpenSeadragon.Placement} LEFT\n     */\n    $.Placement = $.freezeObject({\n        CENTER:       0,\n        TOP_LEFT:     1,\n        TOP:          2,\n        TOP_RIGHT:    3,\n        RIGHT:        4,\n        BOTTOM_RIGHT: 5,\n        BOTTOM:       6,\n        BOTTOM_LEFT:  7,\n        LEFT:         8,\n        properties: {\n            0: {\n                isLeft: false,\n                isHorizontallyCentered: true,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: true,\n                isBottom: false\n            },\n            1: {\n                isLeft: true,\n                isHorizontallyCentered: false,\n                isRight: false,\n                isTop: true,\n                isVerticallyCentered: false,\n                isBottom: false\n            },\n            2: {\n                isLeft: false,\n                isHorizontallyCentered: true,\n                isRight: false,\n                isTop: true,\n                isVerticallyCentered: false,\n                isBottom: false\n            },\n            3: {\n                isLeft: false,\n                isHorizontallyCentered: false,\n                isRight: true,\n                isTop: true,\n                isVerticallyCentered: false,\n                isBottom: false\n            },\n            4: {\n                isLeft: false,\n                isHorizontallyCentered: false,\n                isRight: true,\n                isTop: false,\n                isVerticallyCentered: true,\n                isBottom: false\n            },\n            5: {\n                isLeft: false,\n                isHorizontallyCentered: false,\n                isRight: true,\n                isTop: false,\n                isVerticallyCentered: false,\n                isBottom: true\n            },\n            6: {\n                isLeft: false,\n                isHorizontallyCentered: true,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: false,\n                isBottom: true\n            },\n            7: {\n                isLeft: true,\n                isHorizontallyCentered: false,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: false,\n                isBottom: true\n            },\n            8: {\n                isLeft: true,\n                isHorizontallyCentered: false,\n                isRight: false,\n                isTop: false,\n                isVerticallyCentered: true,\n                isBottom: false\n            }\n        }\n    });\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - Viewer\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// dictionary from hash to private properties\nvar THIS = {};\nvar nextHash = 1;\n\n/**\n *\n * The main point of entry into creating a zoomable image on the page.<br>\n * <br>\n * We have provided an idiomatic javascript constructor which takes\n * a single object, but still support the legacy positional arguments.<br>\n * <br>\n * The options below are given in order that they appeared in the constructor\n * as arguments and we translate a positional call into an idiomatic call.<br>\n * <br>\n * To create a viewer, you can use either of this methods:<br>\n * <ul>\n * <li><code>var viewer = new OpenSeadragon.Viewer(options);</code></li>\n * <li><code>var viewer = OpenSeadragon(options);</code></li>\n * </ul>\n * @class Viewer\n * @classdesc The main OpenSeadragon viewer class.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @extends OpenSeadragon.ControlDock\n * @param {OpenSeadragon.Options} options - Viewer options.\n *\n **/\n$.Viewer = function( options ) {\n\n    var args  = arguments,\n        _this = this,\n        i;\n\n\n    //backward compatibility for positional args while prefering more\n    //idiomatic javascript options object as the only argument\n    if( !$.isPlainObject( options ) ){\n        options = {\n            id:                 args[ 0 ],\n            xmlPath:            args.length > 1 ? args[ 1 ] : undefined,\n            prefixUrl:          args.length > 2 ? args[ 2 ] : undefined,\n            controls:           args.length > 3 ? args[ 3 ] : undefined,\n            overlays:           args.length > 4 ? args[ 4 ] : undefined\n        };\n    }\n\n    //options.config and the general config argument are deprecated\n    //in favor of the more direct specification of optional settings\n    //being pass directly on the options object\n    if ( options.config ){\n        $.extend( true, options, options.config );\n        delete options.config;\n    }\n\n    //Public properties\n    //Allow the options object to override global defaults\n    $.extend( true, this, {\n\n        //internal state and dom identifiers\n        id:             options.id,\n        hash:           options.hash || nextHash++,\n\n        //dom nodes\n        /**\n         * The parent element of this Viewer instance, passed in when the Viewer was created.\n         * @member {Element} element\n         * @memberof OpenSeadragon.Viewer#\n         */\n        element:        null,\n        /**\n         * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>\n         * Child element of {@link OpenSeadragon.Viewer#element}.\n         * @member {Element} container\n         * @memberof OpenSeadragon.Viewer#\n         */\n        container:      null,\n        /**\n         * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>\n         * Child element of {@link OpenSeadragon.Viewer#container},\n         * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>\n         * The parent of {@link OpenSeadragon.Drawer#canvas} instances.\n         * @member {Element} canvas\n         * @memberof OpenSeadragon.Viewer#\n         */\n        canvas:         null,\n\n        // Overlays list. An overlay allows to add html on top of the viewer.\n        overlays:           [],\n        // Container inside the canvas where overlays are drawn.\n        overlaysContainer:  null,\n\n        //private state properties\n        previousBody:   [],\n\n        //This was originally initialized in the constructor and so could never\n        //have anything in it.  now it can because we allow it to be specified\n        //in the options and is only empty by default if not specified. Also\n        //this array was returned from get_controls which I find confusing\n        //since this object has a controls property which is treated in other\n        //functions like clearControls.  I\'m removing the accessors.\n        customControls: [],\n\n        //These are originally not part options but declared as members\n        //in initialize.  It\'s still considered idiomatic to put them here\n        source:         null,\n        /**\n         * Handles rendering of tiles in the viewer. Created for each TileSource opened.\n         * @member {OpenSeadragon.Drawer} drawer\n         * @memberof OpenSeadragon.Viewer#\n         */\n        drawer:             null,\n        world:              null,\n        /**\n         * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.\n         * @member {OpenSeadragon.Viewport} viewport\n         * @memberof OpenSeadragon.Viewer#\n         */\n        viewport:       null,\n        /**\n         * @member {OpenSeadragon.Navigator} navigator\n         * @memberof OpenSeadragon.Viewer#\n         */\n        navigator:      null,\n\n        //A collection viewport is a separate viewport used to provide\n        //simultaneous rendering of sets of tiles\n        collectionViewport:     null,\n        collectionDrawer:       null,\n\n        //UI image resources\n        //TODO: rename navImages to uiImages\n        navImages:      null,\n\n        //interface button controls\n        buttons:        null,\n\n        //TODO: this is defunct so safely remove it\n        profiler:       null\n\n    }, $.DEFAULT_SETTINGS, options );\n\n    if ( typeof( this.hash) === "undefined" ) {\n        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");\n    }\n    if ( typeof( THIS[ this.hash ] ) !== "undefined" ) {\n        // We don\'t want to throw an error here, as the user might have discarded\n        // the previous viewer with the same hash and now want to recreate it.\n        $.console.warn("Hash " + this.hash + " has already been used.");\n    }\n\n    //Private state properties\n    THIS[ this.hash ] = {\n        "fsBoundsDelta":     new $.Point( 1, 1 ),\n        "prevContainerSize": null,\n        "animating":         false,\n        "forceRedraw":       false,\n        "mouseInside":       false,\n        "group":             null,\n        // whether we should be continuously zooming\n        "zooming":           false,\n        // how much we should be continuously zooming by\n        "zoomFactor":        null,\n        "lastZoomTime":      null,\n        "fullPage":          false,\n        "onfullscreenchange": null\n    };\n\n    this._sequenceIndex = 0;\n    this._firstOpen = true;\n    this._updateRequestId = null;\n    this._loadQueue = [];\n    this.currentOverlays = [];\n\n    this._lastScrollTime = $.now(); // variable used to help normalize the scroll event speed of different devices\n\n    //Inherit some behaviors and properties\n    $.EventSource.call( this );\n\n    this.addHandler( \'open-failed\', function ( event ) {\n        var msg = $.getString( "Errors.OpenFailed", event.eventSource, event.message);\n        _this._showMessage( msg );\n    });\n\n    $.ControlDock.call( this, options );\n\n    //Deal with tile sources\n    if ( this.xmlPath  ){\n        //Deprecated option.  Now it is preferred to use the tileSources option\n        this.tileSources = [ this.xmlPath ];\n    }\n\n    this.element              = this.element || document.getElementById( this.id );\n    this.canvas               = $.makeNeutralElement( "div" );\n\n    this.canvas.className = "openseadragon-canvas";\n    (function( style ){\n        style.width    = "100%";\n        style.height   = "100%";\n        style.overflow = "hidden";\n        style.position = "absolute";\n        style.top      = "0px";\n        style.left     = "0px";\n    }(this.canvas.style));\n    $.setElementTouchActionNone( this.canvas );\n    if (options.tabIndex !== "") {\n        this.canvas.tabIndex = (options.tabIndex === undefined ? 0 : options.tabIndex);\n    }\n\n    //the container is created through applying the ControlDock constructor above\n    this.container.className = "openseadragon-container";\n    (function( style ){\n        style.width     = "100%";\n        style.height    = "100%";\n        style.position  = "relative";\n        style.overflow  = "hidden";\n        style.left      = "0px";\n        style.top       = "0px";\n        style.textAlign = "left";  // needed to protect against\n    }( this.container.style ));\n\n    this.container.insertBefore( this.canvas, this.container.firstChild );\n    this.element.appendChild( this.container );\n\n    //Used for toggling between fullscreen and default container size\n    //TODO: these can be closure private and shared across Viewer\n    //      instances.\n    this.bodyWidth      = document.body.style.width;\n    this.bodyHeight     = document.body.style.height;\n    this.bodyOverflow   = document.body.style.overflow;\n    this.docOverflow    = document.documentElement.style.overflow;\n\n    this.innerTracker = new $.MouseTracker({\n        element:                  this.canvas,\n        startDisabled:            this.mouseNavEnabled ? false : true,\n        clickTimeThreshold:       this.clickTimeThreshold,\n        clickDistThreshold:       this.clickDistThreshold,\n        dblClickTimeThreshold:    this.dblClickTimeThreshold,\n        dblClickDistThreshold:    this.dblClickDistThreshold,\n        keyDownHandler:           $.delegate( this, onCanvasKeyDown ),\n        keyHandler:               $.delegate( this, onCanvasKeyPress ),\n        clickHandler:             $.delegate( this, onCanvasClick ),\n        dblClickHandler:          $.delegate( this, onCanvasDblClick ),\n        dragHandler:              $.delegate( this, onCanvasDrag ),\n        dragEndHandler:           $.delegate( this, onCanvasDragEnd ),\n        enterHandler:             $.delegate( this, onCanvasEnter ),\n        exitHandler:              $.delegate( this, onCanvasExit ),\n        pressHandler:             $.delegate( this, onCanvasPress ),\n        releaseHandler:           $.delegate( this, onCanvasRelease ),\n        nonPrimaryPressHandler:   $.delegate( this, onCanvasNonPrimaryPress ),\n        nonPrimaryReleaseHandler: $.delegate( this, onCanvasNonPrimaryRelease ),\n        scrollHandler:            $.delegate( this, onCanvasScroll ),\n        pinchHandler:             $.delegate( this, onCanvasPinch )\n    });\n\n    this.outerTracker = new $.MouseTracker({\n        element:               this.container,\n        startDisabled:         this.mouseNavEnabled ? false : true,\n        clickTimeThreshold:    this.clickTimeThreshold,\n        clickDistThreshold:    this.clickDistThreshold,\n        dblClickTimeThreshold: this.dblClickTimeThreshold,\n        dblClickDistThreshold: this.dblClickDistThreshold,\n        enterHandler:          $.delegate( this, onContainerEnter ),\n        exitHandler:           $.delegate( this, onContainerExit )\n    });\n\n    if( this.toolbar ){\n        this.toolbar = new $.ControlDock({ element: this.toolbar });\n    }\n\n    this.bindStandardControls();\n\n    THIS[ this.hash ].prevContainerSize = _getSafeElemSize( this.container );\n\n    // Create the world\n    this.world = new $.World({\n        viewer: this\n    });\n\n    this.world.addHandler(\'add-item\', function(event) {\n        // For backwards compatibility, we maintain the source property\n        _this.source = _this.world.getItemAt(0).source;\n\n        THIS[ _this.hash ].forceRedraw = true;\n\n        if (!_this._updateRequestId) {\n            _this._updateRequestId = scheduleUpdate( _this, updateMulti );\n        }\n    });\n\n    this.world.addHandler(\'remove-item\', function(event) {\n        // For backwards compatibility, we maintain the source property\n        if (_this.world.getItemCount()) {\n            _this.source = _this.world.getItemAt(0).source;\n        } else {\n            _this.source = null;\n        }\n\n        THIS[ _this.hash ].forceRedraw = true;\n    });\n\n    this.world.addHandler(\'metrics-change\', function(event) {\n        if (_this.viewport) {\n            _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());\n        }\n    });\n\n    this.world.addHandler(\'item-index-change\', function(event) {\n        // For backwards compatibility, we maintain the source property\n        _this.source = _this.world.getItemAt(0).source;\n    });\n\n    // Create the viewport\n    this.viewport = new $.Viewport({\n        containerSize:      THIS[ this.hash ].prevContainerSize,\n        springStiffness:    this.springStiffness,\n        animationTime:      this.animationTime,\n        minZoomImageRatio:  this.minZoomImageRatio,\n        maxZoomPixelRatio:  this.maxZoomPixelRatio,\n        visibilityRatio:    this.visibilityRatio,\n        wrapHorizontal:     this.wrapHorizontal,\n        wrapVertical:       this.wrapVertical,\n        defaultZoomLevel:   this.defaultZoomLevel,\n        minZoomLevel:       this.minZoomLevel,\n        maxZoomLevel:       this.maxZoomLevel,\n        viewer:             this,\n        degrees:            this.degrees,\n        navigatorRotate:    this.navigatorRotate,\n        homeFillsViewer:    this.homeFillsViewer,\n        margins:            this.viewportMargins\n    });\n\n    this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());\n\n    // Create the image loader\n    this.imageLoader = new $.ImageLoader({\n        jobLimit: this.imageLoaderLimit\n    });\n\n    // Create the tile cache\n    this.tileCache = new $.TileCache({\n        maxImageCacheCount: this.maxImageCacheCount\n    });\n\n    // Create the drawer\n    this.drawer = new $.Drawer({\n        viewer:             this,\n        viewport:           this.viewport,\n        element:            this.canvas,\n        debugGridColor:     this.debugGridColor\n    });\n\n    // Overlay container\n    this.overlaysContainer    = $.makeNeutralElement( "div" );\n    this.canvas.appendChild( this.overlaysContainer );\n\n    // Now that we have a drawer, see if it supports rotate. If not we need to remove the rotate buttons\n    if (!this.drawer.canRotate()) {\n        // Disable/remove the rotate left/right buttons since they aren\'t supported\n        if (this.rotateLeft) {\n            i = this.buttons.buttons.indexOf(this.rotateLeft);\n            this.buttons.buttons.splice(i, 1);\n            this.buttons.element.removeChild(this.rotateLeft.element);\n        }\n        if (this.rotateRight) {\n            i = this.buttons.buttons.indexOf(this.rotateRight);\n            this.buttons.buttons.splice(i, 1);\n            this.buttons.element.removeChild(this.rotateRight.element);\n        }\n    }\n\n    //Instantiate a navigator if configured\n    if ( this.showNavigator){\n        this.navigator = new $.Navigator({\n            id:                this.navigatorId,\n            position:          this.navigatorPosition,\n            sizeRatio:         this.navigatorSizeRatio,\n            maintainSizeRatio: this.navigatorMaintainSizeRatio,\n            top:               this.navigatorTop,\n            left:              this.navigatorLeft,\n            width:             this.navigatorWidth,\n            height:            this.navigatorHeight,\n            autoResize:        this.navigatorAutoResize,\n            autoFade:          this.navigatorAutoFade,\n            prefixUrl:         this.prefixUrl,\n            viewer:            this,\n            navigatorRotate:   this.navigatorRotate,\n            crossOriginPolicy: this.crossOriginPolicy\n        });\n    }\n\n    // Sequence mode\n    if (this.sequenceMode) {\n        this.bindSequenceControls();\n    }\n\n    // Open initial tilesources\n    if (this.tileSources) {\n        this.open( this.tileSources );\n    }\n\n    // Add custom controls\n    for ( i = 0; i < this.customControls.length; i++ ) {\n        this.addControl(\n            this.customControls[ i ].id,\n            {anchor: this.customControls[ i ].anchor}\n        );\n    }\n\n    // Initial fade out\n    $.requestAnimationFrame( function(){\n        beginControlsAutoHide( _this );\n    } );\n};\n\n$.extend( $.Viewer.prototype, $.EventSource.prototype, $.ControlDock.prototype, /** @lends OpenSeadragon.Viewer.prototype */{\n\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isOpen: function () {\n        return !!this.world.getItemCount();\n    },\n\n    // deprecated\n    openDzi: function ( dzi ) {\n        $.console.error( "[Viewer.openDzi] this function is deprecated; use Viewer.open() instead." );\n        return this.open( dzi );\n    },\n\n    // deprecated\n    openTileSource: function ( tileSource ) {\n        $.console.error( "[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead." );\n        return this.open( tileSource );\n    },\n\n    /**\n     * Open tiled images into the viewer, closing any others.\n     * @function\n     * @param {Array|String|Object|Function} tileSources - This can be a TiledImage\n     * specifier, a TileSource specifier, or an array of either. A TiledImage specifier\n     * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},\n     * except for the index property; images are added in sequence.\n     * A TileSource specifier is anything you could pass as the tileSource property\n     * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:open\n     * @fires OpenSeadragon.Viewer.event:open-failed\n     */\n    open: function (tileSources) {\n        var _this = this;\n\n        this.close();\n\n        if (!tileSources) {\n            return;\n        }\n\n        if (this.sequenceMode && $.isArray(tileSources)) {\n            if (this.referenceStrip) {\n                this.referenceStrip.destroy();\n                this.referenceStrip = null;\n            }\n\n            this.tileSources = tileSources;\n            this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));\n            if (this.tileSources.length) {\n                this.open(this.tileSources[this._sequenceIndex]);\n\n                if ( this.showReferenceStrip ){\n                    this.referenceStrip = new $.ReferenceStrip({\n                        id:          this.referenceStripElement,\n                        position:    this.referenceStripPosition,\n                        sizeRatio:   this.referenceStripSizeRatio,\n                        scroll:      this.referenceStripScroll,\n                        height:      this.referenceStripHeight,\n                        width:       this.referenceStripWidth,\n                        tileSources: this.tileSources,\n                        prefixUrl:   this.prefixUrl,\n                        viewer:      this\n                    });\n                }\n            }\n\n            this._updateSequenceButtons( this._sequenceIndex );\n            return;\n        }\n\n        if (!$.isArray(tileSources)) {\n            tileSources = [tileSources];\n        }\n\n        if (!tileSources.length) {\n            return;\n        }\n\n        this._opening = true;\n\n        var expected = tileSources.length;\n        var successes = 0;\n        var failures = 0;\n        var failEvent;\n\n        var checkCompletion = function() {\n            if (successes + failures === expected) {\n                if (successes) {\n                    if (_this._firstOpen || !_this.preserveViewport) {\n                        _this.viewport.goHome( true );\n                        _this.viewport.update();\n                    }\n\n                    _this._firstOpen = false;\n\n                    var source = tileSources[0];\n                    if (source.tileSource) {\n                        source = source.tileSource;\n                    }\n\n                    // Global overlays\n                    if( _this.overlays && !_this.preserveOverlays ){\n                        for ( var i = 0; i < _this.overlays.length; i++ ) {\n                            _this.currentOverlays[ i ] = getOverlayObject( _this, _this.overlays[ i ] );\n                        }\n                    }\n\n                    _this._drawOverlays();\n                    _this._opening = false;\n\n                    /**\n                     * Raised when the viewer has opened and loaded one or more TileSources.\n                     *\n                     * @event open\n                     * @memberof OpenSeadragon.Viewer\n                     * @type {object}\n                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n                     * @property {OpenSeadragon.TileSource} source - The tile source that was opened.\n                     * @property {?Object} userData - Arbitrary subscriber-defined object.\n                     */\n                    // TODO: what if there are multiple sources?\n                    _this.raiseEvent( \'open\', { source: source } );\n                } else {\n                    _this._opening = false;\n\n                    /**\n                     * Raised when an error occurs loading a TileSource.\n                     *\n                     * @event open-failed\n                     * @memberof OpenSeadragon.Viewer\n                     * @type {object}\n                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n                     * @property {String} message - Information about what failed.\n                     * @property {String} source - The tile source that failed.\n                     * @property {?Object} userData - Arbitrary subscriber-defined object.\n                     */\n                    _this.raiseEvent( \'open-failed\', failEvent );\n                }\n            }\n        };\n\n        var doOne = function(options) {\n            if (!$.isPlainObject(options) || !options.tileSource) {\n                options = {\n                    tileSource: options\n                };\n            }\n\n            if (options.index !== undefined) {\n                $.console.error(\'[Viewer.open] setting indexes here is not supported; use addTiledImage instead\');\n                delete options.index;\n            }\n\n            if (options.collectionImmediately === undefined) {\n                options.collectionImmediately = true;\n            }\n\n            var originalSuccess = options.success;\n            options.success = function(event) {\n                successes++;\n\n                // TODO: now that options has other things besides tileSource, the overlays\n                // should probably be at the options level, not the tileSource level.\n                if (options.tileSource.overlays) {\n                    for (var i = 0; i < options.tileSource.overlays.length; i++) {\n                        _this.addOverlay(options.tileSource.overlays[i]);\n                    }\n                }\n\n                if (originalSuccess) {\n                    originalSuccess(event);\n                }\n\n                checkCompletion();\n            };\n\n            var originalError = options.error;\n            options.error = function(event) {\n                failures++;\n\n                if (!failEvent) {\n                    failEvent = event;\n                }\n\n                if (originalError) {\n                    originalError(event);\n                }\n\n                checkCompletion();\n            };\n\n            _this.addTiledImage(options);\n        };\n\n        // TileSources\n        for (var i = 0; i < tileSources.length; i++) {\n            doOne(tileSources[i]);\n        }\n\n        return this;\n    },\n\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:close\n     */\n    close: function ( ) {\n        if ( !THIS[ this.hash ] ) {\n            //this viewer has already been destroyed: returning immediately\n            return this;\n        }\n\n        this._opening = false;\n\n        if ( this.navigator ) {\n            this.navigator.close();\n        }\n\n        if( ! this.preserveOverlays) {\n            this.clearOverlays();\n            this.overlaysContainer.innerHTML = "";\n        }\n\n        THIS[ this.hash ].animating = false;\n        this.world.removeAll();\n        this.imageLoader.clear();\n\n        /**\n         * Raised when the viewer is closed (see {@link OpenSeadragon.Viewer#close}).\n         *\n         * @event close\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'close\' );\n\n        return this;\n    },\n\n\n    /**\n     * Function to destroy the viewer and clean up everything created by OpenSeadragon.\n     *\n     * Example:\n     * var viewer = OpenSeadragon({\n     *   [...]\n     * });\n     *\n     * //when you are done with the viewer:\n     * viewer.destroy();\n     * viewer = null; //important\n     *\n     * @function\n     */\n    destroy: function( ) {\n        if ( !THIS[ this.hash ] ) {\n            //this viewer has already been destroyed: returning immediately\n            return;\n        }\n\n        this.close();\n\n        this.clearOverlays();\n        this.overlaysContainer.innerHTML = "";\n\n        //TODO: implement this...\n        //this.unbindSequenceControls()\n        //this.unbindStandardControls()\n\n        if (this.referenceStrip) {\n            this.referenceStrip.destroy();\n            this.referenceStrip = null;\n        }\n\n        if ( this._updateRequestId !== null ) {\n            $.cancelAnimationFrame( this._updateRequestId );\n            this._updateRequestId = null;\n        }\n\n        if ( this.drawer ) {\n            this.drawer.destroy();\n        }\n\n        this.removeAllHandlers();\n\n        // Go through top element (passed to us) and remove all children\n        // Use removeChild to make sure it handles SVG or any non-html\n        // also it performs better - http://jsperf.com/innerhtml-vs-removechild/15\n        if (this.element){\n            while (this.element.firstChild) {\n                this.element.removeChild(this.element.firstChild);\n            }\n        }\n\n        // destroy the mouse trackers\n        if (this.innerTracker){\n            this.innerTracker.destroy();\n        }\n        if (this.outerTracker){\n            this.outerTracker.destroy();\n        }\n\n        THIS[ this.hash ] = null;\n        delete THIS[ this.hash ];\n\n        // clear all our references to dom objects\n        this.canvas = null;\n        this.container = null;\n\n        // clear our reference to the main element - they will need to pass it in again, creating a new viewer\n        this.element = null;\n    },\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isMouseNavEnabled: function () {\n        return this.innerTracker.isTracking();\n    },\n\n    /**\n     * @function\n     * @param {Boolean} enabled - true to enable, false to disable\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:mouse-enabled\n     */\n    setMouseNavEnabled: function( enabled ){\n        this.innerTracker.setTracking( enabled );\n        this.outerTracker.setTracking( enabled );\n        /**\n         * Raised when mouse/touch navigation is enabled or disabled (see {@link OpenSeadragon.Viewer#setMouseNavEnabled}).\n         *\n         * @event mouse-enabled\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} enabled\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'mouse-enabled\', { enabled: enabled } );\n        return this;\n    },\n\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    areControlsEnabled: function () {\n        var enabled = this.controls.length,\n            i;\n        for( i = 0; i < this.controls.length; i++ ){\n            enabled = enabled && this.controls[ i ].isVisibile();\n        }\n        return enabled;\n    },\n\n\n    /**\n     * Shows or hides the controls (e.g. the default navigation buttons).\n     *\n     * @function\n     * @param {Boolean} true to show, false to hide.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:controls-enabled\n     */\n    setControlsEnabled: function( enabled ) {\n        if( enabled ){\n            abortControlsAutoHide( this );\n        } else {\n            beginControlsAutoHide( this );\n        }\n        /**\n         * Raised when the navigation controls are shown or hidden (see {@link OpenSeadragon.Viewer#setControlsEnabled}).\n         *\n         * @event controls-enabled\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} enabled\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'controls-enabled\', { enabled: enabled } );\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isFullPage: function () {\n        return THIS[ this.hash ].fullPage;\n    },\n\n\n    /**\n     * Toggle full page mode.\n     * @function\n     * @param {Boolean} fullPage\n     *      If true, enter full page mode.  If false, exit full page mode.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pre-full-page\n     * @fires OpenSeadragon.Viewer.event:full-page\n     */\n    setFullPage: function( fullPage ) {\n\n        var body = document.body,\n            bodyStyle = body.style,\n            docStyle = document.documentElement.style,\n            _this = this,\n            hash,\n            nodes,\n            i;\n\n        //dont bother modifying the DOM if we are already in full page mode.\n        if ( fullPage == this.isFullPage() ) {\n            return this;\n        }\n\n        var fullPageEventArgs = {\n            fullPage: fullPage,\n            preventDefaultAction: false\n        };\n        /**\n         * Raised when the viewer is about to change to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).\n         *\n         * @event pre-full-page\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} fullPage - True if entering full-page mode, false if exiting full-page mode.\n         * @property {Boolean} preventDefaultAction - Set to true to prevent full-page mode change. Default: false.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'pre-full-page\', fullPageEventArgs );\n        if ( fullPageEventArgs.preventDefaultAction ) {\n            return this;\n        }\n\n        if ( fullPage ) {\n\n            this.elementSize = $.getElementSize( this.element );\n            this.pageScroll = $.getPageScroll();\n\n            this.elementMargin = this.element.style.margin;\n            this.element.style.margin = "0";\n            this.elementPadding = this.element.style.padding;\n            this.element.style.padding = "0";\n\n            this.bodyMargin = bodyStyle.margin;\n            this.docMargin = docStyle.margin;\n            bodyStyle.margin = "0";\n            docStyle.margin = "0";\n\n            this.bodyPadding = bodyStyle.padding;\n            this.docPadding = docStyle.padding;\n            bodyStyle.padding = "0";\n            docStyle.padding = "0";\n\n            this.bodyWidth = bodyStyle.width;\n            this.docWidth = docStyle.width;\n            bodyStyle.width = "100%";\n            docStyle.width = "100%";\n\n            this.bodyHeight = bodyStyle.height;\n            this.docHeight = docStyle.height;\n            bodyStyle.height = "100%";\n            docStyle.height = "100%";\n\n            //when entering full screen on the ipad it wasnt sufficient to leave\n            //the body intact as only only the top half of the screen would\n            //respond to touch events on the canvas, while the bottom half treated\n            //them as touch events on the document body.  Thus we remove and store\n            //the bodies elements and replace them when we leave full screen.\n            this.previousBody = [];\n            THIS[ this.hash ].prevElementParent = this.element.parentNode;\n            THIS[ this.hash ].prevNextSibling = this.element.nextSibling;\n            THIS[ this.hash ].prevElementWidth = this.element.style.width;\n            THIS[ this.hash ].prevElementHeight = this.element.style.height;\n            nodes = body.childNodes.length;\n            for ( i = 0; i < nodes; i++ ) {\n                this.previousBody.push( body.childNodes[ 0 ] );\n                body.removeChild( body.childNodes[ 0 ] );\n            }\n\n            //If we\'ve got a toolbar, we need to enable the user to use css to\n            //preserve it in fullpage mode\n            if ( this.toolbar && this.toolbar.element ) {\n                //save a reference to the parent so we can put it back\n                //in the long run we need a better strategy\n                this.toolbar.parentNode = this.toolbar.element.parentNode;\n                this.toolbar.nextSibling = this.toolbar.element.nextSibling;\n                body.appendChild( this.toolbar.element );\n\n                //Make sure the user has some ability to style the toolbar based\n                //on the mode\n                $.addClass( this.toolbar.element, \'fullpage\' );\n            }\n\n            $.addClass( this.element, \'fullpage\' );\n            body.appendChild( this.element );\n\n            this.element.style.height = $.getWindowSize().y + \'px\';\n            this.element.style.width = $.getWindowSize().x + \'px\';\n\n            if ( this.toolbar && this.toolbar.element ) {\n                this.element.style.height = (\n                    $.getElementSize( this.element ).y - $.getElementSize( this.toolbar.element ).y\n                ) + \'px\';\n            }\n\n            THIS[ this.hash ].fullPage = true;\n\n            // mouse will be inside container now\n            $.delegate( this, onContainerEnter )( {} );\n\n        } else {\n\n            this.element.style.margin = this.elementMargin;\n            this.element.style.padding = this.elementPadding;\n\n            bodyStyle.margin = this.bodyMargin;\n            docStyle.margin = this.docMargin;\n\n            bodyStyle.padding = this.bodyPadding;\n            docStyle.padding = this.docPadding;\n\n            bodyStyle.width = this.bodyWidth;\n            docStyle.width = this.docWidth;\n\n            bodyStyle.height = this.bodyHeight;\n            docStyle.height = this.docHeight;\n\n            body.removeChild( this.element );\n            nodes = this.previousBody.length;\n            for ( i = 0; i < nodes; i++ ) {\n                body.appendChild( this.previousBody.shift() );\n            }\n\n            $.removeClass( this.element, \'fullpage\' );\n            THIS[ this.hash ].prevElementParent.insertBefore(\n                this.element,\n                THIS[ this.hash ].prevNextSibling\n            );\n\n            //If we\'ve got a toolbar, we need to enable the user to use css to\n            //reset it to its original state\n            if ( this.toolbar && this.toolbar.element ) {\n                body.removeChild( this.toolbar.element );\n\n                //Make sure the user has some ability to style the toolbar based\n                //on the mode\n                $.removeClass( this.toolbar.element, \'fullpage\' );\n\n                this.toolbar.parentNode.insertBefore(\n                    this.toolbar.element,\n                    this.toolbar.nextSibling\n                );\n                delete this.toolbar.parentNode;\n                delete this.toolbar.nextSibling;\n            }\n\n            this.element.style.width = THIS[ this.hash ].prevElementWidth;\n            this.element.style.height = THIS[ this.hash ].prevElementHeight;\n\n            // After exiting fullPage or fullScreen, it can take some time\n            // before the browser can actually set the scroll.\n            var restoreScrollCounter = 0;\n            var restoreScroll = function() {\n                $.setPageScroll( _this.pageScroll );\n                var pageScroll = $.getPageScroll();\n                restoreScrollCounter++;\n                if ( restoreScrollCounter < 10 &&\n                    pageScroll.x !== _this.pageScroll.x ||\n                    pageScroll.y !== _this.pageScroll.y ) {\n                    $.requestAnimationFrame( restoreScroll );\n                }\n            };\n            $.requestAnimationFrame( restoreScroll );\n\n            THIS[ this.hash ].fullPage = false;\n\n            // mouse will likely be outside now\n            $.delegate( this, onContainerExit )( { } );\n\n        }\n\n        if ( this.navigator && this.viewport ) {\n            this.navigator.update( this.viewport );\n        }\n\n        /**\n         * Raised when the viewer has changed to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).\n         *\n         * @event full-page\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} fullPage - True if changed to full-page mode, false if exited full-page mode.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'full-page\', { fullPage: fullPage } );\n\n        return this;\n    },\n\n    /**\n     * Toggle full screen mode if supported. Toggle full page mode otherwise.\n     * @function\n     * @param {Boolean} fullScreen\n     *      If true, enter full screen mode.  If false, exit full screen mode.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pre-full-screen\n     * @fires OpenSeadragon.Viewer.event:full-screen\n     */\n    setFullScreen: function( fullScreen ) {\n        var _this = this;\n\n        if ( !$.supportsFullScreen ) {\n            return this.setFullPage( fullScreen );\n        }\n\n        if ( $.isFullScreen() === fullScreen ) {\n            return this;\n        }\n\n        var fullScreeEventArgs = {\n            fullScreen: fullScreen,\n            preventDefaultAction: false\n        };\n        /**\n         * Raised when the viewer is about to change to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).\n         * Note: the pre-full-screen event is not raised when the user is exiting\n         * full-screen mode by pressing the Esc key. In that case, consider using\n         * the full-screen, pre-full-page or full-page events.\n         *\n         * @event pre-full-screen\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} fullScreen - True if entering full-screen mode, false if exiting full-screen mode.\n         * @property {Boolean} preventDefaultAction - Set to true to prevent full-screen mode change. Default: false.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'pre-full-screen\', fullScreeEventArgs );\n        if ( fullScreeEventArgs.preventDefaultAction ) {\n            return this;\n        }\n\n        if ( fullScreen ) {\n\n            this.setFullPage( true );\n            // If the full page mode is not actually entered, we need to prevent\n            // the full screen mode.\n            if ( !this.isFullPage() ) {\n                return this;\n            }\n\n            this.fullPageStyleWidth = this.element.style.width;\n            this.fullPageStyleHeight = this.element.style.height;\n            this.element.style.width = \'100%\';\n            this.element.style.height = \'100%\';\n\n            var onFullScreenChange = function() {\n                var isFullScreen = $.isFullScreen();\n                if ( !isFullScreen ) {\n                    $.removeEvent( document, $.fullScreenEventName, onFullScreenChange );\n                    $.removeEvent( document, $.fullScreenErrorEventName, onFullScreenChange );\n\n                    _this.setFullPage( false );\n                    if ( _this.isFullPage() ) {\n                        _this.element.style.width = _this.fullPageStyleWidth;\n                        _this.element.style.height = _this.fullPageStyleHeight;\n                    }\n                }\n                if ( _this.navigator && _this.viewport ) {\n                    _this.navigator.update( _this.viewport );\n                }\n                /**\n                 * Raised when the viewer has changed to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).\n                 *\n                 * @event full-screen\n                 * @memberof OpenSeadragon.Viewer\n                 * @type {object}\n                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n                 * @property {Boolean} fullScreen - True if changed to full-screen mode, false if exited full-screen mode.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( \'full-screen\', { fullScreen: isFullScreen } );\n            };\n            $.addEvent( document, $.fullScreenEventName, onFullScreenChange );\n            $.addEvent( document, $.fullScreenErrorEventName, onFullScreenChange );\n\n            $.requestFullScreen( document.body );\n\n        } else {\n            $.exitFullScreen();\n        }\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {Boolean}\n     */\n    isVisible: function () {\n        return this.container.style.visibility != "hidden";\n    },\n\n\n    /**\n     * @function\n     * @param {Boolean} visible\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:visible\n     */\n    setVisible: function( visible ){\n        this.container.style.visibility = visible ? "" : "hidden";\n        /**\n         * Raised when the viewer is shown or hidden (see {@link OpenSeadragon.Viewer#setVisible}).\n         *\n         * @event visible\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Boolean} visible\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'visible\', { visible: visible } );\n        return this;\n    },\n\n    /**\n     * Add a tiled image to the viewer.\n     * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}\n     *  supports except arrays of images.\n     * Note that you can specify options.width or options.height, but not both.\n     * The other dimension will be calculated according to the item\'s aspect ratio.\n     * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is\n     * automatically arranged with the others.\n     * @function\n     * @param {Object} options\n     * @param {String|Object|Function} options.tileSource - The TileSource specifier.\n     * A String implies a url used to determine the tileSource implementation\n     *      based on the file extension of url. JSONP is implied by *.js,\n     *      otherwise the url is retrieved as text and the resulting text is\n     *      introspected to determine if its json, xml, or text and parsed.\n     * An Object implies an inline configuration which has a single\n     *      property sufficient for being able to determine tileSource\n     *      implementation. If the object has a property which is a function\n     *      named \'getTileUrl\', it is treated as a custom TileSource.\n     * @param {Number} [options.index] The index of the item. Added on top of\n     * all other items if not specified.\n     * @param {Boolean} [options.replace=false] If true, the item at options.index will be\n     * removed and the new item is added in its place. options.tileSource will be\n     * interpreted and fetched if necessary before the old item is removed to avoid leaving\n     * a gap in the world.\n     * @param {Number} [options.x=0] The X position for the image in viewport coordinates.\n     * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.\n     * @param {Number} [options.width=1] The width for the image in viewport coordinates.\n     * @param {Number} [options.height] The height for the image in viewport coordinates.\n     * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates\n     * to fit the image into. If specified, x, y, width and height get ignored.\n     * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]\n     * How to anchor the image in the bounds if options.fitBounds is set.\n     * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to\n     * (portions of the image outside of this area will not be visible). Only works on\n     * browsers that support the HTML5 canvas.\n     * @param {Number} [options.opacity] Opacity the tiled image should be drawn at by default.\n     * @param {String} [options.compositeOperation] How the image is composited onto other images.\n     * @param {Function} [options.success] A function that gets called when the image is\n     * successfully added. It\'s passed the event object which contains a single property:\n     * "item", the resulting TiledImage.\n     * @param {Function} [options.error] A function that gets called if the image is\n     * unable to be added. It\'s passed the error event object, which contains "message"\n     * and "source" properties.\n     * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,\n     * specifies whether to snap to the new arrangement immediately or to animate to it.\n     * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.\n     * @fires OpenSeadragon.World.event:add-item\n     * @fires OpenSeadragon.Viewer.event:add-item-failed\n     */\n    addTiledImage: function( options ) {\n        $.console.assert(options, "[Viewer.addTiledImage] options is required");\n        $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");\n        $.console.assert(!options.replace || (options.index > -1 && options.index < this.world.getItemCount()),\n            "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world");\n\n        var _this = this;\n\n        if (options.replace) {\n            options.replaceItem = _this.world.getItemAt(options.index);\n        }\n\n        this._hideMessage();\n\n        if (options.placeholderFillStyle === undefined) {\n            options.placeholderFillStyle = this.placeholderFillStyle;\n        }\n        if (options.opacity === undefined) {\n            options.opacity = this.opacity;\n        }\n        if (options.compositeOperation === undefined) {\n            options.compositeOperation = this.compositeOperation;\n        }\n\n        var myQueueItem = {\n            options: options\n        };\n\n        function raiseAddItemFailed( event ) {\n            for (var i = 0; i < _this._loadQueue.length; i++) {\n                if (_this._loadQueue[i] === myQueueItem) {\n                    _this._loadQueue.splice(i, 1);\n                    break;\n                }\n            }\n\n            if (_this._loadQueue.length === 0) {\n                refreshWorld(myQueueItem);\n            }\n\n             /**\n             * Raised when an error occurs while adding a item.\n             * @event add-item-failed\n             * @memberOf OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n             * @property {String} message\n             * @property {String} source\n             * @property {Object} options The options passed to the addTiledImage method.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( \'add-item-failed\', event );\n\n            if (options.error) {\n                options.error(event);\n            }\n        }\n\n        function refreshWorld(theItem) {\n            if (_this.collectionMode) {\n                _this.world.arrange({\n                    immediately: theItem.options.collectionImmediately,\n                    rows: _this.collectionRows,\n                    columns: _this.collectionColumns,\n                    layout: _this.collectionLayout,\n                    tileSize: _this.collectionTileSize,\n                    tileMargin: _this.collectionTileMargin\n                });\n                _this.world.setAutoRefigureSizes(true);\n            }\n        }\n\n        if ($.isArray(options.tileSource)) {\n            setTimeout(function() {\n                raiseAddItemFailed({\n                    message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",\n                    source: options.tileSource,\n                    options: options\n                });\n            });\n            return;\n        }\n\n        this._loadQueue.push(myQueueItem);\n\n        getTileSourceImplementation( this, options.tileSource, function( tileSource ) {\n\n            myQueueItem.tileSource = tileSource;\n\n            // add everybody at the front of the queue that\'s ready to go\n            var queueItem, tiledImage, optionsClone;\n            while (_this._loadQueue.length) {\n                queueItem = _this._loadQueue[0];\n                if (!queueItem.tileSource) {\n                    break;\n                }\n\n                _this._loadQueue.splice(0, 1);\n\n                if (queueItem.options.replace) {\n                    var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);\n                    if (newIndex != -1) {\n                        queueItem.options.index = newIndex;\n                    }\n                    _this.world.removeItem(queueItem.options.replaceItem);\n                }\n\n                tiledImage = new $.TiledImage({\n                    viewer: _this,\n                    source: queueItem.tileSource,\n                    viewport: _this.viewport,\n                    drawer: _this.drawer,\n                    tileCache: _this.tileCache,\n                    imageLoader: _this.imageLoader,\n                    x: queueItem.options.x,\n                    y: queueItem.options.y,\n                    width: queueItem.options.width,\n                    height: queueItem.options.height,\n                    fitBounds: queueItem.options.fitBounds,\n                    fitBoundsPlacement: queueItem.options.fitBoundsPlacement,\n                    clip: queueItem.options.clip,\n                    placeholderFillStyle: queueItem.options.placeholderFillStyle,\n                    opacity: queueItem.options.opacity,\n                    compositeOperation: queueItem.options.compositeOperation,\n                    springStiffness: _this.springStiffness,\n                    animationTime: _this.animationTime,\n                    minZoomImageRatio: _this.minZoomImageRatio,\n                    wrapHorizontal: _this.wrapHorizontal,\n                    wrapVertical: _this.wrapVertical,\n                    immediateRender: _this.immediateRender,\n                    blendTime: _this.blendTime,\n                    alwaysBlend: _this.alwaysBlend,\n                    minPixelRatio: _this.minPixelRatio,\n                    smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,\n                    iOSDevice: _this.iOSDevice,\n                    crossOriginPolicy: _this.crossOriginPolicy,\n                    debugMode: _this.debugMode\n                });\n\n                if (_this.collectionMode) {\n                    _this.world.setAutoRefigureSizes(false);\n                }\n                _this.world.addItem( tiledImage, {\n                    index: queueItem.options.index\n                });\n\n                if (_this._loadQueue.length === 0) {\n                    //this restores the autoRefigureSizes flag to true.\n                    refreshWorld(queueItem);\n                }\n\n                if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {\n                    _this.viewport.goHome(true);\n                }\n\n                if (_this.navigator) {\n                    optionsClone = $.extend({}, queueItem.options, {\n                        replace: false, // navigator already removed the layer, nothing to replace\n                        originalTiledImage: tiledImage,\n                        tileSource: queueItem.tileSource\n                    });\n\n                    _this.navigator.addTiledImage(optionsClone);\n                }\n\n                if (queueItem.options.success) {\n                    queueItem.options.success({\n                        item: tiledImage\n                    });\n                }\n            }\n        }, function( event ) {\n            event.options = options;\n            raiseAddItemFailed(event);\n        } );\n    },\n\n    /**\n     * Add a simple image to the viewer.\n     * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}\n     * except for options.tileSource which is replaced by options.url.\n     * @function\n     * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}\n     * for all the options\n     * @param {String} options.url - The URL of the image to add.\n     * @fires OpenSeadragon.World.event:add-item\n     * @fires OpenSeadragon.Viewer.event:add-item-failed\n     */\n    addSimpleImage: function(options) {\n        $.console.assert(options, "[Viewer.addSimpleImage] options is required");\n        $.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");\n\n        var opts = $.extend({}, options, {\n            tileSource: {\n                type: \'image\',\n                url:  options.url\n            }\n        });\n        delete opts.url;\n        this.addTiledImage(opts);\n    },\n\n    // deprecated\n    addLayer: function( options ) {\n        var _this = this;\n\n        $.console.error( "[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead." );\n\n        var optionsClone = $.extend({}, options, {\n            success: function(event) {\n                _this.raiseEvent("add-layer", {\n                    options: options,\n                    drawer: event.item\n                });\n            },\n            error: function(event) {\n                _this.raiseEvent("add-layer-failed", event);\n            }\n        });\n\n        this.addTiledImage(optionsClone);\n        return this;\n    },\n\n    // deprecated\n    getLayerAtLevel: function( level ) {\n        $.console.error( "[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead." );\n        return this.world.getItemAt(level);\n    },\n\n    // deprecated\n    getLevelOfLayer: function( drawer ) {\n        $.console.error( "[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead." );\n        return this.world.getIndexOfItem(drawer);\n    },\n\n    // deprecated\n    getLayersCount: function() {\n        $.console.error( "[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead." );\n        return this.world.getItemCount();\n    },\n\n    // deprecated\n    setLayerLevel: function( drawer, level ) {\n        $.console.error( "[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead." );\n        return this.world.setItemIndex(drawer, level);\n    },\n\n    // deprecated\n    removeLayer: function( drawer ) {\n        $.console.error( "[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead." );\n        return this.world.removeItem(drawer);\n    },\n\n    /**\n     * Force the viewer to redraw its contents.\n     * @returns {OpenSeadragon.Viewer} Chainable.\n     */\n    forceRedraw: function() {\n        THIS[ this.hash ].forceRedraw = true;\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     */\n    bindSequenceControls: function(){\n\n        //////////////////////////////////////////////////////////////////////////\n        // Image Sequence Controls\n        //////////////////////////////////////////////////////////////////////////\n        var onFocusHandler          = $.delegate( this, onFocus ),\n            onBlurHandler           = $.delegate( this, onBlur ),\n            onNextHandler           = $.delegate( this, onNext ),\n            onPreviousHandler       = $.delegate( this, onPrevious ),\n            navImages               = this.navImages,\n            useGroup                = true ;\n\n        if( this.showSequenceControl ){\n\n            if( this.previousButton || this.nextButton ){\n                //if we are binding to custom buttons then layout and\n                //grouping is the responsibility of the page author\n                useGroup = false;\n            }\n\n            this.previousButton = new $.Button({\n                element:    this.previousButton ? $.getElement( this.previousButton ) : null,\n                clickTimeThreshold: this.clickTimeThreshold,\n                clickDistThreshold: this.clickDistThreshold,\n                tooltip:    $.getString( "Tooltips.PreviousPage" ),\n                srcRest:    resolveUrl( this.prefixUrl, navImages.previous.REST ),\n                srcGroup:   resolveUrl( this.prefixUrl, navImages.previous.GROUP ),\n                srcHover:   resolveUrl( this.prefixUrl, navImages.previous.HOVER ),\n                srcDown:    resolveUrl( this.prefixUrl, navImages.previous.DOWN ),\n                onRelease:  onPreviousHandler,\n                onFocus:    onFocusHandler,\n                onBlur:     onBlurHandler\n            });\n\n            this.nextButton = new $.Button({\n                element:    this.nextButton ? $.getElement( this.nextButton ) : null,\n                clickTimeThreshold: this.clickTimeThreshold,\n                clickDistThreshold: this.clickDistThreshold,\n                tooltip:    $.getString( "Tooltips.NextPage" ),\n                srcRest:    resolveUrl( this.prefixUrl, navImages.next.REST ),\n                srcGroup:   resolveUrl( this.prefixUrl, navImages.next.GROUP ),\n                srcHover:   resolveUrl( this.prefixUrl, navImages.next.HOVER ),\n                srcDown:    resolveUrl( this.prefixUrl, navImages.next.DOWN ),\n                onRelease:  onNextHandler,\n                onFocus:    onFocusHandler,\n                onBlur:     onBlurHandler\n            });\n\n            if( !this.navPrevNextWrap ){\n                this.previousButton.disable();\n            }\n\n            if (!this.tileSources || !this.tileSources.length) {\n                this.nextButton.disable();\n            }\n\n            if( useGroup ){\n                this.paging = new $.ButtonGroup({\n                    buttons: [\n                        this.previousButton,\n                        this.nextButton\n                    ],\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold\n                });\n\n                this.pagingControl = this.paging.element;\n\n                if( this.toolbar ){\n                    this.toolbar.addControl(\n                        this.pagingControl,\n                        {anchor: $.ControlAnchor.BOTTOM_RIGHT}\n                    );\n                }else{\n                    this.addControl(\n                        this.pagingControl,\n                        {anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT}\n                    );\n                }\n            }\n        }\n        return this;\n    },\n\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     */\n    bindStandardControls: function(){\n        //////////////////////////////////////////////////////////////////////////\n        // Navigation Controls\n        //////////////////////////////////////////////////////////////////////////\n        var beginZoomingInHandler   = $.delegate( this, beginZoomingIn ),\n            endZoomingHandler       = $.delegate( this, endZooming ),\n            doSingleZoomInHandler   = $.delegate( this, doSingleZoomIn ),\n            beginZoomingOutHandler  = $.delegate( this, beginZoomingOut ),\n            doSingleZoomOutHandler  = $.delegate( this, doSingleZoomOut ),\n            onHomeHandler           = $.delegate( this, onHome ),\n            onFullScreenHandler     = $.delegate( this, onFullScreen ),\n            onRotateLeftHandler     = $.delegate( this, onRotateLeft ),\n            onRotateRightHandler    = $.delegate( this, onRotateRight ),\n            onFocusHandler          = $.delegate( this, onFocus ),\n            onBlurHandler           = $.delegate( this, onBlur ),\n            navImages               = this.navImages,\n            buttons                 = [],\n            useGroup                = true ;\n\n\n        if ( this.showNavigationControl ) {\n\n            if( this.zoomInButton || this.zoomOutButton ||\n                this.homeButton || this.fullPageButton ||\n                this.rotateLeftButton || this.rotateRightButton ) {\n                //if we are binding to custom buttons then layout and\n                //grouping is the responsibility of the page author\n                useGroup = false;\n            }\n\n            if ( this.showZoomControl ) {\n                buttons.push( this.zoomInButton = new $.Button({\n                    element:    this.zoomInButton ? $.getElement( this.zoomInButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.ZoomIn" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomIn.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomIn.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomIn.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomIn.DOWN ),\n                    onPress:    beginZoomingInHandler,\n                    onRelease:  endZoomingHandler,\n                    onClick:    doSingleZoomInHandler,\n                    onEnter:    beginZoomingInHandler,\n                    onExit:     endZoomingHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n\n                buttons.push( this.zoomOutButton = new $.Button({\n                    element:    this.zoomOutButton ? $.getElement( this.zoomOutButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.ZoomOut" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomOut.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomOut.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomOut.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomOut.DOWN ),\n                    onPress:    beginZoomingOutHandler,\n                    onRelease:  endZoomingHandler,\n                    onClick:    doSingleZoomOutHandler,\n                    onEnter:    beginZoomingOutHandler,\n                    onExit:     endZoomingHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n            }\n\n            if ( this.showHomeControl ) {\n                buttons.push( this.homeButton = new $.Button({\n                    element:    this.homeButton ? $.getElement( this.homeButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.Home" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.home.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.home.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.home.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.home.DOWN ),\n                    onRelease:  onHomeHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n            }\n\n            if ( this.showFullPageControl ) {\n                buttons.push( this.fullPageButton = new $.Button({\n                    element:    this.fullPageButton ? $.getElement( this.fullPageButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.FullPage" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.fullpage.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.fullpage.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.fullpage.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.fullpage.DOWN ),\n                    onRelease:  onFullScreenHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n            }\n\n            if ( this.showRotationControl ) {\n                buttons.push( this.rotateLeftButton = new $.Button({\n                    element:    this.rotateLeftButton ? $.getElement( this.rotateLeftButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.RotateLeft" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateleft.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateleft.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateleft.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateleft.DOWN ),\n                    onRelease:  onRotateLeftHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n\n                buttons.push( this.rotateRightButton = new $.Button({\n                    element:    this.rotateRightButton ? $.getElement( this.rotateRightButton ) : null,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold,\n                    tooltip:    $.getString( "Tooltips.RotateRight" ),\n                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateright.REST ),\n                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateright.GROUP ),\n                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateright.HOVER ),\n                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateright.DOWN ),\n                    onRelease:  onRotateRightHandler,\n                    onFocus:    onFocusHandler,\n                    onBlur:     onBlurHandler\n                }));\n\n            }\n\n            if ( useGroup ) {\n                this.buttons = new $.ButtonGroup({\n                    buttons:            buttons,\n                    clickTimeThreshold: this.clickTimeThreshold,\n                    clickDistThreshold: this.clickDistThreshold\n                });\n\n                this.navControl  = this.buttons.element;\n                this.addHandler( \'open\', $.delegate( this, lightUp ) );\n\n                if( this.toolbar ){\n                    this.toolbar.addControl(\n                        this.navControl,\n                        {anchor: $.ControlAnchor.TOP_LEFT}\n                    );\n                } else {\n                    this.addControl(\n                        this.navControl,\n                        {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}\n                    );\n                }\n            }\n\n        }\n        return this;\n    },\n\n    /**\n     * Gets the active page of a sequence\n     * @function\n     * @return {Number}\n     */\n    currentPage: function() {\n        return this._sequenceIndex;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:page\n     */\n    goToPage: function( page ){\n        if( this.tileSources && page >= 0 && page < this.tileSources.length ){\n            /**\n             * Raised when the page is changed on a viewer configured with multiple image sources (see {@link OpenSeadragon.Viewer#goToPage}).\n             *\n             * @event page\n             * @memberof OpenSeadragon.Viewer\n             * @type {Object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n             * @property {Number} page - The page index.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent( \'page\', { page: page } );\n\n            this._sequenceIndex = page;\n\n            this._updateSequenceButtons( page );\n\n            this.open( this.tileSources[ page ] );\n\n            if( this.referenceStrip ){\n                this.referenceStrip.setFocus( page );\n            }\n        }\n\n        return this;\n    },\n\n   /**\n     * Adds an html element as an overlay to the current viewport.  Useful for\n     * highlighting words or areas of interest on an image or other zoomable\n     * interface. The overlays added via this method are removed when the viewport\n     * is closed which include when changing page.\n     * @method\n     * @param {Element|String|Object} element - A reference to an element or an id for\n     *      the element which will be overlayed. Or an Object specifying the configuration for the overlay.\n     *      If using an object, see {@link OpenSeadragon.Overlay} for a list of\n     *      all available options.\n     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or\n     *      rectangle which will be overlayed. This is a viewport relative location.\n     * @param {OpenSeadragon.Placement} placement - The position of the\n     *      viewport which the location coordinates will be treated as relative\n     *      to.\n     * @param {function} onDraw - If supplied the callback is called when the overlay\n     *      needs to be drawn. It it the responsibility of the callback to do any drawing/positioning.\n     *      It is passed position, size and element.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:add-overlay\n     */\n    addOverlay: function( element, location, placement, onDraw ) {\n        var options;\n        if( $.isPlainObject( element ) ){\n            options = element;\n        } else {\n            options = {\n                element: element,\n                location: location,\n                placement: placement,\n                onDraw: onDraw\n            };\n        }\n\n        element = $.getElement( options.element );\n\n        if ( getOverlayIndex( this.currentOverlays, element ) >= 0 ) {\n            // they\'re trying to add a duplicate overlay\n            return this;\n        }\n\n        var overlay = getOverlayObject( this, options);\n        this.currentOverlays.push(overlay);\n        overlay.drawHTML( this.overlaysContainer, this.viewport );\n\n        /**\n         * Raised when an overlay is added to the viewer (see {@link OpenSeadragon.Viewer#addOverlay}).\n         *\n         * @event add-overlay\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Element} element - The overlay element.\n         * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location\n         * @property {OpenSeadragon.Placement} placement\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'add-overlay\', {\n            element: element,\n            location: options.location,\n            placement: options.placement\n        });\n        return this;\n    },\n\n    /**\n     * Updates the overlay represented by the reference to the element or\n     * element id moving it to the new location, relative to the new placement.\n     * @method\n     * @param {Element|String} element - A reference to an element or an id for\n     *      the element which is overlayed.\n     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or\n     *      rectangle which will be overlayed. This is a viewport relative location.\n     * @param {OpenSeadragon.Placement} placement - The position of the\n     *      viewport which the location coordinates will be treated as relative\n     *      to.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:update-overlay\n     */\n    updateOverlay: function( element, location, placement ) {\n        var i;\n\n        element = $.getElement( element );\n        i = getOverlayIndex( this.currentOverlays, element );\n\n        if ( i >= 0 ) {\n            this.currentOverlays[ i ].update( location, placement );\n            THIS[ this.hash ].forceRedraw = true;\n            /**\n             * Raised when an overlay\'s location or placement changes\n             * (see {@link OpenSeadragon.Viewer#updateOverlay}).\n             *\n             * @event update-overlay\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the\n             * Viewer which raised the event.\n             * @property {Element} element\n             * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location\n             * @property {OpenSeadragon.Placement} placement\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent( \'update-overlay\', {\n                element: element,\n                location: location,\n                placement: placement\n            });\n        }\n        return this;\n    },\n\n    /**\n     * Removes an overlay identified by the reference element or element id\n     * and schedules an update.\n     * @method\n     * @param {Element|String} element - A reference to the element or an\n     *      element id which represent the ovelay content to be removed.\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:remove-overlay\n     */\n    removeOverlay: function( element ) {\n        var i;\n\n        element = $.getElement( element );\n        i = getOverlayIndex( this.currentOverlays, element );\n\n        if ( i >= 0 ) {\n            this.currentOverlays[ i ].destroy();\n            this.currentOverlays.splice( i, 1 );\n            THIS[ this.hash ].forceRedraw = true;\n            /**\n             * Raised when an overlay is removed from the viewer\n             * (see {@link OpenSeadragon.Viewer#removeOverlay}).\n             *\n             * @event remove-overlay\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the\n             * Viewer which raised the event.\n             * @property {Element} element - The overlay element.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent( \'remove-overlay\', {\n                element: element\n            });\n        }\n        return this;\n    },\n\n    /**\n     * Removes all currently configured Overlays from this Viewer and schedules\n     * an update.\n     * @method\n     * @return {OpenSeadragon.Viewer} Chainable.\n     * @fires OpenSeadragon.Viewer.event:clear-overlay\n     */\n    clearOverlays: function() {\n        while ( this.currentOverlays.length > 0 ) {\n            this.currentOverlays.pop().destroy();\n        }\n        THIS[ this.hash ].forceRedraw = true;\n        /**\n         * Raised when all overlays are removed from the viewer (see {@link OpenSeadragon.Drawer#clearOverlays}).\n         *\n         * @event clear-overlay\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'clear-overlay\', {} );\n        return this;\n    },\n\n     /**\n     * Finds an overlay identified by the reference element or element id\n     * and returns it as an object, return null if not found.\n     * @method\n     * @param {Element|String} element - A reference to the element or an\n     *      element id which represents the overlay content.\n     * @return {OpenSeadragon.Overlay} the matching overlay or null if none found.\n     */\n    getOverlayById: function( element ) {\n        var i;\n\n        element = $.getElement( element );\n        i = getOverlayIndex( this.currentOverlays, element );\n\n        if (i>=0) {\n            return this.currentOverlays[i];\n        } else {\n            return null;\n        }\n    },\n\n    /**\n     * Updates the sequence buttons.\n     * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons\n     * @private\n     * @param {Number} Sequence Value\n     */\n    _updateSequenceButtons: function( page ) {\n\n            if ( this.nextButton ) {\n                if(!this.tileSources || this.tileSources.length - 1 === page) {\n                    //Disable next button\n                    if ( !this.navPrevNextWrap ) {\n                        this.nextButton.disable();\n                    }\n                } else {\n                    this.nextButton.enable();\n                }\n            }\n            if ( this.previousButton ) {\n                if ( page > 0 ) {\n                    //Enable previous button\n                    this.previousButton.enable();\n                } else {\n                    if ( !this.navPrevNextWrap ) {\n                        this.previousButton.disable();\n                    }\n                }\n            }\n      },\n\n    /**\n     * Display a message in the viewport\n     * @function OpenSeadragon.Viewer.prototype._showMessage\n     * @private\n     * @param {String} text message\n     */\n    _showMessage: function ( message ) {\n        this._hideMessage();\n\n        var div = $.makeNeutralElement( "div" );\n        div.appendChild( document.createTextNode( message ) );\n\n        this.messageDiv = $.makeCenteredNode( div );\n\n        $.addClass(this.messageDiv, "openseadragon-message");\n\n        this.container.appendChild( this.messageDiv );\n    },\n\n    /**\n     * Hide any currently displayed viewport message\n     * @function OpenSeadragon.Viewer.prototype._hideMessage\n     * @private\n     */\n    _hideMessage: function () {\n        var div = this.messageDiv;\n        if (div) {\n            div.parentNode.removeChild(div);\n            delete this.messageDiv;\n        }\n    },\n\n    /**\n     * Gets this viewer\'s gesture settings for the given pointer device type.\n     * @method\n     * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).\n     * @return {OpenSeadragon.GestureSettings}\n     */\n    gestureSettingsByDeviceType: function ( type ) {\n        switch ( type ) {\n            case \'mouse\':\n                return this.gestureSettingsMouse;\n            case \'touch\':\n                return this.gestureSettingsTouch;\n            case \'pen\':\n                return this.gestureSettingsPen;\n            default:\n                return this.gestureSettingsUnknown;\n        }\n    },\n\n    // private\n    _drawOverlays: function() {\n        var i,\n            length = this.currentOverlays.length;\n        for ( i = 0; i < length; i++ ) {\n            this.currentOverlays[ i ].drawHTML( this.overlaysContainer, this.viewport );\n        }\n    },\n\n    /**\n     * Cancel the "in flight" images.\n     */\n    _cancelPendingImages: function() {\n        this._loadQueue = [];\n    }\n});\n\n\n/**\n * _getSafeElemSize is like getElementSize(), but refuses to return 0 for x or y,\n * which was causing some calling operations to return NaN.\n * @returns {Point}\n * @private\n */\nfunction _getSafeElemSize (oElement) {\n    oElement = $.getElement( oElement );\n\n    return new $.Point(\n        (oElement.clientWidth === 0 ? 1 : oElement.clientWidth),\n        (oElement.clientHeight === 0 ? 1 : oElement.clientHeight)\n    );\n}\n\n/**\n * @function\n * @private\n */\nfunction getTileSourceImplementation( viewer, tileSource, successCallback,\n    failCallback ) {\n    var _this = viewer;\n\n    //allow plain xml strings or json strings to be parsed here\n    if ( $.type( tileSource ) == \'string\' ) {\n        if ( tileSource.match( /\\s*<.*/ ) ) {\n            tileSource = $.parseXml( tileSource );\n        } else if ( tileSource.match( /\\s*[\\{\\[].*/ ) ) {\n            tileSource = $.parseJSON(tileSource);\n        }\n    }\n\n    function waitUntilReady(tileSource, originalTileSource) {\n        if (tileSource.ready) {\n            successCallback(tileSource);\n        } else {\n            tileSource.addHandler(\'ready\', function () {\n                successCallback(tileSource);\n            });\n            tileSource.addHandler(\'open-failed\', function (event) {\n                failCallback({\n                    message: event.message,\n                    source: originalTileSource\n                });\n            });\n        }\n    }\n\n    setTimeout( function() {\n        if ( $.type( tileSource ) == \'string\' ) {\n            //If its still a string it means it must be a url at this point\n            tileSource = new $.TileSource({\n                url: tileSource,\n                crossOriginPolicy: viewer.crossOriginPolicy,\n                ajaxWithCredentials: viewer.ajaxWithCredentials,\n                useCanvas: viewer.useCanvas,\n                success: function( event ) {\n                    successCallback( event.tileSource );\n                }\n            });\n            tileSource.addHandler( \'open-failed\', function( event ) {\n                failCallback( event );\n            } );\n\n        } else if ($.isPlainObject(tileSource) || tileSource.nodeType) {\n            if (!tileSource.crossOriginPolicy && viewer.crossOriginPolicy) {\n                tileSource.crossOriginPolicy = viewer.crossOriginPolicy;\n            }\n            if (tileSource.ajaxWithCredentials === undefined) {\n                tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;\n            }\n            if (tileSource.useCanvas === undefined) {\n                tileSource.useCanvas = viewer.useCanvas;\n            }\n\n            if ( $.isFunction( tileSource.getTileUrl ) ) {\n                //Custom tile source\n                var customTileSource = new $.TileSource( tileSource );\n                customTileSource.getTileUrl = tileSource.getTileUrl;\n                successCallback( customTileSource );\n            } else {\n                //inline configuration\n                var $TileSource = $.TileSource.determineType( _this, tileSource );\n                if ( !$TileSource ) {\n                    failCallback( {\n                        message: "Unable to load TileSource",\n                        source: tileSource\n                    });\n                    return;\n                }\n                var options = $TileSource.prototype.configure.apply( _this, [ tileSource ] );\n                waitUntilReady(new $TileSource(options), tileSource);\n            }\n        } else {\n            //can assume it\'s already a tile source implementation\n            waitUntilReady(tileSource, tileSource);\n        }\n    });\n}\n\nfunction getOverlayObject( viewer, overlay ) {\n    if ( overlay instanceof $.Overlay ) {\n        return overlay;\n    }\n\n    var element = null;\n    if ( overlay.element ) {\n        element = $.getElement( overlay.element );\n    } else {\n        var id = overlay.id ?\n            overlay.id :\n            "openseadragon-overlay-" + Math.floor( Math.random() * 10000000 );\n\n        element = $.getElement( overlay.id );\n        if ( !element ) {\n            element         = document.createElement( "a" );\n            element.href    = "#/overlay/" + id;\n        }\n        element.id = id;\n        $.addClass( element, overlay.className ?\n            overlay.className :\n            "openseadragon-overlay"\n        );\n    }\n\n    var location = overlay.location;\n    var width = overlay.width;\n    var height = overlay.height;\n    if (!location) {\n        var x = overlay.x;\n        var y = overlay.y;\n        if (overlay.px !== undefined) {\n            var rect = viewer.viewport.imageToViewportRectangle(new $.Rect(\n                overlay.px,\n                overlay.py,\n                width || 0,\n                height || 0));\n            x = rect.x;\n            y = rect.y;\n            width = width !== undefined ? rect.width : undefined;\n            height = height !== undefined ? rect.height : undefined;\n        }\n        location = new $.Point(x, y);\n    }\n\n    var placement = overlay.placement;\n    if (placement && $.type(placement) === "string") {\n        placement = $.Placement[overlay.placement.toUpperCase()];\n    }\n\n    return new $.Overlay({\n        element: element,\n        location: location,\n        placement: placement,\n        onDraw: overlay.onDraw,\n        checkResize: overlay.checkResize,\n        width: width,\n        height: height,\n        rotationMode: overlay.rotationMode\n    });\n}\n\n/**\n * @private\n * @inner\n * Determines the index of the given overlay in the given overlays array.\n */\nfunction getOverlayIndex( overlays, element ) {\n    var i;\n    for ( i = overlays.length - 1; i >= 0; i-- ) {\n        if ( overlays[ i ].element === element ) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Schedulers provide the general engine for animation\n///////////////////////////////////////////////////////////////////////////////\nfunction scheduleUpdate( viewer, updateFunc ){\n    return $.requestAnimationFrame( function(){\n        updateFunc( viewer );\n    } );\n}\n\n\n//provides a sequence in the fade animation\nfunction scheduleControlsFade( viewer ) {\n    $.requestAnimationFrame( function(){\n        updateControlsFade( viewer );\n    });\n}\n\n\n//initiates an animation to hide the controls\nfunction beginControlsAutoHide( viewer ) {\n    if ( !viewer.autoHideControls ) {\n        return;\n    }\n    viewer.controlsShouldFade = true;\n    viewer.controlsFadeBeginTime =\n        $.now() +\n        viewer.controlsFadeDelay;\n\n    window.setTimeout( function(){\n        scheduleControlsFade( viewer );\n    }, viewer.controlsFadeDelay );\n}\n\n\n//determines if fade animation is done or continues the animation\nfunction updateControlsFade( viewer ) {\n    var currentTime,\n        deltaTime,\n        opacity,\n        i;\n    if ( viewer.controlsShouldFade ) {\n        currentTime = $.now();\n        deltaTime = currentTime - viewer.controlsFadeBeginTime;\n        opacity = 1.0 - deltaTime / viewer.controlsFadeLength;\n\n        opacity = Math.min( 1.0, opacity );\n        opacity = Math.max( 0.0, opacity );\n\n        for ( i = viewer.controls.length - 1; i >= 0; i--) {\n            if (viewer.controls[ i ].autoFade) {\n                viewer.controls[ i ].setOpacity( opacity );\n            }\n        }\n\n        if ( opacity > 0 ) {\n            // fade again\n            scheduleControlsFade( viewer );\n        }\n    }\n}\n\n\n//stop the fade animation on the controls and show them\nfunction abortControlsAutoHide( viewer ) {\n    var i;\n    viewer.controlsShouldFade = false;\n    for ( i = viewer.controls.length - 1; i >= 0; i-- ) {\n        viewer.controls[ i ].setOpacity( 1.0 );\n    }\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Default view event handlers.\n///////////////////////////////////////////////////////////////////////////////\nfunction onFocus(){\n    abortControlsAutoHide( this );\n}\n\nfunction onBlur(){\n    beginControlsAutoHide( this );\n\n}\n\nfunction onCanvasKeyDown( event ) {\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch( event.keyCode ){\n            case 38://up arrow\n                if ( event.shift ) {\n                    this.viewport.zoomBy(1.1);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 40://down arrow\n                if ( event.shift ) {\n                    this.viewport.zoomBy(0.9);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 37://left arrow\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            case 39://right arrow\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\nfunction onCanvasKeyPress( event ) {\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch( event.keyCode ){\n            case 43://=|+\n            case 61://=|+\n                this.viewport.zoomBy(1.1);\n                this.viewport.applyConstraints();\n                return false;\n            case 45://-|_\n                this.viewport.zoomBy(0.9);\n                this.viewport.applyConstraints();\n                return false;\n            case 48://0|)\n                this.viewport.goHome();\n                this.viewport.applyConstraints();\n                return false;\n            case 119://w\n            case 87://W\n                if ( event.shift ) {\n                    this.viewport.zoomBy(1.1);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 115://s\n            case 83://S\n                if ( event.shift ) {\n                    this.viewport.zoomBy(0.9);\n                } else {\n                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));\n                }\n                this.viewport.applyConstraints();\n                return false;\n            case 97://a\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            case 100://d\n                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));\n                this.viewport.applyConstraints();\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\nfunction onCanvasClick( event ) {\n    var gestureSettings;\n\n    var haveKeyboardFocus = document.activeElement == this.canvas;\n\n    // If we don\'t have keyboard focus, request it.\n    if ( !haveKeyboardFocus ) {\n        this.canvas.focus();\n    }\n\n    if ( !event.preventDefaultAction && this.viewport && event.quick ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if ( gestureSettings.clickToZoom ) {\n            this.viewport.zoomBy(\n                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,\n                this.viewport.pointFromPixel( event.position, true )\n            );\n            this.viewport.applyConstraints();\n        }\n    }\n    /**\n     * Raised when a mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-click\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-click\', {\n        tracker: event.eventSource,\n        position: event.position,\n        quick: event.quick,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasDblClick( event ) {\n    var gestureSettings;\n\n    if ( !event.preventDefaultAction && this.viewport ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if ( gestureSettings.dblClickToZoom ) {\n            this.viewport.zoomBy(\n                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,\n                this.viewport.pointFromPixel( event.position, true )\n            );\n            this.viewport.applyConstraints();\n        }\n    }\n    /**\n     * Raised when a double mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-double-click\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-double-click\', {\n        tracker: event.eventSource,\n        position: event.position,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasDrag( event ) {\n    var gestureSettings;\n\n    if ( !event.preventDefaultAction && this.viewport ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if( !this.panHorizontal ){\n            event.delta.x = 0;\n        }\n        if( !this.panVertical ){\n            event.delta.y = 0;\n        }\n        this.viewport.panBy( this.viewport.deltaPointsFromPixels( event.delta.negate() ), gestureSettings.flickEnabled );\n        if( this.constrainDuringPan ){\n            this.viewport.applyConstraints();\n        }\n    }\n    /**\n     * Raised when a mouse or touch drag operation occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-drag\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.\n     * @property {Number} speed - Current computed speed, in pixels per second.\n     * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-drag\', {\n        tracker: event.eventSource,\n        position: event.position,\n        delta: event.delta,\n        speed: event.speed,\n        direction: event.direction,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasDragEnd( event ) {\n    if (!event.preventDefaultAction && this.viewport) {\n        var gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);\n        if (gestureSettings.flickEnabled &&\n            event.speed >= gestureSettings.flickMinSpeed) {\n            var amplitudeX = 0;\n            if (this.panHorizontal) {\n                amplitudeX = gestureSettings.flickMomentum * event.speed *\n                    Math.cos(event.direction);\n            }\n            var amplitudeY = 0;\n            if (this.panVertical) {\n                amplitudeY = gestureSettings.flickMomentum * event.speed *\n                    Math.sin(event.direction);\n            }\n            var center = this.viewport.pixelFromPoint(\n                this.viewport.getCenter(true));\n            var target = this.viewport.pointFromPixel(\n                new $.Point(center.x - amplitudeX, center.y - amplitudeY));\n            this.viewport.panTo(target, false);\n        }\n        this.viewport.applyConstraints();\n    }\n    /**\n     * Raised when a mouse or touch drag operation ends on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-drag-end\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} speed - Speed at the end of a drag gesture, in pixels per second.\n     * @property {Number} direction - Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent(\'canvas-drag-end\', {\n        tracker: event.eventSource,\n        position: event.position,\n        speed: event.speed,\n        direction: event.direction,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasEnter( event ) {\n    /**\n     * Raised when a pointer enters the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-enter\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-enter\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasExit( event ) {\n    /**\n     * Raised when a pointer leaves the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-exit\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-exit\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasPress( event ) {\n    /**\n     * Raised when the primary mouse button is pressed or touch starts on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-press\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-press\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        insideElementPressed: event.insideElementPressed,\n        insideElementReleased: event.insideElementReleased,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasRelease( event ) {\n    /**\n     * Raised when the primary mouse button is released or touch ends on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-release\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-release\', {\n        tracker: event.eventSource,\n        pointerType: event.pointerType,\n        position: event.position,\n        insideElementPressed: event.insideElementPressed,\n        insideElementReleased: event.insideElementReleased,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasNonPrimaryPress( event ) {\n    /**\n     * Raised when any non-primary pointer button is pressed on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-nonprimary-press\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {Number} button - Button which caused the event.\n     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     * @property {Number} buttons - Current buttons pressed.\n     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-nonprimary-press\', {\n        tracker: event.eventSource,\n        position: event.position,\n        pointerType: event.pointerType,\n        button: event.button,\n        buttons: event.buttons,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasNonPrimaryRelease( event ) {\n    /**\n     * Raised when any non-primary pointer button is released on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-nonprimary-release\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {String} pointerType - "mouse", "touch", "pen", etc.\n     * @property {Number} button - Button which caused the event.\n     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.\n     * @property {Number} buttons - Current buttons pressed.\n     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'canvas-nonprimary-release\', {\n        tracker: event.eventSource,\n        position: event.position,\n        pointerType: event.pointerType,\n        button: event.button,\n        buttons: event.buttons,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onCanvasPinch( event ) {\n    var gestureSettings,\n        centerPt,\n        lastCenterPt,\n        panByPt;\n\n    if ( !event.preventDefaultAction && this.viewport ) {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if ( gestureSettings.pinchToZoom ) {\n            centerPt = this.viewport.pointFromPixel( event.center, true );\n            lastCenterPt = this.viewport.pointFromPixel( event.lastCenter, true );\n            panByPt = lastCenterPt.minus( centerPt );\n            if( !this.panHorizontal ) {\n                panByPt.x = 0;\n            }\n            if( !this.panVertical ) {\n                panByPt.y = 0;\n            }\n            this.viewport.zoomBy( event.distance / event.lastDistance, centerPt, true );\n            this.viewport.panBy( panByPt, true );\n            this.viewport.applyConstraints();\n        }\n        if ( gestureSettings.pinchRotate ) {\n            // Pinch rotate\n            var angle1 = Math.atan2(event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,\n                event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x);\n            var angle2 = Math.atan2(event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,\n                event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x);\n            this.viewport.setRotation(this.viewport.getRotation() + ((angle1 - angle2) * (180 / Math.PI)));\n        }\n    }\n    /**\n     * Raised when a pinch event occurs on the {@link OpenSeadragon.Viewer#canvas} element.\n     *\n     * @event canvas-pinch\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gesturePoints - Gesture points associated with the gesture. Velocity data can be found here.\n     * @property {OpenSeadragon.Point} lastCenter - The previous center point of the two pinch contact points relative to the tracked element.\n     * @property {OpenSeadragon.Point} center - The center point of the two pinch contact points relative to the tracked element.\n     * @property {Number} lastDistance - The previous distance between the two pinch contact points in CSS pixels.\n     * @property {Number} distance - The distance between the two pinch contact points in CSS pixels.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent(\'canvas-pinch\', {\n        tracker: event.eventSource,\n        gesturePoints: event.gesturePoints,\n        lastCenter: event.lastCenter,\n        center: event.center,\n        lastDistance: event.lastDistance,\n        distance: event.distance,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n    //cancels event\n    return false;\n}\n\nfunction onCanvasScroll( event ) {\n    var gestureSettings,\n        factor,\n        thisScrollTime,\n        deltaScrollTime;\n\n    /* Certain scroll devices fire the scroll event way too fast so we are injecting a simple adjustment to keep things\n     * partially normalized. If we have already fired an event within the last \'minScrollDelta\' milliseconds we skip\n     * this one and wait for the next event. */\n    thisScrollTime = $.now();\n    deltaScrollTime = thisScrollTime - this._lastScrollTime;\n    if (deltaScrollTime > this.minScrollDeltaTime) {\n        this._lastScrollTime = thisScrollTime;\n\n        if ( !event.preventDefaultAction && this.viewport ) {\n            gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n            if ( gestureSettings.scrollToZoom ) {\n                factor = Math.pow( this.zoomPerScroll, event.scroll );\n                this.viewport.zoomBy(\n                    factor,\n                    this.viewport.pointFromPixel( event.position, true )\n                );\n                this.viewport.applyConstraints();\n            }\n        }\n        /**\n         * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#canvas} element (mouse wheel).\n         *\n         * @event canvas-scroll\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n         * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n         * @property {Number} scroll - The scroll delta for the event.\n         * @property {Boolean} shift - True if the shift key was pressed during this event.\n         * @property {Object} originalEvent - The original DOM event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'canvas-scroll\', {\n            tracker: event.eventSource,\n            position: event.position,\n            scroll: event.scroll,\n            shift: event.shift,\n            originalEvent: event.originalEvent\n        });\n        if (gestureSettings && gestureSettings.scrollToZoom) {\n            //cancels event\n            return false;\n        }\n    }\n    else {\n        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );\n        if (gestureSettings && gestureSettings.scrollToZoom) {\n            return false;   // We are swallowing this event\n        }\n    }\n}\n\nfunction onContainerEnter( event ) {\n    THIS[ this.hash ].mouseInside = true;\n    abortControlsAutoHide( this );\n    /**\n     * Raised when the cursor enters the {@link OpenSeadragon.Viewer#container} element.\n     *\n     * @event container-enter\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'container-enter\', {\n        tracker: event.eventSource,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\nfunction onContainerExit( event ) {\n    if ( event.pointers < 1 ) {\n        THIS[ this.hash ].mouseInside = false;\n        if ( !THIS[ this.hash ].animating ) {\n            beginControlsAutoHide( this );\n        }\n    }\n    /**\n     * Raised when the cursor leaves the {@link OpenSeadragon.Viewer#container} element.\n     *\n     * @event container-exit\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.\n     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.\n     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.\n     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.raiseEvent( \'container-exit\', {\n        tracker: event.eventSource,\n        position: event.position,\n        buttons: event.buttons,\n        pointers: event.pointers,\n        insideElementPressed: event.insideElementPressed,\n        buttonDownAny: event.buttonDownAny,\n        originalEvent: event.originalEvent\n    });\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Page update routines ( aka Views - for future reference )\n///////////////////////////////////////////////////////////////////////////////\n\nfunction updateMulti( viewer ) {\n    updateOnce( viewer );\n\n    // Request the next frame, unless we\'ve been closed\n    if ( viewer.isOpen() ) {\n        viewer._updateRequestId = scheduleUpdate( viewer, updateMulti );\n    } else {\n        viewer._updateRequestId = false;\n    }\n}\n\nfunction updateOnce( viewer ) {\n\n    //viewer.profiler.beginUpdate();\n\n    if (viewer._opening) {\n        return;\n    }\n\n    if (viewer.autoResize) {\n        var containerSize = _getSafeElemSize(viewer.container);\n        var prevContainerSize = THIS[viewer.hash].prevContainerSize;\n        if (!containerSize.equals(prevContainerSize)) {\n            var viewport = viewer.viewport;\n            if (viewer.preserveImageSizeOnResize) {\n                var resizeRatio = prevContainerSize.x / containerSize.x;\n                var zoom = viewport.getZoom() * resizeRatio;\n                var center = viewport.getCenter();\n                viewport.resize(containerSize, false);\n                viewport.zoomTo(zoom, null, true);\n                viewport.panTo(center, true);\n            } else {\n                // maintain image position\n                var oldBounds = viewport.getBounds();\n                viewport.resize(containerSize, true);\n                viewport.fitBoundsWithConstraints(oldBounds, true);\n            }\n            THIS[viewer.hash].prevContainerSize = containerSize;\n            THIS[viewer.hash].forceRedraw = true;\n        }\n    }\n\n    var viewportChange = viewer.viewport.update();\n    var animated = viewer.world.update() || viewportChange;\n\n    if (viewportChange) {\n        /**\n         * Raised when any spring animation update occurs (zoom, pan, etc.),\n         * before the viewer has drawn the new location.\n         *\n         * @event viewport-change\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        viewer.raiseEvent(\'viewport-change\');\n    }\n\n    if( viewer.referenceStrip ){\n        animated = viewer.referenceStrip.update( viewer.viewport ) || animated;\n    }\n\n    if ( !THIS[ viewer.hash ].animating && animated ) {\n        /**\n         * Raised when any spring animation starts (zoom, pan, etc.).\n         *\n         * @event animation-start\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        viewer.raiseEvent( "animation-start" );\n        abortControlsAutoHide( viewer );\n    }\n\n    if ( animated || THIS[ viewer.hash ].forceRedraw || viewer.world.needsDraw() ) {\n        drawWorld( viewer );\n        viewer._drawOverlays();\n        if( viewer.navigator ){\n            viewer.navigator.update( viewer.viewport );\n        }\n\n        THIS[ viewer.hash ].forceRedraw = false;\n\n        if (animated) {\n            /**\n             * Raised when any spring animation update occurs (zoom, pan, etc.),\n             * after the viewer has drawn the new location.\n             *\n             * @event animation\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            viewer.raiseEvent( "animation" );\n        }\n    }\n\n    if ( THIS[ viewer.hash ].animating && !animated ) {\n        /**\n         * Raised when any spring animation ends (zoom, pan, etc.).\n         *\n         * @event animation-finish\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        viewer.raiseEvent( "animation-finish" );\n\n        if ( !THIS[ viewer.hash ].mouseInside ) {\n            beginControlsAutoHide( viewer );\n        }\n    }\n\n    THIS[ viewer.hash ].animating = animated;\n\n    //viewer.profiler.endUpdate();\n}\n\nfunction drawWorld( viewer ) {\n    viewer.imageLoader.clear();\n    viewer.drawer.clear();\n    viewer.world.draw();\n\n    /**\n     * <em>- Needs documentation -</em>\n     *\n     * @event update-viewport\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    viewer.raiseEvent( \'update-viewport\', {} );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Navigation Controls\n///////////////////////////////////////////////////////////////////////////////\nfunction resolveUrl( prefix, url ) {\n    return prefix ? prefix + url : url;\n}\n\n\n\nfunction beginZoomingIn() {\n    THIS[ this.hash ].lastZoomTime = $.now();\n    THIS[ this.hash ].zoomFactor = this.zoomPerSecond;\n    THIS[ this.hash ].zooming = true;\n    scheduleZoom( this );\n}\n\n\nfunction beginZoomingOut() {\n    THIS[ this.hash ].lastZoomTime = $.now();\n    THIS[ this.hash ].zoomFactor = 1.0 / this.zoomPerSecond;\n    THIS[ this.hash ].zooming = true;\n    scheduleZoom( this );\n}\n\n\nfunction endZooming() {\n    THIS[ this.hash ].zooming = false;\n}\n\n\nfunction scheduleZoom( viewer ) {\n    $.requestAnimationFrame( $.delegate( viewer, doZoom ) );\n}\n\n\nfunction doZoom() {\n    var currentTime,\n        deltaTime,\n        adjustedFactor;\n\n    if ( THIS[ this.hash ].zooming && this.viewport) {\n        currentTime     = $.now();\n        deltaTime       = currentTime - THIS[ this.hash ].lastZoomTime;\n        adjustedFactor  = Math.pow( THIS[ this.hash ].zoomFactor, deltaTime / 1000 );\n\n        this.viewport.zoomBy( adjustedFactor );\n        this.viewport.applyConstraints();\n        THIS[ this.hash ].lastZoomTime = currentTime;\n        scheduleZoom( this );\n    }\n}\n\n\nfunction doSingleZoomIn() {\n    if ( this.viewport ) {\n        THIS[ this.hash ].zooming = false;\n        this.viewport.zoomBy(\n            this.zoomPerClick / 1.0\n        );\n        this.viewport.applyConstraints();\n    }\n}\n\n\nfunction doSingleZoomOut() {\n    if ( this.viewport ) {\n        THIS[ this.hash ].zooming = false;\n        this.viewport.zoomBy(\n            1.0 / this.zoomPerClick\n        );\n        this.viewport.applyConstraints();\n    }\n}\n\n\nfunction lightUp() {\n    this.buttons.emulateEnter();\n    this.buttons.emulateExit();\n}\n\n\nfunction onHome() {\n    if ( this.viewport ) {\n        this.viewport.goHome();\n    }\n}\n\n\nfunction onFullScreen() {\n    if ( this.isFullPage() && !$.isFullScreen() ) {\n        // Is fullPage but not fullScreen\n        this.setFullPage( false );\n    } else {\n        this.setFullScreen( !this.isFullPage() );\n    }\n    // correct for no mouseout event on change\n    if ( this.buttons ) {\n        this.buttons.emulateExit();\n    }\n    this.fullPageButton.element.focus();\n    if ( this.viewport ) {\n        this.viewport.applyConstraints();\n    }\n}\n\n/**\n * Note: The current rotation feature is limited to 90 degree turns.\n */\nfunction onRotateLeft() {\n    if ( this.viewport ) {\n        var currRotation = this.viewport.getRotation();\n        if (currRotation === 0) {\n            currRotation = 270;\n        }\n        else {\n            currRotation -= 90;\n        }\n        this.viewport.setRotation(currRotation);\n    }\n}\n\n/**\n * Note: The current rotation feature is limited to 90 degree turns.\n */\nfunction onRotateRight() {\n    if ( this.viewport ) {\n        var currRotation = this.viewport.getRotation();\n        if (currRotation === 270) {\n            currRotation = 0;\n        }\n        else {\n            currRotation += 90;\n        }\n        this.viewport.setRotation(currRotation);\n    }\n}\n\n\nfunction onPrevious(){\n    var previous = this._sequenceIndex - 1;\n    if(this.navPrevNextWrap && previous < 0){\n        previous += this.tileSources.length;\n    }\n    this.goToPage( previous );\n}\n\n\nfunction onNext(){\n    var next = this._sequenceIndex + 1;\n    if(this.navPrevNextWrap && next >= this.tileSources.length){\n        next = 0;\n    }\n    this.goToPage( next );\n}\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Navigator\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Navigator\n * @classdesc The Navigator provides a small view of the current image as fixed\n * while representing the viewport as a moving box serving as a frame\n * of reference in the larger viewport as to which portion of the image\n * is currently being examined.  The navigator\'s viewport can be interacted\n * with using the keyboard or the mouse.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.Viewer\n * @extends OpenSeadragon.EventSource\n * @param {Object} options\n */\n$.Navigator = function( options ){\n\n    var viewer      = options.viewer,\n        _this = this,\n        viewerSize,\n        navigatorSize;\n\n    //We may need to create a new element and id if they did not\n    //provide the id for the existing element\n    if( !options.id ){\n        options.id              = \'navigator-\' + $.now();\n        this.element            = $.makeNeutralElement( "div" );\n        options.controlOptions  = {\n            anchor:           $.ControlAnchor.TOP_RIGHT,\n            attachToViewer:   true,\n            autoFade:         options.autoFade\n        };\n\n        if( options.position ){\n            if( \'BOTTOM_RIGHT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;\n            } else if( \'BOTTOM_LEFT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;\n            } else if( \'TOP_RIGHT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;\n            } else if( \'TOP_LEFT\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;\n            } else if( \'ABSOLUTE\' == options.position ){\n               options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;\n               options.controlOptions.top = options.top;\n               options.controlOptions.left = options.left;\n               options.controlOptions.height = options.height;\n               options.controlOptions.width = options.width;\n            }\n        }\n\n    } else {\n        this.element            = document.getElementById( options.id );\n        options.controlOptions  = {\n            anchor:           $.ControlAnchor.NONE,\n            attachToViewer:   false,\n            autoFade:         false\n        };\n    }\n    this.element.id         = options.id;\n    this.element.className  += \' navigator\';\n\n    options = $.extend( true, {\n        sizeRatio:     $.DEFAULT_SETTINGS.navigatorSizeRatio\n    }, options, {\n        element:                this.element,\n        tabIndex:               -1, // No keyboard navigation, omit from tab order\n        //These need to be overridden to prevent recursion since\n        //the navigator is a viewer and a viewer has a navigator\n        showNavigator:          false,\n        mouseNavEnabled:        false,\n        showNavigationControl:  false,\n        showSequenceControl:    false,\n        immediateRender:        true,\n        blendTime:              0,\n        animationTime:          0,\n        autoResize:             options.autoResize,\n        // prevent resizing the navigator from adding unwanted space around the image\n        minZoomImageRatio:      1.0\n    });\n\n    options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;\n\n    $.setElementTouchActionNone( this.element );\n\n    this.borderWidth = 2;\n    //At some browser magnification levels the display regions lines up correctly, but at some there appears to\n    //be a one pixel gap.\n    this.fudge = new $.Point(1, 1);\n    this.totalBorderWidths = new $.Point(this.borderWidth*2, this.borderWidth*2).minus(this.fudge);\n\n\n    if ( options.controlOptions.anchor != $.ControlAnchor.NONE ) {\n        (function( style, borderWidth ){\n            style.margin        = \'0px\';\n            style.border        = borderWidth + \'px solid #555\';\n            style.padding       = \'0px\';\n            style.background    = \'#000\';\n            style.opacity       = 0.8;\n            style.overflow      = \'hidden\';\n        }( this.element.style, this.borderWidth));\n    }\n\n    this.displayRegion           = $.makeNeutralElement( "div" );\n    this.displayRegion.id        = this.element.id + \'-displayregion\';\n    this.displayRegion.className = \'displayregion\';\n\n    (function( style, borderWidth ){\n        style.position      = \'relative\';\n        style.top           = \'0px\';\n        style.left          = \'0px\';\n        style.fontSize      = \'0px\';\n        style.overflow      = \'hidden\';\n        style.border        = borderWidth + \'px solid #900\';\n        style.margin        = \'0px\';\n        style.padding       = \'0px\';\n        //TODO: IE doesnt like this property being set\n        //try{ style.outline  = \'2px auto #909\'; }catch(e){/*ignore*/}\n\n        style.background    = \'transparent\';\n\n        // We use square bracket notation on the statement below, because float is a keyword.\n        // This is important for the Google Closure compiler, if nothing else.\n        /*jshint sub:true */\n        style[\'float\']      = \'left\'; //Webkit\n\n        style.cssFloat      = \'left\'; //Firefox\n        style.styleFloat    = \'left\'; //IE\n        style.zIndex        = 999999999;\n        style.cursor        = \'default\';\n    }( this.displayRegion.style, this.borderWidth ));\n\n    this.displayRegionContainer = $.makeNeutralElement("div");\n    this.displayRegionContainer.id = this.element.id + \'-displayregioncontainer\';\n    this.displayRegionContainer.className = "displayregioncontainer";\n    this.displayRegionContainer.style.width = "100%";\n    this.displayRegionContainer.style.height = "100%";\n\n    viewer.addControl(\n        this.element,\n        options.controlOptions\n    );\n\n    this._resizeWithViewer = options.controlOptions.anchor != $.ControlAnchor.ABSOLUTE &&\n        options.controlOptions.anchor != $.ControlAnchor.NONE;\n\n    if ( this._resizeWithViewer ) {\n        if ( options.width && options.height ) {\n            this.element.style.height = typeof ( options.height )  == "number" ? ( options.height + \'px\' ) : options.height;\n            this.element.style.width  = typeof ( options.width )  == "number" ? ( options.width + \'px\' ) : options.width;\n        } else {\n            viewerSize = $.getElementSize( viewer.element );\n            this.element.style.height = Math.round( viewerSize.y * options.sizeRatio ) + \'px\';\n            this.element.style.width  = Math.round( viewerSize.x * options.sizeRatio ) + \'px\';\n            this.oldViewerSize = viewerSize;\n        }\n        navigatorSize = $.getElementSize( this.element );\n        this.elementArea = navigatorSize.x * navigatorSize.y;\n    }\n\n    this.oldContainerSize = new $.Point( 0, 0 );\n\n    $.Viewer.apply( this, [ options ] );\n\n    this.displayRegionContainer.appendChild(this.displayRegion);\n    this.element.getElementsByTagName(\'div\')[0].appendChild(this.displayRegionContainer);\n\n    function rotate(degrees) {\n        _setTransformRotate(_this.displayRegionContainer, degrees);\n        _setTransformRotate(_this.displayRegion, -degrees);\n        _this.viewport.setRotation(degrees);\n    }\n    if (options.navigatorRotate) {\n        var degrees = options.viewer.viewport ?\n            options.viewer.viewport.getRotation() :\n            options.viewer.degrees || 0;\n        rotate(degrees);\n        options.viewer.addHandler("rotate", function (args) {\n            rotate(args.degrees);\n        });\n    }\n\n    // Remove the base class\' (Viewer\'s) innerTracker and replace it with our own\n    this.innerTracker.destroy();\n    this.innerTracker = new $.MouseTracker({\n        element:         this.element,\n        dragHandler:     $.delegate( this, onCanvasDrag ),\n        clickHandler:    $.delegate( this, onCanvasClick ),\n        releaseHandler:  $.delegate( this, onCanvasRelease ),\n        scrollHandler:   $.delegate( this, onCanvasScroll )\n    });\n\n    this.addHandler("reset-size", function() {\n        if (_this.viewport) {\n            _this.viewport.goHome(true);\n        }\n    });\n\n    viewer.world.addHandler("item-index-change", function(event) {\n        var item = _this.world.getItemAt(event.previousIndex);\n        _this.world.setItemIndex(item, event.newIndex);\n    });\n\n    viewer.world.addHandler("remove-item", function(event) {\n        var theirItem = event.item;\n        var myItem = _this._getMatchingItem(theirItem);\n        if (myItem) {\n            _this.world.removeItem(myItem);\n        }\n    });\n\n    this.update(viewer.viewport);\n};\n\n$.extend( $.Navigator.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.Navigator.prototype */{\n\n    /**\n     * Used to notify the navigator when its size has changed.\n     * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.\n     * @function\n     */\n    updateSize: function () {\n        if ( this.viewport ) {\n            var containerSize = new $.Point(\n                    (this.container.clientWidth === 0 ? 1 : this.container.clientWidth),\n                    (this.container.clientHeight === 0 ? 1 : this.container.clientHeight)\n                );\n\n            if ( !containerSize.equals( this.oldContainerSize ) ) {\n                this.viewport.resize( containerSize, true );\n                this.viewport.goHome(true);\n                this.oldContainerSize = containerSize;\n                this.drawer.clear();\n                this.world.draw();\n            }\n        }\n    },\n\n    /**\n     * Used to update the navigator minimap\'s viewport rectangle when a change in the viewer\'s viewport occurs.\n     * @function\n     * @param {OpenSeadragon.Viewport} The viewport this navigator is tracking.\n     */\n    update: function( viewport ) {\n\n        var viewerSize,\n            newWidth,\n            newHeight,\n            bounds,\n            topleft,\n            bottomright;\n\n        viewerSize = $.getElementSize( this.viewer.element );\n        if ( this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals( this.oldViewerSize ) ) {\n            this.oldViewerSize = viewerSize;\n\n            if ( this.maintainSizeRatio || !this.elementArea) {\n                newWidth  = viewerSize.x * this.sizeRatio;\n                newHeight = viewerSize.y * this.sizeRatio;\n            } else {\n                newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));\n                newHeight = this.elementArea / newWidth;\n            }\n\n            this.element.style.width  = Math.round( newWidth ) + \'px\';\n            this.element.style.height = Math.round( newHeight ) + \'px\';\n\n            if (!this.elementArea) {\n                this.elementArea = newWidth * newHeight;\n            }\n\n            this.updateSize();\n        }\n\n        if (viewport && this.viewport) {\n            bounds      = viewport.getBoundsNoRotate(true);\n            topleft     = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);\n            bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false)\n                .minus( this.totalBorderWidths );\n\n            //update style for navigator-box\n            var style = this.displayRegion.style;\n            style.display = this.world.getItemCount() ? \'block\' : \'none\';\n\n            style.top    = Math.round( topleft.y ) + \'px\';\n            style.left   = Math.round( topleft.x ) + \'px\';\n\n            var width = Math.abs( topleft.x - bottomright.x );\n            var height = Math.abs( topleft.y - bottomright.y );\n            // make sure width and height are non-negative so IE doesn\'t throw\n            style.width  = Math.round( Math.max( width, 0 ) ) + \'px\';\n            style.height = Math.round( Math.max( height, 0 ) ) + \'px\';\n        }\n\n    },\n\n    // overrides Viewer.addTiledImage\n    addTiledImage: function(options) {\n        var _this = this;\n\n        var original = options.originalTiledImage;\n        delete options.original;\n\n        var optionsClone = $.extend({}, options, {\n            success: function(event) {\n                var myItem = event.item;\n                myItem._originalForNavigator = original;\n                _this._matchBounds(myItem, original, true);\n\n                original.addHandler(\'bounds-change\', function() {\n                    _this._matchBounds(myItem, original);\n                });\n            }\n        });\n\n        return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);\n    },\n\n    // private\n    _getMatchingItem: function(theirItem) {\n        var count = this.world.getItemCount();\n        var item;\n        for (var i = 0; i < count; i++) {\n            item = this.world.getItemAt(i);\n            if (item._originalForNavigator === theirItem) {\n                return item;\n            }\n        }\n\n        return null;\n    },\n\n    // private\n    _matchBounds: function(myItem, theirItem, immediately) {\n        var bounds = theirItem.getBounds();\n        myItem.setPosition(bounds.getTopLeft(), immediately);\n        myItem.setWidth(bounds.width, immediately);\n    }\n});\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasClick( event ) {\n    if ( event.quick && this.viewer.viewport ) {\n        this.viewer.viewport.panTo(this.viewport.pointFromPixel(event.position));\n        this.viewer.viewport.applyConstraints();\n    }\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasDrag( event ) {\n    if ( this.viewer.viewport ) {\n        if( !this.panHorizontal ){\n            event.delta.x = 0;\n        }\n        if( !this.panVertical ){\n            event.delta.y = 0;\n        }\n        this.viewer.viewport.panBy(\n            this.viewport.deltaPointsFromPixels(\n                event.delta\n            )\n        );\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasRelease( event ) {\n    if ( event.insideElementPressed && this.viewer.viewport ) {\n        this.viewer.viewport.applyConstraints();\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onCanvasScroll( event ) {\n    /**\n     * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#navigator} element (mouse wheel, touch pinch, etc.).\n     *\n     * @event navigator-scroll\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.\n     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.\n     * @property {Number} scroll - The scroll delta for the event.\n     * @property {Boolean} shift - True if the shift key was pressed during this event.\n     * @property {Object} originalEvent - The original DOM event.\n     * @property {?Object} userData - Arbitrary subscriber-defined object.\n     */\n    this.viewer.raiseEvent( \'navigator-scroll\', {\n        tracker: event.eventSource,\n        position: event.position,\n        scroll: event.scroll,\n        shift: event.shift,\n        originalEvent: event.originalEvent\n    });\n\n    //dont scroll the page up and down if the user is scrolling\n    //in the navigator\n    return false;\n}\n\n/**\n    * @function\n    * @private\n    * @param {Object} element\n    * @param {Number} degrees\n    */\nfunction _setTransformRotate (element, degrees) {\n    element.style.webkitTransform = "rotate(" + degrees + "deg)";\n    element.style.mozTransform = "rotate(" + degrees + "deg)";\n    element.style.msTransform = "rotate(" + degrees + "deg)";\n    element.style.oTransform = "rotate(" + degrees + "deg)";\n    element.style.transform = "rotate(" + degrees + "deg)";\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - getString/setString\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n//TODO: I guess this is where the i18n needs to be reimplemented.  I\'ll look\n//      into existing patterns for i18n in javascript but i think that mimicking\n//      pythons gettext might be a reasonable approach.\nvar I18N = {\n    Errors: {\n        Dzc:            "Sorry, we don\'t support Deep Zoom Collections!",\n        Dzi:            "Hmm, this doesn\'t appear to be a valid Deep Zoom Image.",\n        Xml:            "Hmm, this doesn\'t appear to be a valid Deep Zoom Image.",\n        ImageFormat:    "Sorry, we don\'t support {0}-based Deep Zoom Images.",\n        Security:       "It looks like a security restriction stopped us from " +\n                        "loading this Deep Zoom Image.",\n        Status:         "This space unintentionally left blank ({0} {1}).",\n        OpenFailed:     "Unable to open {0}: {1}"\n    },\n\n    Tooltips: {\n        FullPage:       "Toggle full page",\n        Home:           "Go home",\n        ZoomIn:         "Zoom in",\n        ZoomOut:        "Zoom out",\n        NextPage:       "Next page",\n        PreviousPage:   "Previous page",\n        RotateLeft:     "Rotate left",\n        RotateRight:    "Rotate right"\n    }\n};\n\n$.extend( $, /** @lends OpenSeadragon */{\n\n    /**\n     * @function\n     * @param {String} property\n     */\n    getString: function( prop ) {\n\n        var props   = prop.split(\'.\'),\n            string  = null,\n            args    = arguments,\n            container = I18N,\n            i;\n\n        for ( i = 0; i < props.length-1; i++ ) {\n            // in case not a subproperty\n            container = container[ props[ i ] ] || {};\n        }\n        string = container[ props[ i ] ];\n\n        if ( typeof( string ) != "string" ) {\n            $.console.debug( "Untranslated source string:", prop );\n            string = ""; // FIXME: this breaks gettext()-style convention, which would return source\n        }\n\n        return string.replace(/\\{\\d+\\}/g, function(capture) {\n            var i = parseInt( capture.match( /\\d+/ ), 10 ) + 1;\n            return i < args.length ?\n                args[ i ] :\n                "";\n        });\n    },\n\n    /**\n     * @function\n     * @param {String} property\n     * @param {*} value\n     */\n    setString: function( prop, value ) {\n\n        var props     = prop.split(\'.\'),\n            container = I18N,\n            i;\n\n        for ( i = 0; i < props.length - 1; i++ ) {\n            if ( !container[ props[ i ] ] ) {\n                container[ props[ i ] ] = {};\n            }\n            container = container[ props[ i ] ];\n        }\n\n        container[ props[ i ] ] = value;\n    }\n\n});\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Point\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Point\n * @classdesc A Point is really used as a 2-dimensional vector, equally useful for\n * representing a point on a plane, or the height and width of a plane\n * not requiring any other frame of reference.\n *\n * @memberof OpenSeadragon\n * @param {Number} [x] The vector component \'x\'. Defaults to the origin at 0.\n * @param {Number} [y] The vector component \'y\'. Defaults to the origin at 0.\n */\n$.Point = function( x, y ) {\n    /**\n     * The vector component \'x\'.\n     * @member {Number} x\n     * @memberof OpenSeadragon.Point#\n     */\n    this.x = typeof ( x ) == "number" ? x : 0;\n    /**\n     * The vector component \'y\'.\n     * @member {Number} y\n     * @memberof OpenSeadragon.Point#\n     */\n    this.y = typeof ( y ) == "number" ? y : 0;\n};\n\n/** @lends OpenSeadragon.Point.prototype */\n$.Point.prototype = {\n    /**\n     * @function\n     * @returns {OpenSeadragon.Point} a duplicate of this Point\n     */\n    clone: function() {\n        return new $.Point(this.x, this.y);\n    },\n\n    /**\n     * Add another Point to this point and return a new Point.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to add vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the sum of the\n     *  vector components\n     */\n    plus: function( point ) {\n        return new $.Point(\n            this.x + point.x,\n            this.y + point.y\n        );\n    },\n\n    /**\n     * Substract another Point to this point and return a new Point.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to substract vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the substraction of the\n     *  vector components\n     */\n    minus: function( point ) {\n        return new $.Point(\n            this.x - point.x,\n            this.y - point.y\n        );\n    },\n\n    /**\n     * Multiply this point by a factor and return a new Point.\n     * @function\n     * @param {Number} factor The factor to multiply vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the multiplication\n     *  of the vector components by the factor\n     */\n    times: function( factor ) {\n        return new $.Point(\n            this.x * factor,\n            this.y * factor\n        );\n    },\n\n    /**\n     * Divide this point by a factor and return a new Point.\n     * @function\n     * @param {Number} factor The factor to divide vector components.\n     * @returns {OpenSeadragon.Point} A new point representing the division of the\n     *  vector components by the factor\n     */\n    divide: function( factor ) {\n        return new $.Point(\n            this.x / factor,\n            this.y / factor\n        );\n    },\n\n    /**\n     * Compute the opposite of this point and return a new Point.\n     * @function\n     * @returns {OpenSeadragon.Point} A new point representing the opposite of the\n     *  vector components\n     */\n    negate: function() {\n        return new $.Point( -this.x, -this.y );\n    },\n\n    /**\n     * Compute the distance between this point and another point.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to compute the distance with.\n     * @returns {Number} The distance between the 2 points\n     */\n    distanceTo: function( point ) {\n        return Math.sqrt(\n            Math.pow( this.x - point.x, 2 ) +\n            Math.pow( this.y - point.y, 2 )\n        );\n    },\n\n    /**\n     * Apply a function to each coordinate of this point and return a new point.\n     * @function\n     * @param {function} func The function to apply to each coordinate.\n     * @returns {OpenSeadragon.Point} A new point with the coordinates computed\n     * by the specified function\n     */\n    apply: function( func ) {\n        return new $.Point( func( this.x ), func( this.y ) );\n    },\n\n    /**\n     * Check if this point is equal to another one.\n     * @function\n     * @param {OpenSeadragon.Point} point The point to compare this point with.\n     * @returns {Boolean} true if they are equal, false otherwise.\n     */\n    equals: function( point ) {\n        return (\n            point instanceof $.Point\n        ) && (\n            this.x === point.x\n        ) && (\n            this.y === point.y\n        );\n    },\n\n    /**\n     * Rotates the point around the specified pivot\n     * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point\n     * @function\n     * @param {Number} degress to rotate around the pivot.\n     * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.\n     * Defaults to the origin.\n     * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot\n     */\n    rotate: function (degrees, pivot) {\n        pivot = pivot || new $.Point(0, 0);\n        var cos;\n        var sin;\n        // Avoid float computations when possible\n        if (degrees % 90 === 0) {\n            var d = degrees % 360;\n            if (d < 0) {\n                d += 360;\n            }\n            switch (d) {\n                case 0:\n                    cos = 1;\n                    sin = 0;\n                    break;\n                case 90:\n                    cos = 0;\n                    sin = 1;\n                    break;\n                case 180:\n                    cos = -1;\n                    sin = 0;\n                    break;\n                case 270:\n                    cos = 0;\n                    sin = -1;\n                    break;\n            }\n        } else {\n            var angle = degrees * Math.PI / 180.0;\n            cos = Math.cos(angle);\n            sin = Math.sin(angle);\n        }\n        var x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;\n        var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;\n        return new $.Point(x, y);\n    },\n\n    /**\n     * Convert this point to a string in the format (x,y) where x and y are\n     * rounded to the nearest integer.\n     * @function\n     * @returns {String} A string representation of this point.\n     */\n    toString: function() {\n        return "(" + (Math.round(this.x * 100) / 100) + "," + (Math.round(this.y * 100) / 100) + ")";\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n\n/**\n * @class TileSource\n * @classdesc The TileSource contains the most basic implementation required to create a\n * smooth transition between layers in an image pyramid. It has only a single key\n * interface that must be implemented to complete its key functionality:\n * \'getTileUrl\'.  It also has several optional interfaces that can be\n * implemented if a new TileSource wishes to support configuration via a simple\n * object or array (\'configure\') and if the tile source supports or requires\n * configuration via retrieval of a document on the network ala AJAX or JSONP,\n * (\'getImageInfo\').\n * <br/>\n * By default the image pyramid is split into N layers where the image\'s longest\n * side in M (in pixels), where N is the smallest integer which satisfies\n *      <strong>2^(N+1) >= M</strong>.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @param {Object} options\n *      You can either specify a URL, or literally define the TileSource (by specifying\n *      width, height, tileSize, tileOverlap, minLevel, and maxLevel). For the former,\n *      the extending class is expected to implement \'getImageInfo\' and \'configure\'.\n *      For the latter, the construction is assumed to occur through\n *      the extending classes implementation of \'configure\'.\n * @param {String} [options.url]\n *      The URL for the data necessary for this TileSource.\n * @param {Function} [options.success]\n *      A function to be called upon successful creation.\n * @param {Boolean} [options.ajaxWithCredentials]\n *      If this TileSource needs to make an AJAX call, this specifies whether to set\n *      the XHR\'s withCredentials (for accessing secure data).\n * @param {Number} [options.width]\n *      Width of the source image at max resolution in pixels.\n * @param {Number} [options.height]\n *      Height of the source image at max resolution in pixels.\n * @param {Number} [options.tileSize]\n *      The size of the tiles to assumed to make up each pyramid layer in pixels.\n *      Tile size determines the point at which the image pyramid must be\n *      divided into a matrix of smaller images.\n *      Use options.tileWidth and options.tileHeight to support non-square tiles.\n * @param {Number} [options.tileWidth]\n *      The width of the tiles to assumed to make up each pyramid layer in pixels.\n * @param {Number} [options.tileHeight]\n *      The height of the tiles to assumed to make up each pyramid layer in pixels.\n * @param {Number} [options.tileOverlap]\n *      The number of pixels each tile is expected to overlap touching tiles.\n * @param {Number} [options.minLevel]\n *      The minimum level to attempt to load.\n * @param {Number} [options.maxLevel]\n *      The maximum level to attempt to load.\n */\n$.TileSource = function( width, height, tileSize, tileOverlap, minLevel, maxLevel ) {\n    var _this = this;\n\n    var args = arguments,\n        options,\n        i;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: args[0],\n            height: args[1],\n            tileSize: args[2],\n            tileOverlap: args[3],\n            minLevel: args[4],\n            maxLevel: args[5]\n        };\n    }\n\n    //Tile sources supply some events, namely \'ready\' when they must be configured\n    //by asynchronously fetching their configuration data.\n    $.EventSource.call( this );\n\n    //we allow options to override anything we dont treat as\n    //required via idiomatic options or which is functionally\n    //set depending on the state of the readiness of this tile\n    //source\n    $.extend( true, this, options );\n\n    if (!this.success) {\n        //Any functions that are passed as arguments are bound to the ready callback\n        for ( i = 0; i < arguments.length; i++ ) {\n            if ( $.isFunction( arguments[ i ] ) ) {\n                this.success = arguments[ i ];\n                //only one callback per constructor\n                break;\n            }\n        }\n    }\n\n    if (this.success) {\n        this.addHandler( \'ready\', function ( event ) {\n            _this.success( event );\n        } );\n    }\n\n    /**\n     * Ratio of width to height\n     * @member {Number} aspectRatio\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * Vector storing x and y dimensions ( width and height respectively ).\n     * @member {OpenSeadragon.Point} dimensions\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * The overlap in pixels each tile shares with its adjacent neighbors.\n     * @member {Number} tileOverlap\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * The minimum pyramid level this tile source supports or should attempt to load.\n     * @member {Number} minLevel\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     * The maximum pyramid level this tile source supports or should attempt to load.\n     * @member {Number} maxLevel\n     * @memberof OpenSeadragon.TileSource#\n     */\n    /**\n     *\n     * @member {Boolean} ready\n     * @memberof OpenSeadragon.TileSource#\n     */\n\n    if( \'string\' == $.type( arguments[ 0 ] ) ){\n        this.url = arguments[0];\n    }\n\n    if (this.url) {\n        //in case the getImageInfo method is overriden and/or implies an\n        //async mechanism set some safe defaults first\n        this.aspectRatio = 1;\n        this.dimensions  = new $.Point( 10, 10 );\n        this._tileWidth  = 0;\n        this._tileHeight = 0;\n        this.tileOverlap = 0;\n        this.minLevel    = 0;\n        this.maxLevel    = 0;\n        this.ready       = false;\n        //configuration via url implies the extending class\n        //implements and \'configure\'\n        this.getImageInfo( this.url );\n\n    } else {\n\n        //explicit configuration via positional args in constructor\n        //or the more idiomatic \'options\' object\n        this.ready       = true;\n        this.aspectRatio = ( options.width && options.height ) ?\n            (  options.width / options.height ) : 1;\n        this.dimensions  = new $.Point( options.width, options.height );\n\n        if ( this.tileSize ){\n            this._tileWidth = this._tileHeight = this.tileSize;\n            delete this.tileSize;\n        } else {\n            if( this.tileWidth ){\n                // We were passed tileWidth in options, but we want to rename it\n                // with a leading underscore to make clear that it is not safe to directly modify it\n                this._tileWidth = this.tileWidth;\n                delete this.tileWidth;\n            } else {\n                this._tileWidth = 0;\n            }\n\n            if( this.tileHeight ){\n                // See note above about renaming this.tileWidth\n                this._tileHeight = this.tileHeight;\n                delete this.tileHeight;\n            } else {\n                this._tileHeight = 0;\n            }\n        }\n\n        this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;\n        this.minLevel    = options.minLevel ? options.minLevel : 0;\n        this.maxLevel    = ( undefined !== options.maxLevel && null !== options.maxLevel ) ?\n            options.maxLevel : (\n                ( options.width && options.height ) ? Math.ceil(\n                    Math.log( Math.max( options.width, options.height ) ) /\n                    Math.log( 2 )\n                ) : 0\n            );\n        if( this.success && $.isFunction( this.success ) ){\n            this.success( this );\n        }\n    }\n\n\n};\n\n/** @lends OpenSeadragon.TileSource.prototype */\n$.TileSource.prototype = {\n\n    getTileSize: function( level ) {\n        $.console.error(\n            "[TileSource.getTileSize] is deprecated." +\n            "Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"\n        );\n        return this._tileWidth;\n    },\n\n    /**\n     * Return the tileWidth for a given level.\n     * Subclasses should override this if tileWidth can be different at different levels\n     *   such as in IIIFTileSource.  Code should use this function rather than reading\n     *   from ._tileWidth directly.\n     * @function\n     * @param {Number} level\n     */\n    getTileWidth: function( level ) {\n        if (!this._tileWidth) {\n            return this.getTileSize(level);\n        }\n        return this._tileWidth;\n    },\n\n    /**\n     * Return the tileHeight for a given level.\n     * Subclasses should override this if tileHeight can be different at different levels\n     *   such as in IIIFTileSource.  Code should use this function rather than reading\n     *   from ._tileHeight directly.\n     * @function\n     * @param {Number} level\n     */\n    getTileHeight: function( level ) {\n        if (!this._tileHeight) {\n            return this.getTileSize(level);\n        }\n        return this._tileHeight;\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getLevelScale: function( level ) {\n\n        // see https://github.com/openseadragon/openseadragon/issues/22\n        // we use the tilesources implementation of getLevelScale to generate\n        // a memoized re-implementation\n        var levelScaleCache = {},\n            i;\n        for( i = 0; i <= this.maxLevel; i++ ){\n            levelScaleCache[ i ] = 1 / Math.pow(2, this.maxLevel - i);\n        }\n        this.getLevelScale = function( _level ){\n            return levelScaleCache[ _level ];\n        };\n        return this.getLevelScale( level );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getNumTiles: function( level ) {\n        var scale = this.getLevelScale( level ),\n            x = Math.ceil( scale * this.dimensions.x / this.getTileWidth(level) ),\n            y = Math.ceil( scale * this.dimensions.y / this.getTileHeight(level) );\n\n        return new $.Point( x, y );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getPixelRatio: function( level ) {\n        var imageSizeScaled = this.dimensions.times( this.getLevelScale( level ) ),\n            rx = 1.0 / imageSizeScaled.x,\n            ry = 1.0 / imageSizeScaled.y;\n\n        return new $.Point(rx, ry);\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getClosestLevel: function( rect ) {\n        var i,\n            tilesPerSide,\n            tiles;\n\n        for( i = this.minLevel; i < this.maxLevel; i++ ){\n            tiles = this.getNumTiles( i );\n            tilesPerSide = new $.Point(\n              Math.floor( rect.x / this.getTileWidth(i) ),\n              Math.floor( rect.y / this.getTileHeight(i) )\n            );\n\n            if( tiles.x + 1 >= tilesPerSide.x && tiles.y + 1 >= tilesPerSide.y ){\n                break;\n            }\n        }\n        return Math.max( 0, i - 1 );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {OpenSeadragon.Point} point\n     */\n    getTileAtPoint: function( level, point ) {\n        var pixel = point.times( this.dimensions.x ).times( this.getLevelScale(level) ),\n            tx = Math.floor( pixel.x / this.getTileWidth(level) ),\n            ty = Math.floor( pixel.y / this.getTileHeight(level) );\n\n        return new $.Point( tx, ty );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileBounds: function( level, x, y ) {\n        var dimensionsScaled = this.dimensions.times( this.getLevelScale( level ) ),\n            tileWidth = this.getTileWidth(level),\n            tileHeight = this.getTileHeight(level),\n            px = ( x === 0 ) ? 0 : tileWidth * x - this.tileOverlap,\n            py = ( y === 0 ) ? 0 : tileHeight * y - this.tileOverlap,\n            sx = tileWidth + ( x === 0 ? 1 : 2 ) * this.tileOverlap,\n            sy = tileHeight + ( y === 0 ? 1 : 2 ) * this.tileOverlap,\n            scale = 1.0 / dimensionsScaled.x;\n\n        sx = Math.min( sx, dimensionsScaled.x - px );\n        sy = Math.min( sy, dimensionsScaled.y - py );\n\n        return new $.Rect( px * scale, py * scale, sx * scale, sy * scale );\n    },\n\n\n    /**\n     * Responsible for retrieving, and caching the\n     * image metadata pertinent to this TileSources implementation.\n     * @function\n     * @param {String} url\n     * @throws {Error}\n     */\n    getImageInfo: function( url ) {\n        var _this = this,\n            callbackName,\n            callback,\n            readySource,\n            options,\n            urlParts,\n            filename,\n            lastDot;\n\n\n        if( url ) {\n            urlParts = url.split( \'/\' );\n            filename = urlParts[ urlParts.length - 1 ];\n            lastDot  = filename.lastIndexOf( \'.\' );\n            if ( lastDot > -1 ) {\n                urlParts[ urlParts.length - 1 ] = filename.slice( 0, lastDot );\n            }\n        }\n\n        callback = function( data ){\n            if( typeof(data) === "string" ) {\n                data = $.parseXml( data );\n            }\n            var $TileSource = $.TileSource.determineType( _this, data, url );\n            if ( !$TileSource ) {\n                /**\n                 * Raised when an error occurs loading a TileSource.\n                 *\n                 * @event open-failed\n                 * @memberof OpenSeadragon.TileSource\n                 * @type {object}\n                 * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.\n                 * @property {String} message\n                 * @property {String} source\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( \'open-failed\', { message: "Unable to load TileSource", source: url } );\n                return;\n            }\n\n            options = $TileSource.prototype.configure.apply( _this, [ data, url ]);\n            if (options.ajaxWithCredentials === undefined) {\n                options.ajaxWithCredentials = _this.ajaxWithCredentials;\n            }\n\n            readySource = new $TileSource( options );\n            _this.ready = true;\n            /**\n             * Raised when a TileSource is opened and initialized.\n             *\n             * @event ready\n             * @memberof OpenSeadragon.TileSource\n             * @type {object}\n             * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.\n             * @property {Object} tileSource\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( \'ready\', { tileSource: readySource } );\n        };\n\n        if( url.match(/\\.js$/) ){\n            //TODO: Its not very flexible to require tile sources to end jsonp\n            //      request for info  with a url that ends with \'.js\' but for\n            //      now it\'s the only way I see to distinguish uniformly.\n            callbackName = url.split( \'/\' ).pop().replace(\'.js\',\'\');\n            $.jsonp({\n                url: url,\n                async: false,\n                callbackName: callbackName,\n                callback: callback\n            });\n        } else {\n            // request info via xhr asynchronously.\n            $.makeAjaxRequest( {\n                url: url,\n                withCredentials: this.ajaxWithCredentials,\n                success: function( xhr ) {\n                    var data = processResponse( xhr );\n                    callback( data );\n                },\n                error: function ( xhr, exc ) {\n                    var msg;\n\n                    /*\n                        IE < 10 will block XHR requests to different origins. Any property access on the request\n                        object will raise an exception which we\'ll attempt to handle by formatting the original\n                        exception rather than the second one raised when we try to access xhr.status\n                     */\n                    try {\n                        msg = "HTTP " + xhr.status + " attempting to load TileSource";\n                    } catch ( e ) {\n                        var formattedExc;\n                        if ( typeof( exc ) == "undefined" || !exc.toString ) {\n                            formattedExc = "Unknown error";\n                        } else {\n                            formattedExc = exc.toString();\n                        }\n\n                        msg = formattedExc + " attempting to load TileSource";\n                    }\n\n                    /***\n                     * Raised when an error occurs loading a TileSource.\n                     *\n                     * @event open-failed\n                     * @memberof OpenSeadragon.TileSource\n                     * @type {object}\n                     * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.\n                     * @property {String} message\n                     * @property {String} source\n                     * @property {?Object} userData - Arbitrary subscriber-defined object.\n                     */\n                    _this.raiseEvent( \'open-failed\', {\n                        message: msg,\n                        source: url\n                    });\n                }\n            });\n        }\n\n    },\n\n    /**\n     * Responsible determining if a the particular TileSource supports the\n     * data format ( and allowed to apply logic against the url the data was\n     * loaded from, if any ). Overriding implementations are expected to do\n     * something smart with data and / or url to determine support.  Also\n     * understand that iteration order of TileSources is not guarunteed so\n     * please make sure your data or url is expressive enough to ensure a simple\n     * and sufficient mechanisim for clear determination.\n     * @function\n     * @param {String|Object|Array|Document} data\n     * @param {String} url - the url the data was loaded\n     *      from if any.\n     * @return {Boolean}\n     */\n    supports: function( data, url ) {\n        return false;\n    },\n\n    /**\n     * Responsible for parsing and configuring the\n     * image metadata pertinent to this TileSources implementation.\n     * This method is not implemented by this class other than to throw an Error\n     * announcing you have to implement it.  Because of the variety of tile\n     * server technologies, and various specifications for building image\n     * pyramids, this method is here to allow easy integration.\n     * @function\n     * @param {String|Object|Array|Document} data\n     * @param {String} url - the url the data was loaded\n     *      from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     * @throws {Error}\n     */\n    configure: function( data, url ) {\n        throw new Error( "Method not implemented." );\n    },\n\n    /**\n     * Responsible for retriving the url which will return an image for the\n     * region specified by the given x, y, and level components.\n     * This method is not implemented by this class other than to throw an Error\n     * announcing you have to implement it.  Because of the variety of tile\n     * server technologies, and various specifications for building image\n     * pyramids, this method is here to allow easy integration.\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     * @throws {Error}\n     */\n    getTileUrl: function( level, x, y ) {\n        throw new Error( "Method not implemented." );\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    tileExists: function( level, x, y ) {\n        var numTiles = this.getNumTiles( level );\n        return  level >= this.minLevel &&\n                level <= this.maxLevel &&\n                x >= 0 &&\n                y >= 0 &&\n                x < numTiles.x &&\n                y < numTiles.y;\n    }\n};\n\n\n$.extend( true, $.TileSource.prototype, $.EventSource.prototype );\n\n\n/**\n * Decides whether to try to process the response as xml, json, or hand back\n * the text\n * @private\n * @inner\n * @function\n * @param {XMLHttpRequest} xhr - the completed network request\n */\nfunction processResponse( xhr ){\n    var responseText = xhr.responseText,\n        status       = xhr.status,\n        statusText,\n        data;\n\n    if ( !xhr ) {\n        throw new Error( $.getString( "Errors.Security" ) );\n    } else if ( xhr.status !== 200 && xhr.status !== 0 ) {\n        status     = xhr.status;\n        statusText = ( status == 404 ) ?\n            "Not Found" :\n            xhr.statusText;\n        throw new Error( $.getString( "Errors.Status", status, statusText ) );\n    }\n\n    if( responseText.match(/\\s*<.*/) ){\n        try{\n        data = ( xhr.responseXML && xhr.responseXML.documentElement ) ?\n            xhr.responseXML :\n            $.parseXml( responseText );\n        } catch (e){\n            data = xhr.responseText;\n        }\n    }else if( responseText.match(/\\s*[\\{\\[].*/) ){\n        data = $.parseJSON(responseText);\n    }else{\n        data = responseText;\n    }\n    return data;\n}\n\n\n/**\n * Determines the TileSource Implementation by introspection of OpenSeadragon\n * namespace, calling each TileSource implementation of \'isType\'\n * @private\n * @inner\n * @function\n * @param {Object|Array|Document} data - the tile source configuration object\n * @param {String} url - the url where the tile source configuration object was\n *      loaded from, if any.\n */\n$.TileSource.determineType = function( tileSource, data, url ){\n    var property;\n    for( property in OpenSeadragon ){\n        if( property.match(/.+TileSource$/) &&\n            $.isFunction( OpenSeadragon[ property ] ) &&\n            $.isFunction( OpenSeadragon[ property ].prototype.supports ) &&\n            OpenSeadragon[ property ].prototype.supports.call( tileSource, data, url )\n        ){\n            return OpenSeadragon[ property ];\n        }\n    }\n\n    $.console.error( "No TileSource was able to open %s %s", url, data );\n};\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - DziTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class DziTileSource\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Number|Object} width - the pixel width of the image or the idiomatic\n *      options object which is used instead of positional arguments.\n * @param {Number} height\n * @param {Number} tileSize\n * @param {Number} tileOverlap\n * @param {String} tilesUrl\n * @param {String} fileFormat\n * @param {OpenSeadragon.DisplayRect[]} displayRects\n * @property {String} tilesUrl\n * @property {String} fileFormat\n * @property {OpenSeadragon.DisplayRect[]} displayRects\n */\n$.DziTileSource = function( width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel ) {\n    var i,\n        rect,\n        level,\n        options;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: arguments[ 0 ],\n            height: arguments[ 1 ],\n            tileSize: arguments[ 2 ],\n            tileOverlap: arguments[ 3 ],\n            tilesUrl: arguments[ 4 ],\n            fileFormat: arguments[ 5 ],\n            displayRects: arguments[ 6 ],\n            minLevel: arguments[ 7 ],\n            maxLevel: arguments[ 8 ]\n        };\n    }\n\n    this._levelRects  = {};\n    this.tilesUrl     = options.tilesUrl;\n    this.fileFormat   = options.fileFormat;\n    this.displayRects = options.displayRects;\n\n    if ( this.displayRects ) {\n        for ( i = this.displayRects.length - 1; i >= 0; i-- ) {\n            rect = this.displayRects[ i ];\n            for ( level = rect.minLevel; level <= rect.maxLevel; level++ ) {\n                if ( !this._levelRects[ level ] ) {\n                    this._levelRects[ level ] = [];\n                }\n                this._levelRects[ level ].push( rect );\n            }\n        }\n    }\n\n    $.TileSource.apply( this, [ options ] );\n\n};\n\n$.extend( $.DziTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.DziTileSource.prototype */{\n\n\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        var ns;\n        if ( data.Image ) {\n            ns = data.Image.xmlns;\n        } else if ( data.documentElement) {\n            if ("Image" == data.documentElement.localName || "Image" == data.documentElement.tagName) {\n                ns = data.documentElement.namespaceURI;\n            }\n        }\n\n        return ( "http://schemas.microsoft.com/deepzoom/2008" == ns ||\n            "http://schemas.microsoft.com/deepzoom/2009" == ns );\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object|XMLDocument} data - the raw configuration\n     * @param {String} url - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( data, url ){\n\n        var options;\n\n        if( !$.isPlainObject(data) ){\n\n            options = configureFromXML( this, data );\n\n        }else{\n\n            options = configureFromObject( this, data );\n        }\n\n        if (url && !options.tilesUrl) {\n            options.tilesUrl = url.replace(\n                    /([^\\/]+?)(\\.(dzi|xml|js))?\\/?(\\?.*)?$/, \'$1_files/\');\n\n            if (url.search(/\\.(dzi|xml|js)\\?/) != -1) {\n                options.queryParams = url.match(/\\?.*/);\n            }else{\n                options.queryParams = \'\';\n            }\n        }\n\n        return options;\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileUrl: function( level, x, y ) {\n        return [ this.tilesUrl, level, \'/\', x, \'_\', y, \'.\', this.fileFormat, this.queryParams ].join( \'\' );\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    tileExists: function( level, x, y ) {\n        var rects = this._levelRects[ level ],\n            rect,\n            scale,\n            xMin,\n            yMin,\n            xMax,\n            yMax,\n            i;\n\n        if ( !rects || !rects.length ) {\n            return true;\n        }\n\n        for ( i = rects.length - 1; i >= 0; i-- ) {\n            rect = rects[ i ];\n\n            if ( level < rect.minLevel || level > rect.maxLevel ) {\n                continue;\n            }\n\n            scale = this.getLevelScale( level );\n            xMin = rect.x * scale;\n            yMin = rect.y * scale;\n            xMax = xMin + rect.width * scale;\n            yMax = yMin + rect.height * scale;\n\n            xMin = Math.floor( xMin / this.tileSize );\n            yMin = Math.floor( yMin / this.tileSize );\n            xMax = Math.ceil( xMax / this.tileSize );\n            yMax = Math.ceil( yMax / this.tileSize );\n\n            if ( xMin <= x && x < xMax && yMin <= y && y < yMax ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n});\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromXML( tileSource, xmlDoc ){\n\n    if ( !xmlDoc || !xmlDoc.documentElement ) {\n        throw new Error( $.getString( "Errors.Xml" ) );\n    }\n\n    var root           = xmlDoc.documentElement,\n        rootName       = root.localName || root.tagName,\n        ns             = xmlDoc.documentElement.namespaceURI,\n        configuration  = null,\n        displayRects   = [],\n        dispRectNodes,\n        dispRectNode,\n        rectNode,\n        sizeNode,\n        i;\n\n    if ( rootName == "Image" ) {\n\n        try {\n            sizeNode = root.getElementsByTagName("Size" )[ 0 ];\n            if (sizeNode === undefined) {\n                sizeNode = root.getElementsByTagNameNS(ns, "Size" )[ 0 ];\n            }\n\n            configuration = {\n                Image: {\n                    xmlns:       "http://schemas.microsoft.com/deepzoom/2008",\n                    Url:         root.getAttribute( "Url" ),\n                    Format:      root.getAttribute( "Format" ),\n                    DisplayRect: null,\n                    Overlap:     parseInt( root.getAttribute( "Overlap" ), 10 ),\n                    TileSize:    parseInt( root.getAttribute( "TileSize" ), 10 ),\n                    Size: {\n                        Height: parseInt( sizeNode.getAttribute( "Height" ), 10 ),\n                        Width:  parseInt( sizeNode.getAttribute( "Width" ), 10 )\n                    }\n                }\n            };\n\n            if ( !$.imageFormatSupported( configuration.Image.Format ) ) {\n                throw new Error(\n                    $.getString( "Errors.ImageFormat", configuration.Image.Format.toUpperCase() )\n                );\n            }\n\n            dispRectNodes = root.getElementsByTagName("DisplayRect" );\n            if (dispRectNodes === undefined) {\n                dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect" )[ 0 ];\n            }\n\n            for ( i = 0; i < dispRectNodes.length; i++ ) {\n                dispRectNode = dispRectNodes[ i ];\n                rectNode     = dispRectNode.getElementsByTagName("Rect" )[ 0 ];\n                if (rectNode === undefined) {\n                    rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect" )[ 0 ];\n                }\n\n                displayRects.push({\n                    Rect: {\n                        X: parseInt( rectNode.getAttribute( "X" ), 10 ),\n                        Y: parseInt( rectNode.getAttribute( "Y" ), 10 ),\n                        Width: parseInt( rectNode.getAttribute( "Width" ), 10 ),\n                        Height: parseInt( rectNode.getAttribute( "Height" ), 10 ),\n                        MinLevel: parseInt( dispRectNode.getAttribute( "MinLevel" ), 10 ),\n                        MaxLevel: parseInt( dispRectNode.getAttribute( "MaxLevel" ), 10 )\n                    }\n                });\n            }\n\n            if( displayRects.length ){\n                configuration.Image.DisplayRect = displayRects;\n            }\n\n            return configureFromObject( tileSource, configuration );\n\n        } catch ( e ) {\n            throw (e instanceof Error) ?\n                e :\n                new Error( $.getString("Errors.Dzi") );\n        }\n    } else if ( rootName == "Collection" ) {\n        throw new Error( $.getString( "Errors.Dzc" ) );\n    } else if ( rootName == "Error" ) {\n        var messageNode = root.getElementsByTagName("Message")[0];\n        var message = messageNode.firstChild.nodeValue;\n        throw new Error(message);\n    }\n\n    throw new Error( $.getString( "Errors.Dzi" ) );\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromObject( tileSource, configuration ){\n    var imageData     = configuration.Image,\n        tilesUrl      = imageData.Url,\n        fileFormat    = imageData.Format,\n        sizeData      = imageData.Size,\n        dispRectData  = imageData.DisplayRect || [],\n        width         = parseInt( sizeData.Width, 10 ),\n        height        = parseInt( sizeData.Height, 10 ),\n        tileSize      = parseInt( imageData.TileSize, 10 ),\n        tileOverlap   = parseInt( imageData.Overlap, 10 ),\n        displayRects  = [],\n        rectData,\n        i;\n\n    //TODO: need to figure out out to better handle image format compatibility\n    //      which actually includes additional file formats like xml and pdf\n    //      and plain text for various tilesource implementations to avoid low\n    //      level errors.\n    //\n    //      For now, just don\'t perform the check.\n    //\n    /*if ( !imageFormatSupported( fileFormat ) ) {\n        throw new Error(\n            $.getString( "Errors.ImageFormat", fileFormat.toUpperCase() )\n        );\n    }*/\n\n    for ( i = 0; i < dispRectData.length; i++ ) {\n        rectData = dispRectData[ i ].Rect;\n\n        displayRects.push( new $.DisplayRect(\n            parseInt( rectData.X, 10 ),\n            parseInt( rectData.Y, 10 ),\n            parseInt( rectData.Width, 10 ),\n            parseInt( rectData.Height, 10 ),\n            parseInt( rectData.MinLevel, 10 ),\n            parseInt( rectData.MaxLevel, 10 )\n        ));\n    }\n\n    return $.extend(true, {\n        width: width, /* width *required */\n        height: height, /* height *required */\n        tileSize: tileSize, /* tileSize *required */\n        tileOverlap: tileOverlap, /* tileOverlap *required */\n        minLevel: null, /* minLevel */\n        maxLevel: null, /* maxLevel */\n        tilesUrl: tilesUrl, /* tilesUrl */\n        fileFormat: fileFormat, /* fileFormat */\n        displayRects: displayRects /* displayRects */\n    }, configuration );\n\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - IIIFTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class IIIFTileSource\n * @classdesc A client implementation of the International Image Interoperability Framework\n * Format: Image API 1.0 - 2.1\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @see http://iiif.io/api/image/\n */\n$.IIIFTileSource = function( options ){\n\n\n    $.extend( true, this, options );\n\n    if ( !( this.height && this.width && this[\'@id\'] ) ) {\n        throw new Error( \'IIIF required parameters not provided.\' );\n    }\n\n    options.tileSizePerScaleFactor = {};\n\n    // N.B. 2.0 renamed scale_factors to scaleFactors\n    if ( this.tile_width && this.tile_height ) {\n        options.tileWidth = this.tile_width;\n        options.tileHeight = this.tile_height;\n    } else if ( this.tile_width ) {\n        options.tileSize = this.tile_width;\n    } else if ( this.tile_height ) {\n        options.tileSize = this.tile_height;\n    } else if ( this.tiles ) {\n        // Version 2.0 forwards\n        if ( this.tiles.length == 1 ) {\n            options.tileWidth  = this.tiles[0].width;\n            // Use height if provided, otherwise assume square tiles and use width.\n            options.tileHeight = this.tiles[0].height || this.tiles[0].width;\n            this.scale_factors = this.tiles[0].scaleFactors;\n        } else {\n            // Multiple tile sizes at different levels\n            this.scale_factors = [];\n            for (var t = 0; t < this.tiles.length; t++ ) {\n                for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {\n                    var scaleFactor = this.tiles[t].scaleFactors[sf];\n                    this.scale_factors.push(scaleFactor);\n                    options.tileSizePerScaleFactor[scaleFactor] = {\n                        width: this.tiles[t].width,\n                        height: this.tiles[t].height || this.tiles[t].width\n                    };\n                }\n            }\n        }\n    } else if ( canBeTiled(options.profile) ) {\n        // use the largest of tileOptions that is smaller than the short dimension\n        var shortDim = Math.min( this.height, this.width ),\n            tileOptions = [256,512,1024],\n            smallerTiles = [];\n\n        for ( var c = 0; c < tileOptions.length; c++ ) {\n            if ( tileOptions[c] <= shortDim ) {\n                smallerTiles.push( tileOptions[c] );\n            }\n        }\n\n        if ( smallerTiles.length > 0 ) {\n            options.tileSize = Math.max.apply( null, smallerTiles );\n        } else {\n            // If we\'re smaller than 256, just use the short side.\n            options.tileSize = shortDim;\n        }\n    } else if (this.sizes && this.sizes.length > 0) {\n        // This info.json can\'t be tiled, but we can still construct a legacy pyramid from the sizes array. \n        // In this mode, IIIFTileSource will call functions from the abstract baseTileSource or the \n        // LegacyTileSource instead of performing IIIF tiling.      \n        this.emulateLegacyImagePyramid = true;\n        \n        options.levels = constructLevels( this );\n        // use the largest available size to define tiles\n        $.extend( true, options, {\n            width: options.levels[ options.levels.length - 1 ].width,\n            height: options.levels[ options.levels.length - 1 ].height,\n            tileSize: Math.max( options.height, options.width ),\n            tileOverlap: 0,\n            minLevel: 0,\n            maxLevel: options.levels.length - 1\n        });\n        this.levels = options.levels;\n    } else {\n        $.console.error("Nothing in the info.json to construct image pyramids from");\n    }\n\n    if (!options.maxLevel && !this.emulateLegacyImagePyramid) {\n        if (!this.scale_factors) {\n            options.maxLevel = Number(Math.ceil(Math.log(Math.max(this.width, this.height), 2)));\n        } else {\n            options.maxLevel = Math.floor(Math.pow(Math.max.apply(null, this.scale_factors), 0.5));\n        }\n    }\n\n    $.TileSource.apply( this, [ options ] );\n};\n\n$.extend( $.IIIFTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.IIIFTileSource.prototype */{\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n     \n    supports: function( data, url ) {\n        // Version 2.0 and forwards\n        if (data.protocol && data.protocol == \'http://iiif.io/api/image\') {\n            return true;\n        // Version 1.1\n        } else if ( data[\'@context\'] && (\n            data[\'@context\'] == "http://library.stanford.edu/iiif/image-api/1.1/context.json" ||\n            data[\'@context\'] == "http://iiif.io/api/image/1/context.json") ) {\n            // N.B. the iiif.io context is wrong, but where the representation lives so likely to be used\n            return true;\n\n        // Version 1.0\n        } else if ( data.profile &&\n            data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {\n            return true;\n        } else if ( data.identifier && data.width && data.height ) {\n            return true;\n        } else if ( data.documentElement &&\n            "info" == data.documentElement.tagName &&\n            "http://library.stanford.edu/iiif/image-api/ns/" ==\n                data.documentElement.namespaceURI) {\n            return true;\n\n        // Not IIIF\n        } else {\n            return false;\n        }\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object} data - the raw configuration\n     * @example <caption>IIIF 1.1 Info Looks like this</caption>\n     * {\n     *   "@context" : "http://library.stanford.edu/iiif/image-api/1.1/context.json",\n     *   "@id" : "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",\n     *   "width" : 6000,\n     *   "height" : 4000,\n     *   "scale_factors" : [ 1, 2, 4 ],\n     *   "tile_width" : 1024,\n     *   "tile_height" : 1024,\n     *   "formats" : [ "jpg", "png" ],\n     *   "qualities" : [ "native", "grey" ],\n     *   "profile" : "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0"\n     * }\n     */\n    configure: function( data, url ){\n        // Try to deduce our version and fake it upwards if needed\n        if ( !$.isPlainObject(data) ) {\n            var options = configureFromXml10( data );\n            options[\'@context\'] = "http://iiif.io/api/image/1.0/context.json";\n            options[\'@id\'] = url.replace(\'/info.xml\', \'\');\n            return options;\n        } else if ( !data[\'@context\'] ) {\n            data[\'@context\'] = \'http://iiif.io/api/image/1.0/context.json\';\n            data[\'@id\'] = url.replace(\'/info.json\', \'\');\n            return data;\n        } else {\n            return data;\n        }\n    },\n\n    /**\n     * Return the tileWidth for the given level.\n     * @function\n     * @param {Number} level\n     */\n    getTileWidth: function( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            return $.TileSource.prototype.getTileWidth.call(this, level);\n        }\n\n        var scaleFactor = Math.pow(2, this.maxLevel - level);\n\n        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {\n            return this.tileSizePerScaleFactor[scaleFactor].width;\n        }\n        return this._tileWidth;\n    },\n\n    /**\n     * Return the tileHeight for the given level.\n     * @function\n     * @param {Number} level\n     */\n    getTileHeight: function( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            return $.TileSource.prototype.getTileHeight.call(this, level);\n        }\n\n        var scaleFactor = Math.pow(2, this.maxLevel - level);\n\n        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {\n            return this.tileSizePerScaleFactor[scaleFactor].height;\n        }\n        return this._tileHeight;\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getLevelScale: function ( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            var levelScale = NaN;\n            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {\n                levelScale =\n                    this.levels[level].width /\n                    this.levels[this.maxLevel].width;\n            }\n            return levelScale;\n        }\n\n        return $.TileSource.prototype.getLevelScale.call(this, level);\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getNumTiles: function( level ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            var scale = this.getLevelScale(level);\n            if (scale) {\n                return new $.Point(1, 1);\n            } else {\n                return new $.Point(0, 0);\n            }\n        }\n\n        return $.TileSource.prototype.getNumTiles.call(this, level);\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {OpenSeadragon.Point} point\n     */\n    getTileAtPoint: function( level, point ) {\n\n        if(this.emulateLegacyImagePyramid) {\n            return new $.Point(0, 0);\n        }\n\n        return $.TileSource.prototype.getTileAtPoint.call(this, level, point);\n    },\n\n\n    /**\n     * Responsible for retrieving the url which will return an image for the\n     * region specified by the given x, y, and level components.\n     * @function\n     * @param {Number} level - z index\n     * @param {Number} x\n     * @param {Number} y\n     * @throws {Error}\n     */\n    getTileUrl: function( level, x, y ){\n\n        if(this.emulateLegacyImagePyramid) {\n            var url = null;\n            if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {\n                url = this.levels[ level ].url;\n            }\n            return url;\n        }\n\n        //# constants\n        var IIIF_ROTATION = \'0\',\n            //## get the scale (level as a decimal)\n            scale = Math.pow( 0.5, this.maxLevel - level ),\n\n            //# image dimensions at this level\n            levelWidth = Math.ceil( this.width * scale ),\n            levelHeight = Math.ceil( this.height * scale ),\n\n            //## iiif region\n            tileWidth,\n            tileHeight,\n            iiifTileSizeWidth,\n            iiifTileSizeHeight,\n            iiifRegion,\n            iiifTileX,\n            iiifTileY,\n            iiifTileW,\n            iiifTileH,\n            iiifSize,\n            iiifQuality,\n            uri;\n\n        tileWidth = this.getTileWidth(level);\n        tileHeight = this.getTileHeight(level);\n        iiifTileSizeWidth = Math.ceil( tileWidth / scale );\n        iiifTileSizeHeight = Math.ceil( tileHeight / scale );\n\n        if ( this[\'@context\'].indexOf(\'/1.0/context.json\') > -1 ||\n             this[\'@context\'].indexOf(\'/1.1/context.json\') > -1 ||\n             this[\'@context\'].indexOf(\'/1/context.json\') > -1 ) {\n            iiifQuality = "native.jpg";\n        } else {\n            iiifQuality = "default.jpg";\n        }\n\n        if ( levelWidth < tileWidth && levelHeight < tileHeight ){\n            iiifSize = levelWidth + ",";\n            iiifRegion = \'full\';\n        } else {\n            iiifTileX = x * iiifTileSizeWidth;\n            iiifTileY = y * iiifTileSizeHeight;\n            iiifTileW = Math.min( iiifTileSizeWidth, this.width - iiifTileX );\n            iiifTileH = Math.min( iiifTileSizeHeight, this.height - iiifTileY );\n            iiifSize = Math.ceil( iiifTileW * scale ) + ",";\n            iiifRegion = [ iiifTileX, iiifTileY, iiifTileW, iiifTileH ].join( \',\' );\n        }\n        uri = [ this[\'@id\'], iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality ].join( \'/\' );\n\n        return uri;\n    }\n\n  });\n\n    /**\n     * Determine whether arbitrary tile requests can be made against a service with the given profile\n     * @function\n     * @param {object} profile - IIIF profile object\n     * @throws {Error}\n     */\n    function canBeTiled (profile ) {\n        var level0Profiles = [\n            "http://library.stanford.edu/iiif/image-api/compliance.html#level0",\n            "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",\n            "http://iiif.io/api/image/2/level0.json"\n        ];\n        var isLevel0 = (level0Profiles.indexOf(profile[0]) != -1);\n        return !isLevel0 || (profile.indexOf("sizeByW") != -1);\n    }\n\n    /**\n     * Build the legacy pyramid URLs (one tile per level)\n     * @function\n     * @param {object} options - infoJson\n     * @throws {Error}\n     */\n    function constructLevels(options) {\n        var levels = [];\n        for(var i=0; i<options.sizes.length; i++) {\n            levels.push({\n                url: options[\'@id\'] + \'/full/\' + options.sizes[i].width + \',/0/default.jpg\',\n                width: options.sizes[i].width,\n                height: options.sizes[i].height\n            });\n        }\n        return levels.sort(function(a,b){return a.width - b.width;});\n    }\n\n\n    function configureFromXml10(xmlDoc) {\n        //parse the xml\n        if ( !xmlDoc || !xmlDoc.documentElement ) {\n            throw new Error( $.getString( "Errors.Xml" ) );\n        }\n\n        var root            = xmlDoc.documentElement,\n            rootName        = root.tagName,\n            configuration   = null;\n\n        if ( rootName == "info" ) {\n            try {\n                configuration = {};\n                parseXML10( root, configuration );\n                return configuration;\n\n            } catch ( e ) {\n                throw (e instanceof Error) ?\n                    e :\n                    new Error( $.getString("Errors.IIIF") );\n            }\n        }\n        throw new Error( $.getString( "Errors.IIIF" ) );\n    }\n\n    function parseXML10( node, configuration, property ) {\n        var i,\n            value;\n        if ( node.nodeType == 3 && property ) {//text node\n            value = node.nodeValue.trim();\n            if( value.match(/^\\d*$/)){\n                value = Number( value );\n            }\n            if( !configuration[ property ] ){\n                configuration[ property ] = value;\n            }else{\n                if( !$.isArray( configuration[ property ] ) ){\n                    configuration[ property ] = [ configuration[ property ] ];\n                }\n                configuration[ property ].push( value );\n            }\n        } else if( node.nodeType == 1 ){\n            for( i = 0; i < node.childNodes.length; i++ ){\n                parseXML10( node.childNodes[ i ], configuration, node.nodeName );\n            }\n        }\n    }\n\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - OsmTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Derived from the OSM tile source in Rainer Simon\'s seajax-utils project\n * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed\n * the included code to the OpenSeadragon project under the New BSD license;\n * see <https://github.com/openseadragon/openseadragon/issues/58>.\n */\n\n\n(function( $ ){\n\n/**\n * @class OsmTileSource\n * @classdesc A tilesource implementation for OpenStreetMap.<br><br>\n *\n * Note 1. Zoomlevels. Deep Zoom and OSM define zoom levels differently. In  Deep\n * Zoom, level 0 equals an image of 1x1 pixels. In OSM, level 0 equals an image of\n * 256x256 levels (see http://gasi.ch/blog/inside-deep-zoom-2). I.e. there is a\n * difference of log2(256)=8 levels.<br><br>\n *\n * Note 2. Image dimension. According to the OSM Wiki\n * (http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Zoom_levels)\n * the highest Mapnik zoom level has 256.144x256.144 tiles, with a 256x256\n * pixel size. I.e. the Deep Zoom image dimension is 65.572.864x65.572.864\n * pixels.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Number|Object} width - the pixel width of the image or the idiomatic\n *      options object which is used instead of positional arguments.\n * @param {Number} height\n * @param {Number} tileSize\n * @param {Number} tileOverlap\n * @param {String} tilesUrl\n */\n$.OsmTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {\n    var options;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: arguments[0],\n            height: arguments[1],\n            tileSize: arguments[2],\n            tileOverlap: arguments[3],\n            tilesUrl: arguments[4]\n        };\n    }\n    //apply default setting for standard public OpenStreatMaps service\n    //but allow them to be specified so fliks can host there own instance\n    //or apply against other services supportting the same standard\n    if( !options.width || !options.height ){\n        options.width = 65572864;\n        options.height = 65572864;\n    }\n    if( !options.tileSize ){\n        options.tileSize = 256;\n        options.tileOverlap = 0;\n    }\n    if( !options.tilesUrl ){\n        options.tilesUrl = "http://tile.openstreetmap.org/";\n    }\n    options.minLevel = 8;\n\n    $.TileSource.apply( this, [ options ] );\n\n};\n\n$.extend( $.OsmTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.OsmTileSource.prototype */{\n\n\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        return (\n            data.type &&\n            "openstreetmaps" == data.type\n        );\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object} data - the raw configuration\n     * @param {String} url - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( data, url ){\n        return data;\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileUrl: function( level, x, y ) {\n        return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";\n    }\n});\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TmsTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Derived from the TMS tile source in Rainer Simon\'s seajax-utils project\n * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed\n * the included code to the OpenSeadragon project under the New BSD license;\n * see <https://github.com/openseadragon/openseadragon/issues/58>.\n */\n\n\n(function( $ ){\n\n/**\n * @class TmsTileSource\n * @classdesc A tilesource implementation for Tiled Map Services (TMS).\n * TMS tile scheme ( [ as supported by OpenLayers ] is described here\n * ( http://openlayers.org/dev/examples/tms.html ).\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Number|Object} width - the pixel width of the image or the idiomatic\n *      options object which is used instead of positional arguments.\n * @param {Number} height\n * @param {Number} tileSize\n * @param {Number} tileOverlap\n * @param {String} tilesUrl\n */\n$.TmsTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {\n    var options;\n\n    if( $.isPlainObject( width ) ){\n        options = width;\n    }else{\n        options = {\n            width: arguments[0],\n            height: arguments[1],\n            tileSize: arguments[2],\n            tileOverlap: arguments[3],\n            tilesUrl: arguments[4]\n        };\n    }\n    // TMS has integer multiples of 256 for width/height and adds buffer\n    // if necessary -> account for this!\n    var bufferedWidth = Math.ceil(options.width / 256) * 256,\n        bufferedHeight = Math.ceil(options.height / 256) * 256,\n        max;\n\n    // Compute number of zoomlevels in this tileset\n    if (bufferedWidth > bufferedHeight) {\n        max = bufferedWidth / 256;\n    } else {\n        max = bufferedHeight / 256;\n    }\n    options.maxLevel = Math.ceil(Math.log(max)/Math.log(2)) - 1;\n    options.tileSize = 256;\n    options.width = bufferedWidth;\n    options.height = bufferedHeight;\n\n    $.TileSource.apply( this, [ options ] );\n\n};\n\n$.extend( $.TmsTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.TmsTileSource.prototype */{\n\n\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        return ( data.type && "tiledmapservice" == data.type );\n    },\n\n    /**\n     *\n     * @function\n     * @param {Object} data - the raw configuration\n     * @param {String} url - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( data, url ){\n        return data;\n    },\n\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     */\n    getTileUrl: function( level, x, y ) {\n        // Convert from Deep Zoom definition to TMS zoom definition\n        var yTiles = this.getNumTiles( level ).y - 1;\n\n        return this.tilesUrl + level + "/" + x + "/" +  (yTiles - y) + ".png";\n    }\n});\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - LegacyTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class LegacyTileSource\n * @classdesc The LegacyTileSource allows simple, traditional image pyramids to be loaded\n * into an OpenSeadragon Viewer.  Basically, this translates to the historically\n * common practice of starting with a \'master\' image, maybe a tiff for example,\n * and generating a set of \'service\' images like one or more thumbnails, a medium\n * resolution image and a high resolution image in standard web formats like\n * png or jpg.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {Array} levels An array of file descriptions, each is an object with\n *      a \'url\', a \'width\', and a \'height\'.  Overriding classes can expect more\n *      properties but these properties are sufficient for this implementation.\n *      Additionally, the levels are required to be listed in order from\n *      smallest to largest.\n * @property {Number} aspectRatio\n * @property {Number} dimensions\n * @property {Number} tileSize\n * @property {Number} tileOverlap\n * @property {Number} minLevel\n * @property {Number} maxLevel\n * @property {Array}  levels\n */\n$.LegacyTileSource = function( levels ) {\n\n    var options,\n        width,\n        height;\n\n    if( $.isArray( levels ) ){\n        options = {\n            type: \'legacy-image-pyramid\',\n            levels: levels\n        };\n    }\n\n    //clean up the levels to make sure we support all formats\n    options.levels = filterFiles( options.levels );\n\n    if ( options.levels.length > 0 ) {\n        width = options.levels[ options.levels.length - 1 ].width;\n        height = options.levels[ options.levels.length - 1 ].height;\n    }\n    else {\n        width = 0;\n        height = 0;\n        $.console.error( "No supported image formats found" );\n    }\n\n    $.extend( true, options, {\n        width: width,\n        height: height,\n        tileSize: Math.max( height, width ),\n        tileOverlap: 0,\n        minLevel: 0,\n        maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0\n    } );\n\n    $.TileSource.apply( this, [ options ] );\n\n    this.levels = options.levels;\n};\n\n$.extend( $.LegacyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.LegacyTileSource.prototype */{\n    /**\n     * Determine if the data and/or url imply the image service is supported by\n     * this tile source.\n     * @function\n     * @param {Object|Array} data\n     * @param {String} optional - url\n     */\n    supports: function( data, url ){\n        return (\n            data.type &&\n            "legacy-image-pyramid" == data.type\n        ) || (\n            data.documentElement &&\n            "legacy-image-pyramid" == data.documentElement.getAttribute(\'type\')\n        );\n    },\n\n\n    /**\n     *\n     * @function\n     * @param {Object|XMLDocument} configuration - the raw configuration\n     * @param {String} dataUrl - the url the data was retreived from if any.\n     * @return {Object} options - A dictionary of keyword arguments sufficient\n     *      to configure this tile sources constructor.\n     */\n    configure: function( configuration, dataUrl ){\n\n        var options;\n\n        if( !$.isPlainObject(configuration) ){\n\n            options = configureFromXML( this, configuration );\n\n        }else{\n\n            options = configureFromObject( this, configuration );\n        }\n\n        return options;\n\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getLevelScale: function ( level ) {\n        var levelScale = NaN;\n        if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {\n            levelScale =\n                this.levels[ level ].width /\n                this.levels[ this.maxLevel ].width;\n        }\n        return levelScale;\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     */\n    getNumTiles: function( level ) {\n        var scale = this.getLevelScale( level );\n        if ( scale ){\n            return new $.Point( 1, 1 );\n        } else {\n            return new $.Point( 0, 0 );\n        }\n    },\n\n    /**\n     * @function\n     * @param {Number} level\n     * @param {OpenSeadragon.Point} point\n     */\n    getTileAtPoint: function( level, point ) {\n        return new $.Point( 0, 0 );\n    },\n\n\n    /**\n     * This method is not implemented by this class other than to throw an Error\n     * announcing you have to implement it.  Because of the variety of tile\n     * server technologies, and various specifications for building image\n     * pyramids, this method is here to allow easy integration.\n     * @function\n     * @param {Number} level\n     * @param {Number} x\n     * @param {Number} y\n     * @throws {Error}\n     */\n    getTileUrl: function ( level, x, y ) {\n        var url = null;\n        if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {\n            url = this.levels[ level ].url;\n        }\n        return url;\n    }\n} );\n\n/**\n * This method removes any files from the Array which dont conform to our\n * basic requirements for a \'level\' in the LegacyTileSource.\n * @private\n * @inner\n * @function\n */\nfunction filterFiles( files ){\n    var filtered = [],\n        file,\n        i;\n    for( i = 0; i < files.length; i++ ){\n        file = files[ i ];\n        if( file.height &&\n            file.width &&\n            file.url && (\n                file.url.toLowerCase().match(/^.*\\.(png|jpg|jpeg|gif)(?:\\?.*)?$/) || (\n                    file.mimetype &&\n                    file.mimetype.toLowerCase().match(/^.*\\/(png|jpg|jpeg|gif)$/)\n                )\n            ) ){\n            //This is sufficient to serve as a level\n            filtered.push({\n                url: file.url,\n                width: Number( file.width ),\n                height: Number( file.height )\n            });\n        }\n        else {\n            $.console.error( \'Unsupported image format: %s\', file.url ? file.url : \'<no URL>\' );\n        }\n    }\n\n    return filtered.sort(function(a,b){\n        return a.height - b.height;\n    });\n\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromXML( tileSource, xmlDoc ){\n\n    if ( !xmlDoc || !xmlDoc.documentElement ) {\n        throw new Error( $.getString( "Errors.Xml" ) );\n    }\n\n    var root         = xmlDoc.documentElement,\n        rootName     = root.tagName,\n        conf         = null,\n        levels       = [],\n        level,\n        i;\n\n    if ( rootName == "image" ) {\n\n        try {\n            conf = {\n                type:        root.getAttribute( "type" ),\n                levels:      []\n            };\n\n            levels = root.getElementsByTagName( "level" );\n            for ( i = 0; i < levels.length; i++ ) {\n                level = levels[ i ];\n\n                conf.levels .push({\n                    url:    level.getAttribute( "url" ),\n                    width:  parseInt( level.getAttribute( "width" ), 10 ),\n                    height: parseInt( level.getAttribute( "height" ), 10 )\n                });\n            }\n\n            return configureFromObject( tileSource, conf );\n\n        } catch ( e ) {\n            throw (e instanceof Error) ?\n                e :\n                new Error( \'Unknown error parsing Legacy Image Pyramid XML.\' );\n        }\n    } else if ( rootName == "collection" ) {\n        throw new Error( \'Legacy Image Pyramid Collections not yet supported.\' );\n    } else if ( rootName == "error" ) {\n        throw new Error( \'Error: \' + xmlDoc );\n    }\n\n    throw new Error( \'Unknown element \' + rootName );\n}\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction configureFromObject( tileSource, configuration ){\n\n    return configuration.levels;\n\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ImageTileSource\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function ($) {\n\n    /**\n     * @class ImageTileSource\n     * @classdesc The ImageTileSource allows a simple image to be loaded\n     * into an OpenSeadragon Viewer.\n     * There are 2 ways to open an ImageTileSource:\n     * 1. viewer.open({type: \'image\', url: fooUrl});\n     * 2. viewer.open(new OpenSeadragon.ImageTileSource({url: fooUrl}));\n     *\n     * With the first syntax, the crossOriginPolicy, ajaxWithCredentials and\n     * useCanvas options are inherited from the viewer if they are not\n     * specified directly in the options object.\n     *\n     * @memberof OpenSeadragon\n     * @extends OpenSeadragon.TileSource\n     * @param {Object} options Options object.\n     * @param {String} options.url URL of the image\n     * @param {Boolean} [options.buildPyramid=true] If set to true (default), a\n     * pyramid will be built internally to provide a better downsampling.\n     * @param {String|Boolean} [options.crossOriginPolicy=false] Valid values are\n     * \'Anonymous\', \'use-credentials\', and false. If false, image requests will\n     * not use CORS preventing internal pyramid building for images from other\n     * domains.\n     * @param {String|Boolean} [options.ajaxWithCredentials=false] Whether to set\n     * the withCredentials XHR flag for AJAX requests (when loading tile sources).\n     * @param {Boolean} [options.useCanvas=true] Set to false to prevent any use\n     * of the canvas API.\n     */\n    $.ImageTileSource = function (options) {\n\n        options = $.extend({\n            buildPyramid: true,\n            crossOriginPolicy: false,\n            ajaxWithCredentials: false,\n            useCanvas: true\n        }, options);\n        $.TileSource.apply(this, [options]);\n\n    };\n\n    $.extend($.ImageTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.ImageTileSource.prototype */{\n        /**\n         * Determine if the data and/or url imply the image service is supported by\n         * this tile source.\n         * @function\n         * @param {Object|Array} data\n         * @param {String} optional - url\n         */\n        supports: function (data, url) {\n            return data.type && data.type === "image";\n        },\n        /**\n         *\n         * @function\n         * @param {Object} options - the options\n         * @param {String} dataUrl - the url the image was retreived from, if any.\n         * @return {Object} options - A dictionary of keyword arguments sufficient\n         *      to configure this tile sources constructor.\n         */\n        configure: function (options, dataUrl) {\n            return options;\n        },\n        /**\n         * Responsible for retrieving, and caching the\n         * image metadata pertinent to this TileSources implementation.\n         * @function\n         * @param {String} url\n         * @throws {Error}\n         */\n        getImageInfo: function (url) {\n            var image = this._image = new Image();\n            var _this = this;\n\n            if (this.crossOriginPolicy) {\n                image.crossOrigin = this.crossOriginPolicy;\n            }\n            if (this.ajaxWithCredentials) {\n                image.useCredentials = this.ajaxWithCredentials;\n            }\n\n            $.addEvent(image, \'load\', function () {\n                _this.width = image.naturalWidth;\n                _this.height = image.naturalHeight;\n                _this.aspectRatio = _this.width / _this.height;\n                _this.dimensions = new $.Point(_this.width, _this.height);\n                _this._tileWidth = _this.width;\n                _this._tileHeight = _this.height;\n                _this.tileOverlap = 0;\n                _this.minLevel = 0;\n                _this.levels = _this._buildLevels();\n                _this.maxLevel = _this.levels.length - 1;\n\n                _this.ready = true;\n\n                // Note: this event is documented elsewhere, in TileSource\n                _this.raiseEvent(\'ready\', {tileSource: _this});\n            });\n\n            $.addEvent(image, \'error\', function () {\n                // Note: this event is documented elsewhere, in TileSource\n                _this.raiseEvent(\'open-failed\', {\n                    message: "Error loading image at " + url,\n                    source: url\n                });\n            });\n\n            image.src = url;\n        },\n        /**\n         * @function\n         * @param {Number} level\n         */\n        getLevelScale: function (level) {\n            var levelScale = NaN;\n            if (level >= this.minLevel && level <= this.maxLevel) {\n                levelScale =\n                        this.levels[level].width /\n                        this.levels[this.maxLevel].width;\n            }\n            return levelScale;\n        },\n        /**\n         * @function\n         * @param {Number} level\n         */\n        getNumTiles: function (level) {\n            var scale = this.getLevelScale(level);\n            if (scale) {\n                return new $.Point(1, 1);\n            } else {\n                return new $.Point(0, 0);\n            }\n        },\n        /**\n         * @function\n         * @param {Number} level\n         * @param {OpenSeadragon.Point} point\n         */\n        getTileAtPoint: function (level, point) {\n            return new $.Point(0, 0);\n        },\n        /**\n         * Retrieves a tile url\n         * @function\n         * @param {Number} level Level of the tile\n         * @param {Number} x x coordinate of the tile\n         * @param {Number} y y coordinate of the tile\n         */\n        getTileUrl: function (level, x, y) {\n            var url = null;\n            if (level >= this.minLevel && level <= this.maxLevel) {\n                url = this.levels[level].url;\n            }\n            return url;\n        },\n        /**\n         * Retrieves a tile context 2D\n         * @function\n         * @param {Number} level Level of the tile\n         * @param {Number} x x coordinate of the tile\n         * @param {Number} y y coordinate of the tile\n         */\n        getContext2D: function (level, x, y) {\n            var context = null;\n            if (level >= this.minLevel && level <= this.maxLevel) {\n                context = this.levels[level].context2D;\n            }\n            return context;\n        },\n\n        // private\n        //\n        // Builds the differents levels of the pyramid if possible\n        // (i.e. if canvas API enabled and no canvas tainting issue).\n        _buildLevels: function () {\n            var levels = [{\n                    url: this._image.src,\n                    width: this._image.naturalWidth,\n                    height: this._image.naturalHeight\n                }];\n\n            if (!this.buildPyramid || !$.supportsCanvas || !this.useCanvas) {\n                // We don\'t need the image anymore. Allows it to be GC.\n                delete this._image;\n                return levels;\n            }\n\n            var currentWidth = this._image.naturalWidth;\n            var currentHeight = this._image.naturalHeight;\n\n            var bigCanvas = document.createElement("canvas");\n            var bigContext = bigCanvas.getContext("2d");\n\n            bigCanvas.width = currentWidth;\n            bigCanvas.height = currentHeight;\n            bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);\n            // We cache the context of the highest level because the browser\n            // is a lot faster at downsampling something it already has\n            // downsampled before.\n            levels[0].context2D = bigContext;\n            // We don\'t need the image anymore. Allows it to be GC.\n            delete this._image;\n\n            if ($.isCanvasTainted(bigCanvas)) {\n                // If the canvas is tainted, we can\'t compute the pyramid.\n                return levels;\n            }\n\n            // We build smaller levels until either width or height becomes\n            // 1 pixel wide.\n            while (currentWidth >= 2 && currentHeight >= 2) {\n                currentWidth = Math.floor(currentWidth / 2);\n                currentHeight = Math.floor(currentHeight / 2);\n                var smallCanvas = document.createElement("canvas");\n                var smallContext = smallCanvas.getContext("2d");\n                smallCanvas.width = currentWidth;\n                smallCanvas.height = currentHeight;\n                smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);\n\n                levels.splice(0, 0, {\n                    context2D: smallContext,\n                    width: currentWidth,\n                    height: currentHeight\n                });\n\n                bigCanvas = smallCanvas;\n                bigContext = smallContext;\n            }\n            return levels;\n        }\n    });\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - TileSourceCollection\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// deprecated\n$.TileSourceCollection = function( tileSize, tileSources, rows, layout  ) {\n    $.console.error(\'TileSourceCollection is deprecated; use World instead\');\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Button\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * An enumeration of button states\n * @member ButtonState\n * @memberof OpenSeadragon\n * @static\n * @type {Object}\n * @property {Number} REST\n * @property {Number} GROUP\n * @property {Number} HOVER\n * @property {Number} DOWN\n */\n$.ButtonState = {\n    REST:   0,\n    GROUP:  1,\n    HOVER:  2,\n    DOWN:   3\n};\n\n/**\n * @class Button\n * @classdesc Manages events, hover states for individual buttons, tool-tips, as well\n * as fading the buttons out when the user has not interacted with them\n * for a specified period.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @param {Object} options\n * @param {Element} [options.element=null] Element to use as the button. If not specified, an HTML &lt;button&gt; element is created.\n * @param {String} [options.tooltip=null] Provides context help for the button when the\n *  user hovers over it.\n * @param {String} [options.srcRest=null] URL of image to use in \'rest\' state.\n * @param {String} [options.srcGroup=null] URL of image to use in \'up\' state.\n * @param {String} [options.srcHover=null] URL of image to use in \'hover\' state.\n * @param {String} [options.srcDown=null] URL of image to use in \'down\' state.\n * @param {Number} [options.fadeDelay=0] How long to wait before fading.\n * @param {Number} [options.fadeLength=2000] How long should it take to fade the button.\n * @param {OpenSeadragon.EventHandler} [options.onPress=null] Event handler callback for {@link OpenSeadragon.Button.event:press}.\n * @param {OpenSeadragon.EventHandler} [options.onRelease=null] Event handler callback for {@link OpenSeadragon.Button.event:release}.\n * @param {OpenSeadragon.EventHandler} [options.onClick=null] Event handler callback for {@link OpenSeadragon.Button.event:click}.\n * @param {OpenSeadragon.EventHandler} [options.onEnter=null] Event handler callback for {@link OpenSeadragon.Button.event:enter}.\n * @param {OpenSeadragon.EventHandler} [options.onExit=null] Event handler callback for {@link OpenSeadragon.Button.event:exit}.\n * @param {OpenSeadragon.EventHandler} [options.onFocus=null] Event handler callback for {@link OpenSeadragon.Button.event:focus}.\n * @param {OpenSeadragon.EventHandler} [options.onBlur=null] Event handler callback for {@link OpenSeadragon.Button.event:blur}.\n */\n$.Button = function( options ) {\n\n    var _this = this;\n\n    $.EventSource.call( this );\n\n    $.extend( true, this, {\n\n        tooltip:            null,\n        srcRest:            null,\n        srcGroup:           null,\n        srcHover:           null,\n        srcDown:            null,\n        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,\n        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,\n        /**\n         * How long to wait before fading.\n         * @member {Number} fadeDelay\n         * @memberof OpenSeadragon.Button#\n         */\n        fadeDelay:          0,\n        /**\n         * How long should it take to fade the button.\n         * @member {Number} fadeLength\n         * @memberof OpenSeadragon.Button#\n         */\n        fadeLength:         2000,\n        onPress:            null,\n        onRelease:          null,\n        onClick:            null,\n        onEnter:            null,\n        onExit:             null,\n        onFocus:            null,\n        onBlur:             null\n\n    }, options );\n\n    /**\n     * The button element.\n     * @member {Element} element\n     * @memberof OpenSeadragon.Button#\n     */\n    this.element        = options.element   || $.makeNeutralElement( "div" );\n\n    //if the user has specified the element to bind the control to explicitly\n    //then do not add the default control images\n    if ( !options.element ) {\n        this.imgRest      = $.makeTransparentImage( this.srcRest );\n        this.imgGroup     = $.makeTransparentImage( this.srcGroup );\n        this.imgHover     = $.makeTransparentImage( this.srcHover );\n        this.imgDown      = $.makeTransparentImage( this.srcDown );\n\n        this.imgRest.alt  =\n        this.imgGroup.alt =\n        this.imgHover.alt =\n        this.imgDown.alt  =\n            this.tooltip;\n\n        this.element.style.position = "relative";\n        $.setElementTouchActionNone( this.element );\n\n        this.imgGroup.style.position =\n        this.imgHover.style.position =\n        this.imgDown.style.position  =\n            "absolute";\n\n        this.imgGroup.style.top =\n        this.imgHover.style.top =\n        this.imgDown.style.top  =\n            "0px";\n\n        this.imgGroup.style.left =\n        this.imgHover.style.left =\n        this.imgDown.style.left  =\n            "0px";\n\n        this.imgHover.style.visibility =\n        this.imgDown.style.visibility  =\n            "hidden";\n\n        if ( $.Browser.vendor == $.BROWSERS.FIREFOX  && $.Browser.version < 3 ){\n            this.imgGroup.style.top =\n            this.imgHover.style.top =\n            this.imgDown.style.top  =\n                "";\n        }\n\n        this.element.appendChild( this.imgRest );\n        this.element.appendChild( this.imgGroup );\n        this.element.appendChild( this.imgHover );\n        this.element.appendChild( this.imgDown );\n    }\n\n\n    this.addHandler( "press",     this.onPress );\n    this.addHandler( "release",   this.onRelease );\n    this.addHandler( "click",     this.onClick );\n    this.addHandler( "enter",     this.onEnter );\n    this.addHandler( "exit",      this.onExit );\n    this.addHandler( "focus",     this.onFocus );\n    this.addHandler( "blur",      this.onBlur );\n\n    /**\n     * The button\'s current state.\n     * @member {OpenSeadragon.ButtonState} currentState\n     * @memberof OpenSeadragon.Button#\n     */\n    this.currentState = $.ButtonState.GROUP;\n\n    // When the button last began to fade.\n    this.fadeBeginTime  = null;\n    // Whether this button should fade after user stops interacting with the viewport.\n    this.shouldFade     = false;\n\n    this.element.style.display  = "inline-block";\n    this.element.style.position = "relative";\n    this.element.title          = this.tooltip;\n\n    /**\n     * Tracks mouse/touch/key events on the button.\n     * @member {OpenSeadragon.MouseTracker} tracker\n     * @memberof OpenSeadragon.Button#\n     */\n    this.tracker = new $.MouseTracker({\n\n        element:            this.element,\n        clickTimeThreshold: this.clickTimeThreshold,\n        clickDistThreshold: this.clickDistThreshold,\n\n        enterHandler: function( event ) {\n            if ( event.insideElementPressed ) {\n                inTo( _this, $.ButtonState.DOWN );\n                /**\n                 * Raised when the cursor enters the Button element.\n                 *\n                 * @event enter\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "enter", { originalEvent: event.originalEvent } );\n            } else if ( !event.buttonDownAny ) {\n                inTo( _this, $.ButtonState.HOVER );\n            }\n        },\n\n        focusHandler: function ( event ) {\n            this.enterHandler( event );\n            /**\n             * Raised when the Button element receives focus.\n             *\n             * @event focus\n             * @memberof OpenSeadragon.Button\n             * @type {object}\n             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n             * @property {Object} originalEvent - The original DOM event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( "focus", { originalEvent: event.originalEvent } );\n        },\n\n        exitHandler: function( event ) {\n            outTo( _this, $.ButtonState.GROUP );\n            if ( event.insideElementPressed ) {\n                /**\n                 * Raised when the cursor leaves the Button element.\n                 *\n                 * @event exit\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "exit", { originalEvent: event.originalEvent } );\n            }\n        },\n\n        blurHandler: function ( event ) {\n            this.exitHandler( event );\n            /**\n             * Raised when the Button element loses focus.\n             *\n             * @event blur\n             * @memberof OpenSeadragon.Button\n             * @type {object}\n             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n             * @property {Object} originalEvent - The original DOM event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( "blur", { originalEvent: event.originalEvent } );\n        },\n\n        pressHandler: function ( event ) {\n            inTo( _this, $.ButtonState.DOWN );\n            /**\n             * Raised when a mouse button is pressed or touch occurs in the Button element.\n             *\n             * @event press\n             * @memberof OpenSeadragon.Button\n             * @type {object}\n             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n             * @property {Object} originalEvent - The original DOM event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            _this.raiseEvent( "press", { originalEvent: event.originalEvent } );\n        },\n\n        releaseHandler: function( event ) {\n            if ( event.insideElementPressed && event.insideElementReleased ) {\n                outTo( _this, $.ButtonState.HOVER );\n                /**\n                 * Raised when the mouse button is released or touch ends in the Button element.\n                 *\n                 * @event release\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );\n            } else if ( event.insideElementPressed ) {\n                outTo( _this, $.ButtonState.GROUP );\n            } else {\n                inTo( _this, $.ButtonState.HOVER );\n            }\n        },\n\n        clickHandler: function( event ) {\n            if ( event.quick ) {\n                /**\n                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.\n                 *\n                 * @event click\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent("click", { originalEvent: event.originalEvent });\n            }\n        },\n\n        keyHandler: function( event ){\n            //console.log( "%s : handling key %s!", _this.tooltip, event.keyCode);\n            if( 13 === event.keyCode ){\n                /***\n                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.\n                 *\n                 * @event click\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "click", { originalEvent: event.originalEvent } );\n                /***\n                 * Raised when the mouse button is released or touch ends in the Button element.\n                 *\n                 * @event release\n                 * @memberof OpenSeadragon.Button\n                 * @type {object}\n                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.\n                 * @property {Object} originalEvent - The original DOM event.\n                 * @property {?Object} userData - Arbitrary subscriber-defined object.\n                 */\n                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );\n                return false;\n            }\n            return true;\n        }\n\n    });\n\n    outTo( this, $.ButtonState.REST );\n};\n\n$.extend( $.Button.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.Button.prototype */{\n\n    /**\n     * TODO: Determine what this function is intended to do and if it\'s actually\n     * useful as an API point.\n     * @function\n     */\n    notifyGroupEnter: function() {\n        inTo( this, $.ButtonState.GROUP );\n    },\n\n    /**\n     * TODO: Determine what this function is intended to do and if it\'s actually\n     * useful as an API point.\n     * @function\n     */\n    notifyGroupExit: function() {\n        outTo( this, $.ButtonState.REST );\n    },\n\n    /**\n     * @function\n     */\n    disable: function(){\n        this.notifyGroupExit();\n        this.element.disabled = true;\n        $.setElementOpacity( this.element, 0.2, true );\n    },\n\n    /**\n     * @function\n     */\n    enable: function(){\n        this.element.disabled = false;\n        $.setElementOpacity( this.element, 1.0, true );\n        this.notifyGroupEnter();\n    }\n\n});\n\n\nfunction scheduleFade( button ) {\n    $.requestAnimationFrame(function(){\n        updateFade( button );\n    });\n}\n\nfunction updateFade( button ) {\n    var currentTime,\n        deltaTime,\n        opacity;\n\n    if ( button.shouldFade ) {\n        currentTime = $.now();\n        deltaTime   = currentTime - button.fadeBeginTime;\n        opacity     = 1.0 - deltaTime / button.fadeLength;\n        opacity     = Math.min( 1.0, opacity );\n        opacity     = Math.max( 0.0, opacity );\n\n        if( button.imgGroup ){\n            $.setElementOpacity( button.imgGroup, opacity, true );\n        }\n        if ( opacity > 0 ) {\n            // fade again\n            scheduleFade( button );\n        }\n    }\n}\n\nfunction beginFading( button ) {\n    button.shouldFade = true;\n    button.fadeBeginTime = $.now() + button.fadeDelay;\n    window.setTimeout( function(){\n        scheduleFade( button );\n    }, button.fadeDelay );\n}\n\nfunction stopFading( button ) {\n    button.shouldFade = false;\n    if( button.imgGroup ){\n        $.setElementOpacity( button.imgGroup, 1.0, true );\n    }\n}\n\nfunction inTo( button, newState ) {\n\n    if( button.element.disabled ){\n        return;\n    }\n\n    if ( newState >= $.ButtonState.GROUP &&\n         button.currentState == $.ButtonState.REST ) {\n        stopFading( button );\n        button.currentState = $.ButtonState.GROUP;\n    }\n\n    if ( newState >= $.ButtonState.HOVER &&\n         button.currentState == $.ButtonState.GROUP ) {\n        if( button.imgHover ){\n            button.imgHover.style.visibility = "";\n        }\n        button.currentState = $.ButtonState.HOVER;\n    }\n\n    if ( newState >= $.ButtonState.DOWN &&\n         button.currentState == $.ButtonState.HOVER ) {\n        if( button.imgDown ){\n            button.imgDown.style.visibility = "";\n        }\n        button.currentState = $.ButtonState.DOWN;\n    }\n}\n\n\nfunction outTo( button, newState ) {\n\n    if( button.element.disabled ){\n        return;\n    }\n\n    if ( newState <= $.ButtonState.HOVER &&\n         button.currentState == $.ButtonState.DOWN ) {\n        if( button.imgDown ){\n            button.imgDown.style.visibility = "hidden";\n        }\n        button.currentState = $.ButtonState.HOVER;\n    }\n\n    if ( newState <= $.ButtonState.GROUP &&\n         button.currentState == $.ButtonState.HOVER ) {\n        if( button.imgHover ){\n            button.imgHover.style.visibility = "hidden";\n        }\n        button.currentState = $.ButtonState.GROUP;\n    }\n\n    if ( newState <= $.ButtonState.REST &&\n         button.currentState == $.ButtonState.GROUP ) {\n        beginFading( button );\n        button.currentState = $.ButtonState.REST;\n    }\n}\n\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ButtonGroup\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n/**\n * @class ButtonGroup\n * @classdesc Manages events on groups of buttons.\n *\n * @memberof OpenSeadragon\n * @param {Object} options - A dictionary of settings applied against the entire group of buttons.\n * @param {Array} options.buttons Array of buttons\n * @param {Element} [options.element] Element to use as the container\n **/\n$.ButtonGroup = function( options ) {\n\n    $.extend( true, this, {\n        /**\n         * An array containing the buttons themselves.\n         * @member {Array} buttons\n         * @memberof OpenSeadragon.ButtonGroup#\n         */\n        buttons:            [],\n        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,\n        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,\n        labelText:          ""\n    }, options );\n\n    // copy the button elements  TODO: Why?\n    var buttons = this.buttons.concat([]),\n        _this = this,\n        i;\n\n    /**\n     * The shared container for the buttons.\n     * @member {Element} element\n     * @memberof OpenSeadragon.ButtonGroup#\n     */\n    this.element = options.element || $.makeNeutralElement( "div" );\n\n    // TODO What if there IS an options.group specified?\n    if( !options.group ){\n        this.label   = $.makeNeutralElement( "label" );\n        //TODO: support labels for ButtonGroups\n        //this.label.innerHTML = this.labelText;\n        this.element.style.display = "inline-block";\n        this.element.appendChild( this.label );\n        for ( i = 0; i < buttons.length; i++ ) {\n            this.element.appendChild( buttons[ i ].element );\n        }\n    }\n\n    $.setElementTouchActionNone( this.element );\n\n    /**\n     * Tracks mouse/touch/key events accross the group of buttons.\n     * @member {OpenSeadragon.MouseTracker} tracker\n     * @memberof OpenSeadragon.ButtonGroup#\n     */\n    this.tracker = new $.MouseTracker({\n        element:            this.element,\n        clickTimeThreshold: this.clickTimeThreshold,\n        clickDistThreshold: this.clickDistThreshold,\n        enterHandler: function ( event ) {\n            var i;\n            for ( i = 0; i < _this.buttons.length; i++ ) {\n                _this.buttons[ i ].notifyGroupEnter();\n            }\n        },\n        exitHandler: function ( event ) {\n            var i;\n            if ( !event.insideElementPressed ) {\n                for ( i = 0; i < _this.buttons.length; i++ ) {\n                    _this.buttons[ i ].notifyGroupExit();\n                }\n            }\n        },\n    });\n};\n\n/** @lends OpenSeadragon.ButtonGroup.prototype */\n$.ButtonGroup.prototype = {\n\n    /**\n     * TODO: Figure out why this is used on the public API and if a more useful\n     * api can be created.\n     * @function\n     * @private\n     */\n    emulateEnter: function() {\n        this.tracker.enterHandler( { eventSource: this.tracker } );\n    },\n\n    /**\n     * TODO: Figure out why this is used on the public API and if a more useful\n     * api can be created.\n     * @function\n     * @private\n     */\n    emulateExit: function() {\n        this.tracker.exitHandler( { eventSource: this.tracker } );\n    }\n};\n\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Rect\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($) {\n\n/**\n * @class Rect\n * @classdesc A Rectangle is described by it top left coordinates (x, y), width,\n * height and degrees of rotation around (x, y).\n * Note that the coordinate system used is the one commonly used with images:\n * x increases when going to the right\n * y increases when going to the bottom\n * degrees increases clockwise with 0 being the horizontal\n *\n * The constructor normalizes the rectangle to always have 0 <= degrees < 90\n *\n * @memberof OpenSeadragon\n * @param {Number} [x=0] The vector component \'x\'.\n * @param {Number} [y=0] The vector component \'y\'.\n * @param {Number} [width=0] The vector component \'width\'.\n * @param {Number} [height=0] The vector component \'height\'.\n * @param {Number} [degrees=0] Rotation of the rectangle around (x,y) in degrees.\n */\n$.Rect = function(x, y, width, height, degrees) {\n    /**\n     * The vector component \'x\'.\n     * @member {Number} x\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.x = typeof(x) === "number" ? x : 0;\n    /**\n     * The vector component \'y\'.\n     * @member {Number} y\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.y = typeof(y) === "number" ? y : 0;\n    /**\n     * The vector component \'width\'.\n     * @member {Number} width\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.width  = typeof(width) === "number" ? width : 0;\n    /**\n     * The vector component \'height\'.\n     * @member {Number} height\n     * @memberof OpenSeadragon.Rect#\n     */\n    this.height = typeof(height) === "number" ? height : 0;\n\n    this.degrees = typeof(degrees) === "number" ? degrees : 0;\n\n    // Normalizes the rectangle.\n    this.degrees = this.degrees % 360;\n    if (this.degrees < 0) {\n        this.degrees += 360;\n    }\n    var newTopLeft, newWidth;\n    if (this.degrees >= 270) {\n        newTopLeft = this.getTopRight();\n        this.x = newTopLeft.x;\n        this.y = newTopLeft.y;\n        newWidth = this.height;\n        this.height = this.width;\n        this.width = newWidth;\n        this.degrees -= 270;\n    } else if (this.degrees >= 180) {\n        newTopLeft = this.getBottomRight();\n        this.x = newTopLeft.x;\n        this.y = newTopLeft.y;\n        this.degrees -= 180;\n    } else if (this.degrees >= 90) {\n        newTopLeft = this.getBottomLeft();\n        this.x = newTopLeft.x;\n        this.y = newTopLeft.y;\n        newWidth = this.height;\n        this.height = this.width;\n        this.width = newWidth;\n        this.degrees -= 90;\n    }\n};\n\n/**\n * Builds a rectangle having the 3 specified points as summits.\n * @static\n * @memberof OpenSeadragon.Rect\n * @param {OpenSeadragon.Point} topLeft\n * @param {OpenSeadragon.Point} topRight\n * @param {OpenSeadragon.Point} bottomLeft\n * @returns {OpenSeadragon.Rect}\n */\n$.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {\n    var width = topLeft.distanceTo(topRight);\n    var height = topLeft.distanceTo(bottomLeft);\n    var diff = topRight.minus(topLeft);\n    var radians = Math.atan(diff.y / diff.x);\n    if (diff.x < 0) {\n        radians += Math.PI;\n    } else if (diff.y < 0) {\n        radians += 2 * Math.PI;\n    }\n    return new $.Rect(\n        topLeft.x,\n        topLeft.y,\n        width,\n        height,\n        radians / Math.PI * 180);\n};\n\n/** @lends OpenSeadragon.Rect.prototype */\n$.Rect.prototype = {\n    /**\n     * @function\n     * @returns {OpenSeadragon.Rect} a duplicate of this Rect\n     */\n    clone: function() {\n        return new $.Rect(\n            this.x,\n            this.y,\n            this.width,\n            this.height,\n            this.degrees);\n    },\n\n    /**\n     * The aspect ratio is simply the ratio of width to height.\n     * @function\n     * @returns {Number} The ratio of width to height.\n     */\n    getAspectRatio: function() {\n        return this.width / this.height;\n    },\n\n    /**\n     * Provides the coordinates of the upper-left corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of\n     *  the rectangle.\n     */\n    getTopLeft: function() {\n        return new $.Point(\n            this.x,\n            this.y\n        );\n    },\n\n    /**\n     * Provides the coordinates of the bottom-right corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of\n     *  the rectangle.\n     */\n    getBottomRight: function() {\n        return new $.Point(this.x + this.width, this.y + this.height)\n            .rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Provides the coordinates of the top-right corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of\n     *  the rectangle.\n     */\n    getTopRight: function() {\n        return new $.Point(this.x + this.width, this.y)\n            .rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Provides the coordinates of the bottom-left corner of the rectangle as a\n     * point.\n     * @function\n     * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of\n     *  the rectangle.\n     */\n    getBottomLeft: function() {\n        return new $.Point(this.x, this.y + this.height)\n            .rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Computes the center of the rectangle.\n     * @function\n     * @returns {OpenSeadragon.Point} The center of the rectangle as represented\n     *  as represented by a 2-dimensional vector (x,y)\n     */\n    getCenter: function() {\n        return new $.Point(\n            this.x + this.width / 2.0,\n            this.y + this.height / 2.0\n        ).rotate(this.degrees, this.getTopLeft());\n    },\n\n    /**\n     * Returns the width and height component as a vector OpenSeadragon.Point\n     * @function\n     * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the\n     *  the width and height of the rectangle.\n     */\n    getSize: function() {\n        return new $.Point(this.width, this.height);\n    },\n\n    /**\n     * Determines if two Rectangles have equivalent components.\n     * @function\n     * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.\n     * @return {Boolean} \'true\' if all components are equal, otherwise \'false\'.\n     */\n    equals: function(other) {\n        return (other instanceof $.Rect) &&\n            this.x === other.x &&\n            this.y === other.y &&\n            this.width === other.width &&\n            this.height === other.height &&\n            this.degrees === other.degrees;\n    },\n\n    /**\n    * Multiply all dimensions (except degrees) in this Rect by a factor and\n    * return a new Rect.\n    * @function\n    * @param {Number} factor The factor to multiply vector components.\n    * @returns {OpenSeadragon.Rect} A new rect representing the multiplication\n    *  of the vector components by the factor\n    */\n    times: function(factor) {\n        return new $.Rect(\n            this.x * factor,\n            this.y * factor,\n            this.width * factor,\n            this.height * factor,\n            this.degrees);\n    },\n\n    /**\n    * Translate/move this Rect by a vector and return new Rect.\n    * @function\n    * @param {OpenSeadragon.Point} delta The translation vector.\n    * @returns {OpenSeadragon.Rect} A new rect with altered position\n    */\n    translate: function(delta) {\n        return new $.Rect(\n            this.x + delta.x,\n            this.y + delta.y,\n            this.width,\n            this.height,\n            this.degrees);\n    },\n\n    /**\n     * Returns the smallest rectangle that will contain this and the given\n     * rectangle bounding boxes.\n     * @param {OpenSeadragon.Rect} rect\n     * @return {OpenSeadragon.Rect} The new rectangle.\n     */\n    union: function(rect) {\n        var thisBoundingBox = this.getBoundingBox();\n        var otherBoundingBox = rect.getBoundingBox();\n\n        var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);\n        var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);\n        var right = Math.max(\n            thisBoundingBox.x + thisBoundingBox.width,\n            otherBoundingBox.x + otherBoundingBox.width);\n        var bottom = Math.max(\n            thisBoundingBox.y + thisBoundingBox.height,\n            otherBoundingBox.y + otherBoundingBox.height);\n\n        return new $.Rect(\n            left,\n            top,\n            right - left,\n            bottom - top);\n    },\n\n    /**\n     * Returns the bounding box of the intersection of this rectangle with the\n     * given rectangle.\n     * @param {OpenSeadragon.Rect} rect\n     * @return {OpenSeadragon.Rect} the bounding box of the intersection\n     * or null if the rectangles don\'t intersect.\n     */\n    intersection: function(rect) {\n        // Simplified version of Weiler Atherton clipping algorithm\n        // https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm\n        // Because we just want the bounding box of the intersection,\n        // we can just compute the bounding box of:\n        // 1. all the summits of this which are inside rect\n        // 2. all the summits of rect which are inside this\n        // 3. all the intersections of rect and this\n        var EPSILON = 0.0000000001;\n\n        var intersectionPoints = [];\n\n        var thisTopLeft = this.getTopLeft();\n        if (rect.containsPoint(thisTopLeft, EPSILON)) {\n            intersectionPoints.push(thisTopLeft);\n        }\n        var thisTopRight = this.getTopRight();\n        if (rect.containsPoint(thisTopRight, EPSILON)) {\n            intersectionPoints.push(thisTopRight);\n        }\n        var thisBottomLeft = this.getBottomLeft();\n        if (rect.containsPoint(thisBottomLeft, EPSILON)) {\n            intersectionPoints.push(thisBottomLeft);\n        }\n        var thisBottomRight = this.getBottomRight();\n        if (rect.containsPoint(thisBottomRight, EPSILON)) {\n            intersectionPoints.push(thisBottomRight);\n        }\n\n        var rectTopLeft = rect.getTopLeft();\n        if (this.containsPoint(rectTopLeft, EPSILON)) {\n            intersectionPoints.push(rectTopLeft);\n        }\n        var rectTopRight = rect.getTopRight();\n        if (this.containsPoint(rectTopRight, EPSILON)) {\n            intersectionPoints.push(rectTopRight);\n        }\n        var rectBottomLeft = rect.getBottomLeft();\n        if (this.containsPoint(rectBottomLeft, EPSILON)) {\n            intersectionPoints.push(rectBottomLeft);\n        }\n        var rectBottomRight = rect.getBottomRight();\n        if (this.containsPoint(rectBottomRight, EPSILON)) {\n            intersectionPoints.push(rectBottomRight);\n        }\n\n        var thisSegments = this._getSegments();\n        var rectSegments = rect._getSegments();\n        for (var i = 0; i < thisSegments.length; i++) {\n            var thisSegment = thisSegments[i];\n            for (var j = 0; j < rectSegments.length; j++) {\n                var rectSegment = rectSegments[j];\n                var intersect = getIntersection(thisSegment[0], thisSegment[1],\n                    rectSegment[0], rectSegment[1]);\n                if (intersect) {\n                    intersectionPoints.push(intersect);\n                }\n            }\n        }\n\n        // Get intersection point of segments [a,b] and [c,d]\n        function getIntersection(a, b, c, d) {\n            // http://stackoverflow.com/a/1968345/1440403\n            var abVector = b.minus(a);\n            var cdVector = d.minus(c);\n\n            var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;\n            if (denom === 0) {\n                return null;\n            }\n\n            var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;\n            var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;\n\n            if (-EPSILON <= s && s <= 1 - EPSILON &&\n                -EPSILON <= t && t <= 1 - EPSILON) {\n                return new $.Point(a.x + t * abVector.x, a.y + t * abVector.y);\n            }\n            return null;\n        }\n\n        if (intersectionPoints.length === 0) {\n            return null;\n        }\n\n        var minX = intersectionPoints[0].x;\n        var maxX = intersectionPoints[0].x;\n        var minY = intersectionPoints[0].y;\n        var maxY = intersectionPoints[0].y;\n        for (var k = 1; k < intersectionPoints.length; k++) {\n            var point = intersectionPoints[k];\n            if (point.x < minX) {\n                minX = point.x;\n            }\n            if (point.x > maxX) {\n                maxX = point.x;\n            }\n            if (point.y < minY) {\n                minY = point.y;\n            }\n            if (point.y > maxY) {\n                maxY = point.y;\n            }\n        }\n        return new $.Rect(minX, minY, maxX - minX, maxY - minY);\n    },\n\n    // private\n    _getSegments: function() {\n        var topLeft = this.getTopLeft();\n        var topRight = this.getTopRight();\n        var bottomLeft = this.getBottomLeft();\n        var bottomRight = this.getBottomRight();\n        return [[topLeft, topRight],\n            [topRight, bottomRight],\n            [bottomRight, bottomLeft],\n            [bottomLeft, topLeft]];\n    },\n\n    /**\n     * Rotates a rectangle around a point.\n     * @function\n     * @param {Number} degrees The angle in degrees to rotate.\n     * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.\n     * Defaults to the center of the rectangle.\n     * @return {OpenSeadragon.Rect}\n     */\n    rotate: function(degrees, pivot) {\n        degrees = degrees % 360;\n        if (degrees === 0) {\n            return this.clone();\n        }\n        if (degrees < 0) {\n            degrees += 360;\n        }\n\n        pivot = pivot || this.getCenter();\n        var newTopLeft = this.getTopLeft().rotate(degrees, pivot);\n        var newTopRight = this.getTopRight().rotate(degrees, pivot);\n\n        var diff = newTopRight.minus(newTopLeft);\n        var radians = Math.atan(diff.y / diff.x);\n        if (diff.x < 0) {\n            radians += Math.PI;\n        } else if (diff.y < 0) {\n            radians += 2 * Math.PI;\n        }\n        return new $.Rect(\n            newTopLeft.x,\n            newTopLeft.y,\n            this.width,\n            this.height,\n            radians / Math.PI * 180);\n    },\n\n    /**\n     * Retrieves the smallest horizontal (degrees=0) rectangle which contains\n     * this rectangle.\n     * @returns {OpenSeadragon.Rect}\n     */\n    getBoundingBox: function() {\n        if (this.degrees === 0) {\n            return this.clone();\n        }\n        var topLeft = this.getTopLeft();\n        var topRight = this.getTopRight();\n        var bottomLeft = this.getBottomLeft();\n        var bottomRight = this.getBottomRight();\n        var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);\n        var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);\n        var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);\n        var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);\n        return new $.Rect(\n            minX,\n            minY,\n            maxX - minX,\n            maxY - minY);\n    },\n\n    /**\n     * Retrieves the smallest horizontal (degrees=0) rectangle which contains\n     * this rectangle and has integers x, y, width and height\n     * @returns {OpenSeadragon.Rect}\n     */\n    getIntegerBoundingBox: function() {\n        var boundingBox = this.getBoundingBox();\n        var x = Math.floor(boundingBox.x);\n        var y = Math.floor(boundingBox.y);\n        var width = Math.ceil(boundingBox.width + boundingBox.x - x);\n        var height = Math.ceil(boundingBox.height + boundingBox.y - y);\n        return new $.Rect(x, y, width, height);\n    },\n\n    /**\n     * Determines whether a point is inside this rectangle (edge included).\n     * @function\n     * @param {OpenSeadragon.Point} point\n     * @param {Number} [epsilon=0] the margin of error allowed\n     * @returns {Boolean} true if the point is inside this rectangle, false\n     * otherwise.\n     */\n    containsPoint: function(point, epsilon) {\n        epsilon = epsilon || 0;\n\n        // See http://stackoverflow.com/a/2752754/1440403 for explanation\n        var topLeft = this.getTopLeft();\n        var topRight = this.getTopRight();\n        var bottomLeft = this.getBottomLeft();\n        var topDiff = topRight.minus(topLeft);\n        var leftDiff = bottomLeft.minus(topLeft);\n\n        return ((point.x - topLeft.x) * topDiff.x +\n            (point.y - topLeft.y) * topDiff.y >= -epsilon) &&\n\n            ((point.x - topRight.x) * topDiff.x +\n            (point.y - topRight.y) * topDiff.y <= epsilon) &&\n\n            ((point.x - topLeft.x) * leftDiff.x +\n            (point.y - topLeft.y) * leftDiff.y >= -epsilon) &&\n\n            ((point.x - bottomLeft.x) * leftDiff.x +\n            (point.y - bottomLeft.y) * leftDiff.y <= epsilon);\n    },\n\n    /**\n     * Provides a string representation of the rectangle which is useful for\n     * debugging.\n     * @function\n     * @returns {String} A string representation of the rectangle.\n     */\n    toString: function() {\n        return "[" +\n            (Math.round(this.x * 100) / 100) + ", " +\n            (Math.round(this.y * 100) / 100) + ", " +\n            (Math.round(this.width * 100) / 100) + "x" +\n            (Math.round(this.height * 100) / 100) + ", " +\n            (Math.round(this.degrees * 100) / 100) + "deg" +\n            "]";\n    }\n};\n\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - ReferenceStrip\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function ( $ ) {\n\n// dictionary from id to private properties\nvar THIS = {};\n\n/**\n *  The CollectionDrawer is a reimplementation if the Drawer API that\n *  focuses on allowing a viewport to be redefined as a collection\n *  of smaller viewports, defined by a clear number of rows and / or\n *  columns of which each item in the matrix of viewports has its own\n *  source.\n *\n *  This idea is a reexpression of the idea of dzi collections\n *  which allows a clearer algorithm to reuse the tile sources already\n *  supported by OpenSeadragon, in heterogenious or homogenious\n *  sequences just like mixed groups already supported by the viewer\n *  for the purpose of image sequnces.\n *\n *  TODO:   The difficult part of this feature is figuring out how to express\n *          this functionality as a combination of the functionality already\n *          provided by Drawer, Viewport, TileSource, and Navigator.  It may\n *          require better abstraction at those points in order to effeciently\n *          reuse those paradigms.\n */\n/**\n * @class ReferenceStrip\n * @memberof OpenSeadragon\n * @param {Object} options\n */\n$.ReferenceStrip = function ( options ) {\n\n    var _this       = this,\n        viewer      = options.viewer,\n        viewerSize  = $.getElementSize( viewer.element ),\n        element,\n        style,\n        i;\n\n    //We may need to create a new element and id if they did not\n    //provide the id for the existing element\n    if ( !options.id ) {\n        options.id              = \'referencestrip-\' + $.now();\n        this.element            = $.makeNeutralElement( "div" );\n        this.element.id         = options.id;\n        this.element.className  = \'referencestrip\';\n    }\n\n    options = $.extend( true, {\n        sizeRatio:  $.DEFAULT_SETTINGS.referenceStripSizeRatio,\n        position:   $.DEFAULT_SETTINGS.referenceStripPosition,\n        scroll:     $.DEFAULT_SETTINGS.referenceStripScroll,\n        clickTimeThreshold:  $.DEFAULT_SETTINGS.clickTimeThreshold\n    }, options, {\n        //required overrides\n        element:                this.element,\n        //These need to be overridden to prevent recursion since\n        //the navigator is a viewer and a viewer has a navigator\n        showNavigator:          false,\n        mouseNavEnabled:        false,\n        showNavigationControl:  false,\n        showSequenceControl:    false\n    } );\n\n    $.extend( this, options );\n    //Private state properties\n    THIS[this.id] = {\n        "animating":           false\n    };\n\n    this.minPixelRatio = this.viewer.minPixelRatio;\n\n    style = this.element.style;\n    style.marginTop     = \'0px\';\n    style.marginRight   = \'0px\';\n    style.marginBottom  = \'0px\';\n    style.marginLeft    = \'0px\';\n    style.left          = \'0px\';\n    style.bottom        = \'0px\';\n    style.border        = \'0px\';\n    style.background    = \'#000\';\n    style.position      = \'relative\';\n\n    $.setElementTouchActionNone( this.element );\n\n    $.setElementOpacity( this.element, 0.8 );\n\n    this.viewer = viewer;\n    this.innerTracker = new $.MouseTracker( {\n        element:        this.element,\n        dragHandler:    $.delegate( this, onStripDrag ),\n        scrollHandler:  $.delegate( this, onStripScroll ),\n        enterHandler:   $.delegate( this, onStripEnter ),\n        exitHandler:    $.delegate( this, onStripExit ),\n        keyDownHandler: $.delegate( this, onKeyDown ),\n        keyHandler:     $.delegate( this, onKeyPress )\n    } );\n\n    //Controls the position and orientation of the reference strip and sets the\n    //appropriate width and height\n    if ( options.width && options.height ) {\n        this.element.style.width  = options.width + \'px\';\n        this.element.style.height = options.height + \'px\';\n        viewer.addControl(\n            this.element,\n            { anchor: $.ControlAnchor.BOTTOM_LEFT }\n        );\n    } else {\n        if ( "horizontal" == options.scroll ) {\n            this.element.style.width = (\n                viewerSize.x *\n                options.sizeRatio *\n                viewer.tileSources.length\n            ) + ( 12 * viewer.tileSources.length ) + \'px\';\n\n            this.element.style.height = (\n                viewerSize.y *\n                options.sizeRatio\n            ) + \'px\';\n\n            viewer.addControl(\n                this.element,\n                { anchor: $.ControlAnchor.BOTTOM_LEFT }\n            );\n        } else {\n            this.element.style.height = (\n                viewerSize.y *\n                options.sizeRatio *\n                viewer.tileSources.length\n            ) + ( 12 * viewer.tileSources.length ) + \'px\';\n\n            this.element.style.width = (\n                viewerSize.x *\n                options.sizeRatio\n            ) + \'px\';\n\n            viewer.addControl(\n                this.element,\n                { anchor: $.ControlAnchor.TOP_LEFT }\n            );\n\n        }\n    }\n\n    this.panelWidth = ( viewerSize.x * this.sizeRatio ) + 8;\n    this.panelHeight = ( viewerSize.y * this.sizeRatio ) + 8;\n    this.panels = [];\n\n    /*jshint loopfunc:true*/\n    for ( i = 0; i < viewer.tileSources.length; i++ ) {\n\n        element = $.makeNeutralElement( \'div\' );\n        element.id = this.element.id + "-" + i;\n\n        element.style.width         = _this.panelWidth + \'px\';\n        element.style.height        = _this.panelHeight + \'px\';\n        element.style.display       = \'inline\';\n        element.style.float         = \'left\'; //Webkit\n        element.style.cssFloat      = \'left\'; //Firefox\n        element.style.styleFloat    = \'left\'; //IE\n        element.style.padding       = \'2px\';\n        $.setElementTouchActionNone( element );\n\n        element.innerTracker = new $.MouseTracker( {\n            element:            element,\n            clickTimeThreshold: this.clickTimeThreshold,\n            clickDistThreshold: this.clickDistThreshold,\n            pressHandler: function ( event ) {\n                event.eventSource.dragging = $.now();\n            },\n            releaseHandler: function ( event ) {\n                var tracker = event.eventSource,\n                    id      = tracker.element.id,\n                    page    = Number( id.split( \'-\' )[2] ),\n                    now     = $.now();\n\n                if ( event.insideElementPressed &&\n                     event.insideElementReleased &&\n                     tracker.dragging &&\n                     ( now - tracker.dragging ) < tracker.clickTimeThreshold ) {\n                    tracker.dragging = null;\n                    viewer.goToPage( page );\n                }\n            }\n        } );\n\n        this.element.appendChild( element );\n\n        element.activePanel = false;\n\n        this.panels.push( element );\n\n    }\n    loadPanels( this, this.scroll == \'vertical\' ? viewerSize.y : viewerSize.x, 0 );\n    this.setFocus( 0 );\n\n};\n\n$.extend( $.ReferenceStrip.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.ReferenceStrip.prototype */{\n\n    /**\n     * @function\n     */\n    setFocus: function ( page ) {\n        var element      = $.getElement( this.element.id + \'-\' + page ),\n            viewerSize   = $.getElementSize( this.viewer.canvas ),\n            scrollWidth  = Number( this.element.style.width.replace( \'px\', \'\' ) ),\n            scrollHeight = Number( this.element.style.height.replace( \'px\', \'\' ) ),\n            offsetLeft   = -Number( this.element.style.marginLeft.replace( \'px\', \'\' ) ),\n            offsetTop    = -Number( this.element.style.marginTop.replace( \'px\', \'\' ) ),\n            offset;\n\n        if ( this.currentSelected !== element ) {\n            if ( this.currentSelected ) {\n                this.currentSelected.style.background = \'#000\';\n            }\n            this.currentSelected = element;\n            this.currentSelected.style.background = \'#999\';\n\n            if ( \'horizontal\' == this.scroll ) {\n                //right left\n                offset = ( Number( page ) ) * ( this.panelWidth + 3 );\n                if ( offset > offsetLeft + viewerSize.x - this.panelWidth ) {\n                    offset = Math.min( offset, ( scrollWidth - viewerSize.x ) );\n                    this.element.style.marginLeft = -offset + \'px\';\n                    loadPanels( this, viewerSize.x, -offset );\n                } else if ( offset < offsetLeft ) {\n                    offset = Math.max( 0, offset - viewerSize.x / 2 );\n                    this.element.style.marginLeft = -offset + \'px\';\n                    loadPanels( this, viewerSize.x, -offset );\n                }\n            } else {\n                offset = ( Number( page ) ) * ( this.panelHeight + 3 );\n                if ( offset > offsetTop + viewerSize.y - this.panelHeight ) {\n                    offset = Math.min( offset, ( scrollHeight - viewerSize.y ) );\n                    this.element.style.marginTop = -offset + \'px\';\n                    loadPanels( this, viewerSize.y, -offset );\n                } else if ( offset < offsetTop ) {\n                    offset = Math.max( 0, offset - viewerSize.y / 2 );\n                    this.element.style.marginTop = -offset + \'px\';\n                    loadPanels( this, viewerSize.y, -offset );\n                }\n            }\n\n            this.currentPage = page;\n            onStripEnter.call( this, { eventSource: this.innerTracker } );\n        }\n    },\n\n    /**\n     * @function\n     */\n    update: function () {\n        if ( THIS[this.id].animating ) {\n            $.console.log( \'image reference strip update\' );\n            return true;\n        }\n        return false;\n    },\n\n    // Overrides Viewer.destroy\n    destroy: function() {\n        if (this.element) {\n            this.element.parentNode.removeChild(this.element);\n        }\n    }\n\n} );\n\n\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripDrag( event ) {\n\n    var offsetLeft   = Number( this.element.style.marginLeft.replace( \'px\', \'\' ) ),\n        offsetTop    = Number( this.element.style.marginTop.replace( \'px\', \'\' ) ),\n        scrollWidth  = Number( this.element.style.width.replace( \'px\', \'\' ) ),\n        scrollHeight = Number( this.element.style.height.replace( \'px\', \'\' ) ),\n        viewerSize   = $.getElementSize( this.viewer.canvas );\n    this.dragging = true;\n    if ( this.element ) {\n        if ( \'horizontal\' == this.scroll ) {\n            if ( -event.delta.x > 0 ) {\n                //forward\n                if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {\n                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );\n                }\n            } else if ( -event.delta.x < 0 ) {\n                //reverse\n                if ( offsetLeft < 0 ) {\n                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );\n                }\n            }\n        } else {\n            if ( -event.delta.y > 0 ) {\n                //forward\n                if ( offsetTop > -( scrollHeight - viewerSize.y ) ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );\n                }\n            } else if ( -event.delta.y < 0 ) {\n                //reverse\n                if ( offsetTop < 0 ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );\n                }\n            }\n        }\n    }\n    return false;\n\n}\n\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripScroll( event ) {\n    var offsetLeft   = Number( this.element.style.marginLeft.replace( \'px\', \'\' ) ),\n        offsetTop    = Number( this.element.style.marginTop.replace( \'px\', \'\' ) ),\n        scrollWidth  = Number( this.element.style.width.replace( \'px\', \'\' ) ),\n        scrollHeight = Number( this.element.style.height.replace( \'px\', \'\' ) ),\n        viewerSize   = $.getElementSize( this.viewer.canvas );\n    if ( this.element ) {\n        if ( \'horizontal\' == this.scroll ) {\n            if ( event.scroll > 0 ) {\n                //forward\n                if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {\n                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );\n                }\n            } else if ( event.scroll < 0 ) {\n                //reverse\n                if ( offsetLeft < 0 ) {\n                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );\n                }\n            }\n        } else {\n            if ( event.scroll < 0 ) {\n                //scroll up\n                if ( offsetTop > viewerSize.y - scrollHeight ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );\n                }\n            } else if ( event.scroll > 0 ) {\n                //scroll dowm\n                if ( offsetTop < 0 ) {\n                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + \'px\';\n                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );\n                }\n            }\n        }\n    }\n    //cancels event\n    return false;\n}\n\n\nfunction loadPanels( strip, viewerSize, scroll ) {\n    var panelSize,\n        activePanelsStart,\n        activePanelsEnd,\n        miniViewer,\n        style,\n        i,\n        element;\n    if ( \'horizontal\' == strip.scroll ) {\n        panelSize = strip.panelWidth;\n    } else {\n        panelSize = strip.panelHeight;\n    }\n    activePanelsStart = Math.ceil( viewerSize / panelSize ) + 5;\n    activePanelsEnd = Math.ceil( ( Math.abs( scroll ) + viewerSize ) / panelSize ) + 1;\n    activePanelsStart = activePanelsEnd - activePanelsStart;\n    activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;\n\n    for ( i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++ ) {\n        element = strip.panels[i];\n        if ( !element.activePanel ) {\n            miniViewer = new $.Viewer( {\n                id:                     element.id,\n                tileSources:            [strip.viewer.tileSources[i]],\n                element:                element,\n                navigatorSizeRatio:     strip.sizeRatio,\n                showNavigator:          false,\n                mouseNavEnabled:        false,\n                showNavigationControl:  false,\n                showSequenceControl:    false,\n                immediateRender:        true,\n                blendTime:              0,\n                animationTime:          0\n            } );\n\n            miniViewer.displayRegion           = $.makeNeutralElement( "div" );\n            miniViewer.displayRegion.id        = element.id + \'-displayregion\';\n            miniViewer.displayRegion.className = \'displayregion\';\n\n            style               = miniViewer.displayRegion.style;\n            style.position      = \'relative\';\n            style.top           = \'0px\';\n            style.left          = \'0px\';\n            style.fontSize      = \'0px\';\n            style.overflow      = \'hidden\';\n            style.float         = \'left\'; //Webkit\n            style.cssFloat      = \'left\'; //Firefox\n            style.styleFloat    = \'left\'; //IE\n            style.zIndex        = 999999999;\n            style.cursor        = \'default\';\n            style.width         = ( strip.panelWidth - 4 ) + \'px\';\n            style.height        = ( strip.panelHeight - 4 ) + \'px\';\n\n            // TODO: What is this for? Future keyboard navigation support?\n            miniViewer.displayRegion.innerTracker = new $.MouseTracker( {\n                element: miniViewer.displayRegion,\n                startDisabled: true\n            } );\n\n            element.getElementsByTagName( \'div\' )[0].appendChild(\n                miniViewer.displayRegion\n            );\n\n            element.activePanel = true;\n        }\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripEnter( event ) {\n    var element = event.eventSource.element;\n\n    //$.setElementOpacity(element, 0.8);\n\n    //element.style.border = \'1px solid #555\';\n    //element.style.background = \'#000\';\n\n    if ( \'horizontal\' == this.scroll ) {\n\n        //element.style.paddingTop = "0px";\n        element.style.marginBottom = "0px";\n\n    } else {\n\n        //element.style.paddingRight = "0px";\n        element.style.marginLeft = "0px";\n\n    }\n    return false;\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onStripExit( event ) {\n    var element = event.eventSource.element;\n\n    if ( \'horizontal\' == this.scroll ) {\n\n        //element.style.paddingTop = "10px";\n        element.style.marginBottom = "-" + ( $.getElementSize( element ).y / 2 ) + "px";\n\n    } else {\n\n        //element.style.paddingRight = "10px";\n        element.style.marginLeft = "-" + ( $.getElementSize( element ).x / 2 ) + "px";\n\n    }\n    return false;\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onKeyDown( event ) {\n    //console.log( event.keyCode );\n\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch ( event.keyCode ) {\n            case 38: //up arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            case 40: //down arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 37: //left arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 39: //right arrow\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\n\n/**\n * @private\n * @inner\n * @function\n */\nfunction onKeyPress( event ) {\n    //console.log( event.keyCode );\n\n    if ( !event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {\n        switch ( event.keyCode ) {\n            case 61: //=|+\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            case 45: //-|_\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 48: //0|)\n            case 119: //w\n            case 87: //W\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            case 115: //s\n            case 83: //S\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 97: //a\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );\n                return false;\n            case 100: //d\n                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );\n                return false;\n            default:\n                //console.log( \'navigator keycode %s\', event.keyCode );\n                return true;\n        }\n    } else {\n        return true;\n    }\n}\n\n\n\n} ( OpenSeadragon ) );\n\n/*\n * OpenSeadragon - DisplayRect\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class DisplayRect\n * @classdesc A display rectangle is very similar to {@link OpenSeadragon.Rect} but adds two\n * fields, \'minLevel\' and \'maxLevel\' which denote the supported zoom levels\n * for this rectangle.\n *\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.Rect\n * @param {Number} x The vector component \'x\'.\n * @param {Number} y The vector component \'y\'.\n * @param {Number} width The vector component \'height\'.\n * @param {Number} height The vector component \'width\'.\n * @param {Number} minLevel The lowest zoom level supported.\n * @param {Number} maxLevel The highest zoom level supported.\n */\n$.DisplayRect = function( x, y, width, height, minLevel, maxLevel ) {\n    $.Rect.apply( this, [ x, y, width, height ] );\n\n    /**\n     * The lowest zoom level supported.\n     * @member {Number} minLevel\n     * @memberof OpenSeadragon.DisplayRect#\n     */\n    this.minLevel = minLevel;\n    /**\n     * The highest zoom level supported.\n     * @member {Number} maxLevel\n     * @memberof OpenSeadragon.DisplayRect#\n     */\n    this.maxLevel = maxLevel;\n};\n\n$.extend( $.DisplayRect.prototype, $.Rect.prototype );\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Spring\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Spring\n * @memberof OpenSeadragon\n * @param {Object} options - Spring configuration settings.\n * @param {Number} options.springStiffness - Spring stiffness. Must be greater than zero.\n * The closer to zero, the closer to linear animation.\n * @param {Number} options.animationTime - Animation duration per spring, in seconds.\n * Must be zero or greater.\n * @param {Number} [options.initial=0] - Initial value of spring.\n * @param {Boolean} [options.exponential=false] - Whether this spring represents\n * an exponential scale (such as zoom) and should be animated accordingly. Note that\n * exponential springs must have non-zero values.\n */\n$.Spring = function( options ) {\n    var args = arguments;\n\n    if( typeof( options ) != \'object\' ){\n        //allows backward compatible use of ( initialValue, config ) as\n        //constructor parameters\n        options = {\n            initial: args.length && typeof ( args[ 0 ] ) == "number" ?\n                args[ 0 ] :\n                undefined,\n            /**\n             * Spring stiffness.\n             * @member {Number} springStiffness\n             * @memberof OpenSeadragon.Spring#\n             */\n            springStiffness: args.length > 1 ?\n                args[ 1 ].springStiffness :\n                5.0,\n            /**\n             * Animation duration per spring.\n             * @member {Number} animationTime\n             * @memberof OpenSeadragon.Spring#\n             */\n            animationTime: args.length > 1 ?\n                args[ 1 ].animationTime :\n                1.5\n        };\n    }\n\n    $.console.assert(typeof options.springStiffness === "number" && options.springStiffness !== 0,\n        "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number");\n\n    $.console.assert(typeof options.animationTime === "number" && options.animationTime >= 0,\n        "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0");\n\n    if (options.exponential) {\n        this._exponential = true;\n        delete options.exponential;\n    }\n\n    $.extend( true, this, options);\n\n    /**\n     * @member {Object} current\n     * @memberof OpenSeadragon.Spring#\n     * @property {Number} value\n     * @property {Number} time\n     */\n    this.current = {\n        value: typeof ( this.initial ) == "number" ?\n            this.initial :\n            (this._exponential ? 0 : 1),\n        time:  $.now() // always work in milliseconds\n    };\n\n    $.console.assert(!this._exponential || this.current.value !== 0,\n        "[OpenSeadragon.Spring] value must be non-zero for exponential springs");\n\n    /**\n     * @member {Object} start\n     * @memberof OpenSeadragon.Spring#\n     * @property {Number} value\n     * @property {Number} time\n     */\n    this.start = {\n        value: this.current.value,\n        time:  this.current.time\n    };\n\n    /**\n     * @member {Object} target\n     * @memberof OpenSeadragon.Spring#\n     * @property {Number} value\n     * @property {Number} time\n     */\n    this.target = {\n        value: this.current.value,\n        time:  this.current.time\n    };\n\n    if (this._exponential) {\n        this.start._logValue = Math.log(this.start.value);\n        this.target._logValue = Math.log(this.target.value);\n        this.current._logValue = Math.log(this.current.value);\n    }\n};\n\n/** @lends OpenSeadragon.Spring.prototype */\n$.Spring.prototype = {\n\n    /**\n     * @function\n     * @param {Number} target\n     */\n    resetTo: function( target ) {\n        $.console.assert(!this._exponential || target !== 0,\n            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs");\n\n        this.start.value = this.target.value = this.current.value = target;\n        this.start.time = this.target.time = this.current.time = $.now();\n\n        if (this._exponential) {\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n            this.current._logValue = Math.log(this.current.value);\n        }\n    },\n\n    /**\n     * @function\n     * @param {Number} target\n     */\n    springTo: function( target ) {\n        $.console.assert(!this._exponential || target !== 0,\n            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs");\n\n        this.start.value  = this.current.value;\n        this.start.time   = this.current.time;\n        this.target.value = target;\n        this.target.time  = this.start.time + 1000 * this.animationTime;\n\n        if (this._exponential) {\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n        }\n    },\n\n    /**\n     * @function\n     * @param {Number} delta\n     */\n    shiftBy: function( delta ) {\n        this.start.value  += delta;\n        this.target.value += delta;\n\n        if (this._exponential) {\n            $.console.assert(this.target.value !== 0 && this.start.value !== 0,\n                "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs");\n\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n        }\n    },\n\n    setExponential: function(value) {\n        this._exponential = value;\n\n        if (this._exponential) {\n            $.console.assert(this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,\n                "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs");\n\n            this.start._logValue = Math.log(this.start.value);\n            this.target._logValue = Math.log(this.target.value);\n            this.current._logValue = Math.log(this.current.value);\n        }\n    },\n\n    /**\n     * @function\n     */\n    update: function() {\n        this.current.time  = $.now();\n\n        var startValue, targetValue;\n        if (this._exponential) {\n            startValue = this.start._logValue;\n            targetValue = this.target._logValue;\n        } else {\n            startValue = this.start.value;\n            targetValue = this.target.value;\n        }\n\n        var currentValue = (this.current.time >= this.target.time) ?\n            targetValue :\n            startValue +\n                ( targetValue - startValue ) *\n                transform(\n                    this.springStiffness,\n                    ( this.current.time - this.start.time ) /\n                    ( this.target.time  - this.start.time )\n                );\n\n        if (this._exponential) {\n            this.current.value = Math.exp(currentValue);\n        } else {\n            this.current.value = currentValue;\n        }\n    },\n\n    /**\n     * Returns whether the spring is at the target value\n     * @function\n     * @returns {Boolean} True if at target value, false otherwise\n     */\n    isAtTargetValue: function() {\n        return this.current.value === this.target.value;\n    }\n};\n\n/**\n * @private\n */\nfunction transform( stiffness, x ) {\n    return ( 1.0 - Math.exp( stiffness * -x ) ) /\n        ( 1.0 - Math.exp( -stiffness ) );\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - ImageLoader\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// private class\nfunction ImageJob ( options ) {\n\n    $.extend( true, this, {\n        timeout:        $.DEFAULT_SETTINGS.timeout,\n        jobId:          null\n    }, options );\n\n    /**\n     * Image object which will contain downloaded image.\n     * @member {Image} image\n     * @memberof OpenSeadragon.ImageJob#\n     */\n    this.image = null;\n}\n\nImageJob.prototype = {\n    errorMsg: null,\n    start: function(){\n        var _this = this;\n\n        this.image = new Image();\n\n        if ( this.crossOriginPolicy !== false ) {\n            this.image.crossOrigin = this.crossOriginPolicy;\n        }\n\n        this.image.onload = function(){\n            _this.finish( true );\n        };\n        this.image.onabort = this.image.onerror = function(){\n            _this.errorMsg = "Image load aborted";\n            _this.finish( false );\n        };\n\n        this.jobId = window.setTimeout( function(){\n            _this.errorMsg = "Image load exceeded timeout";\n            _this.finish( false );\n        }, this.timeout);\n\n        this.image.src = this.src;\n    },\n\n    finish: function( successful ) {\n        this.image.onload = this.image.onerror = this.image.onabort = null;\n        if (!successful) {\n            this.image = null;\n        }\n\n        if ( this.jobId ) {\n            window.clearTimeout( this.jobId );\n        }\n\n        this.callback( this );\n    }\n\n};\n\n/**\n * @class ImageLoader\n * @memberof OpenSeadragon\n * @classdesc Handles downloading of a set of images using asynchronous queue pattern.\n * You generally won\'t have to interact with the ImageLoader directly.\n * @param {Object} options - Options for this ImageLoader.\n * @param {Number} [options.jobLimit] - The number of concurrent image requests. See imageLoaderLimit in {@link OpenSeadragon.Options} for details.\n */\n$.ImageLoader = function( options ) {\n\n    $.extend( true, this, {\n        jobLimit:       $.DEFAULT_SETTINGS.imageLoaderLimit,\n        jobQueue:       [],\n        jobsInProgress: 0\n    }, options );\n\n};\n\n/** @lends OpenSeadragon.ImageLoader.prototype */\n$.ImageLoader.prototype = {\n\n    /**\n     * Add an unloaded image to the loader queue.\n     * @method\n     * @param {String} src - URL of image to download.\n     * @param {String} crossOriginPolicy - CORS policy to use for downloads\n     * @param {Function} callback - Called once image has been downloaded.\n     */\n    addJob: function( options ) {\n        var _this = this,\n            complete = function( job ) {\n                completeJob( _this, job, options.callback );\n            },\n            jobOptions = {\n                src: options.src,\n                crossOriginPolicy: options.crossOriginPolicy,\n                callback: complete,\n                abort: options.abort\n            },\n            newJob = new ImageJob( jobOptions );\n\n        if ( !this.jobLimit || this.jobsInProgress < this.jobLimit ) {\n            newJob.start();\n            this.jobsInProgress++;\n        }\n        else {\n            this.jobQueue.push( newJob );\n        }\n    },\n\n    /**\n     * Clear any unstarted image loading jobs from the queue.\n     * @method\n     */\n    clear: function() {\n        for( var i = 0; i < this.jobQueue.length; i++ ) {\n            var job = this.jobQueue[i];\n            if ( typeof job.abort === "function" ) {\n                job.abort();\n            }\n        }\n\n        this.jobQueue = [];\n    }\n};\n\n/**\n * Cleans up ImageJob once completed.\n * @method\n * @private\n * @param loader - ImageLoader used to start job.\n * @param job - The ImageJob that has completed.\n * @param callback - Called once cleanup is finished.\n */\nfunction completeJob( loader, job, callback ) {\n    var nextJob;\n\n    loader.jobsInProgress--;\n\n    if ( (!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {\n        nextJob = loader.jobQueue.shift();\n        nextJob.start();\n        loader.jobsInProgress++;\n    }\n\n    callback( job.image, job.errorMsg );\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Tile\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Tile\n * @memberof OpenSeadragon\n * @param {Number} level The zoom level this tile belongs to.\n * @param {Number} x The vector component \'x\'.\n * @param {Number} y The vector component \'y\'.\n * @param {OpenSeadragon.Point} bounds Where this tile fits, in normalized\n *      coordinates.\n * @param {Boolean} exists Is this tile a part of a sparse image? ( Also has\n *      this tile failed to load? )\n * @param {String} url The URL of this tile\'s image.\n * @param {CanvasRenderingContext2D} context2D The context2D of this tile if it\n * is provided directly by the tile source.\n */\n$.Tile = function(level, x, y, bounds, exists, url, context2D) {\n    /**\n     * The zoom level this tile belongs to.\n     * @member {Number} level\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.level   = level;\n    /**\n     * The vector component \'x\'.\n     * @member {Number} x\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.x       = x;\n    /**\n     * The vector component \'y\'.\n     * @member {Number} y\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.y       = y;\n    /**\n     * Where this tile fits, in normalized coordinates\n     * @member {OpenSeadragon.Rect} bounds\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.bounds  = bounds;\n    /**\n     * Is this tile a part of a sparse image? Also has this tile failed to load?\n     * @member {Boolean} exists\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.exists  = exists;\n    /**\n     * The URL of this tile\'s image.\n     * @member {String} url\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.url     = url;\n    /**\n     * The context2D of this tile if it is provided directly by the tile source.\n     * @member {CanvasRenderingContext2D} context2D\n     * @memberOf OpenSeadragon.Tile#\n     */\n    this.context2D = context2D;\n    /**\n     * Is this tile loaded?\n     * @member {Boolean} loaded\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.loaded  = false;\n    /**\n     * Is this tile loading?\n     * @member {Boolean} loading\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.loading = false;\n\n    /**\n     * The HTML div element for this tile\n     * @member {Element} element\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.element    = null;\n    /**\n     * The HTML img element for this tile.\n     * @member {Element} imgElement\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.imgElement = null;\n    /**\n     * The Image object for this tile.\n     * @member {Object} image\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.image      = null;\n\n    /**\n     * The alias of this.element.style.\n     * @member {String} style\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.style      = null;\n    /**\n     * This tile\'s position on screen, in pixels.\n     * @member {OpenSeadragon.Point} position\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.position   = null;\n    /**\n     * This tile\'s size on screen, in pixels.\n     * @member {OpenSeadragon.Point} size\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.size       = null;\n    /**\n     * The start time of this tile\'s blending.\n     * @member {Number} blendStart\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.blendStart = null;\n    /**\n     * The current opacity this tile should be.\n     * @member {Number} opacity\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.opacity    = null;\n    /**\n     * The distance of this tile to the viewport center.\n     * @member {Number} distance\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.distance   = null;\n    /**\n     * The visibility score of this tile.\n     * @member {Number} visibility\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.visibility = null;\n\n    /**\n     * Whether this tile is currently being drawn.\n     * @member {Boolean} beingDrawn\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.beingDrawn     = false;\n    /**\n     * Timestamp the tile was last touched.\n     * @member {Number} lastTouchTime\n     * @memberof OpenSeadragon.Tile#\n     */\n    this.lastTouchTime  = 0;\n};\n\n/** @lends OpenSeadragon.Tile.prototype */\n$.Tile.prototype = {\n\n    /**\n     * Provides a string representation of this tiles level and (x,y)\n     * components.\n     * @function\n     * @returns {String}\n     */\n    toString: function() {\n        return this.level + "/" + this.x + "_" + this.y;\n    },\n\n    // private\n    _hasTransparencyChannel: function() {\n        return !!this.context2D || this.url.match(\'.png\');\n    },\n\n    /**\n     * Renders the tile in an html container.\n     * @function\n     * @param {Element} container\n     */\n    drawHTML: function( container ) {\n        if (!this.cacheImageRecord) {\n            $.console.warn(\n                \'[Tile.drawHTML] attempting to draw tile %s when it\\\'s not cached\',\n                this.toString());\n            return;\n        }\n\n        if ( !this.loaded ) {\n            $.console.warn(\n                "Attempting to draw tile %s when it\'s not yet loaded.",\n                this.toString()\n            );\n            return;\n        }\n\n        //EXPERIMENTAL - trying to figure out how to scale the container\n        //               content during animation of the container size.\n\n        if ( !this.element ) {\n            this.element                              = $.makeNeutralElement( "div" );\n            this.imgElement                           = this.cacheImageRecord.getImage().cloneNode();\n            this.imgElement.style.msInterpolationMode = "nearest-neighbor";\n            this.imgElement.style.width               = "100%";\n            this.imgElement.style.height              = "100%";\n\n            this.style                     = this.element.style;\n            this.style.position            = "absolute";\n        }\n        if ( this.element.parentNode != container ) {\n            container.appendChild( this.element );\n        }\n        if ( this.imgElement.parentNode != this.element ) {\n            this.element.appendChild( this.imgElement );\n        }\n\n        this.style.top     = this.position.y + "px";\n        this.style.left    = this.position.x + "px";\n        this.style.height  = this.size.y + "px";\n        this.style.width   = this.size.x + "px";\n\n        $.setElementOpacity( this.element, this.opacity );\n    },\n\n    /**\n     * Renders the tile in a canvas-based context.\n     * @function\n     * @param {Canvas} context\n     * @param {Function} drawingHandler - Method for firing the drawing event.\n     * drawingHandler({context, tile, rendered})\n     * where <code>rendered</code> is the context with the pre-drawn image.\n     * @param {Number} [scale=1] - Apply a scale to position and size\n     * @param {OpenSeadragon.Point} [translate] - A translation vector\n     */\n    drawCanvas: function( context, drawingHandler, scale, translate ) {\n\n        var position = this.position.times($.pixelDensityRatio),\n            size     = this.size.times($.pixelDensityRatio),\n            rendered;\n\n        if (!this.context2D && !this.cacheImageRecord) {\n            $.console.warn(\n                \'[Tile.drawCanvas] attempting to draw tile %s when it\\\'s not cached\',\n                this.toString());\n            return;\n        }\n\n        rendered = this.context2D || this.cacheImageRecord.getRenderedContext();\n\n        if ( !this.loaded || !rendered ){\n            $.console.warn(\n                "Attempting to draw tile %s when it\'s not yet loaded.",\n                this.toString()\n            );\n\n            return;\n        }\n\n        context.save();\n\n        context.globalAlpha = this.opacity;\n\n        if (typeof scale === \'number\' && scale !== 1) {\n            // draw tile at a different scale\n            position = position.times(scale);\n            size = size.times(scale);\n        }\n\n        if (translate instanceof $.Point) {\n            // shift tile position slightly\n            position = position.plus(translate);\n        }\n\n        //if we are supposed to be rendering fully opaque rectangle,\n        //ie its done fading or fading is turned off, and if we are drawing\n        //an image with an alpha channel, then the only way\n        //to avoid seeing the tile underneath is to clear the rectangle\n        if (context.globalAlpha === 1 && this._hasTransparencyChannel()) {\n            //clearing only the inside of the rectangle occupied\n            //by the png prevents edge flikering\n            context.clearRect(\n                position.x + 1,\n                position.y + 1,\n                size.x - 2,\n                size.y - 2\n            );\n        }\n\n        // This gives the application a chance to make image manipulation\n        // changes as we are rendering the image\n        drawingHandler({context: context, tile: this, rendered: rendered});\n\n        context.drawImage(\n            rendered.canvas,\n            0,\n            0,\n            rendered.canvas.width,\n            rendered.canvas.height,\n            position.x,\n            position.y,\n            size.x,\n            size.y\n        );\n\n        context.restore();\n    },\n\n    /**\n     * Get the ratio between current and original size.\n     * @function\n     * @return {Float}\n     */\n    getScaleForEdgeSmoothing: function() {\n        var context;\n        if (this.cacheImageRecord) {\n            context = this.cacheImageRecord.getRenderedContext();\n        } else if (this.context2D) {\n            context = this.context2D;\n        } else {\n            $.console.warn(\n                \'[Tile.drawCanvas] attempting to get tile scale %s when tile\\\'s not cached\',\n                this.toString());\n            return 1;\n        }\n        return context.canvas.width / (this.size.x * $.pixelDensityRatio);\n    },\n\n    /**\n     * Get a translation vector that when applied to the tile position produces integer coordinates.\n     * Needed to avoid swimming and twitching.\n     * @function\n     * @param {Number} [scale=1] - Scale to be applied to position.\n     * @return {OpenSeadragon.Point}\n     */\n    getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {\n        // The translation vector must have positive values, otherwise the image goes a bit off\n        // the sketch canvas to the top and left and we must use negative coordinates to repaint it\n        // to the main canvas. In that case, some browsers throw:\n        // INDEX_SIZE_ERR: DOM Exception 1: Index or size was negative, or greater than the allowed value.\n        var x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));\n        var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));\n        return new $.Point(x, y).minus(\n            this.position\n                .times($.pixelDensityRatio)\n                .times(scale || 1)\n                .apply(function(x) {\n                    return x % 1;\n                })\n        );\n    },\n\n    /**\n     * Removes tile from its container.\n     * @function\n     */\n    unload: function() {\n        if ( this.imgElement && this.imgElement.parentNode ) {\n            this.imgElement.parentNode.removeChild( this.imgElement );\n        }\n        if ( this.element && this.element.parentNode ) {\n            this.element.parentNode.removeChild( this.element );\n        }\n\n        this.element    = null;\n        this.imgElement = null;\n        this.loaded     = false;\n        this.loading    = false;\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Overlay\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function($) {\n\n    /**\n     * An enumeration of positions that an overlay may be assigned relative to\n     * the viewport.\n     * It is identical to OpenSeadragon.Placement but is kept for backward\n     * compatibility.\n     * @member OverlayPlacement\n     * @memberof OpenSeadragon\n     * @static\n     * @readonly\n     * @type {Object}\n     * @property {Number} CENTER\n     * @property {Number} TOP_LEFT\n     * @property {Number} TOP\n     * @property {Number} TOP_RIGHT\n     * @property {Number} RIGHT\n     * @property {Number} BOTTOM_RIGHT\n     * @property {Number} BOTTOM\n     * @property {Number} BOTTOM_LEFT\n     * @property {Number} LEFT\n     */\n    $.OverlayPlacement = $.Placement;\n\n    /**\n     * An enumeration of possible ways to handle overlays rotation\n     * @member OverlayRotationMode\n     * @memberOf OpenSeadragon\n     * @static\n     * @readonly\n     * @property {Number} NO_ROTATION The overlay ignore the viewport rotation.\n     * @property {Number} EXACT The overlay use CSS 3 transforms to rotate with\n     * the viewport. If the overlay contains text, it will get rotated as well.\n     * @property {Number} BOUNDING_BOX The overlay adjusts for rotation by\n     * taking the size of the bounding box of the rotated bounds.\n     * Only valid for overlays with Rect location and scalable in both directions.\n     */\n    $.OverlayRotationMode = $.freezeObject({\n        NO_ROTATION: 1,\n        EXACT: 2,\n        BOUNDING_BOX: 3\n    });\n\n    /**\n     * @class Overlay\n     * @classdesc Provides a way to float an HTML element on top of the viewer element.\n     *\n     * @memberof OpenSeadragon\n     * @param {Object} options\n     * @param {Element} options.element\n     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} options.location - The\n     * location of the overlay on the image. If a {@link OpenSeadragon.Point}\n     * is specified, the overlay will be located at this location with respect\n     * to the placement option. If a {@link OpenSeadragon.Rect} is specified,\n     * the overlay will be placed at this location with the corresponding width\n     * and height and placement TOP_LEFT.\n     * @param {OpenSeadragon.Placement} [options.placement=OpenSeadragon.Placement.TOP_LEFT]\n     * Defines what part of the overlay should be at the specified options.location\n     * @param {OpenSeadragon.Overlay.OnDrawCallback} [options.onDraw]\n     * @param {Boolean} [options.checkResize=true] Set to false to avoid to\n     * check the size of the overlay everytime it is drawn in the directions\n     * which are not scaled. It will improve performances but will cause a\n     * misalignment if the overlay size changes.\n     * @param {Number} [options.width] The width of the overlay in viewport\n     * coordinates. If specified, the width of the overlay will be adjusted when\n     * the zoom changes.\n     * @param {Number} [options.height] The height of the overlay in viewport\n     * coordinates. If specified, the height of the overlay will be adjusted when\n     * the zoom changes.\n     * @param {Boolean} [options.rotationMode=OpenSeadragon.OverlayRotationMode.EXACT]\n     * How to handle the rotation of the viewport.\n     */\n    $.Overlay = function(element, location, placement) {\n\n        /**\n         * onDraw callback signature used by {@link OpenSeadragon.Overlay}.\n         *\n         * @callback OnDrawCallback\n         * @memberof OpenSeadragon.Overlay\n         * @param {OpenSeadragon.Point} position\n         * @param {OpenSeadragon.Point} size\n         * @param {Element} element\n         */\n\n        var options;\n        if ($.isPlainObject(element)) {\n            options = element;\n        } else {\n            options = {\n                element: element,\n                location: location,\n                placement: placement\n            };\n        }\n\n        this.element = options.element;\n        this.style = options.element.style;\n        this._init(options);\n    };\n\n    /** @lends OpenSeadragon.Overlay.prototype */\n    $.Overlay.prototype = {\n\n        // private\n        _init: function(options) {\n            this.location = options.location;\n            this.placement = options.placement === undefined ?\n                $.Placement.TOP_LEFT : options.placement;\n            this.onDraw = options.onDraw;\n            this.checkResize = options.checkResize === undefined ?\n                true : options.checkResize;\n\n            // When this.width is not null, the overlay get scaled horizontally\n            this.width = options.width === undefined ? null : options.width;\n\n            // When this.height is not null, the overlay get scaled vertically\n            this.height = options.height === undefined ? null : options.height;\n\n            this.rotationMode = options.rotationMode || $.OverlayRotationMode.EXACT;\n\n            // Having a rect as location is a syntactic sugar\n            if (this.location instanceof $.Rect) {\n                this.width = this.location.width;\n                this.height = this.location.height;\n                this.location = this.location.getTopLeft();\n                this.placement = $.Placement.TOP_LEFT;\n            }\n\n            // Deprecated properties kept for backward compatibility.\n            this.scales = this.width !== null && this.height !== null;\n            this.bounds = new $.Rect(\n                this.location.x, this.location.y, this.width, this.height);\n            this.position = this.location;\n        },\n\n        /**\n         * Internal function to adjust the position of an overlay\n         * depending on it size and placement.\n         * @function\n         * @param {OpenSeadragon.Point} position\n         * @param {OpenSeadragon.Point} size\n         */\n        adjust: function(position, size) {\n            var properties = $.Placement.properties[this.placement];\n            if (!properties) {\n                return;\n            }\n            if (properties.isHorizontallyCentered) {\n                position.x -= size.x / 2;\n            } else if (properties.isRight) {\n                position.x -= size.x;\n            }\n            if (properties.isVerticallyCentered) {\n                position.y -= size.y / 2;\n            } else if (properties.isBottom) {\n                position.y -= size.y;\n            }\n        },\n\n        /**\n         * @function\n         */\n        destroy: function() {\n            var element = this.element;\n            var style = this.style;\n\n            if (element.parentNode) {\n                element.parentNode.removeChild(element);\n                //this should allow us to preserve overlays when required between\n                //pages\n                if (element.prevElementParent) {\n                    style.display = \'none\';\n                    //element.prevElementParent.insertBefore(\n                    //    element,\n                    //    element.prevNextSibling\n                    //);\n                    document.body.appendChild(element);\n                }\n            }\n\n            // clear the onDraw callback\n            this.onDraw = null;\n\n            style.top = "";\n            style.left = "";\n            style.position = "";\n\n            if (this.width !== null) {\n                style.width = "";\n            }\n            if (this.height !== null) {\n                style.height = "";\n            }\n            var transformOriginProp = $.getCssPropertyWithVendorPrefix(\n                \'transformOrigin\');\n            var transformProp = $.getCssPropertyWithVendorPrefix(\n                \'transform\');\n            if (transformOriginProp && transformProp) {\n                style[transformOriginProp] = "";\n                style[transformProp] = "";\n            }\n        },\n\n        /**\n         * @function\n         * @param {Element} container\n         */\n        drawHTML: function(container, viewport) {\n            var element = this.element;\n            if (element.parentNode !== container) {\n                //save the source parent for later if we need it\n                element.prevElementParent = element.parentNode;\n                element.prevNextSibling = element.nextSibling;\n                container.appendChild(element);\n\n                // this.size is used by overlays which don\'t get scaled in at\n                // least one direction when this.checkResize is set to false.\n                this.size = $.getElementSize(element);\n            }\n\n            var positionAndSize = this._getOverlayPositionAndSize(viewport);\n\n            var position = positionAndSize.position;\n            var size = this.size = positionAndSize.size;\n            var rotate = positionAndSize.rotate;\n\n            // call the onDraw callback if it exists to allow one to overwrite\n            // the drawing/positioning/sizing of the overlay\n            if (this.onDraw) {\n                this.onDraw(position, size, this.element);\n            } else {\n                var style = this.style;\n                style.left = position.x + "px";\n                style.top = position.y + "px";\n                if (this.width !== null) {\n                    style.width = size.x + "px";\n                }\n                if (this.height !== null) {\n                    style.height = size.y + "px";\n                }\n                var transformOriginProp = $.getCssPropertyWithVendorPrefix(\n                    \'transformOrigin\');\n                var transformProp = $.getCssPropertyWithVendorPrefix(\n                    \'transform\');\n                if (transformOriginProp && transformProp) {\n                    if (rotate) {\n                        style[transformOriginProp] = this._getTransformOrigin();\n                        style[transformProp] = "rotate(" + rotate + "deg)";\n                    } else {\n                        style[transformOriginProp] = "";\n                        style[transformProp] = "";\n                    }\n                }\n                style.position = "absolute";\n\n                if (style.display !== \'none\') {\n                    style.display = \'block\';\n                }\n            }\n        },\n\n        // private\n        _getOverlayPositionAndSize: function(viewport) {\n            var position = viewport.pixelFromPoint(this.location, true);\n            var size = this._getSizeInPixels(viewport);\n            this.adjust(position, size);\n\n            var rotate = 0;\n            if (viewport.degrees &&\n                this.rotationMode !== $.OverlayRotationMode.NO_ROTATION) {\n                // BOUNDING_BOX is only valid if both directions get scaled.\n                // Get replaced by EXACT otherwise.\n                if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX &&\n                    this.width !== null && this.height !== null) {\n                    var rect = new $.Rect(position.x, position.y, size.x, size.y);\n                    var boundingBox = this._getBoundingBox(rect, viewport.degrees);\n                    position = boundingBox.getTopLeft();\n                    size = boundingBox.getSize();\n                } else {\n                    rotate = viewport.degrees;\n                }\n            }\n\n            return {\n                position: position,\n                size: size,\n                rotate: rotate\n            };\n        },\n\n        // private\n        _getSizeInPixels: function(viewport) {\n            var width = this.size.x;\n            var height = this.size.y;\n            if (this.width !== null || this.height !== null) {\n                var scaledSize = viewport.deltaPixelsFromPointsNoRotate(\n                    new $.Point(this.width || 0, this.height || 0), true);\n                if (this.width !== null) {\n                    width = scaledSize.x;\n                }\n                if (this.height !== null) {\n                    height = scaledSize.y;\n                }\n            }\n            if (this.checkResize &&\n                (this.width === null || this.height === null)) {\n                var eltSize = this.size = $.getElementSize(this.element);\n                if (this.width === null) {\n                    width = eltSize.x;\n                }\n                if (this.height === null) {\n                    height = eltSize.y;\n                }\n            }\n            return new $.Point(width, height);\n        },\n\n        // private\n        _getBoundingBox: function(rect, degrees) {\n            var refPoint = this._getPlacementPoint(rect);\n            return rect.rotate(degrees, refPoint).getBoundingBox();\n        },\n\n        // private\n        _getPlacementPoint: function(rect) {\n            var result = new $.Point(rect.x, rect.y);\n            var properties = $.Placement.properties[this.placement];\n            if (properties) {\n                if (properties.isHorizontallyCentered) {\n                    result.x += rect.width / 2;\n                } else if (properties.isRight) {\n                    result.x += rect.width;\n                }\n                if (properties.isVerticallyCentered) {\n                    result.y += rect.height / 2;\n                } else if (properties.isBottom) {\n                    result.y += rect.height;\n                }\n            }\n            return result;\n        },\n\n        // private\n        _getTransformOrigin: function() {\n            var result = "";\n            var properties = $.Placement.properties[this.placement];\n            if (!properties) {\n                return result;\n            }\n            if (properties.isLeft) {\n                result = "left";\n            } else if (properties.isRight) {\n                result = "right";\n            }\n            if (properties.isTop) {\n                result += " top";\n            } else if (properties.isBottom) {\n                result += " bottom";\n            }\n            return result;\n        },\n\n        /**\n         * Changes the overlay settings.\n         * @function\n         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location\n         * If an object is specified, the options are the same than the constructor\n         * except for the element which can not be changed.\n         * @param {OpenSeadragon.Placement} position\n         */\n        update: function(location, placement) {\n            var options = $.isPlainObject(location) ? location : {\n                location: location,\n                placement: placement\n            };\n            this._init({\n                location: options.location || this.location,\n                placement: options.placement !== undefined ?\n                    options.placement : this.placement,\n                onDraw: options.onDraw || this.onDraw,\n                checkResize: options.checkResize || this.checkResize,\n                width: options.width !== undefined ? options.width : this.width,\n                height: options.height !== undefined ? options.height : this.height,\n                rotationMode: options.rotationMode || this.rotationMode\n            });\n        },\n\n        /**\n         * Returns the current bounds of the overlay in viewport coordinates\n         * @function\n         * @param {OpenSeadragon.Viewport} viewport the viewport\n         * @returns {OpenSeadragon.Rect} overlay bounds\n         */\n        getBounds: function(viewport) {\n            $.console.assert(viewport,\n                \'A viewport must now be passed to Overlay.getBounds.\');\n            var width = this.width;\n            var height = this.height;\n            if (width === null || height === null) {\n                var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);\n                if (width === null) {\n                    width = size.x;\n                }\n                if (height === null) {\n                    height = size.y;\n                }\n            }\n            var location = this.location.clone();\n            this.adjust(location, new $.Point(width, height));\n            return this._adjustBoundsForRotation(\n                viewport, new $.Rect(location.x, location.y, width, height));\n        },\n\n        // private\n        _adjustBoundsForRotation: function(viewport, bounds) {\n            if (!viewport ||\n                viewport.degrees === 0 ||\n                this.rotationMode === $.OverlayRotationMode.EXACT) {\n                return bounds;\n            }\n            if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX) {\n                // If overlay not fully scalable, BOUNDING_BOX falls back to EXACT\n                if (this.width === null || this.height === null) {\n                    return bounds;\n                }\n                // It is easier to just compute the position and size and\n                // convert to viewport coordinates.\n                var positionAndSize = this._getOverlayPositionAndSize(viewport);\n                return viewport.viewerElementToViewportRectangle(new $.Rect(\n                    positionAndSize.position.x,\n                    positionAndSize.position.y,\n                    positionAndSize.size.x,\n                    positionAndSize.size.y));\n            }\n\n            // NO_ROTATION case\n            return bounds.rotate(-viewport.degrees,\n                this._getPlacementPoint(bounds));\n        }\n    };\n\n}(OpenSeadragon));\n\n/*\n * OpenSeadragon - Drawer\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class Drawer\n * @memberof OpenSeadragon\n * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.\n * @param {Object} options - Options for this Drawer.\n * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.\n * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.\n * @param {Element} options.element - Parent element.\n * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.\n */\n$.Drawer = function( options ) {\n\n    $.console.assert( options.viewer, "[Drawer] options.viewer is required" );\n\n    //backward compatibility for positional args while prefering more\n    //idiomatic javascript options object as the only argument\n    var args  = arguments;\n\n    if( !$.isPlainObject( options ) ){\n        options = {\n            source:     args[ 0 ], // Reference to Viewer tile source.\n            viewport:   args[ 1 ], // Reference to Viewer viewport.\n            element:    args[ 2 ]  // Parent element.\n        };\n    }\n\n    $.console.assert( options.viewport, "[Drawer] options.viewport is required" );\n    $.console.assert( options.element, "[Drawer] options.element is required" );\n\n    if ( options.source ) {\n        $.console.error( "[Drawer] options.source is no longer accepted; use TiledImage instead" );\n    }\n\n    this.viewer = options.viewer;\n    this.viewport = options.viewport;\n    this.debugGridColor = options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;\n    if (options.opacity) {\n        $.console.error( "[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead" );\n    }\n\n    this.useCanvas  = $.supportsCanvas && ( this.viewer ? this.viewer.useCanvas : true );\n    /**\n     * The parent element of this Drawer instance, passed in when the Drawer was created.\n     * The parent of {@link OpenSeadragon.Drawer#canvas}.\n     * @member {Element} container\n     * @memberof OpenSeadragon.Drawer#\n     */\n    this.container  = $.getElement( options.element );\n    /**\n     * A &lt;canvas&gt; element if the browser supports them, otherwise a &lt;div&gt; element.\n     * Child element of {@link OpenSeadragon.Drawer#container}.\n     * @member {Element} canvas\n     * @memberof OpenSeadragon.Drawer#\n     */\n    this.canvas     = $.makeNeutralElement( this.useCanvas ? "canvas" : "div" );\n    /**\n     * 2d drawing context for {@link OpenSeadragon.Drawer#canvas} if it\'s a &lt;canvas&gt; element, otherwise null.\n     * @member {Object} context\n     * @memberof OpenSeadragon.Drawer#\n     */\n    this.context    = this.useCanvas ? this.canvas.getContext( "2d" ) : null;\n\n    /**\n     * Sketch canvas used to temporarily draw tiles which cannot be drawn directly\n     * to the main canvas due to opacity. Lazily initialized.\n     */\n    this.sketchCanvas = null;\n    this.sketchContext = null;\n\n    /**\n     * @member {Element} element\n     * @memberof OpenSeadragon.Drawer#\n     * @deprecated Alias for {@link OpenSeadragon.Drawer#container}.\n     */\n    this.element    = this.container;\n\n    // We force our container to ltr because our drawing math doesn\'t work in rtl.\n    // This issue only affects our canvas renderer, but we do it always for consistency.\n    // Note that this means overlays you want to be rtl need to be explicitly set to rtl.\n    this.container.dir = \'ltr\';\n\n    // check canvas available width and height, set canvas width and height such that the canvas backing store is set to the proper pixel density\n    if (this.useCanvas) {\n        var viewportSize = this._calculateCanvasSize();\n        this.canvas.width = viewportSize.x;\n        this.canvas.height = viewportSize.y;\n    }\n\n    this.canvas.style.width     = "100%";\n    this.canvas.style.height    = "100%";\n    this.canvas.style.position  = "absolute";\n    $.setElementOpacity( this.canvas, this.opacity, true );\n\n    // explicit left-align\n    this.container.style.textAlign = "left";\n    this.container.appendChild( this.canvas );\n};\n\n/** @lends OpenSeadragon.Drawer.prototype */\n$.Drawer.prototype = {\n    // deprecated\n    addOverlay: function( element, location, placement, onDraw ) {\n        $.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");\n        this.viewer.addOverlay( element, location, placement, onDraw );\n        return this;\n    },\n\n    // deprecated\n    updateOverlay: function( element, location, placement ) {\n        $.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");\n        this.viewer.updateOverlay( element, location, placement );\n        return this;\n    },\n\n    // deprecated\n    removeOverlay: function( element ) {\n        $.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");\n        this.viewer.removeOverlay( element );\n        return this;\n    },\n\n    // deprecated\n    clearOverlays: function() {\n        $.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");\n        this.viewer.clearOverlays();\n        return this;\n    },\n\n    /**\n     * Set the opacity of the drawer.\n     * @param {Number} opacity\n     * @return {OpenSeadragon.Drawer} Chainable.\n     */\n    setOpacity: function( opacity ) {\n        $.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");\n        var world = this.viewer.world;\n        for (var i = 0; i < world.getItemCount(); i++) {\n            world.getItemAt( i ).setOpacity( opacity );\n        }\n        return this;\n    },\n\n    /**\n     * Get the opacity of the drawer.\n     * @returns {Number}\n     */\n    getOpacity: function() {\n        $.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");\n        var world = this.viewer.world;\n        var maxOpacity = 0;\n        for (var i = 0; i < world.getItemCount(); i++) {\n            var opacity = world.getItemAt( i ).getOpacity();\n            if ( opacity > maxOpacity ) {\n                maxOpacity = opacity;\n            }\n        }\n        return maxOpacity;\n    },\n\n    // deprecated\n    needsUpdate: function() {\n        $.console.error( "[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead." );\n        return this.viewer.world.needsDraw();\n    },\n\n    // deprecated\n    numTilesLoaded: function() {\n        $.console.error( "[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead." );\n        return this.viewer.tileCache.numTilesLoaded();\n    },\n\n    // deprecated\n    reset: function() {\n        $.console.error( "[Drawer.reset] this function is deprecated. Use World.resetItems instead." );\n        this.viewer.world.resetItems();\n        return this;\n    },\n\n    // deprecated\n    update: function() {\n        $.console.error( "[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead." );\n        this.clear();\n        this.viewer.world.draw();\n        return this;\n    },\n\n    /**\n     * @return {Boolean} True if rotation is supported.\n     */\n    canRotate: function() {\n        return this.useCanvas;\n    },\n\n    /**\n     * Destroy the drawer (unload current loaded tiles)\n     */\n    destroy: function() {\n        //force unloading of current canvas (1x1 will be gc later, trick not necessarily needed)\n        this.canvas.width  = 1;\n        this.canvas.height = 1;\n        this.sketchCanvas = null;\n        this.sketchContext = null;\n    },\n\n    /**\n     * Clears the Drawer so it\'s ready to draw another frame.\n     */\n    clear: function() {\n        this.canvas.innerHTML = "";\n        if ( this.useCanvas ) {\n            var viewportSize = this._calculateCanvasSize();\n            if( this.canvas.width != viewportSize.x ||\n                this.canvas.height != viewportSize.y ) {\n                this.canvas.width = viewportSize.x;\n                this.canvas.height = viewportSize.y;\n                if ( this.sketchCanvas !== null ) {\n                    var sketchCanvasSize = this._calculateSketchCanvasSize();\n                    this.sketchCanvas.width = sketchCanvasSize.x;\n                    this.sketchCanvas.height = sketchCanvasSize.y;\n                }\n            }\n            this._clear();\n        }\n    },\n\n    _clear: function (useSketch, bounds) {\n        if (!this.useCanvas) {\n            return;\n        }\n        var context = this._getContext(useSketch);\n        if (bounds) {\n            context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        } else {\n            var canvas = context.canvas;\n            context.clearRect(0, 0, canvas.width, canvas.height);\n        }\n    },\n\n    /**\n     * Scale from OpenSeadragon viewer rectangle to drawer rectangle\n     * (ignoring rotation)\n     * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.\n     * @return {OpenSeadragon.Rect} Rectangle in drawer coordinate system.\n     */\n    viewportToDrawerRectangle: function(rectangle) {\n        var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);\n        var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);\n\n        return new $.Rect(\n            topLeft.x * $.pixelDensityRatio,\n            topLeft.y * $.pixelDensityRatio,\n            size.x    * $.pixelDensityRatio,\n            size.y    * $.pixelDensityRatio\n        );\n    },\n\n    /**\n     * Draws the given tile.\n     * @param {OpenSeadragon.Tile} tile - The tile to draw.\n     * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.\n     * drawingHandler({context, tile, rendered})\n     * @param {Boolean} useSketch - Whether to use the sketch canvas or not.\n     * where <code>rendered</code> is the context with the pre-drawn image.\n     * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.\n     * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position\n     */\n    drawTile: function(tile, drawingHandler, useSketch, scale, translate) {\n        $.console.assert(tile, \'[Drawer.drawTile] tile is required\');\n        $.console.assert(drawingHandler, \'[Drawer.drawTile] drawingHandler is required\');\n\n        if (this.useCanvas) {\n            var context = this._getContext(useSketch);\n            scale = scale || 1;\n            tile.drawCanvas(context, drawingHandler, scale, translate);\n        } else {\n            tile.drawHTML( this.canvas );\n        }\n    },\n\n    _getContext: function( useSketch ) {\n        var context = this.context;\n        if ( useSketch ) {\n            if (this.sketchCanvas === null) {\n                this.sketchCanvas = document.createElement( "canvas" );\n                var sketchCanvasSize = this._calculateSketchCanvasSize();\n                this.sketchCanvas.width = sketchCanvasSize.x;\n                this.sketchCanvas.height = sketchCanvasSize.y;\n                this.sketchContext = this.sketchCanvas.getContext( "2d" );\n\n                // If the viewport is not currently rotated, the sketchCanvas\n                // will have the same size as the main canvas. However, if\n                // the viewport get rotated later on, we will need to resize it.\n                if (this.viewport.getRotation() === 0) {\n                    var self = this;\n                    this.viewer.addHandler(\'rotate\', function resizeSketchCanvas() {\n                        self.viewer.removeHandler(\'rotate\', resizeSketchCanvas);\n                        var sketchCanvasSize = self._calculateSketchCanvasSize();\n                        self.sketchCanvas.width = sketchCanvasSize.x;\n                        self.sketchCanvas.height = sketchCanvasSize.y;\n                    });\n                }\n            }\n            context = this.sketchContext;\n        }\n        return context;\n    },\n\n    // private\n    saveContext: function( useSketch ) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        this._getContext( useSketch ).save();\n    },\n\n    // private\n    restoreContext: function( useSketch ) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        this._getContext( useSketch ).restore();\n    },\n\n    // private\n    setClip: function(rect, useSketch) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        var context = this._getContext( useSketch );\n        context.beginPath();\n        context.rect(rect.x, rect.y, rect.width, rect.height);\n        context.clip();\n    },\n\n    // private\n    drawRectangle: function(rect, fillStyle, useSketch) {\n        if (!this.useCanvas) {\n            return;\n        }\n\n        var context = this._getContext( useSketch );\n        context.save();\n        context.fillStyle = fillStyle;\n        context.fillRect(rect.x, rect.y, rect.width, rect.height);\n        context.restore();\n    },\n\n    /**\n     * Blends the sketch canvas in the main canvas.\n     * @param {Object} options The options\n     * @param {Float} options.opacity The opacity of the blending.\n     * @param {Float} [options.scale=1] The scale at which tiles were drawn on\n     * the sketch. Default is 1.\n     * Use scale to draw at a lower scale and then enlarge onto the main canvas.\n     * @param {OpenSeadragon.Point} [options.translate] A translation vector\n     * that was used to draw the tiles\n     * @param {String} [options.compositeOperation] - How the image is\n     * composited onto other images; see compositeOperation in\n     * {@link OpenSeadragon.Options} for possible values.\n     * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch\n     * canvas to blend in the main canvas. If specified, options.scale and\n     * options.translate get ignored.\n     */\n    blendSketch: function(opacity, scale, translate, compositeOperation) {\n        var options = opacity;\n        if (!$.isPlainObject(options)) {\n            options = {\n                opacity: opacity,\n                scale: scale,\n                translate: translate,\n                compositeOperation: compositeOperation\n            };\n        }\n        if (!this.useCanvas || !this.sketchCanvas) {\n            return;\n        }\n        opacity = options.opacity;\n        compositeOperation = options.compositeOperation;\n        var bounds = options.bounds;\n\n        this.context.save();\n        this.context.globalAlpha = opacity;\n        if (compositeOperation) {\n            this.context.globalCompositeOperation = compositeOperation;\n        }\n        if (bounds) {\n            this.context.drawImage(\n                this.sketchCanvas,\n                bounds.x,\n                bounds.y,\n                bounds.width,\n                bounds.height,\n                bounds.x,\n                bounds.y,\n                bounds.width,\n                bounds.height\n            );\n        } else {\n            scale = options.scale || 1;\n            translate = options.translate;\n            var position = translate instanceof $.Point ?\n                translate : new $.Point(0, 0);\n\n            var widthExt = 0;\n            var heightExt = 0;\n            if (translate) {\n                var widthDiff = this.sketchCanvas.width - this.canvas.width;\n                var heightDiff = this.sketchCanvas.height - this.canvas.height;\n                widthExt = Math.round(widthDiff / 2);\n                heightExt = Math.round(heightDiff / 2);\n            }\n            this.context.drawImage(\n                this.sketchCanvas,\n                position.x - widthExt * scale,\n                position.y - heightExt * scale,\n                (this.canvas.width + 2 * widthExt) * scale,\n                (this.canvas.height  + 2 * heightExt) * scale,\n                -widthExt,\n                -heightExt,\n                this.canvas.width + 2 * widthExt,\n                this.canvas.height + 2 * heightExt\n            );\n        }\n        this.context.restore();\n    },\n\n    // private\n    drawDebugInfo: function( tile, count, i ){\n        if ( !this.useCanvas ) {\n            return;\n        }\n\n        var context = this.context;\n        context.save();\n        context.lineWidth = 2 * $.pixelDensityRatio;\n        context.font = \'small-caps bold \' + (13 * $.pixelDensityRatio) + \'px arial\';\n        context.strokeStyle = this.debugGridColor;\n        context.fillStyle = this.debugGridColor;\n\n        if ( this.viewport.degrees !== 0 ) {\n            this._offsetForRotation(this.viewport.degrees);\n        }\n\n        context.strokeRect(\n            tile.position.x * $.pixelDensityRatio,\n            tile.position.y * $.pixelDensityRatio,\n            tile.size.x * $.pixelDensityRatio,\n            tile.size.y * $.pixelDensityRatio\n        );\n\n        var tileCenterX = (tile.position.x + (tile.size.x / 2)) * $.pixelDensityRatio;\n        var tileCenterY = (tile.position.y + (tile.size.y / 2)) * $.pixelDensityRatio;\n\n        // Rotate the text the right way around.\n        context.translate( tileCenterX, tileCenterY );\n        context.rotate( Math.PI / 180 * -this.viewport.degrees );\n        context.translate( -tileCenterX, -tileCenterY );\n\n        if( tile.x === 0 && tile.y === 0 ){\n            context.fillText(\n                "Zoom: " + this.viewport.getZoom(),\n                tile.position.x * $.pixelDensityRatio,\n                (tile.position.y - 30) * $.pixelDensityRatio\n            );\n            context.fillText(\n                "Pan: " + this.viewport.getBounds().toString(),\n                tile.position.x * $.pixelDensityRatio,\n                (tile.position.y - 20) * $.pixelDensityRatio\n            );\n        }\n        context.fillText(\n            "Level: " + tile.level,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 20) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Column: " + tile.x,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 30) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Row: " + tile.y,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 40) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Order: " + i + " of " + count,\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 50) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Size: " + tile.size.toString(),\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 60) * $.pixelDensityRatio\n        );\n        context.fillText(\n            "Position: " + tile.position.toString(),\n            (tile.position.x + 10) * $.pixelDensityRatio,\n            (tile.position.y + 70) * $.pixelDensityRatio\n        );\n\n        if ( this.viewport.degrees !== 0 ) {\n            this._restoreRotationChanges();\n        }\n        context.restore();\n    },\n\n    // private\n    debugRect: function(rect) {\n        if ( this.useCanvas ) {\n            var context = this.context;\n            context.save();\n            context.lineWidth = 2 * $.pixelDensityRatio;\n            context.strokeStyle = this.debugGridColor;\n            context.fillStyle = this.debugGridColor;\n\n            context.strokeRect(\n                rect.x * $.pixelDensityRatio,\n                rect.y * $.pixelDensityRatio,\n                rect.width * $.pixelDensityRatio,\n                rect.height * $.pixelDensityRatio\n            );\n\n            context.restore();\n        }\n    },\n\n    /**\n     * Get the canvas size\n     * @param {Boolean} sketch If set to true return the size of the sketch canvas\n     * @returns {OpenSeadragon.Point} The size of the canvas\n     */\n    getCanvasSize: function(sketch) {\n        var canvas = this._getContext(sketch).canvas;\n        return new $.Point(canvas.width, canvas.height);\n    },\n\n    // private\n    _offsetForRotation: function(degrees, useSketch) {\n        var cx = this.canvas.width / 2;\n        var cy = this.canvas.height / 2;\n\n        var context = this._getContext(useSketch);\n        context.save();\n\n        context.translate(cx, cy);\n        context.rotate(Math.PI / 180 * degrees);\n        context.translate(-cx, -cy);\n    },\n\n    // private\n    _restoreRotationChanges: function(useSketch) {\n        var context = this._getContext(useSketch);\n        context.restore();\n    },\n\n    // private\n    _calculateCanvasSize: function() {\n        var pixelDensityRatio = $.pixelDensityRatio;\n        var viewportSize = this.viewport.getContainerSize();\n        return {\n            x: viewportSize.x * pixelDensityRatio,\n            y: viewportSize.y * pixelDensityRatio\n        };\n    },\n\n    // private\n    _calculateSketchCanvasSize: function() {\n        var canvasSize = this._calculateCanvasSize();\n        if (this.viewport.getRotation() === 0) {\n            return canvasSize;\n        }\n        // If the viewport is rotated, we need a larger sketch canvas in order\n        // to support edge smoothing.\n        var sketchCanvasSize = Math.ceil(Math.sqrt(\n            canvasSize.x * canvasSize.x +\n            canvasSize.y * canvasSize.y));\n        return {\n            x: sketchCanvasSize,\n            y: sketchCanvasSize\n        };\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - Viewport\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n\n/**\n * @class Viewport\n * @memberof OpenSeadragon\n * @classdesc Handles coordinate-related functionality (zoom, pan, rotation, etc.)\n * for an {@link OpenSeadragon.Viewer}.\n * @param {Object} options - Options for this Viewport.\n * @param {Object} [options.margins] - See viewportMargins in {@link OpenSeadragon.Options}.\n * @param {Number} [options.springStiffness] - See springStiffness in {@link OpenSeadragon.Options}.\n * @param {Number} [options.animationTime] - See animationTime in {@link OpenSeadragon.Options}.\n * @param {Number} [options.minZoomImageRatio] - See minZoomImageRatio in {@link OpenSeadragon.Options}.\n * @param {Number} [options.maxZoomPixelRatio] - See maxZoomPixelRatio in {@link OpenSeadragon.Options}.\n * @param {Number} [options.visibilityRatio] - See visibilityRatio in {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapHorizontal] - See wrapHorizontal in {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapVertical] - See wrapVertical in {@link OpenSeadragon.Options}.\n * @param {Number} [options.defaultZoomLevel] - See defaultZoomLevel in {@link OpenSeadragon.Options}.\n * @param {Number} [options.minZoomLevel] - See minZoomLevel in {@link OpenSeadragon.Options}.\n * @param {Number} [options.maxZoomLevel] - See maxZoomLevel in {@link OpenSeadragon.Options}.\n * @param {Number} [options.degrees] - See degrees in {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.homeFillsViewer] - See homeFillsViewer in {@link OpenSeadragon.Options}.\n */\n$.Viewport = function( options ) {\n\n    //backward compatibility for positional args while prefering more\n    //idiomatic javascript options object as the only argument\n    var args = arguments;\n    if(  args.length && args[ 0 ] instanceof $.Point ){\n        options = {\n            containerSize:  args[ 0 ],\n            contentSize:    args[ 1 ],\n            config:         args[ 2 ]\n        };\n    }\n\n    //options.config and the general config argument are deprecated\n    //in favor of the more direct specification of optional settings\n    //being passed directly on the options object\n    if ( options.config ){\n        $.extend( true, options, options.config );\n        delete options.config;\n    }\n\n    this._margins = $.extend({\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n    }, options.margins || {});\n\n    delete options.margins;\n\n    $.extend( true, this, {\n\n        //required settings\n        containerSize:      null,\n        contentSize:        null,\n\n        //internal state properties\n        zoomPoint:          null,\n        viewer:           null,\n\n        //configurable options\n        springStiffness:    $.DEFAULT_SETTINGS.springStiffness,\n        animationTime:      $.DEFAULT_SETTINGS.animationTime,\n        minZoomImageRatio:  $.DEFAULT_SETTINGS.minZoomImageRatio,\n        maxZoomPixelRatio:  $.DEFAULT_SETTINGS.maxZoomPixelRatio,\n        visibilityRatio:    $.DEFAULT_SETTINGS.visibilityRatio,\n        wrapHorizontal:     $.DEFAULT_SETTINGS.wrapHorizontal,\n        wrapVertical:       $.DEFAULT_SETTINGS.wrapVertical,\n        defaultZoomLevel:   $.DEFAULT_SETTINGS.defaultZoomLevel,\n        minZoomLevel:       $.DEFAULT_SETTINGS.minZoomLevel,\n        maxZoomLevel:       $.DEFAULT_SETTINGS.maxZoomLevel,\n        degrees:            $.DEFAULT_SETTINGS.degrees,\n        homeFillsViewer:    $.DEFAULT_SETTINGS.homeFillsViewer\n\n    }, options );\n\n    this._updateContainerInnerSize();\n\n    this.centerSpringX = new $.Spring({\n        initial: 0,\n        springStiffness: this.springStiffness,\n        animationTime:   this.animationTime\n    });\n    this.centerSpringY = new $.Spring({\n        initial: 0,\n        springStiffness: this.springStiffness,\n        animationTime:   this.animationTime\n    });\n    this.zoomSpring    = new $.Spring({\n        exponential: true,\n        initial: 1,\n        springStiffness: this.springStiffness,\n        animationTime:   this.animationTime\n    });\n\n    this._oldCenterX = this.centerSpringX.current.value;\n    this._oldCenterY = this.centerSpringY.current.value;\n    this._oldZoom    = this.zoomSpring.current.value;\n\n    this._setContentBounds(new $.Rect(0, 0, 1, 1), 1);\n\n    this.goHome(true);\n    this.update();\n};\n\n/** @lends OpenSeadragon.Viewport.prototype */\n$.Viewport.prototype = {\n    /**\n     * Updates the viewport\'s home bounds and constraints for the given content size.\n     * @function\n     * @param {OpenSeadragon.Point} contentSize - size of the content in content units\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:reset-size\n     */\n    resetContentSize: function(contentSize) {\n        $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");\n        $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");\n        $.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");\n        $.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");\n\n        this._setContentBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);\n        return this;\n    },\n\n    // deprecated\n    setHomeBounds: function(bounds, contentFactor) {\n        $.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");\n        this._setContentBounds(bounds, contentFactor);\n    },\n\n    // Set the viewport\'s content bounds\n    // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates\n    // without rotation\n    // @param {Number} contentFactor - how many content units per viewport unit\n    // @fires OpenSeadragon.Viewer.event:reset-size\n    // @private\n    _setContentBounds: function(bounds, contentFactor) {\n        $.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");\n        $.console.assert(bounds instanceof $.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");\n        $.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");\n        $.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");\n\n        this._contentBoundsNoRotate = bounds.clone();\n        this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(\n            contentFactor);\n\n        this._contentBounds = bounds.rotate(this.degrees).getBoundingBox();\n        this._contentSize = this._contentBounds.getSize().times(contentFactor);\n        this._contentAspectRatio = this._contentSize.x / this._contentSize.y;\n\n        if (this.viewer) {\n            /**\n             * Raised when the viewer\'s content size or home bounds are reset\n             * (see {@link OpenSeadragon.Viewport#resetContentSize}).\n             *\n             * @event reset-size\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {OpenSeadragon.Point} contentSize\n             * @property {OpenSeadragon.Rect} contentBounds - Content bounds.\n             * @property {OpenSeadragon.Rect} homeBounds - Content bounds.\n             * Deprecated use contentBounds instead.\n             * @property {Number} contentFactor\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent(\'reset-size\', {\n                contentSize: this._contentSizeNoRotate.clone(),\n                contentFactor: contentFactor,\n                homeBounds: this._contentBoundsNoRotate.clone(),\n                contentBounds: this._contentBounds.clone()\n            });\n        }\n    },\n\n    /**\n     * Returns the home zoom in "viewport zoom" value.\n     * @function\n     * @returns {Number} The home zoom in "viewport zoom".\n     */\n    getHomeZoom: function() {\n        if (this.defaultZoomLevel) {\n            return this.defaultZoomLevel;\n        }\n\n        var aspectFactor = this._contentAspectRatio / this.getAspectRatio();\n        var output;\n        if (this.homeFillsViewer) { // fill the viewer and clip the image\n            output = aspectFactor >= 1 ? aspectFactor : 1;\n        } else {\n            output = aspectFactor >= 1 ? 1 : aspectFactor;\n        }\n\n        return output / this._contentBounds.width;\n    },\n\n    /**\n     * Returns the home bounds in viewport coordinates.\n     * @function\n     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.\n     */\n    getHomeBounds: function() {\n        return this.getHomeBoundsNoRotate().rotate(-this.getRotation());\n    },\n\n    /**\n     * Returns the home bounds in viewport coordinates.\n     * This method ignores the viewport rotation. Use\n     * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.\n     * @function\n     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.\n     */\n    getHomeBoundsNoRotate: function() {\n        var center = this._contentBounds.getCenter();\n        var width  = 1.0 / this.getHomeZoom();\n        var height = width / this.getAspectRatio();\n\n        return new $.Rect(\n            center.x - (width / 2.0),\n            center.y - (height / 2.0),\n            width,\n            height\n        );\n    },\n\n    /**\n     * @function\n     * @param {Boolean} immediately\n     * @fires OpenSeadragon.Viewer.event:home\n     */\n    goHome: function(immediately) {\n        if (this.viewer) {\n            /**\n             * Raised when the "home" operation occurs (see {@link OpenSeadragon.Viewport#goHome}).\n             *\n             * @event home\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent(\'home\', {\n                immediately: immediately\n            });\n        }\n        return this.fitBounds(this.getHomeBounds(), immediately);\n    },\n\n    /**\n     * @function\n     */\n    getMinZoom: function() {\n        var homeZoom = this.getHomeZoom(),\n            zoom = this.minZoomLevel ?\n            this.minZoomLevel :\n                this.minZoomImageRatio * homeZoom;\n\n        return zoom;\n    },\n\n    /**\n     * @function\n     */\n    getMaxZoom: function() {\n        var zoom = this.maxZoomLevel;\n        if (!zoom) {\n            zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;\n            zoom /= this._contentBounds.width;\n        }\n\n        return Math.max( zoom, this.getHomeZoom() );\n    },\n\n    /**\n     * @function\n     */\n    getAspectRatio: function() {\n        return this._containerInnerSize.x / this._containerInnerSize.y;\n    },\n\n    /**\n     * @function\n     * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.\n     */\n    getContainerSize: function() {\n        return new $.Point(\n            this.containerSize.x,\n            this.containerSize.y\n        );\n    },\n\n    /**\n     * The margins push the "home" region in from the sides by the specified amounts.\n     * @function\n     * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.\n     */\n    getMargins: function() {\n        return $.extend({}, this._margins); // Make a copy so we are not returning our original\n    },\n\n    /**\n     * The margins push the "home" region in from the sides by the specified amounts.\n     * @function\n     * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.\n     */\n    setMargins: function(margins) {\n        $.console.assert($.type(margins) === \'object\', \'[Viewport.setMargins] margins must be an object\');\n\n        this._margins = $.extend({\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        }, margins);\n\n        this._updateContainerInnerSize();\n        if (this.viewer) {\n            this.viewer.forceRedraw();\n        }\n    },\n\n    /**\n     * Returns the bounds of the visible area in viewport coordinates.\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.\n     */\n    getBounds: function(current) {\n        return this.getBoundsNoRotate(current).rotate(-this.getRotation());\n    },\n\n    /**\n     * Returns the bounds of the visible area in viewport coordinates.\n     * This method ignores the viewport rotation. Use\n     * {@link OpenSeadragon.Viewport#getBounds} to take it into account.\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.\n     */\n    getBoundsNoRotate: function(current) {\n        var center = this.getCenter(current);\n        var width  = 1.0 / this.getZoom(current);\n        var height = width / this.getAspectRatio();\n\n        return new $.Rect(\n            center.x - (width / 2.0),\n            center.y - (height / 2.0),\n            width,\n            height\n        );\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,\n     * including the space taken by margins, in viewport coordinates.\n     */\n    getBoundsWithMargins: function(current) {\n        return this.getBoundsNoRotateWithMargins(current).rotate(\n            -this.getRotation(), this.getCenter(current));\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,\n     * including the space taken by margins, in viewport coordinates.\n     */\n    getBoundsNoRotateWithMargins: function(current) {\n        var bounds = this.getBoundsNoRotate(current);\n        var factor = this._containerInnerSize.x * this.getZoom(current);\n        bounds.x -= this._margins.left / factor;\n        bounds.y -= this._margins.top / factor;\n        bounds.width += (this._margins.left + this._margins.right) / factor;\n        bounds.height += (this._margins.top + this._margins.bottom) / factor;\n        return bounds;\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     */\n    getCenter: function( current ) {\n        var centerCurrent = new $.Point(\n                this.centerSpringX.current.value,\n                this.centerSpringY.current.value\n            ),\n            centerTarget = new $.Point(\n                this.centerSpringX.target.value,\n                this.centerSpringY.target.value\n            ),\n            oldZoomPixel,\n            zoom,\n            width,\n            height,\n            bounds,\n            newZoomPixel,\n            deltaZoomPixels,\n            deltaZoomPoints;\n\n        if ( current ) {\n            return centerCurrent;\n        } else if ( !this.zoomPoint ) {\n            return centerTarget;\n        }\n\n        oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);\n\n        zoom    = this.getZoom();\n        width   = 1.0 / zoom;\n        height  = width / this.getAspectRatio();\n        bounds  = new $.Rect(\n            centerCurrent.x - width / 2.0,\n            centerCurrent.y - height / 2.0,\n            width,\n            height\n        );\n\n        newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);\n        deltaZoomPixels = newZoomPixel.minus( oldZoomPixel );\n        deltaZoomPoints = deltaZoomPixels.divide( this._containerInnerSize.x * zoom );\n\n        return centerTarget.plus( deltaZoomPoints );\n    },\n\n    /**\n     * @function\n     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).\n     */\n    getZoom: function( current ) {\n        if ( current ) {\n            return this.zoomSpring.current.value;\n        } else {\n            return this.zoomSpring.target.value;\n        }\n    },\n\n    // private\n    _applyZoomConstraints: function(zoom) {\n        return Math.max(\n            Math.min(zoom, this.getMaxZoom()),\n            this.getMinZoom());\n    },\n\n    /**\n     * @function\n     * @private\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Rect} constrained bounds.\n     */\n    _applyBoundaryConstraints: function(bounds, immediately) {\n        var newBounds = new $.Rect(\n                bounds.x,\n                bounds.y,\n                bounds.width,\n                bounds.height);\n\n        if (this.wrapHorizontal) {\n            //do nothing\n        } else {\n            var horizontalThreshold = this.visibilityRatio * newBounds.width;\n            var boundsRight = newBounds.x + newBounds.width;\n            var contentRight = this._contentBoundsNoRotate.x + this._contentBoundsNoRotate.width;\n            var leftDx = this._contentBoundsNoRotate.x - boundsRight + horizontalThreshold;\n            var rightDx = contentRight - newBounds.x - horizontalThreshold;\n\n            if (horizontalThreshold > this._contentBoundsNoRotate.width) {\n                newBounds.x += (leftDx + rightDx) / 2;\n            } else if (rightDx < 0) {\n                newBounds.x += rightDx;\n            } else if (leftDx > 0) {\n                newBounds.x += leftDx;\n            }\n        }\n\n        if (this.wrapVertical) {\n            //do nothing\n        } else {\n            var verticalThreshold   = this.visibilityRatio * newBounds.height;\n            var boundsBottom = newBounds.y + newBounds.height;\n            var contentBottom = this._contentBoundsNoRotate.y + this._contentBoundsNoRotate.height;\n            var topDy = this._contentBoundsNoRotate.y - boundsBottom + verticalThreshold;\n            var bottomDy = contentBottom - newBounds.y - verticalThreshold;\n\n            if (verticalThreshold > this._contentBoundsNoRotate.height) {\n                newBounds.y += (topDy + bottomDy) / 2;\n            } else if (bottomDy < 0) {\n                newBounds.y += bottomDy;\n            } else if (topDy > 0) {\n                newBounds.y += topDy;\n            }\n        }\n\n        if (this.viewer) {\n            /**\n             * Raised when the viewport constraints are applied (see {@link OpenSeadragon.Viewport#applyConstraints}).\n             *\n             * @event constrain\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'constrain\', {\n                immediately: immediately\n            });\n        }\n\n        return newBounds;\n    },\n\n    /**\n     * Enforces the minZoom, maxZoom and visibilityRatio constraints by\n     * zooming and panning to the closest acceptable zoom and location.\n     * @function\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:constrain\n     */\n    applyConstraints: function(immediately) {\n        var actualZoom = this.getZoom();\n        var constrainedZoom = this._applyZoomConstraints(actualZoom);\n\n        if (actualZoom !== constrainedZoom) {\n            this.zoomTo(constrainedZoom, this.zoomPoint, immediately);\n        }\n\n        var bounds = this.getBoundsNoRotate();\n        var constrainedBounds = this._applyBoundaryConstraints(\n            bounds, immediately);\n\n        if (bounds.x !== constrainedBounds.x ||\n            bounds.y !== constrainedBounds.y ||\n            immediately) {\n            this.fitBounds(\n                constrainedBounds.rotate(-this.getRotation()),\n                immediately);\n        }\n        return this;\n    },\n\n    /**\n     * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}\n     * @function\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:constrain\n     */\n    ensureVisible: function(immediately) {\n        return this.applyConstraints(immediately);\n    },\n\n    /**\n     * @function\n     * @private\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Object} options (immediately=false, constraints=false)\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    _fitBounds: function(bounds, options) {\n        options = options || {};\n        var immediately = options.immediately || false;\n        var constraints = options.constraints || false;\n\n        var aspect = this.getAspectRatio();\n        var center = bounds.getCenter();\n\n        // Compute width and height of bounding box.\n        var newBounds = new $.Rect(\n            bounds.x,\n            bounds.y,\n            bounds.width,\n            bounds.height,\n            bounds.degrees + this.getRotation())\n            .getBoundingBox();\n\n        if (newBounds.getAspectRatio() >= aspect) {\n            newBounds.height = newBounds.width / aspect;\n        } else {\n            newBounds.width = newBounds.height * aspect;\n        }\n\n        // Compute x and y from width, height and center position\n        newBounds.x = center.x - newBounds.width / 2;\n        newBounds.y = center.y - newBounds.height / 2;\n        var newZoom = 1.0 / newBounds.width;\n\n        if (constraints) {\n            var newBoundsAspectRatio = newBounds.getAspectRatio();\n            var newConstrainedZoom = this._applyZoomConstraints(newZoom);\n\n            if (newZoom !== newConstrainedZoom) {\n                newZoom = newConstrainedZoom;\n                newBounds.width = 1.0 / newZoom;\n                newBounds.x = center.x - newBounds.width / 2;\n                newBounds.height = newBounds.width / newBoundsAspectRatio;\n                newBounds.y = center.y - newBounds.height / 2;\n            }\n\n            newBounds = this._applyBoundaryConstraints(newBounds, immediately);\n            center = newBounds.getCenter();\n        }\n\n        if (immediately) {\n            this.panTo(center, true);\n            return this.zoomTo(newZoom, null, true);\n        }\n\n        this.panTo(this.getCenter(true), true);\n        this.zoomTo(this.getZoom(true), null, true);\n\n        var oldBounds = this.getBounds();\n        var oldZoom   = this.getZoom();\n\n        if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 0.00000001) {\n            this.zoomTo(newZoom, true);\n            return this.panTo(center, immediately);\n        }\n\n        newBounds = newBounds.rotate(-this.getRotation());\n        var referencePoint = newBounds.getTopLeft().times(newZoom)\n            .minus(oldBounds.getTopLeft().times(oldZoom))\n            .divide(newZoom - oldZoom);\n\n        return this.zoomTo(newZoom, referencePoint, immediately);\n    },\n\n    /**\n     * Makes the viewport zoom and pan so that the specified bounds take\n     * as much space as possible in the viewport.\n     * Note: this method ignores the constraints (minZoom, maxZoom and\n     * visibilityRatio).\n     * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce\n     * them.\n     * @function\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitBounds: function(bounds, immediately) {\n        return this._fitBounds(bounds, {\n            immediately: immediately,\n            constraints: false\n        });\n    },\n\n    /**\n     * Makes the viewport zoom and pan so that the specified bounds take\n     * as much space as possible in the viewport while enforcing the constraints\n     * (minZoom, maxZoom and visibilityRatio).\n     * Note: because this method enforces the constraints, part of the\n     * provided bounds may end up outside of the viewport.\n     * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.\n     * @function\n     * @param {OpenSeadragon.Rect} bounds\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitBoundsWithConstraints: function(bounds, immediately) {\n        return this._fitBounds(bounds, {\n            immediately: immediately,\n            constraints: true\n        });\n    },\n\n    /**\n     * Zooms so the image just fills the viewer vertically.\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitVertically: function(immediately) {\n        var box = new $.Rect(\n            this._contentBounds.x + (this._contentBounds.width / 2),\n            this._contentBounds.y,\n            0,\n            this._contentBounds.height);\n        return this.fitBounds(box, immediately);\n    },\n\n    /**\n     * Zooms so the image just fills the viewer horizontally.\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    fitHorizontally: function(immediately) {\n        var box = new $.Rect(\n            this._contentBounds.x,\n            this._contentBounds.y + (this._contentBounds.height / 2),\n            this._contentBounds.width,\n            0);\n        return this.fitBounds(box, immediately);\n    },\n\n\n    /**\n     * @function\n     * @param {OpenSeadragon.Point} delta\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pan\n     */\n    panBy: function( delta, immediately ) {\n        var center = new $.Point(\n            this.centerSpringX.target.value,\n            this.centerSpringY.target.value\n        );\n        return this.panTo( center.plus( delta ), immediately );\n    },\n\n    /**\n     * @function\n     * @param {OpenSeadragon.Point} center\n     * @param {Boolean} immediately\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:pan\n     */\n    panTo: function( center, immediately ) {\n        if ( immediately ) {\n            this.centerSpringX.resetTo( center.x );\n            this.centerSpringY.resetTo( center.y );\n        } else {\n            this.centerSpringX.springTo( center.x );\n            this.centerSpringY.springTo( center.y );\n        }\n\n        if( this.viewer ){\n            /**\n             * Raised when the viewport is panned (see {@link OpenSeadragon.Viewport#panBy} and {@link OpenSeadragon.Viewport#panTo}).\n             *\n             * @event pan\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {OpenSeadragon.Point} center\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'pan\', {\n                center: center,\n                immediately: immediately\n            });\n        }\n\n        return this;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:zoom\n     */\n    zoomBy: function(factor, refPoint, immediately) {\n        return this.zoomTo(\n            this.zoomSpring.target.value * factor, refPoint, immediately);\n    },\n\n    /**\n     * Zooms to the specified zoom level\n     * @function\n     * @param {Number} zoom The zoom level to zoom to.\n     * @param {OpenSeadragon.Point} [refPoint] The point which will stay at\n     * the same screen location. Defaults to the viewport center.\n     * @param {Boolean} [immediately=false]\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:zoom\n     */\n    zoomTo: function( zoom, refPoint, immediately ) {\n\n        this.zoomPoint = refPoint instanceof $.Point &&\n            !isNaN(refPoint.x) &&\n            !isNaN(refPoint.y) ?\n            refPoint :\n            null;\n\n        if ( immediately ) {\n            this.zoomSpring.resetTo( zoom );\n        } else {\n            this.zoomSpring.springTo( zoom );\n        }\n\n        if( this.viewer ){\n            /**\n             * Raised when the viewport zoom level changes (see {@link OpenSeadragon.Viewport#zoomBy} and {@link OpenSeadragon.Viewport#zoomTo}).\n             *\n             * @event zoom\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {Number} zoom\n             * @property {OpenSeadragon.Point} refPoint\n             * @property {Boolean} immediately\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'zoom\', {\n                zoom: zoom,\n                refPoint: refPoint,\n                immediately: immediately\n            });\n        }\n\n        return this;\n    },\n\n    /**\n     * Rotates this viewport to the angle specified.\n     * @function\n     * @return {OpenSeadragon.Viewport} Chainable.\n     */\n    setRotation: function(degrees) {\n        if (!this.viewer || !this.viewer.drawer.canRotate()) {\n            return this;\n        }\n\n        degrees = degrees % 360;\n        if (degrees < 0) {\n            degrees += 360;\n        }\n        this.degrees = degrees;\n        this._setContentBounds(\n            this.viewer.world.getHomeBounds(),\n            this.viewer.world.getContentFactor());\n        this.viewer.forceRedraw();\n\n        /**\n         * Raised when rotation has been changed.\n         *\n         * @event rotate\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {Number} degrees - The number of degrees the rotation was set to.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.viewer.raiseEvent(\'rotate\', {"degrees": degrees});\n        return this;\n    },\n\n    /**\n     * Gets the current rotation in degrees.\n     * @function\n     * @return {Number} The current rotation in degrees.\n     */\n    getRotation: function() {\n        return this.degrees;\n    },\n\n    /**\n     * @function\n     * @return {OpenSeadragon.Viewport} Chainable.\n     * @fires OpenSeadragon.Viewer.event:resize\n     */\n    resize: function( newContainerSize, maintain ) {\n        var oldBounds = this.getBoundsNoRotate(),\n            newBounds = oldBounds,\n            widthDeltaFactor;\n\n        this.containerSize.x = newContainerSize.x;\n        this.containerSize.y = newContainerSize.y;\n\n        this._updateContainerInnerSize();\n\n        if ( maintain ) {\n            // TODO: widthDeltaFactor will always be 1; probably not what\'s intended\n            widthDeltaFactor = newContainerSize.x / this.containerSize.x;\n            newBounds.width  = oldBounds.width * widthDeltaFactor;\n            newBounds.height = newBounds.width / this.getAspectRatio();\n        }\n\n        if( this.viewer ){\n            /**\n             * Raised when the viewer is resized (see {@link OpenSeadragon.Viewport#resize}).\n             *\n             * @event resize\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.\n             * @property {OpenSeadragon.Point} newContainerSize\n             * @property {Boolean} maintain\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.viewer.raiseEvent( \'resize\', {\n                newContainerSize: newContainerSize,\n                maintain: maintain\n            });\n        }\n\n        return this.fitBounds( newBounds, true );\n    },\n\n    // private\n    _updateContainerInnerSize: function() {\n        this._containerInnerSize = new $.Point(\n            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),\n            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))\n        );\n    },\n\n    /**\n     * Update the zoom and center (X and Y) springs.\n     * @function\n     * @returns {Boolean} True if any change has been made, false otherwise.\n     */\n    update: function() {\n\n        if (this.zoomPoint) {\n            var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);\n            this.zoomSpring.update();\n            var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);\n\n            var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);\n            var deltaZoomPoints = this.deltaPointsFromPixels(\n                deltaZoomPixels, true);\n\n            this.centerSpringX.shiftBy(deltaZoomPoints.x);\n            this.centerSpringY.shiftBy(deltaZoomPoints.y);\n\n            if (this.zoomSpring.isAtTargetValue()) {\n                this.zoomPoint = null;\n            }\n        } else {\n            this.zoomSpring.update();\n        }\n\n        this.centerSpringX.update();\n        this.centerSpringY.update();\n\n        var changed = this.centerSpringX.current.value !== this._oldCenterX ||\n            this.centerSpringY.current.value !== this._oldCenterY ||\n            this.zoomSpring.current.value !== this._oldZoom;\n\n        this._oldCenterX = this.centerSpringX.current.value;\n        this._oldCenterY = this.centerSpringY.current.value;\n        this._oldZoom    = this.zoomSpring.current.value;\n\n        return changed;\n    },\n\n    /**\n     * Convert a delta (translation vector) from viewport coordinates to pixels\n     * coordinates. This method does not take rotation into account.\n     * Consider using deltaPixelsFromPoints if you need to account for rotation.\n     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {\n        return deltaPoints.times(\n            this._containerInnerSize.x * this.getZoom(current)\n        );\n    },\n\n    /**\n     * Convert a delta (translation vector) from viewport coordinates to pixels\n     * coordinates.\n     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPixelsFromPoints: function(deltaPoints, current) {\n        return this.deltaPixelsFromPointsNoRotate(\n            deltaPoints.rotate(this.getRotation()),\n            current);\n    },\n\n    /**\n     * Convert a delta (translation vector) from pixels coordinates to viewport\n     * coordinates. This method does not take rotation into account.\n     * Consider using deltaPointsFromPixels if you need to account for rotation.\n     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {\n        return deltaPixels.divide(\n            this._containerInnerSize.x * this.getZoom(current)\n        );\n    },\n\n    /**\n     * Convert a delta (translation vector) from pixels coordinates to viewport\n     * coordinates.\n     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    deltaPointsFromPixels: function(deltaPixels, current) {\n        return this.deltaPointsFromPixelsNoRotate(deltaPixels, current)\n            .rotate(-this.getRotation());\n    },\n\n    /**\n     * Convert viewport coordinates to pixels coordinates.\n     * This method does not take rotation into account.\n     * Consider using pixelFromPoint if you need to account for rotation.\n     * @param {OpenSeadragon.Point} point the viewport coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pixelFromPointNoRotate: function(point, current) {\n        return this._pixelFromPointNoRotate(\n            point, this.getBoundsNoRotate(current));\n    },\n\n    /**\n     * Convert viewport coordinates to pixel coordinates.\n     * @param {OpenSeadragon.Point} point the viewport coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pixelFromPoint: function(point, current) {\n        return this._pixelFromPoint(point, this.getBoundsNoRotate(current));\n    },\n\n    // private\n    _pixelFromPointNoRotate: function(point, bounds) {\n        return point.minus(\n            bounds.getTopLeft()\n        ).times(\n            this._containerInnerSize.x / bounds.width\n        ).plus(\n            new $.Point(this._margins.left, this._margins.top)\n        );\n    },\n\n    // private\n    _pixelFromPoint: function(point, bounds) {\n        return this._pixelFromPointNoRotate(\n            point.rotate(this.getRotation(), this.getCenter(true)),\n            bounds);\n    },\n\n    /**\n     * Convert pixel coordinates to viewport coordinates.\n     * This method does not take rotation into account.\n     * Consider using pointFromPixel if you need to account for rotation.\n     * @param {OpenSeadragon.Point} pixel Pixel coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pointFromPixelNoRotate: function(pixel, current) {\n        var bounds = this.getBoundsNoRotate(current);\n        return pixel.minus(\n            new $.Point(this._margins.left, this._margins.top)\n        ).divide(\n            this._containerInnerSize.x / bounds.width\n        ).plus(\n            bounds.getTopLeft()\n        );\n    },\n\n    /**\n     * Convert pixel coordinates to viewport coordinates.\n     * @param {OpenSeadragon.Point} pixel Pixel coordinates\n     * @param {Boolean} [current=false] - Pass true for the current location;\n     * defaults to false (target location).\n     * @returns {OpenSeadragon.Point}\n     */\n    pointFromPixel: function(pixel, current) {\n        return this.pointFromPixelNoRotate(pixel, current).rotate(\n            -this.getRotation(),\n            this.getCenter(true)\n        );\n    },\n\n    // private\n    _viewportToImageDelta: function( viewerX, viewerY ) {\n        var scale = this._contentBoundsNoRotate.width;\n        return new $.Point(\n            viewerX * this._contentSizeNoRotate.x / scale,\n            viewerY * this._contentSizeNoRotate.x / scale);\n    },\n\n    /**\n     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.\n     * This method can be called either by passing X,Y coordinates or an\n     * OpenSeadragon.Point\n     * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.\n     * @function\n     * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X\n     * coordinate in viewport coordinate system.\n     * @param {Number} [viewerY] Y coordinate in viewport coordinate system.\n     * @return {OpenSeadragon.Point} a point representing the coordinates in the image.\n     */\n    viewportToImageCoordinates: function(viewerX, viewerY) {\n        if (viewerX instanceof $.Point) {\n            //they passed a point instead of individual components\n            return this.viewportToImageCoordinates(viewerX.x, viewerX.y);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.viewportToImageCoordinates] is not accurate \' +\n                    \'with multi-image; use TiledImage.viewportToImageCoordinates instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageCoordinates\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.viewportToImageCoordinates(viewerX, viewerY, true);\n            }\n        }\n\n        return this._viewportToImageDelta(\n            viewerX - this._contentBoundsNoRotate.x,\n            viewerY - this._contentBoundsNoRotate.y);\n    },\n\n    // private\n    _imageToViewportDelta: function( imageX, imageY ) {\n        var scale = this._contentBoundsNoRotate.width;\n        return new $.Point(\n            imageX / this._contentSizeNoRotate.x * scale,\n            imageY / this._contentSizeNoRotate.x * scale);\n    },\n\n    /**\n     * Translates from image coordinate system to OpenSeadragon viewer coordinate system\n     * This method can be called either by passing X,Y coordinates or an\n     * OpenSeadragon.Point\n     * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.\n     * @function\n     * @param {(OpenSeadragon.Point | Number)} imageX the point or the\n     * X coordinate in image coordinate system.\n     * @param {Number} [imageY] Y coordinate in image coordinate system.\n     * @return {OpenSeadragon.Point} a point representing the coordinates in the viewport.\n     */\n    imageToViewportCoordinates: function(imageX, imageY) {\n        if (imageX instanceof $.Point) {\n            //they passed a point instead of individual components\n            return this.imageToViewportCoordinates(imageX.x, imageX.y);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.imageToViewportCoordinates] is not accurate \' +\n                    \'with multi-image; use TiledImage.imageToViewportCoordinates instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageCoordinates\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.imageToViewportCoordinates(imageX, imageY, true);\n            }\n        }\n\n        var point = this._imageToViewportDelta(imageX, imageY);\n        point.x += this._contentBoundsNoRotate.x;\n        point.y += this._contentBoundsNoRotate.y;\n        return point;\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of the image in\n     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an\n     * OpenSeadragon.Rect\n     * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.\n     * @function\n     * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X\n     * coordinate of the top left corner of the rectangle in image coordinate system.\n     * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle\n     * in image coordinate system.\n     * @param {Number} [pixelWidth] the width in pixel of the rectangle.\n     * @param {Number} [pixelHeight] the height in pixel of the rectangle.\n     */\n    imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {\n        var rect = imageX;\n        if (!(rect instanceof $.Rect)) {\n            //they passed individual components instead of a rectangle\n            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.imageToViewportRectangle] is not accurate \' +\n                    \'with multi-image; use TiledImage.imageToViewportRectangle instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.imageToViewportRectangle\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.imageToViewportRectangle(\n                    imageX, imageY, pixelWidth, pixelHeight, true);\n            }\n        }\n\n        var coordA = this.imageToViewportCoordinates(rect.x, rect.y);\n        var coordB = this._imageToViewportDelta(rect.width, rect.height);\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of\n     * the viewport in point coordinates to image rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an\n     * OpenSeadragon.Rect\n     * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.\n     * @function\n     * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or\n     * the X coordinate of the top left corner of the rectangle in viewport\n     * coordinate system.\n     * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle\n     * in viewport coordinate system.\n     * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.\n     * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.\n     */\n    viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {\n        var rect = viewerX;\n        if (!(rect instanceof $.Rect)) {\n            //they passed individual components instead of a rectangle\n            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);\n        }\n\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.viewportToImageRectangle] is not accurate \' +\n                    \'with multi-image; use TiledImage.viewportToImageRectangle instead.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageCoordinates\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.viewportToImageRectangle(\n                    viewerX, viewerY, pointWidth, pointHeight, true);\n            }\n        }\n\n        var coordA = this.viewportToImageCoordinates(rect.x, rect.y);\n        var coordB = this._viewportToImageDelta(rect.width, rect.height);\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the viewer element to image\n     * coordinates.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    viewerElementToImageCoordinates: function( pixel ) {\n        var point = this.pointFromPixel( pixel, true );\n        return this.viewportToImageCoordinates( point );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the image to\n     * viewer element coordinates.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToViewerElementCoordinates: function( pixel ) {\n        var point = this.imageToViewportCoordinates( pixel );\n        return this.pixelFromPoint( point, true );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the window to image coordinates.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    windowToImageCoordinates: function(pixel) {\n        $.console.assert(this.viewer,\n            "[Viewport.windowToImageCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = pixel.minus(\n                $.getElementPosition(this.viewer.element));\n        return this.viewerElementToImageCoordinates(viewerCoordinates);\n    },\n\n    /**\n     * Convert image coordinates to pixel coordinates relative to the window.\n     * Note: not accurate with multi-image.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToWindowCoordinates: function(pixel) {\n        $.console.assert(this.viewer,\n            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);\n        return viewerCoordinates.plus(\n                $.getElementPosition(this.viewer.element));\n    },\n\n    /**\n     * Convert pixel coordinates relative to the viewer element to viewport\n     * coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    viewerElementToViewportCoordinates: function( pixel ) {\n        return this.pointFromPixel( pixel, true );\n    },\n\n    /**\n     * Convert viewport coordinates to pixel coordinates relative to the\n     * viewer element.\n     * @param {OpenSeadragon.Point} point\n     * @returns {OpenSeadragon.Point}\n     */\n    viewportToViewerElementCoordinates: function( point ) {\n        return this.pixelFromPoint( point, true );\n    },\n\n    /**\n     * Convert a rectangle in pixel coordinates relative to the viewer element\n     * to viewport coordinates.\n     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert\n     * @returns {OpenSeadragon.Rect} the converted rectangle\n     */\n    viewerElementToViewportRectangle: function(rectangle) {\n        return $.Rect.fromSummits(\n            this.pointFromPixel(rectangle.getTopLeft(), true),\n            this.pointFromPixel(rectangle.getTopRight(), true),\n            this.pointFromPixel(rectangle.getBottomLeft(), true)\n        );\n    },\n\n    /**\n     * Convert a rectangle in viewport coordinates to pixel coordinates relative\n     * to the viewer element.\n     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert\n     * @returns {OpenSeadragon.Rect} the converted rectangle\n     */\n    viewportToViewerElementRectangle: function(rectangle) {\n        return $.Rect.fromSummits(\n            this.pixelFromPoint(rectangle.getTopLeft(), true),\n            this.pixelFromPoint(rectangle.getTopRight(), true),\n            this.pixelFromPoint(rectangle.getBottomLeft(), true)\n        );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the window to viewport coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    windowToViewportCoordinates: function(pixel) {\n        $.console.assert(this.viewer,\n            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = pixel.minus(\n                $.getElementPosition(this.viewer.element));\n        return this.viewerElementToViewportCoordinates(viewerCoordinates);\n    },\n\n    /**\n     * Convert viewport coordinates to pixel coordinates relative to the window.\n     * @param {OpenSeadragon.Point} point\n     * @returns {OpenSeadragon.Point}\n     */\n    viewportToWindowCoordinates: function(point) {\n        $.console.assert(this.viewer,\n            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer.");\n        var viewerCoordinates = this.viewportToViewerElementCoordinates(point);\n        return viewerCoordinates.plus(\n                $.getElementPosition(this.viewer.element));\n    },\n\n    /**\n     * Convert a viewport zoom to an image zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * Note: not accurate with multi-image.\n     * @function\n     * @param {Number} viewportZoom The viewport zoom\n     * target zoom.\n     * @returns {Number} imageZoom The image zoom\n     */\n    viewportToImageZoom: function(viewportZoom) {\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.viewportToImageZoom] is not \' +\n                    \'accurate with multi-image.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.viewportToImageZoom\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.viewportToImageZoom(viewportZoom);\n            }\n        }\n\n        var imageWidth = this._contentSizeNoRotate.x;\n        var containerWidth = this._containerInnerSize.x;\n        var scale = this._contentBoundsNoRotate.width;\n        var viewportToImageZoomRatio = (containerWidth / imageWidth) * scale;\n        return viewportZoom * viewportToImageZoomRatio;\n    },\n\n    /**\n     * Convert an image zoom to a viewport zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * Note: not accurate with multi-image.\n     * @function\n     * @param {Number} imageZoom The image zoom\n     * target zoom.\n     * @returns {Number} viewportZoom The viewport zoom\n     */\n    imageToViewportZoom: function(imageZoom) {\n        if (this.viewer) {\n            var count = this.viewer.world.getItemCount();\n            if (count > 1) {\n                $.console.error(\'[Viewport.imageToViewportZoom] is not accurate \' +\n                    \'with multi-image.\');\n            } else if (count === 1) {\n                // It is better to use TiledImage.imageToViewportZoom\n                // because this._contentBoundsNoRotate can not be relied on\n                // with clipping.\n                var item = this.viewer.world.getItemAt(0);\n                return item.imageToViewportZoom(imageZoom);\n            }\n        }\n\n        var imageWidth = this._contentSizeNoRotate.x;\n        var containerWidth = this._containerInnerSize.x;\n        var scale = this._contentBoundsNoRotate.width;\n        var viewportToImageZoomRatio = (imageWidth / containerWidth) / scale;\n        return imageZoom * viewportToImageZoomRatio;\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TiledImage\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * You shouldn\'t have to create a TiledImage directly; use {@link OpenSeadragon.Viewer#open}\n * or {@link OpenSeadragon.Viewer#addTiledImage} instead.\n * @class TiledImage\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.\n * A new instance is created for each TileSource opened.\n * @param {Object} options - Configuration for this TiledImage.\n * @param {OpenSeadragon.TileSource} options.source - The TileSource that defines this TiledImage.\n * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this TiledImage.\n * @param {OpenSeadragon.TileCache} options.tileCache - The TileCache for this TiledImage to use.\n * @param {OpenSeadragon.Drawer} options.drawer - The Drawer for this TiledImage to draw onto.\n * @param {OpenSeadragon.ImageLoader} options.imageLoader - The ImageLoader for this TiledImage to use.\n * @param {Number} [options.x=0] - Left position, in viewport coordinates.\n * @param {Number} [options.y=0] - Top position, in viewport coordinates.\n * @param {Number} [options.width=1] - Width, in viewport coordinates.\n * @param {Number} [options.height] - Height, in viewport coordinates.\n * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates\n * to fit the image into. If specified, x, y, width and height get ignored.\n * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]\n * How to anchor the image in the bounds if options.fitBounds is set.\n * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to\n * (portions of the image outside of this area will not be visible). Only works on\n * browsers that support the HTML5 canvas.\n * @param {Number} [options.springStiffness] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.animationTime] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.minZoomImageRatio] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapHorizontal] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.wrapVertical] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.immediateRender] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.blendTime] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.alwaysBlend] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.minPixelRatio] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.smoothTileEdgesMinZoom] - See {@link OpenSeadragon.Options}.\n * @param {Boolean} [options.iOSDevice] - See {@link OpenSeadragon.Options}.\n * @param {Number} [options.opacity=1] - Opacity the tiled image should be drawn at.\n * @param {String} [options.compositeOperation] - How the image is composited onto other images; see compositeOperation in {@link OpenSeadragon.Options} for possible values.\n * @param {Boolean} [options.debugMode] - See {@link OpenSeadragon.Options}.\n * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.\n * @param {String|Boolean} [options.crossOriginPolicy] - See {@link OpenSeadragon.Options}.\n */\n$.TiledImage = function( options ) {\n    var _this = this;\n\n    $.console.assert( options.tileCache, "[TiledImage] options.tileCache is required" );\n    $.console.assert( options.drawer, "[TiledImage] options.drawer is required" );\n    $.console.assert( options.viewer, "[TiledImage] options.viewer is required" );\n    $.console.assert( options.imageLoader, "[TiledImage] options.imageLoader is required" );\n    $.console.assert( options.source, "[TiledImage] options.source is required" );\n    $.console.assert(!options.clip || options.clip instanceof $.Rect,\n        "[TiledImage] options.clip must be an OpenSeadragon.Rect if present");\n\n    $.EventSource.call( this );\n\n    this._tileCache = options.tileCache;\n    delete options.tileCache;\n\n    this._drawer = options.drawer;\n    delete options.drawer;\n\n    this._imageLoader = options.imageLoader;\n    delete options.imageLoader;\n\n    if (options.clip instanceof $.Rect) {\n        this._clip = options.clip.clone();\n    }\n\n    delete options.clip;\n\n    var x = options.x || 0;\n    delete options.x;\n    var y = options.y || 0;\n    delete options.y;\n\n    // Ratio of zoomable image height to width.\n    this.normHeight = options.source.dimensions.y / options.source.dimensions.x;\n    this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;\n\n    var scale = 1;\n    if ( options.width ) {\n        scale = options.width;\n        delete options.width;\n\n        if ( options.height ) {\n            $.console.error( "specifying both width and height to a tiledImage is not supported" );\n            delete options.height;\n        }\n    } else if ( options.height ) {\n        scale = options.height / this.normHeight;\n        delete options.height;\n    }\n\n    var fitBounds = options.fitBounds;\n    delete options.fitBounds;\n    var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;\n    delete options.fitBoundsPlacement;\n\n    $.extend( true, this, {\n\n        //internal state properties\n        viewer:         null,\n        tilesMatrix:    {},    // A \'3d\' dictionary [level][x][y] --\x3e Tile.\n        coverage:       {},    // A \'3d\' dictionary [level][x][y] --\x3e Boolean.\n        lastDrawn:      [],    // An unordered list of Tiles drawn last frame.\n        lastResetTime:  0,     // Last time for which the tiledImage was reset.\n        _midDraw:       false, // Is the tiledImage currently updating the viewport?\n        _needsDraw:     true,  // Does the tiledImage need to update the viewport again?\n        _hasOpaqueTile: false,  // Do we have even one fully opaque tile?\n        //configurable settings\n        springStiffness:        $.DEFAULT_SETTINGS.springStiffness,\n        animationTime:          $.DEFAULT_SETTINGS.animationTime,\n        minZoomImageRatio:      $.DEFAULT_SETTINGS.minZoomImageRatio,\n        wrapHorizontal:         $.DEFAULT_SETTINGS.wrapHorizontal,\n        wrapVertical:           $.DEFAULT_SETTINGS.wrapVertical,\n        immediateRender:        $.DEFAULT_SETTINGS.immediateRender,\n        blendTime:              $.DEFAULT_SETTINGS.blendTime,\n        alwaysBlend:            $.DEFAULT_SETTINGS.alwaysBlend,\n        minPixelRatio:          $.DEFAULT_SETTINGS.minPixelRatio,\n        smoothTileEdgesMinZoom: $.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,\n        iOSDevice:              $.DEFAULT_SETTINGS.iOSDevice,\n        debugMode:              $.DEFAULT_SETTINGS.debugMode,\n        crossOriginPolicy:      $.DEFAULT_SETTINGS.crossOriginPolicy,\n        placeholderFillStyle:   $.DEFAULT_SETTINGS.placeholderFillStyle,\n        opacity:                $.DEFAULT_SETTINGS.opacity,\n        compositeOperation:     $.DEFAULT_SETTINGS.compositeOperation\n\n    }, options );\n\n    this._xSpring = new $.Spring({\n        initial: x,\n        springStiffness: this.springStiffness,\n        animationTime: this.animationTime\n    });\n\n    this._ySpring = new $.Spring({\n        initial: y,\n        springStiffness: this.springStiffness,\n        animationTime: this.animationTime\n    });\n\n    this._scaleSpring = new $.Spring({\n        initial: scale,\n        springStiffness: this.springStiffness,\n        animationTime: this.animationTime\n    });\n\n    this._updateForScale();\n\n    if (fitBounds) {\n        this.fitBounds(fitBounds, fitBoundsPlacement, true);\n    }\n\n    // We need a callback to give image manipulation a chance to happen\n    this._drawingHandler = function(args) {\n      /**\n       * This event is fired just before the tile is drawn giving the application a chance to alter the image.\n       *\n       * NOTE: This event is only fired when the drawer is using a &lt;canvas&gt;.\n       *\n       * @event tile-drawing\n       * @memberof OpenSeadragon.Viewer\n       * @type {object}\n       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n       * @property {OpenSeadragon.Tile} tile - The Tile being drawn.\n       * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n       * @property {OpenSeadragon.Tile} context - The HTML canvas context being drawn into.\n       * @property {OpenSeadragon.Tile} rendered - The HTML canvas context containing the tile imagery.\n       * @property {?Object} userData - Arbitrary subscriber-defined object.\n       */\n        _this.viewer.raiseEvent(\'tile-drawing\', $.extend({\n            tiledImage: _this\n        }, args));\n    };\n};\n\n$.extend($.TiledImage.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.TiledImage.prototype */{\n    /**\n     * @returns {Boolean} Whether the TiledImage needs to be drawn.\n     */\n    needsDraw: function() {\n        return this._needsDraw;\n    },\n\n    /**\n     * Clears all tiles and triggers an update on the next call to\n     * {@link OpenSeadragon.TiledImage#update}.\n     */\n    reset: function() {\n        this._tileCache.clearTilesFor(this);\n        this.lastResetTime = $.now();\n        this._needsDraw = true;\n    },\n\n    /**\n     * Updates the TiledImage\'s bounds, animating if needed.\n     * @returns {Boolean} Whether the TiledImage animated.\n     */\n    update: function() {\n        var oldX = this._xSpring.current.value;\n        var oldY = this._ySpring.current.value;\n        var oldScale = this._scaleSpring.current.value;\n\n        this._xSpring.update();\n        this._ySpring.update();\n        this._scaleSpring.update();\n\n        if (this._xSpring.current.value !== oldX || this._ySpring.current.value !== oldY ||\n                this._scaleSpring.current.value !== oldScale) {\n            this._updateForScale();\n            this._needsDraw = true;\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Draws the TiledImage to its Drawer.\n     */\n    draw: function() {\n        if (this.opacity !== 0) {\n            this._midDraw = true;\n            updateViewport(this);\n            this._midDraw = false;\n        }\n    },\n\n    /**\n     * Destroy the TiledImage (unload current loaded tiles).\n     */\n    destroy: function() {\n        this.reset();\n    },\n\n    /**\n     * @returns {OpenSeadragon.Rect} This TiledImage\'s bounds in viewport coordinates.\n     * @param {Boolean} [current=false] - Pass true for the current location; false for target location.\n     */\n    getBounds: function(current) {\n        if (current) {\n            return new $.Rect( this._xSpring.current.value, this._ySpring.current.value,\n                this._worldWidthCurrent, this._worldHeightCurrent );\n        }\n\n        return new $.Rect( this._xSpring.target.value, this._ySpring.target.value,\n            this._worldWidthTarget, this._worldHeightTarget );\n    },\n\n    // deprecated\n    getWorldBounds: function() {\n        $.console.error(\'[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead\');\n        return this.getBounds();\n    },\n\n    /**\n     * Get the bounds of the displayed part of the tiled image.\n     * @param {Boolean} [current=false] Pass true for the current location,\n     * false for the target location.\n     * @returns {$.Rect} The clipped bounds in viewport coordinates.\n     */\n    getClippedBounds: function(current) {\n        var bounds = this.getBounds(current);\n        if (this._clip) {\n            var ratio = this._worldWidthCurrent / this.source.dimensions.x;\n            var clip = this._clip.times(ratio);\n            bounds = new $.Rect(\n                bounds.x + clip.x,\n                bounds.y + clip.y,\n                clip.width,\n                clip.height);\n        }\n        return bounds;\n    },\n\n    /**\n     * @returns {OpenSeadragon.Point} This TiledImage\'s content size, in original pixels.\n     */\n    getContentSize: function() {\n        return new $.Point(this.source.dimensions.x, this.source.dimensions.y);\n    },\n\n    // private\n    _viewportToImageDelta: function( viewerX, viewerY, current ) {\n        var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);\n        return new $.Point(viewerX * (this.source.dimensions.x / scale),\n            viewerY * ((this.source.dimensions.y * this.contentAspectX) / scale));\n    },\n\n    /**\n     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.\n     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.\n     * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.\n     * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Point} A point representing the coordinates in the image.\n     */\n    viewportToImageCoordinates: function( viewerX, viewerY, current ) {\n        if (viewerX instanceof $.Point) {\n            //they passed a point instead of individual components\n            current = viewerY;\n            viewerY = viewerX.y;\n            viewerX = viewerX.x;\n        }\n\n        if (current) {\n            return this._viewportToImageDelta(viewerX - this._xSpring.current.value,\n                viewerY - this._ySpring.current.value);\n        }\n\n        return this._viewportToImageDelta(viewerX - this._xSpring.target.value,\n            viewerY - this._ySpring.target.value);\n    },\n\n    // private\n    _imageToViewportDelta: function( imageX, imageY, current ) {\n        var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);\n        return new $.Point((imageX / this.source.dimensions.x) * scale,\n            (imageY / this.source.dimensions.y / this.contentAspectX) * scale);\n    },\n\n    /**\n     * Translates from image coordinate system to OpenSeadragon viewer coordinate system\n     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.\n     * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.\n     * @param {Number} [imageY] - The Y coordinate in image coordinate system.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Point} A point representing the coordinates in the viewport.\n     */\n    imageToViewportCoordinates: function( imageX, imageY, current ) {\n        if (imageX instanceof $.Point) {\n            //they passed a point instead of individual components\n            current = imageY;\n            imageY = imageX.y;\n            imageX = imageX.x;\n        }\n\n        var point = this._imageToViewportDelta(imageX, imageY);\n        if (current) {\n            point.x += this._xSpring.current.value;\n            point.y += this._ySpring.current.value;\n        } else {\n            point.x += this._xSpring.target.value;\n            point.y += this._ySpring.target.value;\n        }\n\n        return point;\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of the image in\n     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.\n     * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.\n     * @param {Number} [imageY] - The top coordinate in image coordinate system.\n     * @param {Number} [pixelWidth] - The width in pixel of the rectangle.\n     * @param {Number} [pixelHeight] - The height in pixel of the rectangle.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.\n     */\n    imageToViewportRectangle: function( imageX, imageY, pixelWidth, pixelHeight, current ) {\n        var rect = imageX;\n        if (rect instanceof $.Rect) {\n            //they passed a rect instead of individual components\n            current = imageY;\n        } else {\n            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);\n        }\n\n        var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);\n        var coordB = this._imageToViewportDelta(rect.width, rect.height, current);\n\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Translates from a rectangle which describes a portion of\n     * the viewport in point coordinates to image rectangle coordinates.\n     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.\n     * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.\n     * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.\n     * @param {Number} [pointWidth] - The width in viewport coordinate system.\n     * @param {Number} [pointHeight] - The height in viewport coordinate system.\n     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.\n     * @return {OpenSeadragon.Rect} A rect representing the coordinates in the image.\n     */\n    viewportToImageRectangle: function( viewerX, viewerY, pointWidth, pointHeight, current ) {\n        var rect = viewerX;\n        if (viewerX instanceof $.Rect) {\n            //they passed a rect instead of individual components\n            current = viewerY;\n        } else {\n            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);\n        }\n\n        var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);\n        var coordB = this._viewportToImageDelta(rect.width, rect.height, current);\n\n        return new $.Rect(\n            coordA.x,\n            coordA.y,\n            coordB.x,\n            coordB.y,\n            rect.degrees\n        );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the viewer element to image\n     * coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    viewerElementToImageCoordinates: function( pixel ) {\n        var point = this.viewport.pointFromPixel( pixel, true );\n        return this.viewportToImageCoordinates( point );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the image to\n     * viewer element coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToViewerElementCoordinates: function( pixel ) {\n        var point = this.imageToViewportCoordinates( pixel );\n        return this.viewport.pixelFromPoint( point, true );\n    },\n\n    /**\n     * Convert pixel coordinates relative to the window to image coordinates.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    windowToImageCoordinates: function( pixel ) {\n        var viewerCoordinates = pixel.minus(\n                OpenSeadragon.getElementPosition( this.viewer.element ));\n        return this.viewerElementToImageCoordinates( viewerCoordinates );\n    },\n\n    /**\n     * Convert image coordinates to pixel coordinates relative to the window.\n     * @param {OpenSeadragon.Point} pixel\n     * @returns {OpenSeadragon.Point}\n     */\n    imageToWindowCoordinates: function( pixel ) {\n        var viewerCoordinates = this.imageToViewerElementCoordinates( pixel );\n        return viewerCoordinates.plus(\n                OpenSeadragon.getElementPosition( this.viewer.element ));\n    },\n\n    /**\n     * Convert a viewport zoom to an image zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * @function\n     * @param {Number} viewportZoom The viewport zoom\n     * @returns {Number} imageZoom The image zoom\n     */\n    viewportToImageZoom: function( viewportZoom ) {\n        var ratio = this._scaleSpring.current.value *\n                this.viewport._containerInnerSize.x / this.source.dimensions.x;\n        return ratio * viewportZoom ;\n    },\n\n    /**\n     * Convert an image zoom to a viewport zoom.\n     * Image zoom: ratio of the original image size to displayed image size.\n     * 1 means original image size, 0.5 half size...\n     * Viewport zoom: ratio of the displayed image\'s width to viewport\'s width.\n     * 1 means identical width, 2 means image\'s width is twice the viewport\'s width...\n     * Note: not accurate with multi-image.\n     * @function\n     * @param {Number} imageZoom The image zoom\n     * @returns {Number} viewportZoom The viewport zoom\n     */\n    imageToViewportZoom: function( imageZoom ) {\n        var ratio = this._scaleSpring.current.value *\n                this.viewport._containerInnerSize.x / this.source.dimensions.x;\n        return imageZoom / ratio;\n    },\n\n    /**\n     * Sets the TiledImage\'s position in the world.\n     * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.\n     * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    setPosition: function(position, immediately) {\n        var sameTarget = (this._xSpring.target.value === position.x &&\n            this._ySpring.target.value === position.y);\n\n        if (immediately) {\n            if (sameTarget && this._xSpring.current.value === position.x &&\n                    this._ySpring.current.value === position.y) {\n                return;\n            }\n\n            this._xSpring.resetTo(position.x);\n            this._ySpring.resetTo(position.y);\n            this._needsDraw = true;\n        } else {\n            if (sameTarget) {\n                return;\n            }\n\n            this._xSpring.springTo(position.x);\n            this._ySpring.springTo(position.y);\n            this._needsDraw = true;\n        }\n\n        if (!sameTarget) {\n            this._raiseBoundsChange();\n        }\n    },\n\n    /**\n     * Sets the TiledImage\'s width in the world, adjusting the height to match based on aspect ratio.\n     * @param {Number} width - The new width, in viewport coordinates.\n     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    setWidth: function(width, immediately) {\n        this._setScale(width, immediately);\n    },\n\n    /**\n     * Sets the TiledImage\'s height in the world, adjusting the width to match based on aspect ratio.\n     * @param {Number} height - The new height, in viewport coordinates.\n     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    setHeight: function(height, immediately) {\n        this._setScale(height / this.normHeight, immediately);\n    },\n\n    /**\n     * Positions and scales the TiledImage to fit in the specified bounds.\n     * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change\n     * twice\n     * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.\n     * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]\n     * How to anchor the image in the bounds.\n     * @param {Boolean} [immediately=false] Whether to animate to the new size\n     * or snap immediately.\n     * @fires OpenSeadragon.TiledImage.event:bounds-change\n     */\n    fitBounds: function(bounds, anchor, immediately) {\n        anchor = anchor || $.Placement.CENTER;\n        var anchorProperties = $.Placement.properties[anchor];\n        var aspectRatio = this.contentAspectX;\n        var xOffset = 0;\n        var yOffset = 0;\n        var displayedWidthRatio = 1;\n        var displayedHeightRatio = 1;\n        if (this._clip) {\n            aspectRatio = this._clip.getAspectRatio();\n            displayedWidthRatio = this._clip.width / this.source.dimensions.x;\n            displayedHeightRatio = this._clip.height / this.source.dimensions.y;\n            if (bounds.getAspectRatio() > aspectRatio) {\n                xOffset = this._clip.x / this._clip.height * bounds.height;\n                yOffset = this._clip.y / this._clip.height * bounds.height;\n            } else {\n                xOffset = this._clip.x / this._clip.width * bounds.width;\n                yOffset = this._clip.y / this._clip.width * bounds.width;\n            }\n        }\n\n        if (bounds.getAspectRatio() > aspectRatio) {\n            // We will have margins on the X axis\n            var height = bounds.height / displayedHeightRatio;\n            var marginLeft = 0;\n            if (anchorProperties.isHorizontallyCentered) {\n                marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;\n            } else if (anchorProperties.isRight) {\n                marginLeft = bounds.width - bounds.height * aspectRatio;\n            }\n            this.setPosition(\n                new $.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),\n                immediately);\n            this.setHeight(height, immediately);\n        } else {\n            // We will have margins on the Y axis\n            var width = bounds.width / displayedWidthRatio;\n            var marginTop = 0;\n            if (anchorProperties.isVerticallyCentered) {\n                marginTop = (bounds.height - bounds.width / aspectRatio) / 2;\n            } else if (anchorProperties.isBottom) {\n                marginTop = bounds.height - bounds.width / aspectRatio;\n            }\n            this.setPosition(\n                new $.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),\n                immediately);\n            this.setWidth(width, immediately);\n        }\n    },\n\n    /**\n     * @returns {OpenSeadragon.Rect|null} The TiledImage\'s current clip rectangle,\n     * in image pixels, or null if none.\n     */\n    getClip: function() {\n        if (this._clip) {\n            return this._clip.clone();\n        }\n\n        return null;\n    },\n\n    /**\n     * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to\n     * (portions of the image outside of this area will not be visible). Only works on\n     * browsers that support the HTML5 canvas.\n     */\n    setClip: function(newClip) {\n        $.console.assert(!newClip || newClip instanceof $.Rect,\n            "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null");\n\n        if (newClip instanceof $.Rect) {\n            this._clip = newClip.clone();\n        } else {\n            this._clip = null;\n        }\n\n        this._needsDraw = true;\n    },\n\n    /**\n     * @returns {Number} The TiledImage\'s current opacity.\n     */\n    getOpacity: function() {\n        return this.opacity;\n    },\n\n    /**\n     * @param {Number} opacity Opacity the tiled image should be drawn at.\n     */\n    setOpacity: function(opacity) {\n        this.opacity = opacity;\n        this._needsDraw = true;\n    },\n\n    /**\n     * @returns {String} The TiledImage\'s current compositeOperation.\n     */\n    getCompositeOperation: function() {\n        return this.compositeOperation;\n    },\n\n    /**\n     * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.\n     */\n    setCompositeOperation: function(compositeOperation) {\n        this.compositeOperation = compositeOperation;\n        this._needsDraw = true;\n    },\n\n    // private\n    _setScale: function(scale, immediately) {\n        var sameTarget = (this._scaleSpring.target.value === scale);\n        if (immediately) {\n            if (sameTarget && this._scaleSpring.current.value === scale) {\n                return;\n            }\n\n            this._scaleSpring.resetTo(scale);\n            this._updateForScale();\n            this._needsDraw = true;\n        } else {\n            if (sameTarget) {\n                return;\n            }\n\n            this._scaleSpring.springTo(scale);\n            this._updateForScale();\n            this._needsDraw = true;\n        }\n\n        if (!sameTarget) {\n            this._raiseBoundsChange();\n        }\n    },\n\n    // private\n    _updateForScale: function() {\n        this._worldWidthTarget = this._scaleSpring.target.value;\n        this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;\n        this._worldWidthCurrent = this._scaleSpring.current.value;\n        this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;\n    },\n\n    // private\n    _raiseBoundsChange: function() {\n        /**\n         * Raised when the TiledImage\'s bounds are changed.\n         * Note that this event is triggered only when the animation target is changed;\n         * not for every frame of animation.\n         * @event bounds-change\n         * @memberOf OpenSeadragon.TiledImage\n         * @type {object}\n         * @property {OpenSeadragon.World} eventSource - A reference to the TiledImage which raised the event.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent(\'bounds-change\');\n    },\n\n    // private\n    _isBottomItem: function() {\n        return this.viewer.world.getItemAt(0) === this;\n    }\n});\n\n/**\n * @private\n * @inner\n * Pretty much every other line in this needs to be documented so it\'s clear\n * how each piece of this routine contributes to the drawing process.  That\'s\n * why there are so many TODO\'s inside this function.\n */\nfunction updateViewport( tiledImage ) {\n\n    tiledImage._needsDraw = false;\n\n    var tile,\n        level,\n        best            = null,\n        haveDrawn       = false,\n        currentTime     = $.now(),\n        viewportBounds  = tiledImage.viewport.getBoundsWithMargins( true ),\n        zeroRatioC      = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio( 0 ),\n            true\n        ).x * tiledImage._scaleSpring.current.value,\n        lowestLevel     = Math.max(\n            tiledImage.source.minLevel,\n            Math.floor(\n                Math.log( tiledImage.minZoomImageRatio ) /\n                Math.log( 2 )\n            )\n        ),\n        highestLevel    = Math.min(\n            Math.abs(tiledImage.source.maxLevel),\n            Math.abs(Math.floor(\n                Math.log( zeroRatioC / tiledImage.minPixelRatio ) /\n                Math.log( 2 )\n            ))\n        ),\n        renderPixelRatioC,\n        renderPixelRatioT,\n        zeroRatioT,\n        optimalRatio,\n        levelOpacity,\n        levelVisibility;\n\n    // Reset tile\'s internal drawn state\n    while (tiledImage.lastDrawn.length > 0) {\n        tile = tiledImage.lastDrawn.pop();\n        tile.beingDrawn = false;\n    }\n\n    if (!tiledImage.wrapHorizontal && !tiledImage.wrapVertical) {\n        var tiledImageBounds = tiledImage.getClippedBounds(true);\n        var intersection = viewportBounds.intersection(tiledImageBounds);\n        if (intersection === null) {\n            return;\n        }\n        viewportBounds = intersection;\n    }\n    viewportBounds = viewportBounds.getBoundingBox();\n    viewportBounds.x -= tiledImage._xSpring.current.value;\n    viewportBounds.y -= tiledImage._ySpring.current.value;\n\n    var viewportTL = viewportBounds.getTopLeft();\n    var viewportBR = viewportBounds.getBottomRight();\n\n    //Don\'t draw if completely outside of the viewport\n    if  ( !tiledImage.wrapHorizontal && (viewportBR.x < 0 || viewportTL.x > tiledImage._worldWidthCurrent ) ) {\n        return;\n    }\n\n    if ( !tiledImage.wrapVertical && ( viewportBR.y < 0 || viewportTL.y > tiledImage._worldHeightCurrent ) ) {\n        return;\n    }\n\n    // Calculate viewport rect / bounds\n    if ( !tiledImage.wrapHorizontal ) {\n        viewportTL.x = Math.max( viewportTL.x, 0 );\n        viewportBR.x = Math.min( viewportBR.x, tiledImage._worldWidthCurrent );\n    }\n\n    if ( !tiledImage.wrapVertical ) {\n        viewportTL.y = Math.max( viewportTL.y, 0 );\n        viewportBR.y = Math.min( viewportBR.y, tiledImage._worldHeightCurrent );\n    }\n\n    // Calculations for the interval of levels to draw\n    // (above in initial var statement)\n    // can return invalid intervals; fix that here if necessary\n    lowestLevel = Math.min( lowestLevel, highestLevel );\n\n    // Update any level that will be drawn\n    var drawLevel; // FIXME: drawLevel should have a more explanatory name\n    for ( level = highestLevel; level >= lowestLevel; level-- ) {\n        drawLevel = false;\n\n        //Avoid calculations for draw if we have already drawn this\n        renderPixelRatioC = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio( level ),\n            true\n        ).x * tiledImage._scaleSpring.current.value;\n\n        if ( ( !haveDrawn && renderPixelRatioC >= tiledImage.minPixelRatio ) ||\n             ( level == lowestLevel ) ) {\n            drawLevel = true;\n            haveDrawn = true;\n        } else if ( !haveDrawn ) {\n            continue;\n        }\n\n        //Perform calculations for draw if we haven\'t drawn this\n        renderPixelRatioT = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio( level ),\n            false\n        ).x * tiledImage._scaleSpring.current.value;\n\n        zeroRatioT      = tiledImage.viewport.deltaPixelsFromPointsNoRotate(\n            tiledImage.source.getPixelRatio(\n                Math.max(\n                    tiledImage.source.getClosestLevel( tiledImage.viewport.containerSize ) - 1,\n                    0\n                )\n            ),\n            false\n        ).x * tiledImage._scaleSpring.current.value;\n\n        optimalRatio    = tiledImage.immediateRender ?\n            1 :\n            zeroRatioT;\n\n        levelOpacity    = Math.min( 1, ( renderPixelRatioC - 0.5 ) / 0.5 );\n\n        levelVisibility = optimalRatio / Math.abs(\n            optimalRatio - renderPixelRatioT\n        );\n\n        // Update the level and keep track of \'best\' tile to load\n        best = updateLevel(\n            tiledImage,\n            haveDrawn,\n            drawLevel,\n            level,\n            levelOpacity,\n            levelVisibility,\n            viewportTL,\n            viewportBR,\n            currentTime,\n            best\n        );\n\n        // Stop the loop if lower-res tiles would all be covered by\n        // already drawn tiles\n        if (  providesCoverage( tiledImage.coverage, level ) ) {\n            break;\n        }\n    }\n\n    // Perform the actual drawing\n    drawTiles( tiledImage, tiledImage.lastDrawn );\n\n    // Load the new \'best\' tile\n    if (best && !best.context2D) {\n        loadTile( tiledImage, best, currentTime );\n    }\n\n}\n\n\nfunction updateLevel( tiledImage, haveDrawn, drawLevel, level, levelOpacity, levelVisibility, viewportTL, viewportBR, currentTime, best ){\n\n    var x, y,\n        tileTL,\n        tileBR,\n        numberOfTiles,\n        viewportCenter  = tiledImage.viewport.pixelFromPoint( tiledImage.viewport.getCenter() );\n\n\n    if( tiledImage.viewer ){\n        /**\n         * <em>- Needs documentation -</em>\n         *\n         * @event update-level\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n         * @property {Object} havedrawn\n         * @property {Object} level\n         * @property {Object} opacity\n         * @property {Object} visibility\n         * @property {Object} topleft\n         * @property {Object} bottomright\n         * @property {Object} currenttime\n         * @property {Object} best\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        tiledImage.viewer.raiseEvent( \'update-level\', {\n            tiledImage: tiledImage,\n            havedrawn: haveDrawn,\n            level: level,\n            opacity: levelOpacity,\n            visibility: levelVisibility,\n            topleft: viewportTL,\n            bottomright: viewportBR,\n            currenttime: currentTime,\n            best: best\n        });\n    }\n\n    //OK, a new drawing so do your calculations\n    tileTL    = tiledImage.source.getTileAtPoint( level, viewportTL.divide( tiledImage._scaleSpring.current.value ));\n    tileBR    = tiledImage.source.getTileAtPoint( level, viewportBR.divide( tiledImage._scaleSpring.current.value ));\n    numberOfTiles  = tiledImage.source.getNumTiles( level );\n\n    resetCoverage( tiledImage.coverage, level );\n\n    if ( !tiledImage.wrapHorizontal ) {\n        tileBR.x = Math.min( tileBR.x, numberOfTiles.x - 1 );\n    }\n    if ( !tiledImage.wrapVertical ) {\n        tileBR.y = Math.min( tileBR.y, numberOfTiles.y - 1 );\n    }\n\n    for ( x = tileTL.x; x <= tileBR.x; x++ ) {\n        for ( y = tileTL.y; y <= tileBR.y; y++ ) {\n\n            best = updateTile(\n                tiledImage,\n                drawLevel,\n                haveDrawn,\n                x, y,\n                level,\n                levelOpacity,\n                levelVisibility,\n                viewportCenter,\n                numberOfTiles,\n                currentTime,\n                best\n            );\n\n        }\n    }\n\n    return best;\n}\n\nfunction updateTile( tiledImage, drawLevel, haveDrawn, x, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best){\n\n    var tile = getTile(\n            x, y,\n            level,\n            tiledImage.source,\n            tiledImage.tilesMatrix,\n            currentTime,\n            numberOfTiles,\n            tiledImage._worldWidthCurrent,\n            tiledImage._worldHeightCurrent\n        ),\n        drawTile = drawLevel;\n\n    if( tiledImage.viewer ){\n        /**\n         * <em>- Needs documentation -</em>\n         *\n         * @event update-tile\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n         * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n         * @property {OpenSeadragon.Tile} tile\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        tiledImage.viewer.raiseEvent( \'update-tile\', {\n            tiledImage: tiledImage,\n            tile: tile\n        });\n    }\n\n    setCoverage( tiledImage.coverage, level, x, y, false );\n\n    if ( !tile.exists ) {\n        return best;\n    }\n\n    if ( haveDrawn && !drawTile ) {\n        if ( isCovered( tiledImage.coverage, level, x, y ) ) {\n            setCoverage( tiledImage.coverage, level, x, y, true );\n        } else {\n            drawTile = true;\n        }\n    }\n\n    if ( !drawTile ) {\n        return best;\n    }\n\n    positionTile(\n        tile,\n        tiledImage.source.tileOverlap,\n        tiledImage.viewport,\n        viewportCenter,\n        levelVisibility,\n        tiledImage\n    );\n\n    if (!tile.loaded) {\n        if (tile.context2D) {\n            setTileLoaded(tiledImage, tile);\n        } else {\n            var imageRecord = tiledImage._tileCache.getImageRecord(tile.url);\n            if (imageRecord) {\n                var image = imageRecord.getImage();\n                setTileLoaded(tiledImage, tile, image);\n            }\n        }\n    }\n\n    if ( tile.loaded ) {\n        var needsDraw = blendTile(\n            tiledImage,\n            tile,\n            x, y,\n            level,\n            levelOpacity,\n            currentTime\n        );\n\n        if ( needsDraw ) {\n            tiledImage._needsDraw = true;\n        }\n    } else if ( tile.loading ) {\n        // the tile is already in the download queue\n        // thanks josh1093 for finally translating this typo\n    } else {\n        best = compareTiles( best, tile );\n    }\n\n    return best;\n}\n\nfunction getTile( x, y, level, tileSource, tilesMatrix, time, numTiles, worldWidth, worldHeight ) {\n    var xMod,\n        yMod,\n        bounds,\n        exists,\n        url,\n        context2D,\n        tile;\n\n    if ( !tilesMatrix[ level ] ) {\n        tilesMatrix[ level ] = {};\n    }\n    if ( !tilesMatrix[ level ][ x ] ) {\n        tilesMatrix[ level ][ x ] = {};\n    }\n\n    if ( !tilesMatrix[ level ][ x ][ y ] ) {\n        xMod    = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;\n        yMod    = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;\n        bounds  = tileSource.getTileBounds( level, xMod, yMod );\n        exists  = tileSource.tileExists( level, xMod, yMod );\n        url     = tileSource.getTileUrl( level, xMod, yMod );\n        context2D = tileSource.getContext2D ?\n            tileSource.getContext2D(level, xMod, yMod) : undefined;\n\n        bounds.x += ( x - xMod ) / numTiles.x;\n        bounds.y += (worldHeight / worldWidth) * (( y - yMod ) / numTiles.y);\n\n        tilesMatrix[ level ][ x ][ y ] = new $.Tile(\n            level,\n            x,\n            y,\n            bounds,\n            exists,\n            url,\n            context2D\n        );\n    }\n\n    tile = tilesMatrix[ level ][ x ][ y ];\n    tile.lastTouchTime = time;\n\n    return tile;\n}\n\nfunction loadTile( tiledImage, tile, time ) {\n    tile.loading = true;\n    tiledImage._imageLoader.addJob({\n        src: tile.url,\n        crossOriginPolicy: tiledImage.crossOriginPolicy,\n        callback: function( image, errorMsg ){\n            onTileLoad( tiledImage, tile, time, image, errorMsg );\n        },\n        abort: function() {\n            tile.loading = false;\n        }\n    });\n}\n\nfunction onTileLoad( tiledImage, tile, time, image, errorMsg ) {\n    if ( !image ) {\n        $.console.log( "Tile %s failed to load: %s - error: %s", tile, tile.url, errorMsg );\n        /**\n         * Triggered when a tile fails to load.\n         *\n         * @event tile-load-failed\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.Tile} tile - The tile that failed to load.\n         * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image the tile belongs to.\n         * @property {number} time - The time in milliseconds when the tile load began.\n         * @property {string} message - The error message.\n         */\n        tiledImage.viewer.raiseEvent("tile-load-failed", {tile: tile, tiledImage: tiledImage, time: time, message: errorMsg});\n        tile.loading = false;\n        tile.exists = false;\n        return;\n    }\n\n    if ( time < tiledImage.lastResetTime ) {\n        $.console.log( "Ignoring tile %s loaded before reset: %s", tile, tile.url );\n        tile.loading = false;\n        return;\n    }\n\n    var finish = function() {\n        var cutoff = Math.ceil( Math.log(\n            tiledImage.source.getTileWidth(tile.level) ) / Math.log( 2 ) );\n        setTileLoaded(tiledImage, tile, image, cutoff);\n    };\n\n    // Check if we\'re mid-update; this can happen on IE8 because image load events for\n    // cached images happen immediately there\n    if ( !tiledImage._midDraw ) {\n        finish();\n    } else {\n        // Wait until after the update, in case caching unloads any tiles\n        window.setTimeout( finish, 1);\n    }\n}\n\nfunction setTileLoaded(tiledImage, tile, image, cutoff) {\n    var increment = 0;\n\n    function getCompletionCallback() {\n        increment++;\n        return completionCallback;\n    }\n\n    function completionCallback() {\n        increment--;\n        if (increment === 0) {\n            tile.loading = false;\n            tile.loaded = true;\n            if (!tile.context2D) {\n                tiledImage._tileCache.cacheTile({\n                    image: image,\n                    tile: tile,\n                    cutoff: cutoff,\n                    tiledImage: tiledImage\n                });\n            }\n            tiledImage._needsDraw = true;\n        }\n    }\n\n    /**\n     * Triggered when a tile has just been loaded in memory. That means that the\n     * image has been downloaded and can be modified before being drawn to the canvas.\n     *\n     * @event tile-loaded\n     * @memberof OpenSeadragon.Viewer\n     * @type {object}\n     * @property {Image} image - The image of the tile.\n     * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the loaded tile.\n     * @property {OpenSeadragon.Tile} tile - The tile which has been loaded.\n     * @property {function} getCompletionCallback - A function giving a callback to call\n     * when the asynchronous processing of the image is done. The image will be\n     * marked as entirely loaded when the callback has been called once for each\n     * call to getCompletionCallback.\n     */\n    tiledImage.viewer.raiseEvent("tile-loaded", {\n        tile: tile,\n        tiledImage: tiledImage,\n        image: image,\n        getCompletionCallback: getCompletionCallback\n    });\n    // In case the completion callback is never called, we at least force it once.\n    getCompletionCallback()();\n}\n\nfunction positionTile( tile, overlap, viewport, viewportCenter, levelVisibility, tiledImage ){\n    var boundsTL     = tile.bounds.getTopLeft();\n\n    boundsTL.x *= tiledImage._scaleSpring.current.value;\n    boundsTL.y *= tiledImage._scaleSpring.current.value;\n    boundsTL.x += tiledImage._xSpring.current.value;\n    boundsTL.y += tiledImage._ySpring.current.value;\n\n    var boundsSize   = tile.bounds.getSize();\n\n    boundsSize.x *= tiledImage._scaleSpring.current.value;\n    boundsSize.y *= tiledImage._scaleSpring.current.value;\n\n    var positionC    = viewport.pixelFromPointNoRotate(boundsTL, true),\n        positionT    = viewport.pixelFromPointNoRotate(boundsTL, false),\n        sizeC        = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true),\n        sizeT        = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false),\n        tileCenter   = positionT.plus( sizeT.divide( 2 ) ),\n        tileDistance = viewportCenter.distanceTo( tileCenter );\n\n    if ( !overlap ) {\n        sizeC = sizeC.plus( new $.Point( 1, 1 ) );\n    }\n\n    tile.position   = positionC;\n    tile.size       = sizeC;\n    tile.distance   = tileDistance;\n    tile.visibility = levelVisibility;\n}\n\n\nfunction blendTile( tiledImage, tile, x, y, level, levelOpacity, currentTime ){\n    var blendTimeMillis = 1000 * tiledImage.blendTime,\n        deltaTime,\n        opacity;\n\n    if ( !tile.blendStart ) {\n        tile.blendStart = currentTime;\n    }\n\n    deltaTime   = currentTime - tile.blendStart;\n    opacity     = blendTimeMillis ? Math.min( 1, deltaTime / ( blendTimeMillis ) ) : 1;\n\n    if ( tiledImage.alwaysBlend ) {\n        opacity *= levelOpacity;\n    }\n\n    tile.opacity = opacity;\n\n    tiledImage.lastDrawn.push( tile );\n\n    if ( opacity == 1 ) {\n        setCoverage( tiledImage.coverage, level, x, y, true );\n        tiledImage._hasOpaqueTile = true;\n    } else if ( deltaTime < blendTimeMillis ) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * @private\n * @inner\n * Returns true if the given tile provides coverage to lower-level tiles of\n * lower resolution representing the same content. If neither x nor y is\n * given, returns true if the entire visible level provides coverage.\n *\n * Note that out-of-bounds tiles provide coverage in this sense, since\n * there\'s no content that they would need to cover. Tiles at non-existent\n * levels that are within the image bounds, however, do not.\n */\nfunction providesCoverage( coverage, level, x, y ) {\n    var rows,\n        cols,\n        i, j;\n\n    if ( !coverage[ level ] ) {\n        return false;\n    }\n\n    if ( x === undefined || y === undefined ) {\n        rows = coverage[ level ];\n        for ( i in rows ) {\n            if ( rows.hasOwnProperty( i ) ) {\n                cols = rows[ i ];\n                for ( j in cols ) {\n                    if ( cols.hasOwnProperty( j ) && !cols[ j ] ) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    return (\n        coverage[ level ][ x] === undefined ||\n        coverage[ level ][ x ][ y ] === undefined ||\n        coverage[ level ][ x ][ y ] === true\n    );\n}\n\n/**\n * @private\n * @inner\n * Returns true if the given tile is completely covered by higher-level\n * tiles of higher resolution representing the same content. If neither x\n * nor y is given, returns true if the entire visible level is covered.\n */\nfunction isCovered( coverage, level, x, y ) {\n    if ( x === undefined || y === undefined ) {\n        return providesCoverage( coverage, level + 1 );\n    } else {\n        return (\n             providesCoverage( coverage, level + 1, 2 * x, 2 * y ) &&\n             providesCoverage( coverage, level + 1, 2 * x, 2 * y + 1 ) &&\n             providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y ) &&\n             providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y + 1 )\n        );\n    }\n}\n\n/**\n * @private\n * @inner\n * Sets whether the given tile provides coverage or not.\n */\nfunction setCoverage( coverage, level, x, y, covers ) {\n    if ( !coverage[ level ] ) {\n        $.console.warn(\n            "Setting coverage for a tile before its level\'s coverage has been reset: %s",\n            level\n        );\n        return;\n    }\n\n    if ( !coverage[ level ][ x ] ) {\n        coverage[ level ][ x ] = {};\n    }\n\n    coverage[ level ][ x ][ y ] = covers;\n}\n\n/**\n * @private\n * @inner\n * Resets coverage information for the given level. This should be called\n * after every draw routine. Note that at the beginning of the next draw\n * routine, coverage for every visible tile should be explicitly set.\n */\nfunction resetCoverage( coverage, level ) {\n    coverage[ level ] = {};\n}\n\n/**\n * @private\n * @inner\n * Determines whether the \'last best\' tile for the area is better than the\n * tile in question.\n */\nfunction compareTiles( previousBest, tile ) {\n    if ( !previousBest ) {\n        return tile;\n    }\n\n    if ( tile.visibility > previousBest.visibility ) {\n        return tile;\n    } else if ( tile.visibility == previousBest.visibility ) {\n        if ( tile.distance < previousBest.distance ) {\n            return tile;\n        }\n    }\n\n    return previousBest;\n}\n\nfunction drawTiles( tiledImage, lastDrawn ) {\n    if (lastDrawn.length === 0) {\n        return;\n    }\n    var tile = lastDrawn[0];\n\n    var useSketch = tiledImage.opacity < 1 ||\n        (tiledImage.compositeOperation &&\n            tiledImage.compositeOperation !== \'source-over\') ||\n        (!tiledImage._isBottomItem() && tile._hasTransparencyChannel());\n\n    var sketchScale;\n    var sketchTranslate;\n\n    var zoom = tiledImage.viewport.getZoom(true);\n    var imageZoom = tiledImage.viewportToImageZoom(zoom);\n    if (imageZoom > tiledImage.smoothTileEdgesMinZoom && !tiledImage.iOSDevice) {\n        // When zoomed in a lot (>100%) the tile edges are visible.\n        // So we have to composite them at ~100% and scale them up together.\n        // Note: Disabled on iOS devices per default as it causes a native crash\n        useSketch = true;\n        sketchScale = tile.getScaleForEdgeSmoothing();\n        sketchTranslate = tile.getTranslationForEdgeSmoothing(sketchScale,\n            tiledImage._drawer.getCanvasSize(false),\n            tiledImage._drawer.getCanvasSize(true));\n    }\n\n    var bounds;\n    if (useSketch) {\n        if (!sketchScale) {\n            // Except when edge smoothing, we only clean the part of the\n            // sketch canvas we are going to use for performance reasons.\n            bounds = tiledImage.viewport.viewportToViewerElementRectangle(\n                tiledImage.getClippedBounds(true))\n                .getIntegerBoundingBox()\n                .times($.pixelDensityRatio);\n        }\n        tiledImage._drawer._clear(true, bounds);\n    }\n\n    // When scaling, we must rotate only when blending the sketch canvas to avoid\n    // interpolation\n    if (tiledImage.viewport.degrees !== 0 && !sketchScale) {\n        tiledImage._drawer._offsetForRotation(tiledImage.viewport.degrees, useSketch);\n    }\n\n    var usedClip = false;\n    if ( tiledImage._clip ) {\n        tiledImage._drawer.saveContext(useSketch);\n\n        var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);\n        var clipRect = tiledImage._drawer.viewportToDrawerRectangle(box);\n        if (sketchScale) {\n            clipRect = clipRect.times(sketchScale);\n        }\n        if (sketchTranslate) {\n            clipRect = clipRect.translate(sketchTranslate);\n        }\n        tiledImage._drawer.setClip(clipRect, useSketch);\n\n        usedClip = true;\n    }\n\n    if ( tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false ) {\n        var placeholderRect = tiledImage._drawer.viewportToDrawerRectangle(tiledImage.getBounds(true));\n        if (sketchScale) {\n            placeholderRect = placeholderRect.times(sketchScale);\n        }\n        if (sketchTranslate) {\n            placeholderRect = placeholderRect.translate(sketchTranslate);\n        }\n\n        var fillStyle = null;\n        if ( typeof tiledImage.placeholderFillStyle === "function" ) {\n            fillStyle = tiledImage.placeholderFillStyle(tiledImage, tiledImage._drawer.context);\n        }\n        else {\n            fillStyle = tiledImage.placeholderFillStyle;\n        }\n\n        tiledImage._drawer.drawRectangle(placeholderRect, fillStyle, useSketch);\n    }\n\n    for (var i = lastDrawn.length - 1; i >= 0; i--) {\n        tile = lastDrawn[ i ];\n        tiledImage._drawer.drawTile( tile, tiledImage._drawingHandler, useSketch, sketchScale, sketchTranslate );\n        tile.beingDrawn = true;\n\n        if( tiledImage.viewer ){\n            /**\n             * <em>- Needs documentation -</em>\n             *\n             * @event tile-drawn\n             * @memberof OpenSeadragon.Viewer\n             * @type {object}\n             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.\n             * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.\n             * @property {OpenSeadragon.Tile} tile\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            tiledImage.viewer.raiseEvent( \'tile-drawn\', {\n                tiledImage: tiledImage,\n                tile: tile\n            });\n        }\n    }\n\n    if ( usedClip ) {\n        tiledImage._drawer.restoreContext( useSketch );\n    }\n\n    if (tiledImage.viewport.degrees !== 0 && !sketchScale) {\n        tiledImage._drawer._restoreRotationChanges(useSketch);\n    }\n\n    if (useSketch) {\n        var offsetForRotation = tiledImage.viewport.degrees !== 0 && sketchScale;\n        if (offsetForRotation) {\n            tiledImage._drawer._offsetForRotation(tiledImage.viewport.degrees, false);\n        }\n        tiledImage._drawer.blendSketch({\n            opacity: tiledImage.opacity,\n            scale: sketchScale,\n            translate: sketchTranslate,\n            compositeOperation: tiledImage.compositeOperation,\n            bounds: bounds\n        });\n        if (offsetForRotation) {\n            tiledImage._drawer._restoreRotationChanges(false);\n        }\n    }\n    drawDebugInfo( tiledImage, lastDrawn );\n}\n\nfunction drawDebugInfo( tiledImage, lastDrawn ) {\n    if( tiledImage.debugMode ) {\n        for ( var i = lastDrawn.length - 1; i >= 0; i-- ) {\n            var tile = lastDrawn[ i ];\n            try {\n                tiledImage._drawer.drawDebugInfo( tile, lastDrawn.length, i );\n            } catch(e) {\n                $.console.error(e);\n            }\n        }\n    }\n}\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - TileCache\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n// private class\nvar TileRecord = function( options ) {\n    $.console.assert( options, "[TileCache.cacheTile] options is required" );\n    $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );\n    $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );\n    this.tile = options.tile;\n    this.tiledImage = options.tiledImage;\n};\n\n// private class\nvar ImageRecord = function(options) {\n    $.console.assert( options, "[ImageRecord] options is required" );\n    $.console.assert( options.image, "[ImageRecord] options.image is required" );\n    this._image = options.image;\n    this._tiles = [];\n};\n\nImageRecord.prototype = {\n    destroy: function() {\n        this._image = null;\n        this._renderedContext = null;\n        this._tiles = null;\n    },\n\n    getImage: function() {\n        return this._image;\n    },\n\n    getRenderedContext: function() {\n        if (!this._renderedContext) {\n            var canvas = document.createElement( \'canvas\' );\n            canvas.width = this._image.width;\n            canvas.height = this._image.height;\n            this._renderedContext = canvas.getContext(\'2d\');\n            this._renderedContext.drawImage( this._image, 0, 0 );\n            //since we are caching the prerendered image on a canvas\n            //allow the image to not be held in memory\n            this._image = null;\n        }\n        return this._renderedContext;\n    },\n\n    setRenderedContext: function(renderedContext) {\n        $.console.error("ImageRecord.setRenderedContext is deprecated. " +\n                "The rendered context should be created by the ImageRecord " +\n                "itself when calling ImageRecord.getRenderedContext.");\n        this._renderedContext = renderedContext;\n    },\n\n    addTile: function(tile) {\n        $.console.assert(tile, \'[ImageRecord.addTile] tile is required\');\n        this._tiles.push(tile);\n    },\n\n    removeTile: function(tile) {\n        for (var i = 0; i < this._tiles.length; i++) {\n            if (this._tiles[i] === tile) {\n                this._tiles.splice(i, 1);\n                return;\n            }\n        }\n\n        $.console.warn(\'[ImageRecord.removeTile] trying to remove unknown tile\', tile);\n    },\n\n    getTileCount: function() {\n        return this._tiles.length;\n    }\n};\n\n/**\n * @class TileCache\n * @memberof OpenSeadragon\n * @classdesc Stores all the tiles displayed in a {@link OpenSeadragon.Viewer}.\n * You generally won\'t have to interact with the TileCache directly.\n * @param {Object} options - Configuration for this TileCache.\n * @param {Number} [options.maxImageCacheCount] - See maxImageCacheCount in\n * {@link OpenSeadragon.Options} for details.\n */\n$.TileCache = function( options ) {\n    options = options || {};\n\n    this._maxImageCacheCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;\n    this._tilesLoaded = [];\n    this._imagesLoaded = [];\n    this._imagesLoadedCount = 0;\n};\n\n/** @lends OpenSeadragon.TileCache.prototype */\n$.TileCache.prototype = {\n    /**\n     * @returns {Number} The total number of tiles that have been loaded by\n     * this TileCache.\n     */\n    numTilesLoaded: function() {\n        return this._tilesLoaded.length;\n    },\n\n    /**\n     * Caches the specified tile, removing an old tile if necessary to stay under the\n     * maxImageCacheCount specified on construction. Note that if multiple tiles reference\n     * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep\n     * the number of images below that number. Note, as well, that even the number of images\n     * may temporarily surpass that number, but should eventually come back down to the max specified.\n     * @param {Object} options - Tile info.\n     * @param {OpenSeadragon.Tile} options.tile - The tile to cache.\n     * @param {Image} options.image - The image of the tile to cache.\n     * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.\n     * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this\n     * function will release an old tile. The cutoff option specifies a tile level at or below which\n     * tiles will not be released.\n     */\n    cacheTile: function( options ) {\n        $.console.assert( options, "[TileCache.cacheTile] options is required" );\n        $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );\n        $.console.assert( options.tile.url, "[TileCache.cacheTile] options.tile.url is required" );\n        $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );\n\n        var cutoff = options.cutoff || 0;\n        var insertionIndex = this._tilesLoaded.length;\n\n        var imageRecord = this._imagesLoaded[options.tile.url];\n        if (!imageRecord) {\n            $.console.assert( options.image, "[TileCache.cacheTile] options.image is required to create an ImageRecord" );\n            imageRecord = this._imagesLoaded[options.tile.url] = new ImageRecord({\n                image: options.image\n            });\n\n            this._imagesLoadedCount++;\n        }\n\n        imageRecord.addTile(options.tile);\n        options.tile.cacheImageRecord = imageRecord;\n\n        // Note that just because we\'re unloading a tile doesn\'t necessarily mean\n        // we\'re unloading an image. With repeated calls it should sort itself out, though.\n        if ( this._imagesLoadedCount > this._maxImageCacheCount ) {\n            var worstTile       = null;\n            var worstTileIndex  = -1;\n            var worstTileRecord = null;\n            var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;\n\n            for ( var i = this._tilesLoaded.length - 1; i >= 0; i-- ) {\n                prevTileRecord = this._tilesLoaded[ i ];\n                prevTile = prevTileRecord.tile;\n\n                if ( prevTile.level <= cutoff || prevTile.beingDrawn ) {\n                    continue;\n                } else if ( !worstTile ) {\n                    worstTile       = prevTile;\n                    worstTileIndex  = i;\n                    worstTileRecord = prevTileRecord;\n                    continue;\n                }\n\n                prevTime    = prevTile.lastTouchTime;\n                worstTime   = worstTile.lastTouchTime;\n                prevLevel   = prevTile.level;\n                worstLevel  = worstTile.level;\n\n                if ( prevTime < worstTime ||\n                   ( prevTime == worstTime && prevLevel > worstLevel ) ) {\n                    worstTile       = prevTile;\n                    worstTileIndex  = i;\n                    worstTileRecord = prevTileRecord;\n                }\n            }\n\n            if ( worstTile && worstTileIndex >= 0 ) {\n                this._unloadTile(worstTileRecord);\n                insertionIndex = worstTileIndex;\n            }\n        }\n\n        this._tilesLoaded[ insertionIndex ] = new TileRecord({\n            tile: options.tile,\n            tiledImage: options.tiledImage\n        });\n    },\n\n    /**\n     * Clears all tiles associated with the specified tiledImage.\n     * @param {OpenSeadragon.TiledImage} tiledImage\n     */\n    clearTilesFor: function( tiledImage ) {\n        $.console.assert(tiledImage, \'[TileCache.clearTilesFor] tiledImage is required\');\n        var tileRecord;\n        for ( var i = 0; i < this._tilesLoaded.length; ++i ) {\n            tileRecord = this._tilesLoaded[ i ];\n            if ( tileRecord.tiledImage === tiledImage ) {\n                this._unloadTile(tileRecord);\n                this._tilesLoaded.splice( i, 1 );\n                i--;\n            }\n        }\n    },\n\n    // private\n    getImageRecord: function(url) {\n        $.console.assert(url, \'[TileCache.getImageRecord] url is required\');\n        return this._imagesLoaded[url];\n    },\n\n    // private\n    _unloadTile: function(tileRecord) {\n        $.console.assert(tileRecord, \'[TileCache._unloadTile] tileRecord is required\');\n        var tile = tileRecord.tile;\n        var tiledImage = tileRecord.tiledImage;\n\n        tile.unload();\n        tile.cacheImageRecord = null;\n\n        var imageRecord = this._imagesLoaded[tile.url];\n        imageRecord.removeTile(tile);\n        if (!imageRecord.getTileCount()) {\n            imageRecord.destroy();\n            delete this._imagesLoaded[tile.url];\n            this._imagesLoadedCount--;\n        }\n\n        /**\n         * Triggered when a tile has just been unloaded from memory.\n         *\n         * @event tile-unloaded\n         * @memberof OpenSeadragon.Viewer\n         * @type {object}\n         * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the unloaded tile.\n         * @property {OpenSeadragon.Tile} tile - The tile which has been unloaded.\n         */\n        tiledImage.viewer.raiseEvent("tile-unloaded", {\n            tile: tile,\n            tiledImage: tiledImage\n        });\n    }\n};\n\n}( OpenSeadragon ));\n\n/*\n * OpenSeadragon - World\n *\n * Copyright (C) 2009 CodePlex Foundation\n * Copyright (C) 2010-2013 OpenSeadragon contributors\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of CodePlex Foundation nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function( $ ){\n\n/**\n * @class World\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.EventSource\n * @classdesc Keeps track of all of the tiled images in the scene.\n * @param {Object} options - World options.\n * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this World.\n **/\n$.World = function( options ) {\n    var _this = this;\n\n    $.console.assert( options.viewer, "[World] options.viewer is required" );\n\n    $.EventSource.call( this );\n\n    this.viewer = options.viewer;\n    this._items = [];\n    this._needsDraw = false;\n    this._autoRefigureSizes = true;\n    this._needsSizesFigured = false;\n    this._delegatedFigureSizes = function(event) {\n        if (_this._autoRefigureSizes) {\n            _this._figureSizes();\n        } else {\n            _this._needsSizesFigured = true;\n        }\n    };\n\n    this._figureSizes();\n};\n\n$.extend( $.World.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.World.prototype */{\n    /**\n     * Add the specified item.\n     * @param {OpenSeadragon.TiledImage} item - The item to add.\n     * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.\n     * @fires OpenSeadragon.World.event:add-item\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    addItem: function( item, options ) {\n        $.console.assert(item, "[World.addItem] item is required");\n        $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");\n\n        options = options || {};\n        if (options.index !== undefined) {\n            var index = Math.max(0, Math.min(this._items.length, options.index));\n            this._items.splice(index, 0, item);\n        } else {\n            this._items.push( item );\n        }\n\n        if (this._autoRefigureSizes) {\n            this._figureSizes();\n        } else {\n            this._needsSizesFigured = true;\n        }\n\n        this._needsDraw = true;\n\n        item.addHandler(\'bounds-change\', this._delegatedFigureSizes);\n\n        /**\n         * Raised when an item is added to the World.\n         * @event add-item\n         * @memberOf OpenSeadragon.World\n         * @type {object}\n         * @property {OpenSeadragon.Viewer} eventSource - A reference to the World which raised the event.\n         * @property {OpenSeadragon.TiledImage} item - The item that has been added.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'add-item\', {\n            item: item\n        } );\n    },\n\n    /**\n     * Get the item at the specified index.\n     * @param {Number} index - The item\'s index.\n     * @returns {OpenSeadragon.TiledImage} The item at the specified index.\n     */\n    getItemAt: function( index ) {\n        $.console.assert(index !== undefined, "[World.getItemAt] index is required");\n        return this._items[ index ];\n    },\n\n    /**\n     * Get the index of the given item or -1 if not present.\n     * @param {OpenSeadragon.TiledImage} item - The item.\n     * @returns {Number} The index of the item or -1 if not present.\n     */\n    getIndexOfItem: function( item ) {\n        $.console.assert(item, "[World.getIndexOfItem] item is required");\n        return $.indexOf( this._items, item );\n    },\n\n    /**\n     * @returns {Number} The number of items used.\n     */\n    getItemCount: function() {\n        return this._items.length;\n    },\n\n    /**\n     * Change the index of a item so that it appears over or under others.\n     * @param {OpenSeadragon.TiledImage} item - The item to move.\n     * @param {Number} index - The new index.\n     * @fires OpenSeadragon.World.event:item-index-change\n     */\n    setItemIndex: function( item, index ) {\n        $.console.assert(item, "[World.setItemIndex] item is required");\n        $.console.assert(index !== undefined, "[World.setItemIndex] index is required");\n\n        var oldIndex = this.getIndexOfItem( item );\n\n        if ( index >= this._items.length ) {\n            throw new Error( "Index bigger than number of layers." );\n        }\n\n        if ( index === oldIndex || oldIndex === -1 ) {\n            return;\n        }\n\n        this._items.splice( oldIndex, 1 );\n        this._items.splice( index, 0, item );\n        this._needsDraw = true;\n\n        /**\n         * Raised when the order of the indexes has been changed.\n         * @event item-index-change\n         * @memberOf OpenSeadragon.World\n         * @type {object}\n         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.\n         * @property {OpenSeadragon.TiledImage} item - The item whose index has\n         * been changed\n         * @property {Number} previousIndex - The previous index of the item\n         * @property {Number} newIndex - The new index of the item\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'item-index-change\', {\n            item: item,\n            previousIndex: oldIndex,\n            newIndex: index\n        } );\n    },\n\n    /**\n     * Remove an item.\n     * @param {OpenSeadragon.TiledImage} item - The item to remove.\n     * @fires OpenSeadragon.World.event:remove-item\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    removeItem: function( item ) {\n        $.console.assert(item, "[World.removeItem] item is required");\n\n        var index = $.indexOf(this._items, item );\n        if ( index === -1 ) {\n            return;\n        }\n\n        item.removeHandler(\'bounds-change\', this._delegatedFigureSizes);\n        item.destroy();\n        this._items.splice( index, 1 );\n        this._figureSizes();\n        this._needsDraw = true;\n        this._raiseRemoveItem(item);\n    },\n\n    /**\n     * Remove all items.\n     * @fires OpenSeadragon.World.event:remove-item\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    removeAll: function() {\n        // We need to make sure any pending images are canceled so the world items don\'t get messed up\n        this.viewer._cancelPendingImages();\n        var item;\n        for (var i = 0; i < this._items.length; i++) {\n            item = this._items[i];\n            item.removeHandler(\'bounds-change\', this._delegatedFigureSizes);\n            item.destroy();\n        }\n\n        var removedItems = this._items;\n        this._items = [];\n        this._figureSizes();\n        this._needsDraw = true;\n\n        for (i = 0; i < removedItems.length; i++) {\n            item = removedItems[i];\n            this._raiseRemoveItem(item);\n        }\n    },\n\n    /**\n     * Clears all tiles and triggers updates for all items.\n     */\n    resetItems: function() {\n        for ( var i = 0; i < this._items.length; i++ ) {\n            this._items[i].reset();\n        }\n    },\n\n    /**\n     * Updates (i.e. animates bounds of) all items.\n     */\n    update: function() {\n        var animated = false;\n        for ( var i = 0; i < this._items.length; i++ ) {\n            animated = this._items[i].update() || animated;\n        }\n\n        return animated;\n    },\n\n    /**\n     * Draws all items.\n     */\n    draw: function() {\n        for ( var i = 0; i < this._items.length; i++ ) {\n            this._items[i].draw();\n        }\n\n        this._needsDraw = false;\n    },\n\n    /**\n     * @returns {Boolean} true if any items need updating.\n     */\n    needsDraw: function() {\n        for ( var i = 0; i < this._items.length; i++ ) {\n            if ( this._items[i].needsDraw() ) {\n                return true;\n            }\n        }\n        return this._needsDraw;\n    },\n\n    /**\n     * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.\n     */\n    getHomeBounds: function() {\n        return this._homeBounds.clone();\n    },\n\n    /**\n     * To facilitate zoom constraints, we keep track of the pixel density of the\n     * densest item in the World (i.e. the item whose content size to viewport size\n     * ratio is the highest) and save it as this "content factor".\n     * @returns {Number} the number of content units per viewport unit.\n     */\n    getContentFactor: function() {\n        return this._contentFactor;\n    },\n\n    /**\n     * As a performance optimization, setting this flag to false allows the bounds-change event handler\n     * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in\n     * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true\n     * or the system may behave oddly.\n     * @param {Boolean} [value] The value to which to set the flag.\n     */\n    setAutoRefigureSizes: function(value) {\n        this._autoRefigureSizes = value;\n        if (value & this._needsSizesFigured) {\n            this._figureSizes();\n            this._needsSizesFigured = false;\n        }\n    },\n\n    /**\n     * Arranges all of the TiledImages with the specified settings.\n     * @param {Object} options - Specifies how to arrange.\n     * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.\n     * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.\n     * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.\n     * @fires OpenSeadragon.World.event:metrics-change\n     */\n    arrange: function(options) {\n        options = options || {};\n        var immediately = options.immediately || false;\n        var layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;\n        var rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;\n        var columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;\n        var tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;\n        var tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;\n        var increment = tileSize + tileMargin;\n        var wrap;\n        if (!options.rows && columns) {\n            wrap = columns;\n        } else {\n            wrap = Math.ceil(this._items.length / rows);\n        }\n        var x = 0;\n        var y = 0;\n        var item, box, width, height, position;\n\n        this.setAutoRefigureSizes(false);\n        for (var i = 0; i < this._items.length; i++) {\n            if (i && (i % wrap) === 0) {\n                if (layout === \'horizontal\') {\n                    y += increment;\n                    x = 0;\n                } else {\n                    x += increment;\n                    y = 0;\n                }\n            }\n\n            item = this._items[i];\n            box = item.getBounds();\n            if (box.width > box.height) {\n                width = tileSize;\n            } else {\n                width = tileSize * (box.width / box.height);\n            }\n\n            height = width * (box.height / box.width);\n            position = new $.Point(x + ((tileSize - width) / 2),\n                y + ((tileSize - height) / 2));\n\n            item.setPosition(position, immediately);\n            item.setWidth(width, immediately);\n\n            if (layout === \'horizontal\') {\n                x += increment;\n            } else {\n                y += increment;\n            }\n        }\n        this.setAutoRefigureSizes(true);\n    },\n\n    // private\n    _figureSizes: function() {\n        var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;\n        var oldContentSize = this._contentSize ? this._contentSize.clone() : null;\n        var oldContentFactor = this._contentFactor || 0;\n\n        if (!this._items.length) {\n            this._homeBounds = new $.Rect(0, 0, 1, 1);\n            this._contentSize = new $.Point(1, 1);\n            this._contentFactor = 1;\n        } else {\n            var item = this._items[0];\n            var bounds = item.getBounds();\n            this._contentFactor = item.getContentSize().x / bounds.width;\n            var clippedBounds = item.getClippedBounds();\n            var left = clippedBounds.x;\n            var top = clippedBounds.y;\n            var right = clippedBounds.x + clippedBounds.width;\n            var bottom = clippedBounds.y + clippedBounds.height;\n            for (var i = 1; i < this._items.length; i++) {\n                item = this._items[i];\n                bounds = item.getBounds();\n                this._contentFactor = Math.max(this._contentFactor,\n                    item.getContentSize().x / bounds.width);\n                clippedBounds = item.getClippedBounds();\n                left = Math.min(left, clippedBounds.x);\n                top = Math.min(top, clippedBounds.y);\n                right = Math.max(right, clippedBounds.x + clippedBounds.width);\n                bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);\n            }\n\n            this._homeBounds = new $.Rect(left, top, right - left, bottom - top);\n            this._contentSize = new $.Point(\n                this._homeBounds.width * this._contentFactor,\n                this._homeBounds.height * this._contentFactor);\n        }\n\n        if (this._contentFactor !== oldContentFactor ||\n            !this._homeBounds.equals(oldHomeBounds) ||\n            !this._contentSize.equals(oldContentSize)) {\n            /**\n             * Raised when the home bounds or content factor change.\n             * @event metrics-change\n             * @memberOf OpenSeadragon.World\n             * @type {object}\n             * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.\n             * @property {?Object} userData - Arbitrary subscriber-defined object.\n             */\n            this.raiseEvent(\'metrics-change\', {});\n        }\n    },\n\n    // private\n    _raiseRemoveItem: function(item) {\n        /**\n         * Raised when an item is removed.\n         * @event remove-item\n         * @memberOf OpenSeadragon.World\n         * @type {object}\n         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.\n         * @property {OpenSeadragon.TiledImage} item - The item\'s underlying item.\n         * @property {?Object} userData - Arbitrary subscriber-defined object.\n         */\n        this.raiseEvent( \'remove-item\', { item: item } );\n    }\n});\n\n}( OpenSeadragon ));\n\n//# sourceMappingURL=openseadragon.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9vcGVuc2VhZHJhZ29uL2J1aWxkL29wZW5zZWFkcmFnb24vb3BlbnNlYWRyYWdvbi5qcz80MjBmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxzRUFBc0U7QUFDdEUsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsU0FBUyx5Q0FBeUM7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBNkM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxnRUFBZ0U7QUFDOUk7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakU7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUUsNEJBQTRCO0FBQ25HO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUtBQXVLO0FBQzVNLHFDQUFxQyx1S0FBdUs7QUFDNU0scUNBQXFDLHVLQUF1SztBQUM1TSxxQ0FBcUMsdUtBQXVLO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBNEM7QUFDM0Q7QUFDQSxlQUFlLHdDQUF3QztBQUN2RDtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUE0QztBQUMzRDtBQUNBLGVBQWUsd0NBQXdDO0FBQ3ZEO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLGdEQUFnRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxnREFBZ0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxnREFBZ0Q7QUFDL0Q7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLGdEQUFnRDtBQUMvRDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsZ0RBQWdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFB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QTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUMsa0JBQWtCLHdCQUF3QjtBQUMxQyxrQkFBa0Isd0JBQXdCO0FBQzFDLGtCQUFrQix3QkFBd0I7QUFDMUMsa0JBQWtCLHdCQUF3QjtBQUMxQyxrQkFBa0Isd0JBQXdCO0FBQzFDLGtCQUFrQix3QkFBd0I7QUFDMUMsa0JBQWtCLHdCQUF3QjtBQUMxQyxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDLEVBQUUsU0FBUzs7QUFFM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FB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LHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IseUJBQXlCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCLHlCQUF5QjtBQUNuRCwwQkFBMEIsbUJBQW1CO0FBQzdDLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMkJBQTJCO0FBQzlFO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxNQUFNO0FBQ3JCLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHNCQUFzQix5QkFBeUI7QUFDL0Msc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsc0JBQXNCLHFCQUFxQjtBQUMzQyxzQkFBc0IseUJBQXlCO0FBQy9DLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHNCQUFzQixvQkFBb0I7QUFDMUMsc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBLHNCQUFzQixPQUFPO0FBQzdCLHNCQUFzQixPQUFPO0FBQzdCLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPLDZDQUE2Qyw0QkFBNEI7QUFDL0YsZUFBZSxPQUFPLHlDQUF5Qyw0QkFBNEI7QUFDM0YsZUFBZSxPQUFPLCtDQUErQyw0QkFBNEI7QUFDakcsZUFBZSxPQUFPLGlEQUFpRCw0QkFBNEI7QUFDbkcsZUFBZSxPQUFPLHFEQUFxRCw0QkFBNEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwwQkFBMEIsb0JBQW9CO0FBQzlDLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsc0JBQXNCLG9CQUFvQjtBQUMxQyxzQkFBc0IseUJBQXlCO0FBQy9DLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQSxDQUFDOztBQUVELENBQUM7O0FBRUQiLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgb3BlbnNlYWRyYWdvbiAyLjIuMVxuLy8hIEJ1aWx0IG9uIDIwMTYtMDctMDFcbi8vISBHaXQgY29tbWl0OiB2Mi4yLjEtMC1iYWJkZWZkXG4vLyEgaHR0cDovL29wZW5zZWFkcmFnb24uZ2l0aHViLmlvXG4vLyEgTGljZW5zZTogaHR0cDovL29wZW5zZWFkcmFnb24uZ2l0aHViLmlvL2xpY2Vuc2UvXG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qXG4gKiBQb3J0aW9ucyBvZiB0aGlzIHNvdXJjZSBmaWxlIHRha2VuIGZyb20galF1ZXJ5OlxuICpcbiAqIENvcHlyaWdodCAyMDExIEpvaG4gUmVzaWdcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKlxuICogUG9ydGlvbnMgb2YgdGhpcyBzb3VyY2UgZmlsZSB0YWtlbiBmcm9tIG1hdHRzbmlkZXIuY29tOlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNi0yMDEzIE1hdHQgU25pZGVyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG4gKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuICogQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVFxuICogT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SXG4gKiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBPcGVuU2VhZHJhZ29uXG4gKiBAdmVyc2lvbiBvcGVuc2VhZHJhZ29uIDIuMi4xXG4gKiBAY2xhc3NkZXNjIFRoZSByb290IG5hbWVzcGFjZSBmb3IgT3BlblNlYWRyYWdvbi4gIEFsbCB1dGlsaXR5IG1ldGhvZHNcbiAqIGFuZCBjbGFzc2VzIGFyZSBkZWZpbmVkIG9uIG9yIGJlbG93IHRoaXMgbmFtZXNwYWNlLlxuICpcbiAqL1xuXG5cbi8vIFR5cGVkZWZzXG5cbiAvKipcbiAgKiBBbGwgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIHNldHRpbmdzIGZvciBpbnN0YW50aWF0aW5nIGEgbmV3IGluc3RhbmNlIG9mIGFuIE9wZW5TZWFkcmFnb24gaW1hZ2Ugdmlld2VyLlxuICAqXG4gICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gaWRcbiAgKiAgICAgSWQgb2YgdGhlIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB2aWV3ZXIncyBjb250YWluZXIgZWxlbWVudCB0by4gSWYgbm90IHByb3ZpZGVkLCB0aGUgJ2VsZW1lbnQnIHByb3BlcnR5IG11c3QgYmUgcHJvdmlkZWQuXG4gICogICAgIElmIGJvdGggdGhlIGVsZW1lbnQgYW5kIGlkIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZCwgdGhlIHZpZXdlciBpcyBhcHBlbmRlZCB0byB0aGUgZWxlbWVudCBwcm92aWRlZCBpbiB0aGUgZWxlbWVudCBwcm9wZXJ0eS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gZWxlbWVudFxuICAqICAgICBUaGUgZWxlbWVudCB0byBhcHBlbmQgdGhlIHZpZXdlcidzIGNvbnRhaW5lciBlbGVtZW50IHRvLiBJZiBub3QgcHJvdmlkZWQsIHRoZSAnaWQnIHByb3BlcnR5IG11c3QgYmUgcHJvdmlkZWQuXG4gICogICAgIElmIGJvdGggdGhlIGVsZW1lbnQgYW5kIGlkIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZCwgdGhlIHZpZXdlciBpcyBhcHBlbmRlZCB0byB0aGUgZWxlbWVudCBwcm92aWRlZCBpbiB0aGUgZWxlbWVudCBwcm9wZXJ0eS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufE9iamVjdH0gW3RpbGVTb3VyY2VzPW51bGxdXG4gICogICAgIFRpbGUgc291cmNlKHMpIHRvIG9wZW4gaW5pdGlhbGx5LiBUaGlzIGlzIGEgY29tcGxleCBwYXJhbWV0ZXI7IHNlZVxuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjb3Blbn0gZm9yIGRldGFpbHMuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3RhYkluZGV4PTBdXG4gICogICAgIFRhYmJpbmcgb3JkZXIgaW5kZXggdG8gYXNzaWduIHRvIHRoZSB2aWV3ZXIgZWxlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGFyZSBzZWxlY3RlZCBpbiBpbmNyZWFzaW5nIG9yZGVyLiBXaGVuIHRhYkluZGV4IGlzIDBcbiAgKiAgICAgc291cmNlIG9yZGVyIGlzIHVzZWQuIEEgbmVnYXRpdmUgdmFsdWUgb21pdHMgdGhlIHZpZXdlciBmcm9tIHRoZSB0YWJiaW5nIG9yZGVyLlxuICAqXG4gICogQHByb3BlcnR5IHtBcnJheX0gb3ZlcmxheXMgQXJyYXkgb2Ygb2JqZWN0cyBkZWZpbmluZyBwZXJtYW5lbnQgb3ZlcmxheXMgb2ZcbiAgKiAgICAgdGhlIHZpZXdlci4gVGhlIG92ZXJsYXlzIGFkZGVkIHZpYSB0aGlzIG9wdGlvbiBhbmQgbGF0ZXIgcmVtb3ZlZCB3aXRoXG4gICogICAgIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNyZW1vdmVPdmVybGF5fSB3aWxsIGJlIGFkZGVkIGJhY2sgd2hlbiBhIG5ld1xuICAqICAgICBpbWFnZSBpcyBvcGVuZWQuXG4gICogICAgIFRvIGFkZCBvdmVybGF5cyB3aGljaCBjYW4gYmUgZGVmaW5pdGl2ZWx5IHJlbW92ZWQsIG9uZSBtdXN0IHVzZVxuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjYWRkT3ZlcmxheX1cbiAgKiAgICAgSWYgZGlzcGxheWluZyBhIHNlcXVlbmNlIG9mIGltYWdlcywgdGhlIG92ZXJsYXlzIGNhbiBiZSBhc3NvY2lhdGVkXG4gICogICAgIHdpdGggYSBzcGVjaWZpYyBwYWdlIGJ5IHBhc3NpbmcgdGhlIG92ZXJsYXlzIGFycmF5IHRvIHRoZSBwYWdlJ3NcbiAgKiAgICAgdGlsZSBzb3VyY2UgY29uZmlndXJhdGlvbi5cbiAgKiAgICAgRXhwZWN0ZWQgcHJvcGVydGllczpcbiAgKiAgICAgKiB4LCB5LCAob3IgcHgsIHB5IGZvciBwaXhlbCBjb29yZGluYXRlcykgdG8gZGVmaW5lIHRoZSBsb2NhdGlvbi5cbiAgKiAgICAgKiB3aWR0aCwgaGVpZ2h0IGluIHBvaW50IGlmIHVzaW5nIHgseSBvciBpbiBwaXhlbHMgaWYgdXNpbmcgcHgscHkuIElmIHdpZHRoXG4gICogICAgICAgYW5kIGhlaWdodCBhcmUgc3BlY2lmaWVkLCB0aGUgb3ZlcmxheSBzaXplIGlzIGFkanVzdGVkIHdoZW4gem9vbWluZyxcbiAgKiAgICAgICBvdGhlcndpc2UgdGhlIHNpemUgc3RheXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgKG9yIHRoZSBzaXplIGRlZmluZWQgYnkgQ1NTKS5cbiAgKiAgICAgKiBjbGFzc05hbWUgdG8gYXNzb2NpYXRlIGEgY2xhc3MgdG8gdGhlIG92ZXJsYXlcbiAgKiAgICAgKiBpZCB0byBzZXQgdGhlIG92ZXJsYXkgZWxlbWVudC4gSWYgYW4gZWxlbWVudCB3aXRoIHRoaXMgaWQgYWxyZWFkeSBleGlzdHMsXG4gICogICAgICAgaXQgaXMgcmV1c2VkLCBvdGhlcndpc2UgaXQgaXMgY3JlYXRlZC4gSWYgbm90IHNwZWNpZmllZCwgYSBuZXcgZWxlbWVudCBpc1xuICAqICAgICAgIGNyZWF0ZWQuXG4gICogICAgICogcGxhY2VtZW50IGEgc3RyaW5nIHRvIGRlZmluZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIHZpZXdwb3J0LlxuICAqICAgICAgIE9ubHkgdXNlZCBpZiBubyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzcGVjaWZpZWQuIERlZmF1bHQ6ICdUT1BfTEVGVCcuXG4gICogICAgICAgU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gZm9yIHBvc3NpYmxlIHZhbHVlcy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbeG1sUGF0aD1udWxsXVxuICAqICAgICA8c3Ryb25nPkRFUFJFQ0FURUQ8L3N0cm9uZz4uIEEgcmVsYXRpdmUgcGF0aCB0byBsb2FkIGEgRFpJIGZpbGUgZnJvbSB0aGUgc2VydmVyLlxuICAqICAgICBQcmVmZXIgdGhlIG5ld2VyIE9wdGlvbnMudGlsZVNvdXJjZXMuXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gW3ByZWZpeFVybD0nL2ltYWdlcy8nXVxuICAqICAgICBQcmVwZW5kcyB0aGUgcHJlZml4VXJsIHRvIG5hdkltYWdlcyBwYXRocywgd2hpY2ggaXMgdmVyeSB1c2VmdWxcbiAgKiAgICAgc2luY2UgdGhlIGRlZmF1bHQgcGF0aHMgYXJlIHJhcmVseSB1c2VmdWwgZm9yIHByb2R1Y3Rpb25cbiAgKiAgICAgZW52aXJvbm1lbnRzLlxuICAqXG4gICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk5hdkltYWdlc30gW25hdkltYWdlc11cbiAgKiAgICAgQW4gb2JqZWN0IHdpdGggYSBwcm9wZXJ0eSBmb3IgZWFjaCBidXR0b24gb3Igb3RoZXIgYnVpbHQtaW4gbmF2aWdhdGlvblxuICAqICAgICBjb250cm9sLCBlZyB0aGUgY3VycmVudCAnem9vbUluJywgJ3pvb21PdXQnLCAnaG9tZScsIGFuZCAnZnVsbHBhZ2UnLlxuICAqICAgICBFYWNoIG9mIHRob3NlIGluIHR1cm4gcHJvdmlkZXMgYW4gaW1hZ2UgcGF0aCBmb3IgZWFjaCBzdGF0ZSBvZiB0aGUgYnV0dG9uXG4gICogICAgIG9yIG5hdmlnYXRpb24gY29udHJvbCwgZWcgJ1JFU1QnLCAnR1JPVVAnLCAnSE9WRVInLCAnUFJFU1MnLiBGaW5hbGx5IHRoZVxuICAqICAgICBpbWFnZSBwYXRocywgYnkgZGVmYXVsdCBhc3N1bWUgdGhlcmUgaXMgYSBmb2xkZXIgb24gdGhlIHNlcnZlcnMgcm9vdCBwYXRoXG4gICogICAgIGNhbGxlZCAnL2ltYWdlcycsIGVnICcvaW1hZ2VzL3pvb21pbl9yZXN0LnBuZycuICBJZiB5b3UgbmVlZCB0byBhZGp1c3RcbiAgKiAgICAgdGhlc2UgcGF0aHMsIHByZWZlciBzZXR0aW5nIHRoZSBvcHRpb24ucHJlZml4VXJsIHJhdGhlciB0aGFuIG92ZXJyaWRpbmdcbiAgKiAgICAgZXZlcnkgaW1hZ2UgcGF0aCBkaXJlY3RseSB0aHJvdWdoIHRoaXMgc2V0dGluZy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RlYnVnTW9kZT1mYWxzZV1cbiAgKiAgICAgVE9ETzogcHJvdmlkZSBhbiBpbi1zY3JlZW4gcGFuZWwgcHJvdmlkaW5nIGV2ZW50IGRldGFpbCBmZWVkYmFjay5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZGVidWdHcmlkQ29sb3I9JyM0MzdBQjInXVxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtibGVuZFRpbWU9MF1cbiAgKiAgICAgU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb24gYXMgaGlnaGVyIG9yIGxvd2VyIGxldmVsIHRpbGVzIGFyZVxuICAqICAgICByZXBsYWNpbmcgdGhlIGV4aXN0aW5nIHRpbGUuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthbHdheXNCbGVuZD1mYWxzZV1cbiAgKiAgICAgRm9yY2VzIHRoZSB0aWxlIHRvIGFsd2F5cyBibGVuZC4gIEJ5IGRlZmF1bHQgdGhlIHRpbGVzIHNraXAgYmxlbmRpbmdcbiAgKiAgICAgd2hlbiB0aGUgYmxlbmRUaW1lIGlzIHN1cnBhc3NlZCBhbmQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lIHdvdWxkXG4gICogICAgIG5vdCBjb21wbGV0ZSB0aGUgYmxlbmQuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthdXRvSGlkZUNvbnRyb2xzPXRydWVdXG4gICogICAgIElmIHRoZSB1c2VyIHN0b3BzIGludGVyYWN0aW5nIHdpdGggdGhlIHZpZXdwb3J0LCBmYWRlIHRoZSBuYXZpZ2F0aW9uXG4gICogICAgIGNvbnRyb2xzLiAgVXNlZnVsIGZvciBwcmVzZW50YXRpb24gc2luY2UgdGhlIGNvbnRyb2xzIGFyZSBieSBkZWZhdWx0XG4gICogICAgIGZsb2F0ZWQgb24gdG9wIG9mIHRoZSBpbWFnZSB0aGUgdXNlciBpcyB2aWV3aW5nLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbaW1tZWRpYXRlUmVuZGVyPWZhbHNlXVxuICAqICAgICBSZW5kZXIgdGhlIGJlc3QgY2xvc2VzdCBsZXZlbCBmaXJzdCwgaWdub3JpbmcgdGhlIGxvd2VyaW5nIGxldmVscyB3aGljaFxuICAqICAgICBwcm92aWRlIHRoZSBlZmZlY3Qgb2YgdmVyeSBibHVycnkgdG8gc2hhcnAuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGNoYW5nZVxuICAqICAgICBzZXR0aW5nIHRvIHRydWUgZm9yIG1vYmlsZSBkZXZpY2VzLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkZWZhdWx0Wm9vbUxldmVsPTBdXG4gICogICAgIFpvb20gbGV2ZWwgdG8gdXNlIHdoZW4gaW1hZ2UgaXMgZmlyc3Qgb3BlbmVkIG9yIHRoZSBob21lIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAqICAgICBJZiAwLCBhZGp1c3RzIHRvIGZpdCB2aWV3ZXIuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW29wYWNpdHk9MV1cbiAgKiAgICAgRGVmYXVsdCBvcGFjaXR5IG9mIHRoZSB0aWxlZCBpbWFnZXMgKDE9b3BhcXVlLCAwPXRyYW5zcGFyZW50KVxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21wb3NpdGVPcGVyYXRpb249bnVsbF1cbiAgKiAgICAgVmFsaWQgdmFsdWVzIGFyZSAnc291cmNlLW92ZXInLCAnc291cmNlLWF0b3AnLCAnc291cmNlLWluJywgJ3NvdXJjZS1vdXQnLFxuICAqICAgICAnZGVzdGluYXRpb24tb3ZlcicsICdkZXN0aW5hdGlvbi1hdG9wJywgJ2Rlc3RpbmF0aW9uLWluJyxcbiAgKiAgICAgJ2Rlc3RpbmF0aW9uLW91dCcsICdsaWdodGVyJywgJ2NvcHknIG9yICd4b3InXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ3xDYW52YXNHcmFkaWVudHxDYW52YXNQYXR0ZXJufEZ1bmN0aW9ufSBbcGxhY2Vob2xkZXJGaWxsU3R5bGU9bnVsbF1cbiAgKiAgICAgRHJhd3MgYSBjb2xvcmVkIHJlY3RhbmdsZSBiZWhpbmQgdGhlIHRpbGUgaWYgaXQgaXMgbm90IGxvYWRlZCB5ZXQuXG4gICogICAgIFlvdSBjYW4gcGFzcyBhIENTUyBjb2xvciB2YWx1ZSBsaWtlIFwiI0ZGODgwMFwiLlxuICAqICAgICBXaGVuIHBhc3NpbmcgYSBmdW5jdGlvbiB0aGUgdGlsZWRJbWFnZSBhbmQgY2FudmFzIGNvbnRleHQgYXJlIGF2YWlsYWJsZSBhcyBhcmd1bWVudCB3aGljaCBpcyB1c2VmdWwgd2hlbiB5b3UgZHJhdyBhIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2RlZ3JlZXM9MF1cbiAgKiAgICAgSW5pdGlhbCByb3RhdGlvbi5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWluWm9vbUxldmVsPW51bGxdXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW21heFpvb21MZXZlbD1udWxsXVxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbaG9tZUZpbGxzVmlld2VyPWZhbHNlXVxuICAqICAgICBNYWtlIHRoZSAnaG9tZScgYnV0dG9uIGZpbGwgdGhlIHZpZXdlciBhbmQgY2xpcCB0aGUgaW1hZ2UsIGluc3RlYWRcbiAgKiAgICAgb2YgZml0dGluZyB0aGUgaW1hZ2UgdG8gdGhlIHZpZXdlciBhbmQgbGV0dGVyYm94aW5nLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbcGFuSG9yaXpvbnRhbD10cnVlXVxuICAqICAgICBBbGxvdyBob3Jpem9udGFsIHBhbi5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3BhblZlcnRpY2FsPXRydWVdXG4gICogICAgIEFsbG93IHZlcnRpY2FsIHBhbi5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0cmFpbkR1cmluZ1Bhbj1mYWxzZV1cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3dyYXBIb3Jpem9udGFsPWZhbHNlXVxuICAqICAgICBTZXQgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgaW1hZ2UgdG8gd3JhcCBob3Jpem9udGFsbHkgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgKiAgICAgVXNlZnVsIGZvciBtYXBzIG9yIGltYWdlcyByZXByZXNlbnRpbmcgdGhlIHN1cmZhY2Ugb2YgYSBzcGhlcmUgb3IgY3lsaW5kZXIuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt3cmFwVmVydGljYWw9ZmFsc2VdXG4gICogICAgIFNldCB0byB0cnVlIHRvIGZvcmNlIHRoZSBpbWFnZSB0byB3cmFwIHZlcnRpY2FsbHkgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgKiAgICAgVXNlZnVsIGZvciBtYXBzIG9yIGltYWdlcyByZXByZXNlbnRpbmcgdGhlIHN1cmZhY2Ugb2YgYSBzcGhlcmUgb3IgY3lsaW5kZXIuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW21pblpvb21JbWFnZVJhdGlvPTAuOV1cbiAgKiAgICAgVGhlIG1pbmltdW0gcGVyY2VudGFnZSAoIGV4cHJlc3NlZCBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgKSBvZlxuICAqICAgICB0aGUgdmlld3BvcnQgaGVpZ2h0IG9yIHdpZHRoIGF0IHdoaWNoIHRoZSB6b29tIG91dCB3aWxsIGJlIGNvbnN0cmFpbmVkLlxuICAqICAgICBTZXR0aW5nIGl0IHRvIDAsIGZvciBleGFtcGxlIHdpbGwgYWxsb3cgeW91IHRvIHpvb20gb3V0IGluZmluaXR5LlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYXhab29tUGl4ZWxSYXRpbz0xLjFdXG4gICogICAgIFRoZSBtYXhpbXVtIHJhdGlvIHRvIGFsbG93IGEgem9vbS1pbiB0byBhZmZlY3QgdGhlIGhpZ2hlc3QgbGV2ZWwgcGl4ZWxcbiAgKiAgICAgcmF0aW8uIFRoaXMgY2FuIGJlIHNldCB0byBJbmZpbml0eSB0byBhbGxvdyAnaW5maW5pdGUnIHpvb21pbmcgaW50byB0aGVcbiAgKiAgICAgaW1hZ2UgdGhvdWdoIGl0IGlzIGxlc3MgZWZmZWN0aXZlIHZpc3VhbGx5IGlmIHRoZSBIVE1MNSBDYW52YXMgaXMgbm90XG4gICogICAgIGF2YWlsYmxlIG9uIHRoZSB2aWV3aW5nIGRldmljZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc21vb3RoVGlsZUVkZ2VzTWluWm9vbT0xLjFdXG4gICogICAgIEEgem9vbSBwZXJjZW50YWdlICggd2hlcmUgMSBpcyAxMDAlICkgb2YgdGhlIGhpZ2hlc3QgcmVzb2x1dGlvbiBsZXZlbC5cbiAgKiAgICAgV2hlbiB6b29tZWQgaW4gYmV5b25kIHRoaXMgdmFsdWUgYWx0ZXJuYXRpdmUgY29tcG9zaXRpbmcgd2lsbCBiZSB1c2VkIHRvXG4gICogICAgIHNtb290aCBvdXQgdGhlIGVkZ2VzIGJldHdlZW4gdGlsZXMuIFRoaXMgd2lsbCBoYXZlIGEgcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAqICAgICBDYW4gYmUgc2V0IHRvIEluZmluaXR5IHRvIHR1cm4gaXQgb2ZmLlxuICAqICAgICBOb3RlOiBUaGlzIHNldHRpbmcgaXMgaWdub3JlZCBvbiBpT1MgZGV2aWNlcyBkdWUgdG8gYSBrbm93biBidWcgKFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL29wZW5zZWFkcmFnb24vb3BlbnNlYWRyYWdvbi9pc3N1ZXMvOTUyfSlcbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2lPU0RldmljZT0/XVxuICAqICAgICBUcnVlIGlmIHJ1bm5pbmcgb24gYW4gaU9TIGRldmljZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqICAgICBVc2VkIHRvIGRpc2FibGUgY2VydGFpbiBmZWF0dXJlcyB0aGF0IGJlaGF2ZSBkaWZmZXJlbnRseSBvbiBpT1MgZGV2aWNlcy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2F1dG9SZXNpemU9dHJ1ZV1cbiAgKiAgICAgU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgcG9sbGluZyBmb3Igdmlld2VyIHNpemUgY2hhbmdlcy4gVXNlZnVsIGZvciBwcm92aWRpbmcgY3VzdG9tIHJlc2l6ZSBiZWhhdmlvci5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3ByZXNlcnZlSW1hZ2VTaXplT25SZXNpemU9ZmFsc2VdXG4gICogICAgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGltYWdlIHNpemUgcHJlc2VydmVkIHdoZW4gdGhlIHZpZXdlciBpcyByZXNpemVkLiBUaGlzIHJlcXVpcmVzIGF1dG9SZXNpemU9dHJ1ZSAoZGVmYXVsdCkuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW21pblNjcm9sbERlbHRhVGltZT01MF1cbiAgKiAgICAgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIGNhbnZhcy1zY3JvbGwgZXZlbnRzLiBUaGlzIHZhbHVlIGhlbHBzIG5vcm1hbGl6ZSB0aGUgcmF0ZSBvZiBjYW52YXMtc2Nyb2xsXG4gICogICAgIGV2ZW50cyBiZXR3ZWVuIGRpZmZlcmVudCBkZXZpY2VzLCBjYXVzaW5nIHRoZSBmYXN0ZXIgZGV2aWNlcyB0byBzbG93IGRvd24gZW5vdWdoIHRvIG1ha2UgdGhlIHpvb20gY29udHJvbFxuICAqICAgICBtb3JlIG1hbmFnZWFibGUuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpeGVsc1BlcldoZWVsTGluZT00MF1cbiAgKiAgICAgRm9yIHBpeGVsLXJlc29sdXRpb24gc2Nyb2xsaW5nIGRldmljZXMsIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGVxdWFsIHRvIG9uZSBzY3JvbGwgbGluZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdmlzaWJpbGl0eVJhdGlvPTAuNV1cbiAgKiAgICAgVGhlIHBlcmNlbnRhZ2UgKCBhcyBhIG51bWJlciBmcm9tIDAgdG8gMSApIG9mIHRoZSBzb3VyY2UgaW1hZ2Ugd2hpY2hcbiAgKiAgICAgbXVzdCBiZSBrZXB0IHdpdGhpbiB0aGUgdmlld3BvcnQuICBJZiB0aGUgaW1hZ2UgaXMgZHJhZ2dlZCBiZXlvbmQgdGhhdFxuICAqICAgICBsaW1pdCwgaXQgd2lsbCAnYm91bmNlJyBiYWNrIHVudGlsIHRoZSBtaW5pbXVtIHZpc2liaWxpdHkgcmF0aW8gaXNcbiAgKiAgICAgYWNoaWV2ZWQuICBTZXR0aW5nIHRoaXMgdG8gMCBhbmQgd3JhcEhvcml6b250YWwgKCBvciB3cmFwVmVydGljYWwgKSB0b1xuICAqICAgICB0cnVlIHdpbGwgcHJvdmlkZSB0aGUgZWZmZWN0IG9mIGFuIGluZmluaXRlbHkgc2Nyb2xsaW5nIHZpZXdwb3J0LlxuICAqXG4gICogQHByb3BlcnR5IHtPYmplY3R9IFt2aWV3cG9ydE1hcmdpbnM9e31dXG4gICogICAgIFB1c2hlcyB0aGUgXCJob21lXCIgcmVnaW9uIGluIGZyb20gdGhlIHNpZGVzIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50cy5cbiAgKiAgICAgUG9zc2libGUgc3VicHJvcGVydGllcyAoTnVtYmVycywgaW4gc2NyZWVuIGNvb3JkaW5hdGVzKTogbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtpbWFnZUxvYWRlckxpbWl0PTBdXG4gICogICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpbWFnZSByZXF1ZXN0cyB0byBtYWtlIGNvbmN1cnJlbnRseS4gQnkgZGVmYXVsdFxuICAqICAgICBpdCBpcyBzZXQgdG8gMCBhbGxvd2luZyB0aGUgYnJvd3NlciB0byBtYWtlIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAqICAgICBpbWFnZSByZXF1ZXN0cyBpbiBwYXJhbGxlbCBhcyBhbGxvd2VkIGJ5IHRoZSBicm93c2VycyBwb2xpY3kuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2NsaWNrVGltZVRocmVzaG9sZD0zMDBdXG4gICogICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB3aXRoaW4gd2hpY2ggYSBwb2ludGVyIGRvd24tdXAgZXZlbnQgY29tYmluYXRpb25cbiAgKiAgICAgIHdpbGwgYmUgdHJlYXRlZCBhcyBhIGNsaWNrIGdlc3R1cmUuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2NsaWNrRGlzdFRocmVzaG9sZD01XVxuICAqICAgICAgVGhlIG1heGltdW0gZGlzdGFuY2UgYWxsb3dlZCBiZXR3ZWVuIGEgcG9pbnRlciBkb3duIGV2ZW50IGFuZCBhIHBvaW50ZXIgdXAgZXZlbnRcbiAgKiAgICAgIHRvIGJlIHRyZWF0ZWQgYXMgYSBjbGljayBnZXN0dXJlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkYmxDbGlja1RpbWVUaHJlc2hvbGQ9MzAwXVxuICAqICAgICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgd2l0aGluIHdoaWNoIHR3byBwb2ludGVyIGRvd24tdXAgZXZlbnQgY29tYmluYXRpb25zXG4gICogICAgICB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBkb3VibGUtY2xpY2sgZ2VzdHVyZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGJsQ2xpY2tEaXN0VGhyZXNob2xkPTIwXVxuICAqICAgICAgVGhlIG1heGltdW0gZGlzdGFuY2UgYWxsb3dlZCBiZXR3ZWVuIHR3byBwb2ludGVyIGNsaWNrIGV2ZW50c1xuICAqICAgICAgdG8gYmUgdHJlYXRlZCBhcyBhIGRvdWJsZS1jbGljayBnZXN0dXJlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzcHJpbmdTdGlmZm5lc3M9Ni41XVxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFthbmltYXRpb25UaW1lPTEuMl1cbiAgKiAgICAgU3BlY2lmaWVzIHRoZSBhbmltYXRpb24gZHVyYXRpb24gcGVyIGVhY2gge0BsaW5rIE9wZW5TZWFkcmFnb24uU3ByaW5nfVxuICAqICAgICB3aGljaCBvY2N1ciB3aGVuIHRoZSBpbWFnZSBpcyBkcmFnZ2VkIG9yIHpvb21lZC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5HZXN0dXJlU2V0dGluZ3N9IFtnZXN0dXJlU2V0dGluZ3NNb3VzZV1cbiAgKiAgICAgU2V0dGluZ3MgZm9yIGdlc3R1cmVzIGdlbmVyYXRlZCBieSBhIG1vdXNlIHBvaW50ZXIgZGV2aWNlLiAoU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLkdlc3R1cmVTZXR0aW5nc30pXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzTW91c2Uuc2Nyb2xsVG9ab29tPXRydWVdIC0gWm9vbSBvbiBzY3JvbGwgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc01vdXNlLmNsaWNrVG9ab29tPXRydWVdIC0gWm9vbSBvbiBjbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzTW91c2UuZGJsQ2xpY2tUb1pvb209ZmFsc2VdIC0gWm9vbSBvbiBkb3VibGUtY2xpY2sgZ2VzdHVyZS4gTm90ZTogSWYgc2V0IHRvIHRydWVcbiAgKiAgICAgdGhlbiBjbGlja1RvWm9vbSBzaG91bGQgYmUgc2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgbXVsdGlwbGUgem9vbXMuXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzTW91c2UucGluY2hUb1pvb209ZmFsc2VdIC0gWm9vbSBvbiBwaW5jaCBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzTW91c2UuZmxpY2tFbmFibGVkPWZhbHNlXSAtIEVuYWJsZSBmbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnZXN0dXJlU2V0dGluZ3NNb3VzZS5mbGlja01pblNwZWVkPTEyMF0gLSBJZiBmbGlja0VuYWJsZWQgaXMgdHJ1ZSwgdGhlIG1pbmltdW0gc3BlZWQgdG8gaW5pdGlhdGUgYSBmbGljayBnZXN0dXJlIChwaXhlbHMtcGVyLXNlY29uZClcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2dlc3R1cmVTZXR0aW5nc01vdXNlLmZsaWNrTW9tZW50dW09MC4yNV0gLSBJZiBmbGlja0VuYWJsZWQgaXMgdHJ1ZSwgdGhlIG1vbWVudHVtIGZhY3RvciBmb3IgdGhlIGZsaWNrIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NNb3VzZS5waW5jaFJvdGF0ZT1mYWxzZV0gLSBJZiBwaW5jaFJvdGF0ZSBpcyB0cnVlLCB0aGUgdXNlciB3aWxsIGhhdmUgdGhlIGFiaWxpdHkgdG8gcm90YXRlIHRoZSBpbWFnZSB1c2luZyB0aGVpciBmaW5nZXJzLlxuICAqXG4gICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkdlc3R1cmVTZXR0aW5nc30gW2dlc3R1cmVTZXR0aW5nc1RvdWNoXVxuICAqICAgICBTZXR0aW5ncyBmb3IgZ2VzdHVyZXMgZ2VuZXJhdGVkIGJ5IGEgdG91Y2ggcG9pbnRlciBkZXZpY2UuIChTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uR2VzdHVyZVNldHRpbmdzfSlcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NUb3VjaC5zY3JvbGxUb1pvb209ZmFsc2VdIC0gWm9vbSBvbiBzY3JvbGwgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1RvdWNoLmNsaWNrVG9ab29tPWZhbHNlXSAtIFpvb20gb24gY2xpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1RvdWNoLmRibENsaWNrVG9ab29tPXRydWVdIC0gWm9vbSBvbiBkb3VibGUtY2xpY2sgZ2VzdHVyZS4gTm90ZTogSWYgc2V0IHRvIHRydWVcbiAgKiAgICAgdGhlbiBjbGlja1RvWm9vbSBzaG91bGQgYmUgc2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgbXVsdGlwbGUgem9vbXMuXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzVG91Y2gucGluY2hUb1pvb209dHJ1ZV0gLSBab29tIG9uIHBpbmNoIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NUb3VjaC5mbGlja0VuYWJsZWQ9dHJ1ZV0gLSBFbmFibGUgZmxpY2sgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2VzdHVyZVNldHRpbmdzVG91Y2guZmxpY2tNaW5TcGVlZD0xMjBdIC0gSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtaW5pbXVtIHNwZWVkIHRvIGluaXRpYXRlIGEgZmxpY2sgZ2VzdHVyZSAocGl4ZWxzLXBlci1zZWNvbmQpXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnZXN0dXJlU2V0dGluZ3NUb3VjaC5mbGlja01vbWVudHVtPTAuMjVdIC0gSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtb21lbnR1bSBmYWN0b3IgZm9yIHRoZSBmbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzVG91Y2gucGluY2hSb3RhdGU9ZmFsc2VdIC0gSWYgcGluY2hSb3RhdGUgaXMgdHJ1ZSwgdGhlIHVzZXIgd2lsbCBoYXZlIHRoZSBhYmlsaXR5IHRvIHJvdGF0ZSB0aGUgaW1hZ2UgdXNpbmcgdGhlaXIgZmluZ2Vycy5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5HZXN0dXJlU2V0dGluZ3N9IFtnZXN0dXJlU2V0dGluZ3NQZW5dXG4gICogICAgIFNldHRpbmdzIGZvciBnZXN0dXJlcyBnZW5lcmF0ZWQgYnkgYSBwZW4gcG9pbnRlciBkZXZpY2UuIChTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uR2VzdHVyZVNldHRpbmdzfSlcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NQZW4uc2Nyb2xsVG9ab29tPWZhbHNlXSAtIFpvb20gb24gc2Nyb2xsIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NQZW4uY2xpY2tUb1pvb209dHJ1ZV0gLSBab29tIG9uIGNsaWNrIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NQZW4uZGJsQ2xpY2tUb1pvb209ZmFsc2VdIC0gWm9vbSBvbiBkb3VibGUtY2xpY2sgZ2VzdHVyZS4gTm90ZTogSWYgc2V0IHRvIHRydWVcbiAgKiAgICAgdGhlbiBjbGlja1RvWm9vbSBzaG91bGQgYmUgc2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgbXVsdGlwbGUgem9vbXMuXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzUGVuLnBpbmNoVG9ab29tPWZhbHNlXSAtIFpvb20gb24gcGluY2ggZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Blbi5mbGlja0VuYWJsZWQ9ZmFsc2VdIC0gRW5hYmxlIGZsaWNrIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2dlc3R1cmVTZXR0aW5nc1Blbi5mbGlja01pblNwZWVkPTEyMF0gLSBJZiBmbGlja0VuYWJsZWQgaXMgdHJ1ZSwgdGhlIG1pbmltdW0gc3BlZWQgdG8gaW5pdGlhdGUgYSBmbGljayBnZXN0dXJlIChwaXhlbHMtcGVyLXNlY29uZClcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2dlc3R1cmVTZXR0aW5nc1Blbi5mbGlja01vbWVudHVtPTAuMjVdIC0gSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtb21lbnR1bSBmYWN0b3IgZm9yIHRoZSBmbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzUGVuLnBpbmNoUm90YXRlPWZhbHNlXSAtIElmIHBpbmNoUm90YXRlIGlzIHRydWUsIHRoZSB1c2VyIHdpbGwgaGF2ZSB0aGUgYWJpbGl0eSB0byByb3RhdGUgdGhlIGltYWdlIHVzaW5nIHRoZWlyIGZpbmdlcnMuXG4gICpcbiAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uR2VzdHVyZVNldHRpbmdzfSBbZ2VzdHVyZVNldHRpbmdzVW5rbm93bl1cbiAgKiAgICAgU2V0dGluZ3MgZm9yIGdlc3R1cmVzIGdlbmVyYXRlZCBieSB1bmtub3duIHBvaW50ZXIgZGV2aWNlcy4gKFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5HZXN0dXJlU2V0dGluZ3N9KVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Vua25vd24uc2Nyb2xsVG9ab29tPXRydWVdIC0gWm9vbSBvbiBzY3JvbGwgZ2VzdHVyZVxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Vua25vd24uY2xpY2tUb1pvb209ZmFsc2VdIC0gWm9vbSBvbiBjbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzVW5rbm93bi5kYmxDbGlja1RvWm9vbT10cnVlXSAtIFpvb20gb24gZG91YmxlLWNsaWNrIGdlc3R1cmUuIE5vdGU6IElmIHNldCB0byB0cnVlXG4gICogICAgIHRoZW4gY2xpY2tUb1pvb20gc2hvdWxkIGJlIHNldCB0byBmYWxzZSB0byBwcmV2ZW50IG11bHRpcGxlIHpvb21zLlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dlc3R1cmVTZXR0aW5nc1Vua25vd24ucGluY2hUb1pvb209dHJ1ZV0gLSBab29tIG9uIHBpbmNoIGdlc3R1cmVcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnZXN0dXJlU2V0dGluZ3NVbmtub3duLmZsaWNrRW5hYmxlZD10cnVlXSAtIEVuYWJsZSBmbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnZXN0dXJlU2V0dGluZ3NVbmtub3duLmZsaWNrTWluU3BlZWQ9MTIwXSAtIElmIGZsaWNrRW5hYmxlZCBpcyB0cnVlLCB0aGUgbWluaW11bSBzcGVlZCB0byBpbml0aWF0ZSBhIGZsaWNrIGdlc3R1cmUgKHBpeGVscy1wZXItc2Vjb25kKVxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2VzdHVyZVNldHRpbmdzVW5rbm93bi5mbGlja01vbWVudHVtPTAuMjVdIC0gSWYgZmxpY2tFbmFibGVkIGlzIHRydWUsIHRoZSBtb21lbnR1bSBmYWN0b3IgZm9yIHRoZSBmbGljayBnZXN0dXJlXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2VzdHVyZVNldHRpbmdzVW5rbm93bi5waW5jaFJvdGF0ZT1mYWxzZV0gLSBJZiBwaW5jaFJvdGF0ZSBpcyB0cnVlLCB0aGUgdXNlciB3aWxsIGhhdmUgdGhlIGFiaWxpdHkgdG8gcm90YXRlIHRoZSBpbWFnZSB1c2luZyB0aGVpciBmaW5nZXJzLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFt6b29tUGVyQ2xpY2s9Mi4wXVxuICAqICAgICBUaGUgXCJ6b29tIGRpc3RhbmNlXCIgcGVyIG1vdXNlIGNsaWNrIG9yIHRvdWNoIHRhcC4gPGVtPjxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gU2V0dGluZyB0aGlzIHRvIDEuMCBlZmZlY3RpdmVseSBkaXNhYmxlcyB0aGUgY2xpY2stdG8tem9vbSBmZWF0dXJlIChhbHNvIHNlZSBnZXN0dXJlU2V0dGluZ3NbTW91c2V8VG91Y2h8UGVuXS5jbGlja1RvWm9vbS9kYmxDbGlja1RvWm9vbSkuPC9lbT5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbem9vbVBlclNjcm9sbD0xLjJdXG4gICogICAgIFRoZSBcInpvb20gZGlzdGFuY2VcIiBwZXIgbW91c2Ugc2Nyb2xsIG9yIHRvdWNoIHBpbmNoLiA8ZW0+PHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBTZXR0aW5nIHRoaXMgdG8gMS4wIGVmZmVjdGl2ZWx5IGRpc2FibGVzIHRoZSBtb3VzZS13aGVlbCB6b29tIGZlYXR1cmUgKGFsc28gc2VlIGdlc3R1cmVTZXR0aW5nc1tNb3VzZXxUb3VjaHxQZW5dLnNjcm9sbFRvWm9vbX0pLjwvZW0+XG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3pvb21QZXJTZWNvbmQ9MS4wXVxuICAqICAgICBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gYW5pbWF0ZSBhIHNpbmdsZSB6b29tIGV2ZW50IG92ZXIuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzaG93TmF2aWdhdG9yPWZhbHNlXVxuICAqICAgICBTZXQgdG8gdHJ1ZSB0byBtYWtlIHRoZSBuYXZpZ2F0b3IgbWluaW1hcCBhcHBlYXIuXG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gW25hdmlnYXRvcklkPW5hdmlnYXRvci1HRU5FUkFURUQgREFURV1cbiAgKiAgICAgVGhlIElEIG9mIGEgZGl2IHRvIGhvbGQgdGhlIG5hdmlnYXRvciBtaW5pbWFwLlxuICAqICAgICBJZiBhbiBJRCBpcyBzcGVjaWZpZWQsIHRoZSBuYXZpZ2F0b3JQb3NpdGlvbiwgbmF2aWdhdG9yU2l6ZVJhdGlvLCBuYXZpZ2F0b3JNYWludGFpblNpemVSYXRpbywgbmF2aWdhdG9yW1RvcHxMZWZ0fEhlaWdodHxXaWR0aF0gYW5kIG5hdmlnYXRvckF1dG9GYWRlIG9wdGlvbnMgd2lsbCBiZSBpZ25vcmVkLlxuICAqICAgICBJZiBhbiBJRCBpcyBub3Qgc3BlY2lmaWVkLCBhIGRpdiBlbGVtZW50IHdpbGwgYmUgZ2VuZXJhdGVkIGFuZCBwbGFjZWQgb24gdG9wIG9mIHRoZSBtYWluIGltYWdlLlxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IFtuYXZpZ2F0b3JQb3NpdGlvbj0nVE9QX1JJR0hUJ11cbiAgKiAgICAgVmFsaWQgdmFsdWVzIGFyZSAnVE9QX0xFRlQnLCAnVE9QX1JJR0hUJywgJ0JPVFRPTV9MRUZUJywgJ0JPVFRPTV9SSUdIVCcsIG9yICdBQlNPTFVURScuPGJyPlxuICAqICAgICBJZiAnQUJTT0xVVEUnIGlzIHNwZWNpZmllZCwgdGhlbiBuYXZpZ2F0b3JbVG9wfExlZnR8SGVpZ2h0fFdpZHRoXSBkZXRlcm1pbmVzIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgbmF2aWdhdG9yIG1pbmltYXAgaW4gdGhlIHZpZXdlciwgYW5kIG5hdmlnYXRvclNpemVSYXRpbyBhbmQgbmF2aWdhdG9yTWFpbnRhaW5TaXplUmF0aW8gYXJlIGlnbm9yZWQuPGJyPlxuICAqICAgICBGb3IgJ1RPUF9MRUZUJywgJ1RPUF9SSUdIVCcsICdCT1RUT01fTEVGVCcsIGFuZCAnQk9UVE9NX1JJR0hUJywgdGhlIG5hdmlnYXRvclNpemVSYXRpbyBvciBuYXZpZ2F0b3JbSGVpZ2h0fFdpZHRoXSB2YWx1ZXMgZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBuYXZpZ2F0b3IgbWluaW1hcC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbmF2aWdhdG9yU2l6ZVJhdGlvPTAuMl1cbiAgKiAgICAgUmF0aW8gb2YgbmF2aWdhdG9yIHNpemUgdG8gdmlld2VyIHNpemUuIElnbm9yZWQgaWYgbmF2aWdhdG9yW0hlaWdodHxXaWR0aF0gYXJlIHNwZWNpZmllZC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW25hdmlnYXRvck1haW50YWluU2l6ZVJhdGlvPWZhbHNlXVxuICAqICAgICBJZiB0cnVlLCB0aGUgbmF2aWdhdG9yIG1pbmltYXAgaXMgcmVzaXplZCAodXNpbmcgbmF2aWdhdG9yU2l6ZVJhdGlvKSB3aGVuIHRoZSB2aWV3ZXIgc2l6ZSBjaGFuZ2VzLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBbbmF2aWdhdG9yVG9wPW51bGxdXG4gICogICAgIFNwZWNpZmllcyB0aGUgbG9jYXRpb24gb2YgdGhlIG5hdmlnYXRvciBtaW5pbWFwIChzZWUgbmF2aWdhdG9yUG9zaXRpb24pLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBbbmF2aWdhdG9yTGVmdD1udWxsXVxuICAqICAgICBTcGVjaWZpZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBuYXZpZ2F0b3IgbWluaW1hcCAoc2VlIG5hdmlnYXRvclBvc2l0aW9uKS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfFN0cmluZ30gW25hdmlnYXRvckhlaWdodD1udWxsXVxuICAqICAgICBTcGVjaWZpZXMgdGhlIHNpemUgb2YgdGhlIG5hdmlnYXRvciBtaW5pbWFwIChzZWUgbmF2aWdhdG9yUG9zaXRpb24pLlxuICAqICAgICBJZiBzcGVjaWZpZWQsIG5hdmlnYXRvclNpemVSYXRpbyBhbmQgbmF2aWdhdG9yTWFpbnRhaW5TaXplUmF0aW8gYXJlIGlnbm9yZWQuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtuYXZpZ2F0b3JXaWR0aD1udWxsXVxuICAqICAgICBTcGVjaWZpZXMgdGhlIHNpemUgb2YgdGhlIG5hdmlnYXRvciBtaW5pbWFwIChzZWUgbmF2aWdhdG9yUG9zaXRpb24pLlxuICAqICAgICBJZiBzcGVjaWZpZWQsIG5hdmlnYXRvclNpemVSYXRpbyBhbmQgbmF2aWdhdG9yTWFpbnRhaW5TaXplUmF0aW8gYXJlIGlnbm9yZWQuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtuYXZpZ2F0b3JBdXRvUmVzaXplPXRydWVdXG4gICogICAgIFNldCB0byBmYWxzZSB0byBwcmV2ZW50IHBvbGxpbmcgZm9yIG5hdmlnYXRvciBzaXplIGNoYW5nZXMuIFVzZWZ1bCBmb3IgcHJvdmlkaW5nIGN1c3RvbSByZXNpemUgYmVoYXZpb3IuXG4gICogICAgIFNldHRpbmcgdG8gZmFsc2UgY2FuIGFsc28gaW1wcm92ZSBwZXJmb3JtYW5jZSB3aGVuIHRoZSBuYXZpZ2F0b3IgaXMgY29uZmlndXJlZCB0byBhIGZpeGVkIHNpemUuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtuYXZpZ2F0b3JBdXRvRmFkZT10cnVlXVxuICAqICAgICBJZiB0aGUgdXNlciBzdG9wcyBpbnRlcmFjdGluZyB3aXRoIHRoZSB2aWV3cG9ydCwgZmFkZSB0aGUgbmF2aWdhdG9yIG1pbmltYXAuXG4gICogICAgIFNldHRpbmcgdG8gZmFsc2Ugd2lsbCBtYWtlIHRoZSBuYXZpZ2F0b3IgbWluaW1hcCBhbHdheXMgdmlzaWJsZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW25hdmlnYXRvclJvdGF0ZT10cnVlXVxuICAqICAgICBJZiB0cnVlLCB0aGUgbmF2aWdhdG9yIHdpbGwgYmUgcm90YXRlZCB0b2dldGhlciB3aXRoIHRoZSB2aWV3ZXIuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbnRyb2xzRmFkZURlbGF5PTIwMDBdXG4gICogICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgb25jZSB0aGUgdXNlciBoYXMgc3RvcHBlZCBpbnRlcmFjdGluZ1xuICAqICAgICB3aXRoIHRoZSBpbnRlcmZhY2UgYmVmb3JlIGJlZ2luaW5nIHRvIGZhZGUgdGhlIGNvbnRyb2xzLiBBc3N1bWVzXG4gICogICAgIHNob3dOYXZpZ2F0aW9uQ29udHJvbCBhbmQgYXV0b0hpZGVDb250cm9scyBhcmUgYm90aCB0cnVlLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb250cm9sc0ZhZGVMZW5ndGg9MTUwMF1cbiAgKiAgICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gYW5pbWF0ZSB0aGUgY29udHJvbHMgZmFkaW5nIG91dC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWF4SW1hZ2VDYWNoZUNvdW50PTIwMF1cbiAgKiAgICAgVGhlIG1heCBudW1iZXIgb2YgaW1hZ2VzIHdlIHNob3VsZCBrZWVwIGluIG1lbW9yeSAocGVyIGRyYXdlcikuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpbWVvdXQ9MzAwMDBdXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt1c2VDYW52YXM9dHJ1ZV1cbiAgKiAgICAgU2V0IHRvIGZhbHNlIHRvIG5vdCB1c2UgYW4gSFRNTCBjYW52YXMgZWxlbWVudCBmb3IgaW1hZ2UgcmVuZGVyaW5nIGV2ZW4gaWYgY2FudmFzIGlzIHN1cHBvcnRlZC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWluUGl4ZWxSYXRpbz0wLjVdXG4gICogICAgIFRoZSBoaWdoZXIgdGhlIG1pblBpeGVsUmF0aW8sIHRoZSBsb3dlciB0aGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgdGhhdFxuICAqICAgICBpcyBjb25zaWRlcmVkIHN1ZmZpY2llbnQgdG8gc3RvcCByZW5kZXJpbmcgYSBnaXZlbiB6b29tIGxldmVsLiAgRm9yXG4gICogICAgIGV4YW1wbGUsIGlmIHlvdSBhcmUgdGFyZ2V0aW5nIG1vYmlsZSBkZXZpY2VzIHdpdGggbGVzcyBiYW5kd2l0aCB5b3UgbWF5XG4gICogICAgIHRyeSBzZXR0aW5nIHRoaXMgdG8gMS41IG9yIGhpZ2hlci5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW21vdXNlTmF2RW5hYmxlZD10cnVlXVxuICAqICAgICBJcyB0aGUgdXNlciBhYmxlIHRvIGludGVyYWN0IHdpdGggdGhlIGltYWdlIHZpYSBtb3VzZSBvciB0b3VjaC4gRGVmYXVsdFxuICAqICAgICBpbnRlcmFjdGlvbnMgaW5jbHVkZSBkcmFnaW5nIHRoZSBpbWFnZSBpbiBhIHBsYW5lLCBhbmQgem9vbWluZyBpbiB0b3dhcmRcbiAgKiAgICAgYW5kIGF3YXkgZnJvbSB0aGUgaW1hZ2UuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzaG93TmF2aWdhdGlvbkNvbnRyb2w9dHJ1ZV1cbiAgKiAgICAgU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGRlZmF1bHQgbmF2aWdhdGlvbiBjb250cm9scy48YnI+XG4gICogICAgIE5vdGUgdGhhdCBpZiBzZXQgdG8gZmFsc2UsIHRoZSBjdXN0b21zIGJ1dHRvbnMgc2V0IGJ5IHRoZSBvcHRpb25zXG4gICogICAgIHpvb21JbkJ1dHRvbiwgem9vbU91dEJ1dHRvbiBldGMsIGFyZSByZW5kZXJlZCBpbmFjdGl2ZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Db250cm9sQW5jaG9yfSBbbmF2aWdhdGlvbkNvbnRyb2xBbmNob3I9VE9QX0xFRlRdXG4gICogICAgIFBsYWNlbWVudCBvZiB0aGUgZGVmYXVsdCBuYXZpZ2F0aW9uIGNvbnRyb2xzLlxuICAqICAgICBUbyBzZXQgdGhlIHBsYWNlbWVudCBvZiB0aGUgc2VxdWVuY2UgY29udHJvbHMsIHNlZSB0aGVcbiAgKiAgICAgc2VxdWVuY2VDb250cm9sQW5jaG9yIG9wdGlvbi5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Nob3dab29tQ29udHJvbD10cnVlXVxuICAqICAgICBJZiB0cnVlIHRoZW4gKyBhbmQgLSBidXR0b25zIHRvIHpvb20gaW4gYW5kIG91dCBhcmUgZGlzcGxheWVkLjxicj5cbiAgKiAgICAgTm90ZToge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5zaG93TmF2aWdhdGlvbkNvbnRyb2x9IGlzIG92ZXJyaWRpbmdcbiAgKiAgICAgdGhpcyBzZXR0aW5nIHdoZW4gc2V0IHRvIGZhbHNlLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbc2hvd0hvbWVDb250cm9sPXRydWVdXG4gICogICAgIElmIHRydWUgdGhlbiB0aGUgJ0dvIGhvbWUnIGJ1dHRvbiBpcyBkaXNwbGF5ZWQgdG8gZ28gYmFjayB0byB0aGUgb3JpZ2luYWxcbiAgKiAgICAgem9vbSBhbmQgcGFuLjxicj5cbiAgKiAgICAgTm90ZToge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5zaG93TmF2aWdhdGlvbkNvbnRyb2x9IGlzIG92ZXJyaWRpbmdcbiAgKiAgICAgdGhpcyBzZXR0aW5nIHdoZW4gc2V0IHRvIGZhbHNlLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbc2hvd0Z1bGxQYWdlQ29udHJvbD10cnVlXVxuICAqICAgICBJZiB0cnVlIHRoZW4gdGhlICdUb2dnbGUgZnVsbCBwYWdlJyBidXR0b24gaXMgZGlzcGxheWVkIHRvIHN3aXRjaFxuICAqICAgICBiZXR3ZWVuIGZ1bGwgcGFnZSBhbmQgbm9ybWFsIG1vZGUuPGJyPlxuICAqICAgICBOb3RlOiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLnNob3dOYXZpZ2F0aW9uQ29udHJvbH0gaXMgb3ZlcnJpZGluZ1xuICAqICAgICB0aGlzIHNldHRpbmcgd2hlbiBzZXQgdG8gZmFsc2UuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzaG93Um90YXRpb25Db250cm9sPWZhbHNlXVxuICAqICAgICBJZiB0cnVlIHRoZW4gdGhlIHJvdGF0ZSBsZWZ0L3JpZ2h0IGNvbnRyb2xzIHdpbGwgYmUgZGlzcGxheWVkIGFzIHBhcnQgb2YgdGhlXG4gICogICAgIHN0YW5kYXJkIGNvbnRyb2xzLiBUaGlzIGlzIGFsc28gc3ViamVjdCB0byB0aGUgYnJvd3NlciBzdXBwb3J0IGZvciByb3RhdGVcbiAgKiAgICAgKGUuZy4gdmlld2VyLmRyYXdlci5jYW5Sb3RhdGUoKSkuPGJyPlxuICAqICAgICBOb3RlOiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLnNob3dOYXZpZ2F0aW9uQ29udHJvbH0gaXMgb3ZlcnJpZGluZ1xuICAqICAgICB0aGlzIHNldHRpbmcgd2hlbiBzZXQgdG8gZmFsc2UuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzaG93U2VxdWVuY2VDb250cm9sPXRydWVdXG4gICogICAgIElmIHNlcXVlbmNlTW9kZSBpcyB0cnVlLCB0aGVuIHByb3ZpZGUgYnV0dG9ucyBmb3IgbmF2aWdhdGluZyBmb3J3YXJkIGFuZFxuICAqICAgICBiYWNrd2FyZCB0aHJvdWdoIHRoZSBpbWFnZXMuXG4gICpcbiAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uQ29udHJvbEFuY2hvcn0gW3NlcXVlbmNlQ29udHJvbEFuY2hvcj1UT1BfTEVGVF1cbiAgKiAgICAgUGxhY2VtZW50IG9mIHRoZSBkZWZhdWx0IHNlcXVlbmNlIGNvbnRyb2xzLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbbmF2UHJldk5leHRXcmFwPWZhbHNlXVxuICAqICAgICBJZiB0cnVlIHRoZW4gdGhlICdwcmV2aW91cycgYnV0dG9uIHdpbGwgd3JhcCB0byB0aGUgbGFzdCBpbWFnZSB3aGVuXG4gICogICAgIHZpZXdpbmcgdGhlIGZpcnN0IGltYWdlIGFuZCB0aGUgJ25leHQnIGJ1dHRvbiB3aWxsIHdyYXAgdG8gdGhlIGZpcnN0XG4gICogICAgIGltYWdlIHdoZW4gdmlld2luZyB0aGUgbGFzdCBpbWFnZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB6b29tSW5CdXR0b25cbiAgKiAgICAgU2V0IHRoZSBpZCBvZiB0aGUgY3VzdG9tICdab29tIGluJyBidXR0b24gdG8gdXNlLlxuICAqICAgICBUaGlzIGlzIHVzZWZ1bCB0byBoYXZlIGEgY3VzdG9tIGJ1dHRvbiBhbnl3aGVyZSBpbiB0aGUgd2ViIHBhZ2UuPGJyPlxuICAqICAgICBUbyBvbmx5IGNoYW5nZSB0aGUgYnV0dG9uIGltYWdlcywgY29uc2lkZXIgdXNpbmdcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5uYXZJbWFnZXN9XG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbU91dEJ1dHRvblxuICAqICAgICBTZXQgdGhlIGlkIG9mIHRoZSBjdXN0b20gJ1pvb20gb3V0JyBidXR0b24gdG8gdXNlLlxuICAqICAgICBUaGlzIGlzIHVzZWZ1bCB0byBoYXZlIGEgY3VzdG9tIGJ1dHRvbiBhbnl3aGVyZSBpbiB0aGUgd2ViIHBhZ2UuPGJyPlxuICAqICAgICBUbyBvbmx5IGNoYW5nZSB0aGUgYnV0dG9uIGltYWdlcywgY29uc2lkZXIgdXNpbmdcbiAgKiAgICAge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9ucy5uYXZJbWFnZXN9XG4gICpcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gaG9tZUJ1dHRvblxuICAqICAgICBTZXQgdGhlIGlkIG9mIHRoZSBjdXN0b20gJ0dvIGhvbWUnIGJ1dHRvbiB0byB1c2UuXG4gICogICAgIFRoaXMgaXMgdXNlZnVsIHRvIGhhdmUgYSBjdXN0b20gYnV0dG9uIGFueXdoZXJlIGluIHRoZSB3ZWIgcGFnZS48YnI+XG4gICogICAgIFRvIG9ubHkgY2hhbmdlIHRoZSBidXR0b24gaW1hZ2VzLCBjb25zaWRlciB1c2luZ1xuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLm5hdkltYWdlc31cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxsUGFnZUJ1dHRvblxuICAqICAgICBTZXQgdGhlIGlkIG9mIHRoZSBjdXN0b20gJ1RvZ2dsZSBmdWxsIHBhZ2UnIGJ1dHRvbiB0byB1c2UuXG4gICogICAgIFRoaXMgaXMgdXNlZnVsIHRvIGhhdmUgYSBjdXN0b20gYnV0dG9uIGFueXdoZXJlIGluIHRoZSB3ZWIgcGFnZS48YnI+XG4gICogICAgIFRvIG9ubHkgY2hhbmdlIHRoZSBidXR0b24gaW1hZ2VzLCBjb25zaWRlciB1c2luZ1xuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLm5hdkltYWdlc31cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVMZWZ0QnV0dG9uXG4gICogICAgIFNldCB0aGUgaWQgb2YgdGhlIGN1c3RvbSAnUm90YXRlIGxlZnQnIGJ1dHRvbiB0byB1c2UuXG4gICogICAgIFRoaXMgaXMgdXNlZnVsIHRvIGhhdmUgYSBjdXN0b20gYnV0dG9uIGFueXdoZXJlIGluIHRoZSB3ZWIgcGFnZS48YnI+XG4gICogICAgIFRvIG9ubHkgY2hhbmdlIHRoZSBidXR0b24gaW1hZ2VzLCBjb25zaWRlciB1c2luZ1xuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLm5hdkltYWdlc31cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVSaWdodEJ1dHRvblxuICAqICAgICBTZXQgdGhlIGlkIG9mIHRoZSBjdXN0b20gJ1JvdGF0ZSByaWdodCcgYnV0dG9uIHRvIHVzZS5cbiAgKiAgICAgVGhpcyBpcyB1c2VmdWwgdG8gaGF2ZSBhIGN1c3RvbSBidXR0b24gYW55d2hlcmUgaW4gdGhlIHdlYiBwYWdlLjxicj5cbiAgKiAgICAgVG8gb25seSBjaGFuZ2UgdGhlIGJ1dHRvbiBpbWFnZXMsIGNvbnNpZGVyIHVzaW5nXG4gICogICAgIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnMubmF2SW1hZ2VzfVxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHByZXZpb3VzQnV0dG9uXG4gICogICAgIFNldCB0aGUgaWQgb2YgdGhlIGN1c3RvbSAnUHJldmlvdXMgcGFnZScgYnV0dG9uIHRvIHVzZS5cbiAgKiAgICAgVGhpcyBpcyB1c2VmdWwgdG8gaGF2ZSBhIGN1c3RvbSBidXR0b24gYW55d2hlcmUgaW4gdGhlIHdlYiBwYWdlLjxicj5cbiAgKiAgICAgVG8gb25seSBjaGFuZ2UgdGhlIGJ1dHRvbiBpbWFnZXMsIGNvbnNpZGVyIHVzaW5nXG4gICogICAgIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnMubmF2SW1hZ2VzfVxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IG5leHRCdXR0b25cbiAgKiAgICAgU2V0IHRoZSBpZCBvZiB0aGUgY3VzdG9tICdOZXh0IHBhZ2UnIGJ1dHRvbiB0byB1c2UuXG4gICogICAgIFRoaXMgaXMgdXNlZnVsIHRvIGhhdmUgYSBjdXN0b20gYnV0dG9uIGFueXdoZXJlIGluIHRoZSB3ZWIgcGFnZS48YnI+XG4gICogICAgIFRvIG9ubHkgY2hhbmdlIHRoZSBidXR0b24gaW1hZ2VzLCBjb25zaWRlciB1c2luZ1xuICAqICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zLm5hdkltYWdlc31cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3NlcXVlbmNlTW9kZT1mYWxzZV1cbiAgKiAgICAgU2V0IHRvIHRydWUgdG8gaGF2ZSB0aGUgdmlld2VyIHRyZWF0IHlvdXIgdGlsZXNvdXJjZXMgYXMgYSBzZXF1ZW5jZSBvZiBpbWFnZXMgdG9cbiAgKiAgICAgYmUgb3BlbmVkIG9uZSBhdCBhIHRpbWUgcmF0aGVyIHRoYW4gYWxsIGF0IG9uY2UuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW2luaXRpYWxQYWdlPTBdXG4gICogICAgIElmIHNlcXVlbmNlTW9kZSBpcyB0cnVlLCBkaXNwbGF5IHRoaXMgcGFnZSBpbml0aWFsbHkuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwcmVzZXJ2ZVZpZXdwb3J0PWZhbHNlXVxuICAqICAgICBJZiBzZXF1ZW5jZU1vZGUgaXMgdHJ1ZSwgdGhlbiBub3JtYWxseSBuYXZpZ2F0aW5nIHRocm91Z2ggZWFjaCBpbWFnZSByZXNldHMgdGhlXG4gICogICAgIHZpZXdwb3J0IHRvICdob21lJyBwb3NpdGlvbi4gIElmIHByZXNlcnZlVmlld3BvcnQgaXMgc2V0IHRvIHRydWUsIHRoZW4gdGhlIHZpZXdwb3J0XG4gICogICAgIHBvc2l0aW9uIGlzIHByZXNlcnZlZCB3aGVuIG5hdmlnYXRpbmcgYmV0d2VlbiBpbWFnZXMgaW4gdGhlIHNlcXVlbmNlLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbcHJlc2VydmVPdmVybGF5cz1mYWxzZV1cbiAgKiAgICAgSWYgc2VxdWVuY2VNb2RlIGlzIHRydWUsIHRoZW4gbm9ybWFsbHkgbmF2aWdhdGluZyB0aHJvdWdoIGVhY2ggaW1hZ2VcbiAgKiAgICAgcmVzZXRzIHRoZSBvdmVybGF5cy5cbiAgKiAgICAgSWYgcHJlc2VydmVPdmVybGF5cyBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgb3ZlcmxheXMgYWRkZWQgd2l0aCB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjYWRkT3ZlcmxheX1cbiAgKiAgICAgYXJlIHByZXNlcnZlZCB3aGVuIG5hdmlnYXRpbmcgYmV0d2VlbiBpbWFnZXMgaW4gdGhlIHNlcXVlbmNlLlxuICAqICAgICBOb3RlOiBzZXR0aW5nIHByZXNlcnZlT3ZlcmxheXMgb3ZlcnJpZGVzIGFueSBvdmVybGF5cyBzcGVjaWZpZWQgaW4gdGhlIGdsb2JhbFxuICAqICAgICBcIm92ZXJsYXlzXCIgb3B0aW9uIGZvciB0aGUgVmlld2VyLiBJdCdzIGFsc28gbm90IGNvbXBhdGlibGUgd2l0aCBzcGVjaWZ5aW5nXG4gICogICAgIHBlci10aWxlU291cmNlIG92ZXJsYXlzIHZpYSB0aGUgb3B0aW9ucywgYXMgdGhvc2Ugb3ZlcmxheXMgd2lsbCBwZXJzaXN0XG4gICogICAgIGV2ZW4gYWZ0ZXIgdGhlIHRpbGVTb3VyY2UgaXMgY2xvc2VkLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbc2hvd1JlZmVyZW5jZVN0cmlwPWZhbHNlXVxuICAqICAgICBJZiBzZXF1ZW5jZU1vZGUgaXMgdHJ1ZSwgdGhlbiBkaXNwbGF5IGEgc2Nyb2xsaW5nIHN0cmlwIG9mIGltYWdlIHRodW1ibmFpbHMgZm9yXG4gICogICAgIG5hdmlnYXRpbmcgdGhyb3VnaCB0aGUgaW1hZ2VzLlxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IFtyZWZlcmVuY2VTdHJpcFNjcm9sbD0naG9yaXpvbnRhbCddXG4gICpcbiAgKiBAcHJvcGVydHkge0VsZW1lbnR9IFtyZWZlcmVuY2VTdHJpcEVsZW1lbnQ9bnVsbF1cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVmZXJlbmNlU3RyaXBIZWlnaHQ9bnVsbF1cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVmZXJlbmNlU3RyaXBXaWR0aD1udWxsXVxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IFtyZWZlcmVuY2VTdHJpcFBvc2l0aW9uPSdCT1RUT01fTEVGVCddXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gW3JlZmVyZW5jZVN0cmlwU2l6ZVJhdGlvPTAuMl1cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbGxlY3Rpb25Nb2RlPWZhbHNlXVxuICAqICAgICBTZXQgdG8gdHJ1ZSB0byBoYXZlIHRoZSB2aWV3ZXIgYXJyYW5nZSB5b3VyIFRpbGVkSW1hZ2VzIGluIGEgZ3JpZCBvciBsaW5lLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb2xsZWN0aW9uUm93cz0zXVxuICAqICAgICBJZiBjb2xsZWN0aW9uTW9kZSBpcyB0cnVlLCBzcGVjaWZpZXMgaG93IG1hbnkgcm93cyB0aGUgZ3JpZCBzaG91bGQgaGF2ZS4gVXNlIDEgdG8gbWFrZSBhIGxpbmUuXG4gICogICAgIElmIGNvbGxlY3Rpb25MYXlvdXQgaXMgJ3ZlcnRpY2FsJywgc3BlY2lmaWVzIGhvdyBtYW55IGNvbHVtbnMgaW5zdGVhZC5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbY29sbGVjdGlvbkNvbHVtbnM9MF1cbiAgKiAgICAgSWYgY29sbGVjdGlvbk1vZGUgaXMgdHJ1ZSwgc3BlY2lmaWVzIGhvdyBtYW55IGNvbHVtbnMgdGhlIGdyaWQgc2hvdWxkIGhhdmUuIFVzZSAxIHRvIG1ha2UgYSBsaW5lLlxuICAqICAgICBJZiBjb2xsZWN0aW9uTGF5b3V0IGlzICd2ZXJ0aWNhbCcsIHNwZWNpZmllcyBob3cgbWFueSByb3dzIGluc3RlYWQuIElnbm9yZWQgaWYgY29sbGVjdGlvblJvd3MgaXMgbm90IHNldCB0byBhIGZhbHN5IHZhbHVlLlxuICAqXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb2xsZWN0aW9uTGF5b3V0PSdob3Jpem9udGFsJ11cbiAgKiAgICAgSWYgY29sbGVjdGlvbk1vZGUgaXMgdHJ1ZSwgc3BlY2lmaWVzIHdoZXRoZXIgdG8gYXJyYW5nZSB2ZXJ0aWNhbGx5IG9yIGhvcml6b250YWxseS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbY29sbGVjdGlvblRpbGVTaXplPTgwMF1cbiAgKiAgICAgSWYgY29sbGVjdGlvbk1vZGUgaXMgdHJ1ZSwgc3BlY2lmaWVzIHRoZSBzaXplLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcywgZm9yIGVhY2ggVGlsZWRJbWFnZSB0byBmaXQgaW50by5cbiAgKiAgICAgVGhlIFRpbGVkSW1hZ2Ugd2lsbCBiZSBjZW50ZXJlZCB3aXRoaW4gYSBzcXVhcmUgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAqXG4gICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb2xsZWN0aW9uVGlsZU1hcmdpbj04MF1cbiAgKiAgICAgSWYgY29sbGVjdGlvbk1vZGUgaXMgdHJ1ZSwgc3BlY2lmaWVzIHRoZSBtYXJnaW4sIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLCBiZXR3ZWVuIGVhY2ggVGlsZWRJbWFnZS5cbiAgKlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfEJvb2xlYW59IFtjcm9zc09yaWdpblBvbGljeT1mYWxzZV1cbiAgKiAgICAgVmFsaWQgdmFsdWVzIGFyZSAnQW5vbnltb3VzJywgJ3VzZS1jcmVkZW50aWFscycsIGFuZCBmYWxzZS4gSWYgZmFsc2UsIGNhbnZhcyByZXF1ZXN0cyB3aWxsXG4gICogICAgIG5vdCB1c2UgQ09SUywgYW5kIHRoZSBjYW52YXMgd2lsbCBiZSB0YWludGVkLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBbYWpheFdpdGhDcmVkZW50aWFscz1mYWxzZV1cbiAgKiAgICAgV2hldGhlciB0byBzZXQgdGhlIHdpdGhDcmVkZW50aWFscyBYSFIgZmxhZyBmb3IgQUpBWCByZXF1ZXN0cyAod2hlbiBsb2FkaW5nIHRpbGUgc291cmNlcykuXG4gICogICAgIE5vdGUgdGhhdCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGF0IHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlfSBsZXZlbC5cbiAgKlxuICAqL1xuXG4gLyoqXG4gICogU2V0dGluZ3MgZm9yIGdlc3R1cmVzIGdlbmVyYXRlZCBieSBhIHBvaW50ZXIgZGV2aWNlLlxuICAqXG4gICogQHR5cGVkZWYge09iamVjdH0gR2VzdHVyZVNldHRpbmdzXG4gICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgKlxuICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2Nyb2xsVG9ab29tXG4gICogICAgIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHpvb21pbmcgb24gc2Nyb2xsIGdlc3R1cmVzLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBjbGlja1RvWm9vbVxuICAqICAgICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nIG9uIGNsaWNrIGdlc3R1cmVzLlxuICAqXG4gICogQHByb3BlcnR5IHtCb29sZWFufSBkYmxDbGlja1RvWm9vbVxuICAqICAgICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nIG9uIGRvdWJsZS1jbGljayBnZXN0dXJlcy4gTm90ZTogSWYgc2V0IHRvIHRydWVcbiAgKiAgICAgdGhlbiBjbGlja1RvWm9vbSBzaG91bGQgYmUgc2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgbXVsdGlwbGUgem9vbXMuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHBpbmNoVG9ab29tXG4gICogICAgIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHpvb21pbmcgb24gcGluY2ggZ2VzdHVyZXMuXG4gICpcbiAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGZsaWNrRW5hYmxlZFxuICAqICAgICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUga2luZXRpYyBwYW5uaW5nIGVmZmVjdCAoZmxpY2spIGF0IHRoZSBlbmQgb2YgYSBkcmFnIGdlc3R1cmUuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gZmxpY2tNaW5TcGVlZFxuICAqICAgICBJZiBmbGlja0VuYWJsZWQgaXMgdHJ1ZSwgdGhlIG1pbmltdW0gc3BlZWQgKGluIHBpeGVscy1wZXItc2Vjb25kKSByZXF1aXJlZCB0byBjYXVzZSB0aGUga2luZXRpYyBwYW5uaW5nIGVmZmVjdCAoZmxpY2spIGF0IHRoZSBlbmQgb2YgYSBkcmFnIGdlc3R1cmUuXG4gICpcbiAgKiBAcHJvcGVydHkge051bWJlcn0gZmxpY2tNb21lbnR1bVxuICAqICAgICBJZiBmbGlja0VuYWJsZWQgaXMgdHJ1ZSwgYSBjb25zdGFudCBtdWx0aXBsaWVkIGJ5IHRoZSB2ZWxvY2l0eSB0byBkZXRlcm1pbmUgdGhlIGRpc3RhbmNlIG9mIHRoZSBraW5ldGljIHBhbm5pbmcgZWZmZWN0IChmbGljaykgYXQgdGhlIGVuZCBvZiBhIGRyYWcgZ2VzdHVyZS5cbiAgKiAgICAgQSBsYXJnZXIgdmFsdWUgd2lsbCBtYWtlIHRoZSBmbGljayBmZWVsIFwibGlnaHRlclwiLCB3aGlsZSBhIHNtYWxsZXIgdmFsdWUgd2lsbCBtYWtlIHRoZSBmbGljayBmZWVsIFwiaGVhdmllclwiLlxuICAqICAgICBOb3RlOiBzcHJpbmdTdGlmZm5lc3MgYW5kIGFuaW1hdGlvblRpbWUgYWxzbyBhZmZlY3QgdGhlIFwic3ByaW5nXCIgdXNlZCB0byBzdG9wIHRoZSBmbGljayBhbmltYXRpb24uXG4gICpcbiAgKi9cblxuLyoqXG4gICogVGhlIG5hbWVzIGZvciB0aGUgaW1hZ2UgcmVzb3VyY2VzIHVzZWQgZm9yIHRoZSBpbWFnZSBuYXZpZ2F0aW9uIGJ1dHRvbnMuXG4gICpcbiAgKiBAdHlwZWRlZiB7T2JqZWN0fSBOYXZJbWFnZXNcbiAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAqXG4gICogQHByb3BlcnR5IHtPYmplY3R9IHpvb21JbiAtIEltYWdlcyBmb3IgdGhlIHpvb20taW4gYnV0dG9uLlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB6b29tSW4uUkVTVFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB6b29tSW4uR1JPVVBcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbUluLkhPVkVSXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHpvb21Jbi5ET1dOXG4gICpcbiAgKiBAcHJvcGVydHkge09iamVjdH0gem9vbU91dCAtIEltYWdlcyBmb3IgdGhlIHpvb20tb3V0IGJ1dHRvbi5cbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbU91dC5SRVNUXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHpvb21PdXQuR1JPVVBcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gem9vbU91dC5IT1ZFUlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB6b29tT3V0LkRPV05cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBob21lIC0gSW1hZ2VzIGZvciB0aGUgaG9tZSBidXR0b24uXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGhvbWUuUkVTVFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBob21lLkdST1VQXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGhvbWUuSE9WRVJcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gaG9tZS5ET1dOXG4gICpcbiAgKiBAcHJvcGVydHkge09iamVjdH0gZnVsbHBhZ2UgLSBJbWFnZXMgZm9yIHRoZSBmdWxsLXBhZ2UgYnV0dG9uLlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxscGFnZS5SRVNUXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGZ1bGxwYWdlLkdST1VQXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGZ1bGxwYWdlLkhPVkVSXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IGZ1bGxwYWdlLkRPV05cbiAgKlxuICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByb3RhdGVsZWZ0IC0gSW1hZ2VzIGZvciB0aGUgcm90YXRlIGxlZnQgYnV0dG9uLlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVsZWZ0LlJFU1RcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlbGVmdC5HUk9VUFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVsZWZ0LkhPVkVSXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHJvdGF0ZWxlZnQuRE9XTlxuICAqXG4gICogQHByb3BlcnR5IHtPYmplY3R9IHJvdGF0ZXJpZ2h0IC0gSW1hZ2VzIGZvciB0aGUgcm90YXRlIHJpZ2h0IGJ1dHRvbi5cbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcm90YXRlcmlnaHQuUkVTVFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVyaWdodC5HUk9VUFxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVyaWdodC5IT1ZFUlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByb3RhdGVyaWdodC5ET1dOXG4gICpcbiAgKiBAcHJvcGVydHkge09iamVjdH0gcHJldmlvdXMgLSBJbWFnZXMgZm9yIHRoZSBwcmV2aW91cyBidXR0b24uXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IHByZXZpb3VzLlJFU1RcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJldmlvdXMuR1JPVVBcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJldmlvdXMuSE9WRVJcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJldmlvdXMuRE9XTlxuICAqXG4gICogQHByb3BlcnR5IHtPYmplY3R9IG5leHQgLSBJbWFnZXMgZm9yIHRoZSBuZXh0IGJ1dHRvbi5cbiAgKiBAcHJvcGVydHkge1N0cmluZ30gbmV4dC5SRVNUXG4gICogQHByb3BlcnR5IHtTdHJpbmd9IG5leHQuR1JPVVBcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gbmV4dC5IT1ZFUlxuICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuZXh0LkRPV05cbiAgKlxuICAqL1xuXG5cbiAvKipcbiAgKiBUaGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyBhIHNpbmdsZSBwb2ludCBvZiBpbnN0YW50aWF0aW9uIGZvciBhbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXJ9LCBpbmNsdWRpbmcgYWxsXG4gICogY29tYmluYXRpb25zIG9mIG91dC1vZi10aGUtYm94IGNvbmZpZ3VyYWJsZSBmZWF0dXJlcy5cbiAgKlxuICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5PcHRpb25zfSBvcHRpb25zIC0gVmlld2VyIG9wdGlvbnMuXG4gICogQHJldHVybnMge09wZW5TZWFkcmFnb24uVmlld2VyfVxuICAqL1xud2luZG93Lk9wZW5TZWFkcmFnb24gPSB3aW5kb3cuT3BlblNlYWRyYWdvbiB8fCBmdW5jdGlvbiggb3B0aW9ucyApe1xuXG4gICAgcmV0dXJuIG5ldyBPcGVuU2VhZHJhZ29uLlZpZXdlciggb3B0aW9ucyApO1xuXG59O1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgIHJldHVybiAod2luZG93Lk9wZW5TZWFkcmFnb24pO1xuICAgfSk7XG59XG5cblxuKGZ1bmN0aW9uKCAkICl7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBPcGVuU2VhZHJhZ29uIHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IE9wZW5TZWFkcmFnb24udmVyc2lvblxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB2ZXJzaW9uU3RyIC0gVGhlIHZlcnNpb24gbnVtYmVyIGFzIGEgc3RyaW5nICgnbWFqb3IubWlub3IucmV2aXNpb24nKS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbWFqb3IgLSBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pbm9yIC0gVGhlIG1pbm9yIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZXZpc2lvbiAtIFRoZSByZXZpc2lvbiBudW1iZXIuXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICovXG4gICAgJC52ZXJzaW9uID0ge1xuICAgICAgICB2ZXJzaW9uU3RyOiAnMi4yLjEnLFxuICAgICAgICBtYWpvcjogcGFyc2VJbnQoJzInLCAxMCksXG4gICAgICAgIG1pbm9yOiBwYXJzZUludCgnMicsIDEwKSxcbiAgICAgICAgcmV2aXNpb246IHBhcnNlSW50KCcxJywgMTApXG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogVGFrZW4gZnJvbSBqcXVlcnkgMS42LjFcbiAgICAgKiBbW0NsYXNzXV0gLT4gdHlwZSBwYWlyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIGNsYXNzMnR5cGUgPSB7XG4gICAgICAgICAgICAnW29iamVjdCBCb29sZWFuXSc6ICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAnW29iamVjdCBOdW1iZXJdJzogICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICdbb2JqZWN0IFN0cmluZ10nOiAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ1tvYmplY3QgRnVuY3Rpb25dJzogICAgJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICdbb2JqZWN0IEFycmF5XSc6ICAgICAgICdhcnJheScsXG4gICAgICAgICAgICAnW29iamVjdCBEYXRlXSc6ICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnW29iamVjdCBSZWdFeHBdJzogICAgICAncmVnZXhwJyxcbiAgICAgICAgICAgICdbb2JqZWN0IE9iamVjdF0nOiAgICAgICdvYmplY3QnXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gc29tZSBjb3JlIG1ldGhvZHNcbiAgICAgICAgdG9TdHJpbmcgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBoYXNPd24gICAgICA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlbiBmcm9tIGpRdWVyeSAxLjYuMVxuICAgICAqIEBmdW5jdGlvbiBpc0Z1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmpxdWVyeS5jb20vIGpRdWVyeX1cbiAgICAgKi9cbiAgICAkLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICByZXR1cm4gJC50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBUYWtlbiBmcm9tIGpRdWVyeSAxLjYuMVxuICAgICAqIEBmdW5jdGlvbiBpc0FycmF5XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmpxdWVyeS5jb20vIGpRdWVyeX1cbiAgICAgKi9cbiAgICAkLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIHJldHVybiAkLnR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEEgY3J1ZGUgd2F5IG9mIGRldGVybWluaW5nIGlmIGFuIG9iamVjdCBpcyBhIHdpbmRvdy5cbiAgICAgKiBUYWtlbiBmcm9tIGpRdWVyeSAxLjYuMVxuICAgICAqIEBmdW5jdGlvbiBpc1dpbmRvd1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5qcXVlcnkuY29tLyBqUXVlcnl9XG4gICAgICovXG4gICAgJC5pc1dpbmRvdyA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBcInNldEludGVydmFsXCIgaW4gb2JqO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFRha2VuIGZyb20galF1ZXJ5IDEuNi4xXG4gICAgICogQGZ1bmN0aW9uIHR5cGVcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuanF1ZXJ5LmNvbS8galF1ZXJ5fVxuICAgICAqL1xuICAgICQudHlwZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIHJldHVybiAoIG9iaiA9PT0gbnVsbCApIHx8ICggb2JqID09PSB1bmRlZmluZWQgKSA/XG4gICAgICAgICAgICBTdHJpbmcoIG9iaiApIDpcbiAgICAgICAgICAgIGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCI7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogVGFrZW4gZnJvbSBqUXVlcnkgMS42LjFcbiAgICAgKiBAZnVuY3Rpb24gaXNQbGFpbk9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5qcXVlcnkuY29tLyBqUXVlcnl9XG4gICAgICovXG4gICAgJC5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgLy8gTXVzdCBiZSBhbiBPYmplY3QuXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgSUUsIHdlIGFsc28gaGF2ZSB0byBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbFxuICAgICAgICBpZiAoICFvYmogfHwgT3BlblNlYWRyYWdvbi50eXBlKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8ICQuaXNXaW5kb3coIG9iaiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuICAgICAgICBpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgIWhhc093bi5jYWxsKG9iaiwgXCJjb25zdHJ1Y3RvclwiKSAmJlxuICAgICAgICAgICAgIWhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuICAgICAgICAvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblxuICAgICAgICB2YXIgbGFzdEtleTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaiApIHtcbiAgICAgICAgICAgIGxhc3RLZXkgPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFzdEtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGxhc3RLZXkgKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBUYWtlbiBmcm9tIGpRdWVyeSAxLjYuMVxuICAgICAqIEBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmpxdWVyeS5jb20vIGpRdWVyeX1cbiAgICAgKi9cbiAgICAkLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNoaW0gYXJvdW5kIE9iamVjdC5mcmVlemUuIERvZXMgbm90aGluZyBpZiBPYmplY3QuZnJlZXplIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGZyZWV6ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iaiBUaGUgZnJvemVuIG9iamVjdC5cbiAgICAgKi9cbiAgICAkLmZyZWV6ZU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgJC5mcmVlemVPYmplY3QgPSBPYmplY3QuZnJlZXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5mcmVlemVPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJC5mcmVlemVPYmplY3Qob2JqKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgSFRNTDUgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzdXBwb3J0c0NhbnZhc1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICovXG4gICAgJC5zdXBwb3J0c0NhbnZhcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgcmV0dXJuICEhKCAkLmlzRnVuY3Rpb24oIGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCApICYmXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCggJzJkJyApICk7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0aGUgc3VibWl0dGVkIGNhbnZhcyBpcyB0YWludGVkIG9yIG5vdC5cbiAgICAgKiBAYXJndW1lbnQge0NhbnZhc30gY2FudmFzIFRoZSBjYW52YXMgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2FudmFzIGlzIHRhaW50ZWQuXG4gICAgICovXG4gICAgJC5pc0NhbnZhc1RhaW50ZWQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgdmFyIGlzVGFpbnRlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgdGVzdCBpZiB0aGUgY2FudmFzIGlzIHRhaW50ZWQgYnkgcmV0cmlldmluZyBkYXRhIGZyb20gaXQuXG4gICAgICAgICAgICAvLyBBbiBleGNlcHRpb24gd2lsbCBiZSByYWlzZWQgaWYgdGhlIGNhbnZhcyBpcyB0YWludGVkLlxuICAgICAgICAgICAgdmFyIGRhdGEgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlzVGFpbnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVGFpbnRlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSByYXRpbyBjb21wYXJpbmcgdGhlIGRldmljZSBzY3JlZW4ncyBwaXhlbCBkZW5zaXR5IHRvIHRoZSBjYW52YXMncyBiYWNraW5nIHN0b3JlIHBpeGVsIGRlbnNpdHkuIERlZmF1bHRzIHRvIDEgaWYgY2FudmFzIGlzbid0IHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHBpeGVsRGVuc2l0eVJhdGlvXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKi9cbiAgICAkLnBpeGVsRGVuc2l0eVJhdGlvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCAkLnN1cHBvcnRzQ2FudmFzICkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qKlxuICogIFRoaXMgY2xvc3VyZSBkZWZpbmVzIGFsbCBzdGF0aWMgbWV0aG9kcyBhdmFpbGFibGUgdG8gdGhlIE9wZW5TZWFkcmFnb25cbiAqICBuYW1lc3BhY2UuICBNYW55LCBpZiBub3QgbW9zdCwgYXJlIHRha2VkIGRpcmVjdGx5IGZyb20galF1ZXJ5IGZvciB1c2VcbiAqICB0byBzaW1wbGlmeSBhbmQgcmVkdWNlIGNvbW1vbiBwcm9ncmFtbWluZyBwYXR0ZXJucy4gIE1vcmUgc3RhdGljIG1ldGhvZHNcbiAqICBmcm9tIGpRdWVyeSBtYXkgZXZlbnR1YWxseSBtYWtlIHRoZWlyIHdheSBpbnRvIHRoaXMgdGhvdWdoIHdlIGFyZVxuICogIGF0dGVtcHRpbmcgdG8gYXZvaWQgYW4gZXhwbGljaXQgZGVwZW5kZW5jeSBvbiBqUXVlcnkgb25seSBiZWNhdXNlXG4gKiAgT3BlblNlYWRyYWdvbiBpcyBhIGJyb2FkbHkgdXNlZnVsIGNvZGUgYmFzZSBhbmQgd291bGQgYmUgbWFkZSBsZXNzIGJyb2FkXG4gKiAgYnkgcmVxdWlyaW5nIGpRdWVyeSBmdWxseS5cbiAqXG4gKiAgU29tZSBzdGF0aWMgbWV0aG9kcyBoYXZlIGFsc28gYmVlbiByZWZhY3RvcmVkIGZyb20gdGhlIG9yaWdpbmFsIE9wZW5TZWFkcmFnb25cbiAqICBwcm9qZWN0LlxuICovXG4oZnVuY3Rpb24oICQgKXtcblxuICAgIC8qKlxuICAgICAqIFRha2VuIGZyb20galF1ZXJ5IDEuNi4xXG4gICAgICogQGZ1bmN0aW9uIGV4dGVuZFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5qcXVlcnkuY29tLyBqUXVlcnl9XG4gICAgICovXG4gICAgJC5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgIGNvcHlJc0FycmF5LFxuICAgICAgICAgICAgY2xvbmUsXG4gICAgICAgICAgICB0YXJnZXQgID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG4gICAgICAgICAgICBsZW5ndGggID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZXAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGkgICAgICAgPSAxO1xuXG4gICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgIGRlZXAgICAgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXQgID0gYXJndW1lbnRzWyAxIF0gfHwge307XG4gICAgICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBpID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIU9wZW5TZWFkcmFnb24uaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgICBpZiAoIGxlbmd0aCA9PT0gaSApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAtLWk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXTtcbiAgICAgICAgICAgIGlmICggb3B0aW9ucyAhPT0gbnVsbCB8fCBvcHRpb25zICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0WyBuYW1lIF07XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRhcmdldCA9PT0gY29weSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggT3BlblNlYWRyYWdvbi5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHwgKCBjb3B5SXNBcnJheSA9IE9wZW5TZWFkcmFnb24uaXNBcnJheSggY29weSApICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBPcGVuU2VhZHJhZ29uLmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgT3BlblNlYWRyYWdvbi5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gT3BlblNlYWRyYWdvbi5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICB2YXIgaXNJT1NEZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJBZ2VudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlckFnZW50LmluZGV4T2YoJ2lQaG9uZScpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgdXNlckFnZW50LmluZGV4T2YoJ2lQYWQnKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgIHVzZXJBZ2VudC5pbmRleE9mKCdpUG9kJykgIT09IC0xO1xuICAgIH07XG5cbiAgICAkLmV4dGVuZCggJCwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uICove1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgb3B0aW9uYWwgc2V0dGluZ3MgZG9jdW1lbnRlZCBhdCB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgREVGQVVMVF9TRVRUSU5HUzoge1xuICAgICAgICAgICAgLy9EQVRBIFNPVVJDRSBERVRBSUxTXG4gICAgICAgICAgICB4bWxQYXRoOiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGlsZVNvdXJjZXM6ICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRpbGVIb3N0OiAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBpbml0aWFsUGFnZTogICAgICAgICAgICAwLFxuICAgICAgICAgICAgY3Jvc3NPcmlnaW5Qb2xpY3k6ICAgICAgZmFsc2UsXG4gICAgICAgICAgICBhamF4V2l0aENyZWRlbnRpYWxzOiAgICBmYWxzZSxcblxuICAgICAgICAgICAgLy9QQU4gQU5EIFpPT00gU0VUVElOR1MgQU5EIENPTlNUUkFJTlRTXG4gICAgICAgICAgICBwYW5Ib3Jpem9udGFsOiAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgcGFuVmVydGljYWw6ICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbkR1cmluZ1BhbjogICAgIGZhbHNlLFxuICAgICAgICAgICAgd3JhcEhvcml6b250YWw6ICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICB3cmFwVmVydGljYWw6ICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHZpc2liaWxpdHlSYXRpbzogICAgICAgIDAuNSwgLy8tPiBob3cgbXVjaCBvZiB0aGUgdmlld2VyIGNhbiBiZSBuZWdhdGl2ZSBzcGFjZVxuICAgICAgICAgICAgbWluUGl4ZWxSYXRpbzogICAgICAgICAgMC41LCAvLy0+Y2xvc2VyIHRvIDAgZHJhd3MgdGlsZXMgbWVhbnQgZm9yIGEgaGlnaGVyIHpvb20gYXQgdGhpcyB6b29tXG4gICAgICAgICAgICBkZWZhdWx0Wm9vbUxldmVsOiAgICAgICAwLFxuICAgICAgICAgICAgbWluWm9vbUxldmVsOiAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG1heFpvb21MZXZlbDogICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBob21lRmlsbHNWaWV3ZXI6ICAgICAgICBmYWxzZSxcblxuICAgICAgICAgICAgLy9VSSBSRVNQT05TSVZFTkVTUyBBTkQgRkVFTFxuICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiAgICAgMzAwLFxuICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiAgICAgNSxcbiAgICAgICAgICAgIGRibENsaWNrVGltZVRocmVzaG9sZDogIDMwMCxcbiAgICAgICAgICAgIGRibENsaWNrRGlzdFRocmVzaG9sZDogIDIwLFxuICAgICAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiAgICAgICAgNi41LFxuICAgICAgICAgICAgYW5pbWF0aW9uVGltZTogICAgICAgICAgMS4yLFxuICAgICAgICAgICAgZ2VzdHVyZVNldHRpbmdzTW91c2U6ICAgeyBzY3JvbGxUb1pvb206IHRydWUsICBjbGlja1RvWm9vbTogdHJ1ZSwgIGRibENsaWNrVG9ab29tOiBmYWxzZSwgcGluY2hUb1pvb206IGZhbHNlLCBmbGlja0VuYWJsZWQ6IGZhbHNlLCBmbGlja01pblNwZWVkOiAxMjAsIGZsaWNrTW9tZW50dW06IDAuMjUsIHBpbmNoUm90YXRlOiBmYWxzZSB9LFxuICAgICAgICAgICAgZ2VzdHVyZVNldHRpbmdzVG91Y2g6ICAgeyBzY3JvbGxUb1pvb206IGZhbHNlLCBjbGlja1RvWm9vbTogZmFsc2UsIGRibENsaWNrVG9ab29tOiB0cnVlLCAgcGluY2hUb1pvb206IHRydWUsICBmbGlja0VuYWJsZWQ6IHRydWUsICBmbGlja01pblNwZWVkOiAxMjAsIGZsaWNrTW9tZW50dW06IDAuMjUsIHBpbmNoUm90YXRlOiBmYWxzZSB9LFxuICAgICAgICAgICAgZ2VzdHVyZVNldHRpbmdzUGVuOiAgICAgeyBzY3JvbGxUb1pvb206IGZhbHNlLCBjbGlja1RvWm9vbTogdHJ1ZSwgIGRibENsaWNrVG9ab29tOiBmYWxzZSwgcGluY2hUb1pvb206IGZhbHNlLCBmbGlja0VuYWJsZWQ6IGZhbHNlLCBmbGlja01pblNwZWVkOiAxMjAsIGZsaWNrTW9tZW50dW06IDAuMjUsIHBpbmNoUm90YXRlOiBmYWxzZSB9LFxuICAgICAgICAgICAgZ2VzdHVyZVNldHRpbmdzVW5rbm93bjogeyBzY3JvbGxUb1pvb206IGZhbHNlLCBjbGlja1RvWm9vbTogZmFsc2UsIGRibENsaWNrVG9ab29tOiB0cnVlLCAgcGluY2hUb1pvb206IHRydWUsICBmbGlja0VuYWJsZWQ6IHRydWUsICBmbGlja01pblNwZWVkOiAxMjAsIGZsaWNrTW9tZW50dW06IDAuMjUsIHBpbmNoUm90YXRlOiBmYWxzZSB9LFxuICAgICAgICAgICAgem9vbVBlckNsaWNrOiAgICAgICAgICAgMixcbiAgICAgICAgICAgIHpvb21QZXJTY3JvbGw6ICAgICAgICAgIDEuMixcbiAgICAgICAgICAgIHpvb21QZXJTZWNvbmQ6ICAgICAgICAgIDEuMCxcbiAgICAgICAgICAgIGJsZW5kVGltZTogICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBhbHdheXNCbGVuZDogICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9IaWRlQ29udHJvbHM6ICAgICAgIHRydWUsXG4gICAgICAgICAgICBpbW1lZGlhdGVSZW5kZXI6ICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIG1pblpvb21JbWFnZVJhdGlvOiAgICAgIDAuOSwgLy8tPiBjbG9zZXIgdG8gMCBhbGxvd3Mgem9vbSBvdXQgdG8gaW5maW5pdHlcbiAgICAgICAgICAgIG1heFpvb21QaXhlbFJhdGlvOiAgICAgIDEuMSwgLy8tPiBoaWdoZXIgYWxsb3dzICdvdmVyIHpvb20nIGludG8gcGl4ZWxzXG4gICAgICAgICAgICBzbW9vdGhUaWxlRWRnZXNNaW5ab29tOiAxLjEsIC8vLT4gaGlnaGVyIHRoYW4gbWF4Wm9vbVBpeGVsUmF0aW8gZGlzYWJsZXMgaXRcbiAgICAgICAgICAgIGlPU0RldmljZTogICAgICAgICAgICAgIGlzSU9TRGV2aWNlKCksXG4gICAgICAgICAgICBwaXhlbHNQZXJXaGVlbExpbmU6ICAgICA0MCxcbiAgICAgICAgICAgIGF1dG9SZXNpemU6ICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBwcmVzZXJ2ZUltYWdlU2l6ZU9uUmVzaXplOiBmYWxzZSwgLy8gcmVxdWlyZXMgYXV0b1Jlc2l6ZT10cnVlXG4gICAgICAgICAgICBtaW5TY3JvbGxEZWx0YVRpbWU6ICAgICA1MCxcblxuICAgICAgICAgICAgLy9ERUZBVUxUIENPTlRST0wgU0VUVElOR1NcbiAgICAgICAgICAgIHNob3dTZXF1ZW5jZUNvbnRyb2w6ICAgICB0cnVlLCAgLy9TRVFVRU5DRVxuICAgICAgICAgICAgc2VxdWVuY2VDb250cm9sQW5jaG9yOiAgIG51bGwsICAvL1NFUVVFTkNFXG4gICAgICAgICAgICBwcmVzZXJ2ZVZpZXdwb3J0OiAgICAgICAgZmFsc2UsIC8vU0VRVUVOQ0VcbiAgICAgICAgICAgIHByZXNlcnZlT3ZlcmxheXM6ICAgICAgICBmYWxzZSwgLy9TRVFVRU5DRVxuICAgICAgICAgICAgbmF2UHJldk5leHRXcmFwOiAgICAgICAgIGZhbHNlLCAvL1NFUVVFTkNFXG4gICAgICAgICAgICBzaG93TmF2aWdhdGlvbkNvbnRyb2w6ICAgdHJ1ZSwgIC8vWk9PTS9IT01FL0ZVTEwvUk9UQVRJT05cbiAgICAgICAgICAgIG5hdmlnYXRpb25Db250cm9sQW5jaG9yOiBudWxsLCAgLy9aT09NL0hPTUUvRlVMTC9ST1RBVElPTlxuICAgICAgICAgICAgc2hvd1pvb21Db250cm9sOiAgICAgICAgIHRydWUsICAvL1pPT01cbiAgICAgICAgICAgIHNob3dIb21lQ29udHJvbDogICAgICAgICB0cnVlLCAgLy9IT01FXG4gICAgICAgICAgICBzaG93RnVsbFBhZ2VDb250cm9sOiAgICAgdHJ1ZSwgIC8vRlVMTFxuICAgICAgICAgICAgc2hvd1JvdGF0aW9uQ29udHJvbDogICAgIGZhbHNlLCAvL1JPVEFUSU9OXG4gICAgICAgICAgICBjb250cm9sc0ZhZGVEZWxheTogICAgICAgMjAwMCwgIC8vWk9PTS9IT01FL0ZVTEwvU0VRVUVOQ0VcbiAgICAgICAgICAgIGNvbnRyb2xzRmFkZUxlbmd0aDogICAgICAxNTAwLCAgLy9aT09NL0hPTUUvRlVMTC9TRVFVRU5DRVxuICAgICAgICAgICAgbW91c2VOYXZFbmFibGVkOiAgICAgICAgIHRydWUsICAvL0dFTkVSQUwgTU9VU0UgSU5URVJBQ1RJVklUWVxuXG4gICAgICAgICAgICAvL1ZJRVdQT1JUIE5BVklHQVRPUiBTRVRUSU5HU1xuICAgICAgICAgICAgc2hvd05hdmlnYXRvcjogICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgbmF2aWdhdG9ySWQ6ICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXZpZ2F0b3JQb3NpdGlvbjogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5hdmlnYXRvclNpemVSYXRpbzogICAgICAgICAwLjIsXG4gICAgICAgICAgICBuYXZpZ2F0b3JNYWludGFpblNpemVSYXRpbzogZmFsc2UsXG4gICAgICAgICAgICBuYXZpZ2F0b3JUb3A6ICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5hdmlnYXRvckxlZnQ6ICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmF2aWdhdG9ySGVpZ2h0OiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXZpZ2F0b3JXaWR0aDogICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5hdmlnYXRvckF1dG9SZXNpemU6ICAgICAgICB0cnVlLFxuICAgICAgICAgICAgbmF2aWdhdG9yQXV0b0ZhZGU6ICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBuYXZpZ2F0b3JSb3RhdGU6ICAgICAgICAgICAgdHJ1ZSxcblxuICAgICAgICAgICAgLy8gSU5JVElBTCBST1RBVElPTlxuICAgICAgICAgICAgZGVncmVlczogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAgICAgICAgIC8vIEFQUEVBUkFOQ0VcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgY29tcG9zaXRlT3BlcmF0aW9uOiAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwbGFjZWhvbGRlckZpbGxTdHlsZTogICAgICAgbnVsbCxcblxuICAgICAgICAgICAgLy9SRUZFUkVOQ0UgU1RSSVAgU0VUVElOR1NcbiAgICAgICAgICAgIHNob3dSZWZlcmVuY2VTdHJpcDogICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICByZWZlcmVuY2VTdHJpcFNjcm9sbDogICAgICAgJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgcmVmZXJlbmNlU3RyaXBFbGVtZW50OiAgICAgICBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlU3RyaXBIZWlnaHQ6ICAgICAgICBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlU3RyaXBXaWR0aDogICAgICAgICBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlU3RyaXBQb3NpdGlvbjogICAgICAnQk9UVE9NX0xFRlQnLFxuICAgICAgICAgICAgcmVmZXJlbmNlU3RyaXBTaXplUmF0aW86ICAgICAwLjIsXG5cbiAgICAgICAgICAgIC8vQ09MTEVDVElPTiBWSVNVQUxJWkFUSU9OIFNFVFRJTkdTXG4gICAgICAgICAgICBjb2xsZWN0aW9uUm93czogICAgICAgICAzLCAvL29yIGNvbHVtbnMgZGVwZW5kaW5nIG9uIGxheW91dFxuICAgICAgICAgICAgY29sbGVjdGlvbkNvbHVtbnM6ICAgICAgMCwgLy9jb2x1bW5zIGluIGhvcml6b250YWwgbGF5b3V0LCByb3dzIGluIHZlcnRpY2FsIGxheW91dFxuICAgICAgICAgICAgY29sbGVjdGlvbkxheW91dDogICAgICAgJ2hvcml6b250YWwnLCAvL3ZlcnRpY2FsXG4gICAgICAgICAgICBjb2xsZWN0aW9uTW9kZTogICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb25UaWxlU2l6ZTogICAgIDgwMCxcbiAgICAgICAgICAgIGNvbGxlY3Rpb25UaWxlTWFyZ2luOiAgIDgwLFxuXG4gICAgICAgICAgICAvL1BFUkZPUk1BTkNFIFNFVFRJTkdTXG4gICAgICAgICAgICBpbWFnZUxvYWRlckxpbWl0OiAgICAgICAwLFxuICAgICAgICAgICAgbWF4SW1hZ2VDYWNoZUNvdW50OiAgICAgMjAwLFxuICAgICAgICAgICAgdGltZW91dDogICAgICAgICAgICAgICAgMzAwMDAsXG4gICAgICAgICAgICB1c2VDYW52YXM6ICAgICAgICAgICAgICB0cnVlLCAgLy8gVXNlIGNhbnZhcyBlbGVtZW50IGZvciBkcmF3aW5nIGlmIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAvL0lOVEVSRkFDRSBSRVNPVVJDRSBTRVRUSU5HU1xuICAgICAgICAgICAgcHJlZml4VXJsOiAgICAgICAgICAgICAgXCIvaW1hZ2VzL1wiLFxuICAgICAgICAgICAgbmF2SW1hZ2VzOiB7XG4gICAgICAgICAgICAgICAgem9vbUluOiB7XG4gICAgICAgICAgICAgICAgICAgIFJFU1Q6ICAgJ3pvb21pbl9yZXN0LnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEdST1VQOiAgJ3pvb21pbl9ncm91cGhvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEhPVkVSOiAgJ3pvb21pbl9ob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBET1dOOiAgICd6b29taW5fcHJlc3NlZC5wbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB6b29tT3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIFJFU1Q6ICAgJ3pvb21vdXRfcmVzdC5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBHUk9VUDogICd6b29tb3V0X2dyb3VwaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgSE9WRVI6ICAnem9vbW91dF9ob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBET1dOOiAgICd6b29tb3V0X3ByZXNzZWQucG5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaG9tZToge1xuICAgICAgICAgICAgICAgICAgICBSRVNUOiAgICdob21lX3Jlc3QucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgR1JPVVA6ICAnaG9tZV9ncm91cGhvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEhPVkVSOiAgJ2hvbWVfaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgRE9XTjogICAnaG9tZV9wcmVzc2VkLnBuZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bGxwYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIFJFU1Q6ICAgJ2Z1bGxwYWdlX3Jlc3QucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgR1JPVVA6ICAnZnVsbHBhZ2VfZ3JvdXBob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBIT1ZFUjogICdmdWxscGFnZV9ob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBET1dOOiAgICdmdWxscGFnZV9wcmVzc2VkLnBuZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJvdGF0ZWxlZnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgUkVTVDogICAncm90YXRlbGVmdF9yZXN0LnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEdST1VQOiAgJ3JvdGF0ZWxlZnRfZ3JvdXBob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBIT1ZFUjogICdyb3RhdGVsZWZ0X2hvdmVyLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIERPV046ICAgJ3JvdGF0ZWxlZnRfcHJlc3NlZC5wbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByb3RhdGVyaWdodDoge1xuICAgICAgICAgICAgICAgICAgICBSRVNUOiAgICdyb3RhdGVyaWdodF9yZXN0LnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEdST1VQOiAgJ3JvdGF0ZXJpZ2h0X2dyb3VwaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgSE9WRVI6ICAncm90YXRlcmlnaHRfaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgRE9XTjogICAncm90YXRlcmlnaHRfcHJlc3NlZC5wbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmV2aW91czoge1xuICAgICAgICAgICAgICAgICAgICBSRVNUOiAgICdwcmV2aW91c19yZXN0LnBuZycsXG4gICAgICAgICAgICAgICAgICAgIEdST1VQOiAgJ3ByZXZpb3VzX2dyb3VwaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgSE9WRVI6ICAncHJldmlvdXNfaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgRE9XTjogICAncHJldmlvdXNfcHJlc3NlZC5wbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIFJFU1Q6ICAgJ25leHRfcmVzdC5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBHUk9VUDogICduZXh0X2dyb3VwaG92ZXIucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgSE9WRVI6ICAnbmV4dF9ob3Zlci5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBET1dOOiAgICduZXh0X3ByZXNzZWQucG5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vREVWRUxPUEVSIFNFVFRJTkdTXG4gICAgICAgICAgICBkZWJ1Z01vZGU6ICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGRlYnVnR3JpZENvbG9yOiAgICAgICAgICcjNDM3QUIyJ1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IGdldCByaWQgb2YgdGhpcy4gIEkgY2FuJ3Qgc2VlIGhvdyBpdCdzIHJlcXVpcmVkIGF0IGFsbC4gIExvb2tzXG4gICAgICAgICAqICAgICAgIGxpa2UgYW4gZWFybHkgbGVnYWN5IGNvZGUgYXJ0aWZhY3QuXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgU0lHTkFMOiBcIi0tLS1zZWFkcmFnb24tLS0tXCIsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGludm9rZXMgdGhlIG1ldGhvZCBhcyBpZiBpdCB3ZXJlIGEgbWV0aG9kIGJlbG9uZ2luZyB0byB0aGUgb2JqZWN0LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uKCBvYmplY3QsIG1ldGhvZCApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIGlmICggYXJncyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSggb2JqZWN0LCBhcmdzICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVudW1lcmF0aW9uIG9mIEJyb3dzZXIgdmVuZG9ycy5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gVU5LTk9XTlxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gSUVcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEZJUkVGT1hcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFNBRkFSSVxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQ0hST01FXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBPUEVSQVxuICAgICAgICAgKi9cbiAgICAgICAgQlJPV1NFUlM6IHtcbiAgICAgICAgICAgIFVOS05PV046ICAgIDAsXG4gICAgICAgICAgICBJRTogICAgICAgICAxLFxuICAgICAgICAgICAgRklSRUZPWDogICAgMixcbiAgICAgICAgICAgIFNBRkFSSTogICAgIDMsXG4gICAgICAgICAgICBDSFJPTUU6ICAgICA0LFxuICAgICAgICAgICAgT1BFUkE6ICAgICAgNVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBET00gRWxlbWVudCBmb3IgdGhlIGdpdmVuIGlkIG9yIGVsZW1lbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbGVtZW50IEFjY2VwdHMgYW4gaWQgb3IgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR9IFRoZSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIGlkLCBudWxsLCBvciB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbGVtZW50OiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mICggZWxlbWVudCApID09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBlbGVtZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50IC0gdGhlIGVsZW1lbmV0IHdlIHdhbnQgdGhlIHBvc2l0aW9uIGZvci5cbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IC0gdGhlIHBvc2l0aW9uIG9mIHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEVsZW1lbnRQb3NpdGlvbjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3ICQuUG9pbnQoKSxcbiAgICAgICAgICAgICAgICBpc0ZpeGVkLFxuICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudDtcblxuICAgICAgICAgICAgZWxlbWVudCAgICAgID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICBpc0ZpeGVkICAgICAgPSAkLmdldEVsZW1lbnRTdHlsZSggZWxlbWVudCApLnBvc2l0aW9uID09IFwiZml4ZWRcIjtcbiAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudCggZWxlbWVudCwgaXNGaXhlZCApO1xuXG4gICAgICAgICAgICB3aGlsZSAoIG9mZnNldFBhcmVudCApIHtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC54ICs9IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICByZXN1bHQueSArPSBlbGVtZW50Lm9mZnNldFRvcDtcblxuICAgICAgICAgICAgICAgIGlmICggaXNGaXhlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBsdXMoICQuZ2V0UGFnZVNjcm9sbCgpICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IG9mZnNldFBhcmVudDtcbiAgICAgICAgICAgICAgICBpc0ZpeGVkID0gJC5nZXRFbGVtZW50U3R5bGUoIGVsZW1lbnQgKS5wb3NpdGlvbiA9PSBcImZpeGVkXCI7XG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KCBlbGVtZW50LCBpc0ZpeGVkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgcG9zaXRpb24gb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBlbGVtZW50IGFkanVzdGVkIGZvciBjdXJyZW50IHBhZ2UgYW5kL29yIGVsZW1lbnQgc2Nyb2xsLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudCAtIHRoZSBlbGVtZW50IHdlIHdhbnQgdGhlIHBvc2l0aW9uIGZvci5cbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IC0gdGhlIHBvc2l0aW9uIG9mIHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgZWxlbWVudCBhZGp1c3RlZCBmb3IgY3VycmVudCBwYWdlIGFuZC9vciBlbGVtZW50IHNjcm9sbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEVsZW1lbnRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuXG4gICAgICAgICAgICB2YXIgZG9jID0gZWxlbWVudCAmJiBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jRWxlbWVudCxcbiAgICAgICAgICAgICAgICB3aW4sXG4gICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuICAgICAgICAgICAgaWYgKCAhZG9jICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb2NFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IHR5cGVvZiB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2luID0gKCBkb2MgPT0gZG9jLndpbmRvdyApID9cbiAgICAgICAgICAgICAgICBkb2MgOlxuICAgICAgICAgICAgICAgICggZG9jLm5vZGVUeXBlID09PSA5ICkgP1xuICAgICAgICAgICAgICAgICAgICBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyA6XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgKyAoIHdpbi5wYWdlWE9mZnNldCB8fCBkb2NFbGVtZW50LnNjcm9sbExlZnQgKSAtICggZG9jRWxlbWVudC5jbGllbnRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3QudG9wICsgKCB3aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbWVudC5zY3JvbGxUb3AgKSAtICggZG9jRWxlbWVudC5jbGllbnRUb3AgfHwgMCApXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBDU1NTdHlsZSBvYmplY3QgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJucyB7Q1NTU3R5bGV9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbGVtZW50U3R5bGU6XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jdXJyZW50U3R5bGU7XG4gICAgICAgICAgICB9IDpcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGVsZW1lbnQsIFwiXCIgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHByb3BlcnR5IHdpdGggdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeCBhcHBlbmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBwcm9wZXJ0eSB3aXRoIHRoZSBjb3JyZWN0IHByZWZpeCBvciBudWxsIGlmIG5vdFxuICAgICAgICAgKiBzdXBwb3J0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDc3NQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXg6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICB2YXIgbWVtbyA9IHt9O1xuXG4gICAgICAgICAgICAkLmdldENzc1Byb3BlcnR5V2l0aFZlbmRvclByZWZpeCA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbW9bcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9bcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvcGVydHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ01TJywgJ08nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dlYmtpdCcsICdtb3onLCAnbXMnLCAnbyddO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VmZml4ID0gJC5jYXBpdGFsaXplRmlyc3RMZXR0ZXIocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByZWZpeGVzW2ldICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lbW9bcHJvcGVydHldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICQuZ2V0Q3NzUHJvcGVydHlXaXRoVmVuZG9yUHJlZml4KHByb3BlcnR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FwaXRhbGl6ZXMgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZ1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgbGV0dGVyIGNhcGl0YWxpemVkXG4gICAgICAgICAqL1xuICAgICAgICBjYXBpdGFsaXplRmlyc3RMZXR0ZXI6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIHRoZSBnaXZlbiBlbGVtZW50IChoaXQtdGVzdCkuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnRcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEluRWxlbWVudDogZnVuY3Rpb24oIGVsZW1lbnQsIHBvaW50ICkge1xuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9ICQuZ2V0RWxlbWVudE9mZnNldCggZWxlbWVudCApLFxuICAgICAgICAgICAgICAgIHNpemUgPSAkLmdldEVsZW1lbnRTaXplKCBlbGVtZW50ICk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQueCA+PSBvZmZzZXQueCAmJiBwb2ludC54IDwgb2Zmc2V0LnggKyBzaXplLnggJiYgcG9pbnQueSA8IG9mZnNldC55ICsgc2l6ZS55ICYmIHBvaW50LnkgPj0gb2Zmc2V0Lnk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbGF0ZXN0IGV2ZW50LCByZWFsbHkgb25seSB1c2VmdWwgaW50ZXJuYWxseSBzaW5jZSBpdHNcbiAgICAgICAgICogc3BlY2lmaWMgdG8gSUUgYmVoYXZpb3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnRdXG4gICAgICAgICAqIEByZXR1cm5zIHtFdmVudH1cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgRm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFdmVudDogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgaWYoIGV2ZW50ICl7XG4gICAgICAgICAgICAgICAgJC5nZXRFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQuZ2V0RXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIG9uIHRoZSBzY3JlZW4gZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnRdXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TW91c2VQb3NpdGlvbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiggZXZlbnQucGFnZVggKSA9PSBcIm51bWJlclwiICkge1xuICAgICAgICAgICAgICAgICQuZ2V0TW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKCBldmVudCApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3ICQuUG9pbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC54ID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC55ID0gZXZlbnQucGFnZVk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mKCBldmVudC5jbGllbnRYICkgPT0gXCJudW1iZXJcIiApIHtcbiAgICAgICAgICAgICAgICAkLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbiggZXZlbnQgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyAkLlBvaW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQueCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jbGllbnRYICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2xpZW50WSArXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVua25vd24gZXZlbnQgbW91c2UgcG9zaXRpb24sIG5vIGtub3duIHRlY2huaXF1ZS5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAkLmdldE1vdXNlUG9zaXRpb24oIGV2ZW50ICk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgcGFnZSdzIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYWdlU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkb2NFbGVtZW50ICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCB7fSxcbiAgICAgICAgICAgICAgICBib2R5ICAgICAgICA9IGRvY3VtZW50LmJvZHkgfHwge307XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mKCB3aW5kb3cucGFnZVhPZmZzZXQgKSA9PSBcIm51bWJlclwiICkge1xuICAgICAgICAgICAgICAgICQuZ2V0UGFnZVNjcm9sbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBib2R5LnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxUb3AgKSB7XG4gICAgICAgICAgICAgICAgJC5nZXRQYWdlU2Nyb2xsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY0VsZW1lbnQuc2Nyb2xsVG9wICkge1xuICAgICAgICAgICAgICAgICQuZ2V0UGFnZVNjcm9sbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHJlYXNzaWduIHRoZSBmdW5jdGlvbiB5ZXQsIGFzIHRoZXJlIHdhcyBubyBzY3JvbGwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KDAsMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAkLmdldFBhZ2VTY3JvbGwoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBwYWdlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGFnZVNjcm9sbDogZnVuY3Rpb24oIHNjcm9sbCApIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mICggd2luZG93LnNjcm9sbFRvICkgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICAgICAgJC5zZXRQYWdlU2Nyb2xsID0gZnVuY3Rpb24oIHNjcm9sbCApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKCBzY3JvbGwueCwgc2Nyb2xsLnkgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxTY3JvbGwgPSAkLmdldFBhZ2VTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAoIG9yaWdpbmFsU2Nyb2xsLnggPT09IHNjcm9sbC54ICYmXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU2Nyb2xsLnkgPT09IHNjcm9sbC55ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWxyZWFkeSBjb3JyZWN0bHkgcG9zaXRpb25lZCBhbmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gd2F5IHRvIGRldGVjdCB0aGUgY29ycmVjdCBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgPSBzY3JvbGwueDtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IHNjcm9sbC55O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2Nyb2xsID0gJC5nZXRQYWdlU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgaWYgKCBjdXJyZW50U2Nyb2xsLnggIT09IG9yaWdpbmFsU2Nyb2xsLnggJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjcm9sbC55ICE9PSBvcmlnaW5hbFNjcm9sbC55ICkge1xuICAgICAgICAgICAgICAgICAgICAkLnNldFBhZ2VTY3JvbGwgPSBmdW5jdGlvbiggc2Nyb2xsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID0gc2Nyb2xsLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IHNjcm9sbC55O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGwueDtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsLnk7XG4gICAgICAgICAgICAgICAgY3VycmVudFNjcm9sbCA9ICQuZ2V0UGFnZVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIGlmICggY3VycmVudFNjcm9sbC54ICE9PSBvcmlnaW5hbFNjcm9sbC54ICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY3JvbGwueSAhPT0gb3JpZ2luYWxTY3JvbGwueSApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5zZXRQYWdlU2Nyb2xsID0gZnVuY3Rpb24oIHNjcm9sbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsLnk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBmaW5kIGFueXRoaW5nIHdvcmtpbmcsIHNvIHdlIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgJC5zZXRQYWdlU2Nyb2xsID0gZnVuY3Rpb24oIHNjcm9sbCApIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJC5zZXRQYWdlU2Nyb2xsKCBzY3JvbGwgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgc2l6ZSBvZiB0aGUgYnJvd3NlcnMgd2luZG93LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaW5kb3dTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IHt9LFxuICAgICAgICAgICAgICAgIGJvZHkgICAgPSBkb2N1bWVudC5ib2R5IHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiggd2luZG93LmlubmVyV2lkdGggKSA9PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICAkLmdldFdpbmRvd1NpemUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBkb2NFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY0VsZW1lbnQuY2xpZW50SGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgICQuZ2V0V2luZG93U2l6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggYm9keS5jbGllbnRXaWR0aCB8fCBib2R5LmNsaWVudEhlaWdodCApIHtcbiAgICAgICAgICAgICAgICAkLmdldFdpbmRvd1NpemUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHdpbmRvdyBzaXplLCBubyBrbm93biB0ZWNobmlxdWUuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJC5nZXRXaW5kb3dTaXplKCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHMgdGhlIGdpdmVuIGVsZW1lbnQgaW4gYSBuZXN0IG9mIGRpdnMgc28gdGhhdCB0aGUgZWxlbWVudCBjYW5cbiAgICAgICAgICogYmUgZWFzaWx5IGNlbnRlcmVkIHVzaW5nIENTUyB0YWJsZXNcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR9IG91dGVybW9zdCB3cmFwcGVyIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIG1ha2VDZW50ZXJlZE5vZGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBhIHBvc3NpYmxlIElEIHRvIGFuIGFjdHVhbCBIVE1MRWxlbWVudFxuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIENTUyB0YWJsZXMgcmVxdWlyZSB5b3UgdG8gaGF2ZSBhIGRpc3BsYXk6dGFibGUvcm93L2NlbGwgaGllcmFyY2h5IHNvIHdlIG5lZWQgdG8gY3JlYXRlXG4gICAgICAgICAgICAgICAgdGhyZWUgbmVzdGVkIHdyYXBwZXIgZGl2czpcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB2YXIgd3JhcHBlcnMgPSBbXG4gICAgICAgICAgICAgICAgJC5tYWtlTmV1dHJhbEVsZW1lbnQoICdkaXYnICksXG4gICAgICAgICAgICAgICAgJC5tYWtlTmV1dHJhbEVsZW1lbnQoICdkaXYnICksXG4gICAgICAgICAgICAgICAgJC5tYWtlTmV1dHJhbEVsZW1lbnQoICdkaXYnIClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIC8vIEl0IGZlZWxzIGxpa2Ugd2Ugc2hvdWxkIGJlIGFibGUgdG8gcGFzcyBzdHlsZSBkaWN0cyB0byBtYWtlTmV1dHJhbEVsZW1lbnQ6XG4gICAgICAgICAgICAkLmV4dGVuZCh3cmFwcGVyc1swXS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwidGFibGVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQuZXh0ZW5kKHdyYXBwZXJzWzFdLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJ0YWJsZS1yb3dcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQuZXh0ZW5kKHdyYXBwZXJzWzJdLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJ0YWJsZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3cmFwcGVyc1swXS5hcHBlbmRDaGlsZCh3cmFwcGVyc1sxXSk7XG4gICAgICAgICAgICB3cmFwcGVyc1sxXS5hcHBlbmRDaGlsZCh3cmFwcGVyc1syXSk7XG4gICAgICAgICAgICB3cmFwcGVyc1syXS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXJzWzBdO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gZWFzaWx5IHBvc2l0aW9uYWJsZSBlbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlIHRoYXQgdGhlcmVmb3JcbiAgICAgICAgICogc2VydmVzIGFzIGFuIGV4Y2VsbGVudCBjb250YWluZXIgZWxlbWVudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZU5ldXRyYWxFbGVtZW50OiBmdW5jdGlvbiggdGFnTmFtZSApIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggdGFnTmFtZSApLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgPSBlbGVtZW50LnN0eWxlO1xuXG4gICAgICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kID0gXCJ0cmFuc3BhcmVudCBub25lXCI7XG4gICAgICAgICAgICBzdHlsZS5ib3JkZXIgICAgID0gXCJub25lXCI7XG4gICAgICAgICAgICBzdHlsZS5tYXJnaW4gICAgID0gXCIwcHhcIjtcbiAgICAgICAgICAgIHN0eWxlLnBhZGRpbmcgICAgPSBcIjBweFwiO1xuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gICA9IFwic3RhdGljXCI7XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmRzLCB1c2luZyBEYXRlLm5vdygpIGlmIGF2YWlsYWJsZVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG5vdzogZnVuY3Rpb24oICkge1xuICAgICAgICAgIGlmIChEYXRlLm5vdykge1xuICAgICAgICAgICAgJC5ub3cgPSBEYXRlLm5vdztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5ub3cgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAkLm5vdygpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZXMgYW4gaW1hZ2UgaXMgbG9hZGVkIGNvcnJlY3RseSB0byBzdXBwb3J0IGFscGhhIHRyYW5zcGFyZW5jeS5cbiAgICAgICAgICogR2VuZXJhbGx5IG9ubHkgSUUgaGFzIGlzc3VlcyBkb2luZyB0aGlzIGNvcnJlY3RseSBmb3IgZm9ybWF0cyBsaWtlXG4gICAgICAgICAqIHBuZy5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBtYWtlVHJhbnNwYXJlbnRJbWFnZTogZnVuY3Rpb24oIHNyYyApIHtcblxuICAgICAgICAgICAgJC5tYWtlVHJhbnNwYXJlbnRJbWFnZSA9IGZ1bmN0aW9uKCBzcmMgKXtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiaW1nXCIgKTtcblxuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCAkLkJyb3dzZXIudmVuZG9yID09ICQuQlJPV1NFUlMuSUUgJiYgJC5Ccm93c2VyLnZlcnNpb24gPCA3ICkge1xuXG4gICAgICAgICAgICAgICAgJC5tYWtlVHJhbnNwYXJlbnRJbWFnZSA9IGZ1bmN0aW9uKCBzcmMgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyAgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJpbWdcIiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICQubWFrZU5ldXRyYWxFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblxuICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoICA9IGVsZW1lbnQuc3R5bGUud2lkdGggfHwgaW1nLndpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBlbGVtZW50LnN0eWxlLmhlaWdodCB8fCBpbWcuaGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZyA9IG51bGw7ICAgICAvLyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZmlsdGVyID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhSW1hZ2VMb2FkZXIoc3JjPSdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInLCBzaXppbmdNZXRob2Q9J3NjYWxlJylcIjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAkLm1ha2VUcmFuc3BhcmVudEltYWdlKCBzcmMgKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wYWNpdHlcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlc0FscGhhXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RWxlbWVudE9wYWNpdHk6IGZ1bmN0aW9uKCBlbGVtZW50LCBvcGFjaXR5LCB1c2VzQWxwaGEgKSB7XG5cbiAgICAgICAgICAgIHZhciBpZU9wYWNpdHksXG4gICAgICAgICAgICAgICAgaWVGaWx0ZXI7XG5cbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgaWYgKCB1c2VzQWxwaGEgJiYgISQuQnJvd3Nlci5hbHBoYSApIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5ID0gTWF0aC5yb3VuZCggb3BhY2l0eSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICQuQnJvd3Nlci5vcGFjaXR5ICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHkgPCAxID8gb3BhY2l0eSA6IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICggb3BhY2l0eSA8IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGllT3BhY2l0eSA9IE1hdGgucm91bmQoIDEwMCAqIG9wYWNpdHkgKTtcbiAgICAgICAgICAgICAgICAgICAgaWVGaWx0ZXIgID0gXCJhbHBoYShvcGFjaXR5PVwiICsgaWVPcGFjaXR5ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZmlsdGVyID0gaWVGaWx0ZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5maWx0ZXIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCdzIHRvdWNoLWFjdGlvbiBzdHlsZSBhdHRyaWJ1dGUgdG8gJ25vbmUnLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RWxlbWVudFRvdWNoQWN0aW9uTm9uZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGVsZW1lbnQuc3R5bGUubXNUb3VjaEFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0aGUgc3BlY2lmaWVkIENTUyBjbGFzcyB0byB0aGUgZWxlbWVudCBpZiBub3QgcHJlc2VudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBjbGFzc05hbWUgKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG5cbiAgICAgICAgICAgIGlmICggISBlbGVtZW50LmNsYXNzTmFtZSApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICggJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKS5cbiAgICAgICAgICAgICAgICBpbmRleE9mKCAnICcgKyBjbGFzc05hbWUgKyAnICcgKSA9PT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhbiBlbGVtZW50IGlzIGZvdW5kIGluIGFuIGFycmF5IG9yIC0xXG4gICAgICAgICAqIGlmIG5vdCBwcmVzZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb2RlIHRha2VuIGFuZCBhZGFwdGVkIGZyb21cbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZiNDb21wYXRpYmlsaXR5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgZnJvbSB3aGljaCB0byBmaW5kIHRoZSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWFyY2hFbGVtZW50IFRoZSBlbGVtZW50IHRvIGZpbmRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXg9MF0gSW5kZXggdG8gc3RhcnQgcmVzZWFyY2guXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleE9mOiBmdW5jdGlvbiggYXJyYXksIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCApIHtcbiAgICAgICAgICAgIGlmICggQXJyYXkucHJvdG90eXBlLmluZGV4T2YgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE9mID0gZnVuY3Rpb24oIGFycmF5LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4T2YgPSBmdW5jdGlvbiggYXJyYXksIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgICAgICBwaXZvdCA9ICggZnJvbUluZGV4ICkgPyBmcm9tSW5kZXggOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFhcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSAwIHx8IHBpdm90ID49IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcGl2b3QgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGl2b3QgPSBsZW5ndGggLSBNYXRoLmFicyggcGl2b3QgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSBwaXZvdDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJheVtpXSA9PT0gc2VhcmNoRWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoIGFycmF5LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBzcGVjaWZpZWQgQ1NTIGNsYXNzIGZyb20gdGhlIGVsZW1lbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwgY2xhc3NOYW1lICkge1xuICAgICAgICAgICAgdmFyIG9sZENsYXNzZXMsXG4gICAgICAgICAgICAgICAgbmV3Q2xhc3NlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgIG9sZENsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCggL1xccysvICk7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG9sZENsYXNzZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBvbGRDbGFzc2VzWyBpIF0gJiYgb2xkQ2xhc3Nlc1sgaSBdICE9PSBjbGFzc05hbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaCggb2xkQ2xhc3Nlc1sgaSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBuZXdDbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCwgZXZlbnROYW1lIGFuZCBoYW5kbGVyLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV1cbiAgICAgICAgICovXG4gICAgICAgIGFkZEV2ZW50OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggd2luZG93LmF0dGFjaEV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCAnb24nICsgZXZlbnROYW1lLCBoYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIk5vIGtub3duIGV2ZW50IG1vZGVsLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0oKSksXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGEgZ2l2ZW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBlbGVtZW50LCBldmVudCB0eXBlIGFuZFxuICAgICAgICAgKiBoYW5kbGVyLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV1cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUV2ZW50OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICggd2luZG93LmRldGFjaEV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gJC5nZXRFbGVtZW50KCBlbGVtZW50ICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoICdvbicgKyBldmVudE5hbWUsIGhhbmRsZXIgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiTm8ga25vd24gZXZlbnQgbW9kZWwuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpKSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWxzIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaGFkIHRoZSBldmVudCBwcm9wYWdhdGVkIGFsbFxuICAgICAgICAgKiB0aGUgd2F5IHVwIHRoZSBET00gdG8gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnRdXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWxFdmVudDogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuXG4gICAgICAgICAgICBpZiAoIGV2ZW50LnByZXZlbnREZWZhdWx0ICkge1xuICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gVzNDIGZvciBwcmV2ZW50aW5nIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICl7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVnYWN5IGZvciBwcmV2ZW50aW5nIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgZm9yIHByZXZlbnRpbmcgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQgdXAgdGhlIERPTS5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IFtldmVudF1cbiAgICAgICAgICovXG4gICAgICAgIHN0b3BFdmVudDogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuXG4gICAgICAgICAgICBpZiAoIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiApIHtcbiAgICAgICAgICAgICAgICAvLyBXM0MgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgJC5zdG9wRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKXtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgJC5zdG9wRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKXtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2ltaWxhciB0byBPcGVuU2VhZHJhZ29uLmRlbGVnYXRlLCBidXQgaXQgZG9lcyBub3QgaW1tZWRpYXRlbHkgY2FsbFxuICAgICAgICAgKiB0aGUgbWV0aG9kIG9uIHRoZSBvYmplY3QsIHJldHVybmluZyBhIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWRcbiAgICAgICAgICogcmVwZWF0ZWRseSB0byBkZWxlZ2F0ZSB0aGUgbWV0aG9kLiBJdCBhbHNvIGFsbG93cyBhZGRpdG9uYWwgYXJndW1lbnRzXG4gICAgICAgICAqIHRvIGJlIHBhc3NlZCBkdXJpbmcgY29uc3RydWN0aW9uIHdoaWNoIHdpbGwgYmUgYWRkZWQgZHVyaW5nIGVhY2hcbiAgICAgICAgICogaW52b2NhdGlvbiwgYW5kIGVhY2ggaW52b2NhdGlvbiBjYW4gYWRkIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFzIHdlbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0gW2FyZ3NdIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGFzIGFyZ3VtZW50cyB0byB0aGVcbiAgICAgICAgICogIGNyZWF0ZWQgY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uKCBvYmplY3QsIG1ldGhvZCApIHtcbiAgICAgICAgICAgIC8vVE9ETzogVGhpcyBwYXR0ZXJuIGlzIHBhaW5mdWwgdG8gdXNlIGFuZCBkZWJ1Zy4gIEl0J3MgbXVjaCBjbGVhbmVyXG4gICAgICAgICAgICAvLyAgICAgIHRvIHVzZSBwaW5uaW5nIHBsdXMgYW5vbnltb3VzIGZ1bmN0aW9ucy4gIEdldCByaWQgb2YgdGhpc1xuICAgICAgICAgICAgLy8gICAgICBwYXR0ZXJuIVxuICAgICAgICAgICAgdmFyIGluaXRpYWxBcmdzID0gW10sXG4gICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgIGZvciAoIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxBcmdzLnB1c2goIGFyZ3VtZW50c1sgaSBdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGluaXRpYWxBcmdzLmNvbmNhdCggW10gKSxcbiAgICAgICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKCBhcmd1bWVudHNbIGkgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoIG9iamVjdCwgYXJncyApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyZWl2ZXMgdGhlIHZhbHVlIG9mIGEgdXJsIHBhcmFtZXRlciBmcm9tIHRoZSB3aW5kb3cubG9jYXRpb24gc3RyaW5nLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIHVybCBwYXJhbWV0ZXIgb3IgbnVsbCBpZiBubyBwYXJhbSBtYXRjaGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VXJsUGFyYW1ldGVyOiBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gVVJMUEFSQU1TWyBrZXkgXTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBwcm90b2NvbCB1c2VkIGJ5IHRoZSB1cmwuIFRoZSB1cmwgY2FuIGVpdGhlciBiZSBhYnNvbHV0ZVxuICAgICAgICAgKiBvciByZWxhdGl2ZS5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVybCB0byByZXRyaWV2ZSB0aGUgcHJvdG9jb2wgZnJvbS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcHJvdG9jb2wgKGh0dHA6LCBodHRwczosIGZpbGU6LCBmdHA6IC4uLilcbiAgICAgICAgICovXG4gICAgICAgIGdldFVybFByb3RvY29sOiBmdW5jdGlvbiggdXJsICkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdXJsLm1hdGNoKC9eKFthLXpdKzopXFwvXFwvL2kpO1xuICAgICAgICAgICAgaWYgKCBtYXRjaCA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAvLyBSZWxhdGl2ZSBVUkwsIHJldHJpdmUgdGhlIHByb3RvY29sIGZyb20gd2luZG93LmxvY2F0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gWEhSIG9iamVjdFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IFtsb2NhbF0gSWYgc2V0IHRvIHRydWUsIHRoZSBYSFIgd2lsbCBiZSBmaWxlOiBwcm90b2NvbFxuICAgICAgICAgKiBjb21wYXRpYmxlIGlmIHBvc3NpYmxlIChidXQgbWF5IHJhaXNlIGEgd2FybmluZyBpbiB0aGUgYnJvd3NlcikuXG4gICAgICAgICAqIEByZXR1cm5zIHtYTUxIdHRwUmVxdWVzdH1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUFqYXhSZXF1ZXN0OiBmdW5jdGlvbiggbG9jYWwgKSB7XG4gICAgICAgICAgICAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgd2luZG93LkFjdGl2ZVhPYmplY3Qgc28gd2UganVzdCB0cnkgdG9cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBvbmUgdG8gc2VlIGlmIGl0IGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgIC8vIFNlZTogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2RuNDIzOTQ4JTI4dj12cy44NSUyOS5hc3B4XG4gICAgICAgICAgICB2YXIgc3VwcG9ydEFjdGl2ZVg7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0OnRydWUgKi9cbiAgICAgICAgICAgICAgICBzdXBwb3J0QWN0aXZlWCA9ICEhbmV3IEFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTEhUVFBcIiApO1xuICAgICAgICAgICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0QWN0aXZlWCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHN1cHBvcnRBY3RpdmVYICkge1xuICAgICAgICAgICAgICAgIGlmICggd2luZG93LlhNTEh0dHBSZXF1ZXN0ICkge1xuICAgICAgICAgICAgICAgICAgICAkLmNyZWF0ZUFqYXhSZXF1ZXN0ID0gZnVuY3Rpb24oIGxvY2FsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsb2NhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTEhUVFBcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQuY3JlYXRlQWpheFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MSFRUUFwiICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggd2luZG93LlhNTEh0dHBSZXF1ZXN0ICkge1xuICAgICAgICAgICAgICAgICQuY3JlYXRlQWpheFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJCcm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQuY3JlYXRlQWpheFJlcXVlc3QoIGxvY2FsICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGFuIEFKQVggcmVxdWVzdC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXJsIC0gdGhlIHVybCB0byByZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc3VjY2VzcyAtIGEgZnVuY3Rpb24gdG8gY2FsbCBvbiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lcnJvciAtIGEgZnVuY3Rpb24gdG8gY2FsbCBvbiB3aGVuIGFuIGVycm9yIG9jY3Vyc1xuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhDcmVkZW50aWFscz1mYWxzZV0gLSB3aGV0aGVyIHRvIHNldCB0aGUgWEhSJ3Mgd2l0aENyZWRlbnRpYWxzXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZUFqYXhSZXF1ZXN0OiBmdW5jdGlvbiggdXJsLCBvblN1Y2Nlc3MsIG9uRXJyb3IgKSB7XG4gICAgICAgICAgICB2YXIgd2l0aENyZWRlbnRpYWxzO1xuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb3VyIHByZWZlcnJlZCBBUEkgaXMgdGhhdCB5b3UgcGFzcyBpbiBhIHNpbmdsZSBvYmplY3Q7IHRoZSBuYW1lZFxuICAgICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBmb3IgbGVnYWN5IHN1cHBvcnQuXG4gICAgICAgICAgICBpZiggJC5pc1BsYWluT2JqZWN0KCB1cmwgKSApe1xuICAgICAgICAgICAgICAgIG9uU3VjY2VzcyA9IHVybC5zdWNjZXNzO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IgPSB1cmwuZXJyb3I7XG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzID0gdXJsLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwudXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSAkLmdldFVybFByb3RvY29sKCB1cmwgKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gJC5jcmVhdGVBamF4UmVxdWVzdCggcHJvdG9jb2wgPT09IFwiZmlsZTpcIiApO1xuXG4gICAgICAgICAgICBpZiAoICEkLmlzRnVuY3Rpb24oIG9uU3VjY2VzcyApICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJtYWtlQWpheFJlcXVlc3QgcmVxdWlyZXMgYSBzdWNjZXNzIGNhbGxiYWNrXCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyA0ID0gRE9ORSAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0I1Byb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgaWYgKCByZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe307XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2l0aCBwcm90b2NvbHMgb3RoZXIgdGhhbiBodHRwL2h0dHBzLCB0aGUgc3RhdHVzIGlzIDIwMFxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBGaXJlZm94IGFuZCAwIG9uIG90aGVyIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCByZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCAhPT0gXCJodHRwOlwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sICE9PSBcImh0dHBzOlwiICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyggcmVxdWVzdCApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5jb25zb2xlLmxvZyggXCJBSkFYIHJlcXVlc3QgcmV0dXJuZWQgJWQ6ICVzXCIsIHJlcXVlc3Quc3RhdHVzLCB1cmwgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIG9uRXJyb3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKCByZXF1ZXN0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAod2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlbiggXCJHRVRcIiwgdXJsLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCBudWxsICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGUubWVzc2FnZTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIElFIDwgMTAgZG9lcyBub3Qgc3VwcG9ydCBDT1JTIGFuZCBhbiBYSFIgcmVxdWVzdCB0byBhIGRpZmZlcmVudCBvcmlnaW4gd2lsbCBmYWlsIGFzIHNvb25cbiAgICAgICAgICAgICAgICAgICAgYXMgc2VuZCgpIGlzIGNhbGxlZC4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgZWFzeSB0byBtaXNzIGR1cmluZyBkZXZlbG9wbWVudCBhbmQgYXBwZWFyIGluXG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3Rpb24gaWYgeW91IHVzZSBhIENETiBvciBkb21haW4gc2hhcmRpbmcgYW5kIHRoZSBzZWN1cml0eSBwb2xpY3kgaXMgbGlrZWx5IHRvIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBoYW5kbGVycyBzaW5jZSBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgYSBwcm9wZXJ0eSBvZiB0aGUgcmVxdWVzdCBvYmplY3Qgd2lsbFxuICAgICAgICAgICAgICAgICAgICByYWlzZSBhbiBhY2Nlc3MgZGVuaWVkIFR5cGVFcnJvciBpbnNpZGUgdGhlIGNhdGNoIGJsb2NrLlxuXG4gICAgICAgICAgICAgICAgICAgIFRvIGJlIGZyaWVuZGxpZXIsIHdlJ2xsIGNoZWNrIGZvciB0aGlzIHNwZWNpZmljIGVycm9yIGFuZCBhZGQgYSBkb2N1bWVudGF0aW9uIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgdG8gcG9pbnQgZGV2ZWxvcGVycyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uLiBXZSB0ZXN0IHRoZSBleGNlcHRpb24gbnVtYmVyIGJlY2F1c2UgSUUnc1xuICAgICAgICAgICAgICAgICAgICBlcnJvciBtZXNzYWdlcyBhcmUgbG9jYWxpemVkLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIG9sZElFID0gJC5Ccm93c2VyLnZlbmRvciA9PSAkLkJST1dTRVJTLklFICYmICQuQnJvd3Nlci52ZXJzaW9uIDwgMTA7XG4gICAgICAgICAgICAgICAgaWYgKCBvbGRJRSAmJiB0eXBlb2YoIGUubnVtYmVyICkgIT0gXCJ1bmRlZmluZWRcIiAmJiBlLm51bWJlciA9PSAtMjE0NzAyNDg5MSApIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiXFxuU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwNSh2PXZzLjg1KS5hc3B4I3hkb21haW5cIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkLmNvbnNvbGUubG9nKCBcIiVzIHdoaWxlIG1ha2luZyBBSkFYIHJlcXVlc3Q6ICVzXCIsIGUubmFtZSwgbXNnICk7XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7fTtcblxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuWERvbWFpblJlcXVlc3QpIHsgLy8gSUU5IG9yIElFOCBtaWdodCBhcyB3ZWxsIHRyeSB0byB1c2UgWERvbWFpblJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ZHIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiggb25TdWNjZXNzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzcyh7IC8vIEZha2luZyBhbiB4aHIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQ6IHhkci5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCwgLy8gWERvbWFpblJlcXVlc3QgZG9lc24ndCBzdXBwb3J0IHN0YXR1cyBjb2Rlcywgc28gd2UganVzdCBmYWtlIG9uZSEgOi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhkci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiAoIG9uRXJyb3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih7IC8vIEZha2luZyBhbiB4aHIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQ6IHhkci5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQ0NCwgLy8gNDQ0IE5vIFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnQW4gZXJyb3IgaGFwcGVuZWQuIER1ZSB0byBhbiBYRG9tYWluUmVxdWVzdCBkZWZpY2llbmN5IHdlIGNhbiBub3QgZXh0cmFjdCBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBlcnJvci4gVXBncmFkZSB5b3VyIGJyb3dzZXIuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ZHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ZHIuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiggb25FcnJvciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKCByZXF1ZXN0LCBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIG9uRXJyb3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoIHJlcXVlc3QsIGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZW4gZnJvbSBqUXVlcnkgMS42LjFcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbT0nY2FsbGJhY2snXSBUaGUgbmFtZSBvZiB0aGUgdXJsIHBhcmFtZXRlclxuICAgICAgICAgKiAgICAgIHRvIHJlcXVlc3QgdGhlIGpzb25wIHByb3ZpZGVyIHdpdGguXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja05hbWU9XSBUaGUgbmFtZSBvZiB0aGUgY2FsbGJhY2sgdG9cbiAgICAgICAgICogICAgICByZXF1ZXN0IHRoZSBqc29ucCBwcm92aWRlciB3aXRoLlxuICAgICAgICAgKi9cbiAgICAgICAganNvbnA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICAgICAgICB2YXIgc2NyaXB0LFxuICAgICAgICAgICAgICAgIHVybCAgICAgPSBvcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICBoZWFkICAgID0gZG9jdW1lbnQuaGVhZCB8fFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJoZWFkXCIgKVsgMCBdIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBqc29ucENhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFja05hbWUgfHwgJ29wZW5zZWFkcmFnb24nICsgJC5ub3coKSxcbiAgICAgICAgICAgICAgICBwcmV2aW91cyAgICAgID0gd2luZG93WyBqc29ucENhbGxiYWNrIF0sXG4gICAgICAgICAgICAgICAgcmVwbGFjZSAgICAgICA9IFwiJDFcIiArIGpzb25wQ2FsbGJhY2sgKyBcIiQyXCIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tQYXJhbSA9IG9wdGlvbnMucGFyYW0gfHwgJ2NhbGxiYWNrJyxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAgICAgID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoIC8oXFw9KVxcPygmfCQpfFxcP1xcPy9pLCByZXBsYWNlICk7XG4gICAgICAgICAgICAvLyBBZGQgY2FsbGJhY2sgbWFudWFsbHlcbiAgICAgICAgICAgIHVybCArPSAoL1xcPy8udGVzdCggdXJsICkgPyBcIiZcIiA6IFwiP1wiKSArIGNhbGxiYWNrUGFyYW0gKyBcIj1cIiArIGpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tcbiAgICAgICAgICAgIHdpbmRvd1sganNvbnBDYWxsYmFjayBdID0gZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuICAgICAgICAgICAgICAgIGlmICggIXByZXZpb3VzICl7XG4gICAgICAgICAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXTtcbiAgICAgICAgICAgICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zd2FsbG93XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXSA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiggY2FsbGJhY2sgJiYgJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICl7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCByZXNwb25zZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuICAgICAgICAgICAgLy9UT0RPOiBoYXZpbmcgYW4gaXNzdWUgd2l0aCBhc3luYyBpbmZvIHJlcXVlc3RzXG4gICAgICAgICAgICBpZiggdW5kZWZpbmVkICE9PSBvcHRpb25zLmFzeW5jIHx8IGZhbHNlICE9PSBvcHRpb25zLmFzeW5jICl7XG4gICAgICAgICAgICAgICAgc2NyaXB0LmFzeW5jID0gXCJhc3luY1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMuc2NyaXB0Q2hhcnNldCApIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQuY2hhcnNldCA9IG9wdGlvbnMuc2NyaXB0Q2hhcnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcblxuICAgICAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJzIGZvciBhbGwgYnJvd3NlcnNcbiAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzQWJvcnQgfHwgIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoIHNjcmlwdC5yZWFkeVN0YXRlICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1lbW9yeSBsZWFrIGluIElFXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhlYWQgJiYgc2NyaXB0LnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlcmVmZXJlbmNlIHRoZSBzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBVc2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgYXBwZW5kQ2hpbGQgIHRvIGNpcmN1bXZlbnQgYW4gSUU2IGJ1Zy5cbiAgICAgICAgICAgIC8vIFRoaXMgYXJpc2VzIHdoZW4gYSBiYXNlIG5vZGUgaXMgdXNlZCAoIzI3MDkgYW5kICM0Mzc4KS5cbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVsbHkgZGVwcmVjYXRlZC4gV2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjb3Blbn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZyb21EWkk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgXCJPcGVuU2VhZHJhZ29uLmNyZWF0ZUZyb21EWkkgaXMgZGVwcmVjYXRlZCwgdXNlIFZpZXdlci5vcGVuLlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYW4gWE1MIHN0cmluZyBpbnRvIGEgRE9NIERvY3VtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJucyB7RG9jdW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZVhtbDogZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICAgICAgICAgIGlmICggd2luZG93LkRPTVBhcnNlciApIHtcblxuICAgICAgICAgICAgICAgICQucGFyc2VYbWwgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeG1sRG9jID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcjtcblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoIHN0cmluZywgXCJ0ZXh0L3htbFwiICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggd2luZG93LkFjdGl2ZVhPYmplY3QgKSB7XG5cbiAgICAgICAgICAgICAgICAkLnBhcnNlWG1sID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhtbERvYyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgeG1sRG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTERPTVwiICk7XG4gICAgICAgICAgICAgICAgICAgIHhtbERvYy5hc3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB4bWxEb2MubG9hZFhNTCggc3RyaW5nICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiQnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgWE1MIERPTS5cIiApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJC5wYXJzZVhtbCggc3RyaW5nICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIEpTT04gc3RyaW5nIGludG8gYSBKYXZhc2NyaXB0IG9iamVjdC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlSlNPTjogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UpIHtcbiAgICAgICAgICAgICAgICAkLnBhcnNlSlNPTiA9IHdpbmRvdy5KU09OLnBhcnNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGJ5IElFOCBpbiBub24gc3RhbmRhcmRzIG1vZGVcbiAgICAgICAgICAgICAgICAkLnBhcnNlSlNPTiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBldmlsOnRydWUqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZhbCgnKCcgKyBzdHJpbmcgKyAnKScpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5wYXJzZUpTT04oc3RyaW5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBpbWFnZSBmb3JtYXQgaXMgc3VwcG9ydGVkIGZvciB0aWxpbmcgaW4gdGhpc1xuICAgICAgICAgKiB2ZXJzaW9uLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtleHRlbnNpb25dXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaW1hZ2VGb3JtYXRTdXBwb3J0ZWQ6IGZ1bmN0aW9uKCBleHRlbnNpb24gKSB7XG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24gPyBleHRlbnNpb24gOiBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuICEhRklMRUZPUk1BVFNbIGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpIF07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBicm93c2VyIHZlbmRvciwgdmVyc2lvbiwgYW5kIHJlbGF0ZWQgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGRldGVjdGVkIGZlYXR1cmVzLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gQnJvd3NlclxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJST1dTRVJTfSB2ZW5kb3IgLSBPbmUgb2YgdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLkJST1dTRVJTfSBlbnVtZXJhdGlvbiB2YWx1ZXMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGFscGhhIC0gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGltYWdlIGFscGhhIHRyYW5zcGFyZW5jeS5cbiAgICAgKi9cbiAgICAkLkJyb3dzZXIgPSB7XG4gICAgICAgIHZlbmRvcjogICAgICQuQlJPV1NFUlMuVU5LTk9XTixcbiAgICAgICAgdmVyc2lvbjogICAgMCxcbiAgICAgICAgYWxwaGE6ICAgICAgdHJ1ZVxuICAgIH07XG5cblxuICAgIHZhciBGSUxFRk9STUFUUyA9IHtcbiAgICAgICAgICAgIFwiYm1wXCI6ICBmYWxzZSxcbiAgICAgICAgICAgIFwianBlZ1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJqcGdcIjogIHRydWUsXG4gICAgICAgICAgICBcInBuZ1wiOiAgdHJ1ZSxcbiAgICAgICAgICAgIFwidGlmXCI6ICBmYWxzZSxcbiAgICAgICAgICAgIFwid2RwXCI6ICBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBVUkxQQVJBTVMgPSB7fTtcblxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgLy9BIHNtYWxsIGF1dG8tZXhlY3V0aW5nIHJvdXRpbmUgdG8gZGV0ZXJtaW5lIHRoZSBicm93c2VyIHZlbmRvcixcbiAgICAgICAgLy92ZXJzaW9uIGFuZCBzdXBwb3J0aW5nIGZlYXR1cmUgc2V0cy5cbiAgICAgICAgdmFyIGFwcCA9IG5hdmlnYXRvci5hcHBOYW1lLFxuICAgICAgICAgICAgdmVyID0gbmF2aWdhdG9yLmFwcFZlcnNpb24sXG4gICAgICAgICAgICB1YSAgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgICAgcmVnZXg7XG5cbiAgICAgICAgLy9jb25zb2xlLmVycm9yKCAnYXBwTmFtZTogJyArIG5hdmlnYXRvci5hcHBOYW1lICk7XG4gICAgICAgIC8vY29uc29sZS5lcnJvciggJ2FwcFZlcnNpb246ICcgKyBuYXZpZ2F0b3IuYXBwVmVyc2lvbiApO1xuICAgICAgICAvL2NvbnNvbGUuZXJyb3IoICd1c2VyQWdlbnQ6ICcgKyBuYXZpZ2F0b3IudXNlckFnZW50ICk7XG5cbiAgICAgICAgc3dpdGNoKCBuYXZpZ2F0b3IuYXBwTmFtZSApe1xuICAgICAgICAgICAgY2FzZSBcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiOlxuICAgICAgICAgICAgICAgIGlmKCAhIXdpbmRvdy5hdHRhY2hFdmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZW5kb3IgPSAkLkJST1dTRVJTLklFO1xuICAgICAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB1YS5zdWJzdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWEuaW5kZXhPZiggXCJNU0lFXCIgKSArIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWEuaW5kZXhPZiggXCI7XCIsIHVhLmluZGV4T2YoIFwiTVNJRVwiICkgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJOZXRzY2FwZVwiOlxuICAgICAgICAgICAgICAgIGlmKCAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyICl7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdWEuaW5kZXhPZiggXCJGaXJlZm94XCIgKSA+PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5Ccm93c2VyLnZlbmRvciA9ICQuQlJPV1NFUlMuRklSRUZPWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZXJzaW9uID0gcGFyc2VGbG9hdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1YS5zdWJzdHJpbmcoIHVhLmluZGV4T2YoIFwiRmlyZWZveFwiICkgKyA4IClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHVhLmluZGV4T2YoIFwiU2FmYXJpXCIgKSA+PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5Ccm93c2VyLnZlbmRvciA9IHVhLmluZGV4T2YoIFwiQ2hyb21lXCIgKSA+PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLkJST1dTRVJTLkNIUk9NRSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5CUk9XU0VSUy5TQUZBUkk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWEuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1YS5zdWJzdHJpbmcoIDAsIHVhLmluZGV4T2YoIFwiU2FmYXJpXCIgKSApLmxhc3RJbmRleE9mKCBcIi9cIiApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWEuaW5kZXhPZiggXCJTYWZhcmlcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cCggXCJUcmlkZW50Ly4qcnY6KFswLTldezEsfVsuMC05XXswLH0pXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZWdleC5leGVjKCB1YSApICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZW5kb3IgPSAkLkJST1dTRVJTLklFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZXJzaW9uID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiT3BlcmFcIjpcbiAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVuZG9yID0gJC5CUk9XU0VSUy5PUEVSQTtcbiAgICAgICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQoIHZlciApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlnbm9yZSAnPycgcG9ydGlvbiBvZiBxdWVyeSBzdHJpbmdcbiAgICAgICAgdmFyIHF1ZXJ5ID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoIDEgKSxcbiAgICAgICAgICAgIHBhcnRzID0gcXVlcnkuc3BsaXQoJyYnKSxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBzZXAsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydHNbIGkgXTtcbiAgICAgICAgICAgIHNlcCAgPSBwYXJ0LmluZGV4T2YoICc9JyApO1xuXG4gICAgICAgICAgICBpZiAoIHNlcCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgVVJMUEFSQU1TWyBwYXJ0LnN1YnN0cmluZyggMCwgc2VwICkgXSA9XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudCggcGFydC5zdWJzdHJpbmcoIHNlcCArIDEgKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9kZXRlcm1pbmUgaWYgdGhpcyBicm93c2VyIHN1cHBvcnRzIGltYWdlIGFscGhhIHRyYW5zcGFyZW5jeVxuICAgICAgICAkLkJyb3dzZXIuYWxwaGEgPSAhKFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZW5kb3IgPT0gJC5CUk9XU0VSUy5JRSAmJlxuICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZXJzaW9uIDwgOVxuICAgICAgICAgICAgKSB8fCAoXG4gICAgICAgICAgICAgICAgJC5Ccm93c2VyLnZlbmRvciA9PSAkLkJST1dTRVJTLkNIUk9NRSAmJlxuICAgICAgICAgICAgICAgICQuQnJvd3Nlci52ZXJzaW9uIDwgMlxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vZGV0ZXJtaW5lIGlmIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBlbGVtZW50LnN0eWxlLm9wYWNpdHlcbiAgICAgICAgJC5Ccm93c2VyLm9wYWNpdHkgPSAhKFxuICAgICAgICAgICAgJC5Ccm93c2VyLnZlbmRvciA9PSAkLkJST1dTRVJTLklFICYmXG4gICAgICAgICAgICAkLkJyb3dzZXIudmVyc2lvbiA8IDlcbiAgICAgICAgKTtcblxuICAgIH0pKCk7XG5cblxuICAgIC8vVE9ETzogJC5jb25zb2xlIGlzIG9mdGVuIHVzZWQgaW5zaWRlIGEgdHJ5L2NhdGNoIGJsb2NrIHdoaWNoIGdlbmVyYWxseVxuICAgIC8vICAgICAgcHJldmVudHMgYWxsb3dpbmdzIGVycm9ycyB0byBvY2N1ciB3aXRoIGRldGVjdGlvbiB1bnRpbCBhIGRlYnVnZ2VyXG4gICAgLy8gICAgICBpcyBhdHRhY2hlZC4gIEFsdGhvdWdoIEkndmUgYmVlbiBndWlsdHkgb2YgdGhlIHNhbWUgYW50aS1wYXR0ZXJuXG4gICAgLy8gICAgICBJIGV2ZW50dWFsbHkgd2FzIGNvbnZpbmNlZCB0aGF0IGVycm9ycyBzaG91bGQgbmF0dXJhbGx5IHByb3BvZ2F0ZSBpblxuICAgIC8vICAgICAgYWxsIGJ1dCB0aGUgbW9zdCBzcGVjaWFsIGNhc2VzLlxuICAgIC8qKlxuICAgICAqIEEgY29udmVuaWVudCBhbGlhcyBmb3IgY29uc29sZSB3aGVuIGF2YWlsYWJsZSwgYW5kIGEgc2ltcGxlIG51bGxcbiAgICAgKiBmdW5jdGlvbiB3aGVuIGNvbnNvbGUgaXMgdW5hdmFpbGFibGUuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIG51bGxmdW5jdGlvbiA9IGZ1bmN0aW9uKCBtc2cgKXtcbiAgICAgICAgICAgIC8vZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IG1zZztcbiAgICAgICAgfTtcblxuICAgICQuY29uc29sZSA9IHdpbmRvdy5jb25zb2xlIHx8IHtcbiAgICAgICAgbG9nOiAgICBudWxsZnVuY3Rpb24sXG4gICAgICAgIGRlYnVnOiAgbnVsbGZ1bmN0aW9uLFxuICAgICAgICBpbmZvOiAgIG51bGxmdW5jdGlvbixcbiAgICAgICAgd2FybjogICBudWxsZnVuY3Rpb24sXG4gICAgICAgIGVycm9yOiAgbnVsbGZ1bmN0aW9uLFxuICAgICAgICBhc3NlcnQ6IG51bGxmdW5jdGlvblxuICAgIH07XG5cblxuICAgIC8vIEFkZGluZyBzdXBwb3J0IGZvciBIVE1MNSdzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhcyBzdWdnZXN0ZWQgYnkgYWNkaGEuXG4gICAgLy8gSW1wbGVtZW50YXRpb24gdGFrZW4gZnJvbSBtYXR0IHN5bmRlcidzIHBvc3QgaGVyZTpcbiAgICAvLyBodHRwOi8vbWF0dHNuaWRlci5jb20vY3Jvc3MtYnJvd3Nlci1hbmQtbGVnYWN5LXN1cHBvcnRlZC1yZXF1ZXN0ZnJhbWVhbmltYXRpb24vXG4gICAgKGZ1bmN0aW9uKCB3ICkge1xuXG4gICAgICAgIC8vIG1vc3QgYnJvd3NlcnMgaGF2ZSBhbiBpbXBsZW1lbnRhdGlvblxuICAgICAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHcubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuICAgICAgICB2YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbiAgICAgICAgLy8gcG9seWZpbGwsIHdoZW4gbmVjZXNzYXJ5XG4gICAgICAgIGlmICggcmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lICkge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgYXNzaWduIHRoZXNlIHdpbmRvdyBtZXRob2RzIGRpcmVjdGx5IHRvICQgYmVjYXVzZSB0aGV5XG4gICAgICAgICAgICAvLyBleHBlY3QgdGhlaXIgXCJ0aGlzXCIgdG8gYmUgXCJ3aW5kb3dcIiwgc28gd2UgY2FsbCB0aGVtIGluIHdyYXBwZXJzLlxuICAgICAgICAgICAgJC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYXBwbHkoIHcsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICQuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZS5hcHBseSggdywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFBbmltUXVldWUgPSBbXSxcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nID0gW10sXG4gICAgICAgICAgICAgICAgaVJlcXVlc3RJZCA9IDAsXG4gICAgICAgICAgICAgICAgaUludGVydmFsSWQ7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG1vY2sgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9uXG4gICAgICAgICAgICAkLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICBhQW5pbVF1ZXVlLnB1c2goIFsgKytpUmVxdWVzdElkLCBjYWxsYmFjayBdICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFpSW50ZXJ2YWxJZCApIHtcbiAgICAgICAgICAgICAgICAgICAgaUludGVydmFsSWQgPSBzZXRJbnRlcnZhbCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFBbmltUXVldWUubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gJC5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFsbCBvZiB0aGUgY3VycmVudGx5IG91dHN0YW5kaW5nIGZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMsIGJ1dCBub25lIHRoYXQgZ2V0IGFkZGVkIGR1cmluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3YXAgdGhlIGFycmF5cyBzbyB3ZSBkb24ndCBoYXZlIHRvIGNyZWF0ZSBhIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IGV2ZXJ5IGZyYW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gcHJvY2Vzc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nID0gYUFuaW1RdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQW5pbVF1ZXVlID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIHByb2Nlc3NpbmcubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLnNoaWZ0KClbIDEgXSggdGltZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgY29udGludWUgdGhlIGludGVydmFsLCBpZiB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoIGlJbnRlcnZhbElkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaUludGVydmFsSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDAgLyA1MCk7ICAvLyBlc3RpbWF0aW5nIHN1cHBvcnQgZm9yIDUwIGZyYW1lcyBwZXIgc2Vjb25kXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlSZXF1ZXN0SWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBtb2NrIGNhbmNlbEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9uXG4gICAgICAgICAgICAkLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIHJlcXVlc3RJZCApIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSByZXF1ZXN0IElEIGFuZCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgaiA9IGFBbmltUXVldWUubGVuZ3RoOyBpIDwgajsgaSArPSAxICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGFBbmltUXVldWVbIGkgXVsgMCBdID09PSByZXF1ZXN0SWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQW5pbVF1ZXVlLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBub3QgaW4gdGhlIHF1ZXVlLCBpdCBtYXkgYmUgaW4gdGhlIHNldCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzaW5nIChpZiBjYW5jZWxBbmltYXRpb25GcmFtZSBpcyBjYWxsZWQgZnJvbSB3aXRoaW4gYVxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjYWxsYmFjaykuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGogPSBwcm9jZXNzaW5nLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9jZXNzaW5nWyBpIF1bIDAgXSA9PT0gcmVxdWVzdElkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZy5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSggd2luZG93ICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzRml4ZWRdXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KCBlbGVtZW50LCBpc0ZpeGVkICkge1xuICAgICAgICBpZiAoIGlzRml4ZWQgJiYgZWxlbWVudCAhPSBkb2N1bWVudC5ib2R5ICkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbn0oT3BlblNlYWRyYWdvbikpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIGZ1bGwtc2NyZWVuIHN1cHBvcnQgZnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgbmF0aXZlIGZ1bGwgc2NyZWVuIHN1cHBvcnQgd2UgY2FuIGdldCBmcm9tIHRoZSBicm93c2VyLlxuICAgICAqIEBtZW1iZXIgZnVsbFNjcmVlbkFwaVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHN1cHBvcnRzRnVsbFNjcmVlbiBSZXR1cm4gdHJ1ZSBpZiBmdWxsIHNjcmVlbiBBUEkgaXMgc3VwcG9ydGVkLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGlzRnVsbFNjcmVlbiBSZXR1cm4gdHJ1ZSBpZiBjdXJyZW50bHkgaW4gZnVsbCBzY3JlZW4gbW9kZS5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRGdWxsU2NyZWVuRWxlbWVudCBSZXR1cm4gdGhlIGVsZW1lbnQgY3VycmVudGx5IGluIGZ1bGwgc2NyZWVuIG1vZGUuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVxdWVzdEZ1bGxTY3JlZW4gTWFrZSBhIHJlcXVlc3QgdG8gZ28gaW4gZnVsbCBzY3JlZW4gbW9kZS5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBleGl0RnVsbFNjcmVlbiBNYWtlIGEgcmVxdWVzdCB0byBleGl0IGZ1bGwgc2NyZWVuIG1vZGUuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FuY2VsRnVsbFNjcmVlbiBEZXByZWNhdGVkLCB1c2UgZXhpdEZ1bGxTY3JlZW4gaW5zdGVhZC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbFNjcmVlbkV2ZW50TmFtZSBFdmVudCBmaXJlZCB3aGVuIHRoZSBmdWxsIHNjcmVlbiBtb2RlIGNoYW5nZS5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbFNjcmVlbkVycm9yRXZlbnROYW1lIEV2ZW50IGZpcmVkIHdoZW4gYSByZXF1ZXN0IHRvIGdvXG4gICAgICogaW4gZnVsbCBzY3JlZW4gbW9kZSBmYWlsZWQuXG4gICAgICovXG4gICAgdmFyIGZ1bGxTY3JlZW5BcGkgPSB7XG4gICAgICAgIHN1cHBvcnRzRnVsbFNjcmVlbjogZmFsc2UsXG4gICAgICAgIGlzRnVsbFNjcmVlbjogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgZ2V0RnVsbFNjcmVlbkVsZW1lbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVxdWVzdEZ1bGxTY3JlZW46IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIGV4aXRGdWxsU2NyZWVuOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBjYW5jZWxGdWxsU2NyZWVuOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmdWxsU2NyZWVuRXZlbnROYW1lOiAnJyxcbiAgICAgICAgZnVsbFNjcmVlbkVycm9yRXZlbnROYW1lOiAnJ1xuICAgIH07XG5cbiAgICAvLyBjaGVjayBmb3IgbmF0aXZlIHN1cHBvcnRcbiAgICBpZiAoIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuICkge1xuICAgICAgICAvLyBXM0Mgc3RhbmRhcmRcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSB0cnVlO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmdldEZ1bGxTY3JlZW5FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkucmVxdWVzdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwiZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FcnJvckV2ZW50TmFtZSA9IFwiZnVsbHNjcmVlbmVycm9yXCI7XG4gICAgfSBlbHNlIGlmICggZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbiApIHtcbiAgICAgICAgLy8gSUUgMTFcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSB0cnVlO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmdldEZ1bGxTY3JlZW5FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5yZXF1ZXN0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmV4aXRGdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCI7XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZnVsbFNjcmVlbkVycm9yRXZlbnROYW1lID0gXCJNU0Z1bGxzY3JlZW5FcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuICkge1xuICAgICAgICAvLyBSZWNlbnQgd2Via2l0XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuc3VwcG9ydHNGdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5nZXRGdWxsU2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLnJlcXVlc3RGdWxsU2NyZWVuID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmV4aXRGdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FdmVudE5hbWUgPSBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIjtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5mdWxsU2NyZWVuRXJyb3JFdmVudE5hbWUgPSBcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoIGRvY3VtZW50LndlYmtpdENhbmNlbEZ1bGxTY3JlZW4gKSB7XG4gICAgICAgIC8vIE9sZCB3ZWJraXRcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSB0cnVlO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmdldEZ1bGxTY3JlZW5FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQud2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLnJlcXVlc3RGdWxsU2NyZWVuID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmV4aXRGdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FcnJvckV2ZW50TmFtZSA9IFwid2Via2l0ZnVsbHNjcmVlbmVycm9yXCI7XG4gICAgfSBlbHNlIGlmICggZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbiApIHtcbiAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICBmdWxsU2NyZWVuQXBpLnN1cHBvcnRzRnVsbFNjcmVlbiA9IHRydWU7XG4gICAgICAgIGZ1bGxTY3JlZW5BcGkuZ2V0RnVsbFNjcmVlbkVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5yZXF1ZXN0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICB9O1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmZ1bGxTY3JlZW5FdmVudE5hbWUgPSBcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIjtcbiAgICAgICAgZnVsbFNjcmVlbkFwaS5mdWxsU2NyZWVuRXJyb3JFdmVudE5hbWUgPSBcIm1vemZ1bGxzY3JlZW5lcnJvclwiO1xuICAgIH1cbiAgICBmdWxsU2NyZWVuQXBpLmlzRnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVsbFNjcmVlbkFwaS5nZXRGdWxsU2NyZWVuRWxlbWVudCgpICE9PSBudWxsO1xuICAgIH07XG4gICAgZnVsbFNjcmVlbkFwaS5jYW5jZWxGdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcImNhbmNlbEZ1bGxTY3JlZW4gaXMgZGVwcmVjYXRlZC4gVXNlIGV4aXRGdWxsU2NyZWVuIGluc3RlYWQuXCIpO1xuICAgICAgICBmdWxsU2NyZWVuQXBpLmV4aXRGdWxsU2NyZWVuKCk7XG4gICAgfTtcblxuICAgIC8vIGV4cG9ydCBhcGlcbiAgICAkLmV4dGVuZCggJCwgZnVsbFNjcmVlbkFwaSApO1xuXG59KSggT3BlblNlYWRyYWdvbiApO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIEV2ZW50U291cmNlXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbigkKXtcblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyIG1ldGhvZCBzaWduYXR1cmUgdXNlZCBieSBhbGwgT3BlblNlYWRyYWdvbiBldmVudHMuXG4gKlxuICogQGNhbGxiYWNrIEV2ZW50SGFuZGxlclxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFNlZSBpbmRpdmlkdWFsIGV2ZW50cyBmb3IgZXZlbnQtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzIEV2ZW50U291cmNlXG4gKiBAY2xhc3NkZXNjIEZvciB1c2UgYnkgY2xhc3NlcyB3aGljaCB3YW50IHRvIHN1cHBvcnQgY3VzdG9tLCBub24tYnJvd3NlciBldmVudHMuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqL1xuJC5FdmVudFNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXZlbnRzID0ge307XG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uRXZlbnRTb3VyY2UucHJvdG90eXBlICovXG4kLkV2ZW50U291cmNlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGJlIHRyaWdnZXJlZCBvbmx5IG9uY2UgKG9yIGEgZ2l2ZW4gbnVtYmVyIG9mIHRpbWVzKVxuICAgICAqIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIGV2ZW50IHRvIHJlZ2lzdGVyLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IGhhbmRsZXIgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlbnRcbiAgICAgKiBpcyB0cmlnZ2VyZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt1c2VyRGF0YT1udWxsXSAtIEFyYml0cmFyeSBvYmplY3QgdG8gYmUgcGFzc2VkIHVuY2hhbmdlZFxuICAgICAqIHRvIHRoZSBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZXM9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGhhbmRsZSB0aGUgZXZlbnRcbiAgICAgKiBiZWZvcmUgcmVtb3ZpbmcgaXQuXG4gICAgICovXG4gICAgYWRkT25jZUhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlckRhdGEsIHRpbWVzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGltZXMgPSB0aW1lcyB8fCAxO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgb25jZUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gdGltZXMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUhhbmRsZXIoZXZlbnROYW1lLCBvbmNlSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRIYW5kbGVyKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIsIHVzZXJEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgZXZlbnQgdG8gcmVnaXN0ZXIuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gaGFuZGxlciAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt1c2VyRGF0YT1udWxsXSAtIEFyYml0cmFyeSBvYmplY3QgdG8gYmUgcGFzc2VkIHVuY2hhbmdlZCB0byB0aGUgaGFuZGxlci5cbiAgICAgKi9cbiAgICBhZGRIYW5kbGVyOiBmdW5jdGlvbiAoIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlckRhdGEgKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50c1sgZXZlbnROYW1lIF07XG4gICAgICAgIGlmICggIWV2ZW50cyApIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICggaGFuZGxlciAmJiAkLmlzRnVuY3Rpb24oIGhhbmRsZXIgKSApIHtcbiAgICAgICAgICAgIGV2ZW50c1sgZXZlbnRzLmxlbmd0aCBdID0geyBoYW5kbGVyOiBoYW5kbGVyLCB1c2VyRGF0YTogdXNlckRhdGEgfHwgbnVsbCB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNwZWNpZmljIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgZXZlbnQgZm9yIHdoaWNoIHRoZSBoYW5kbGVyIGlzIHRvIGJlIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gaGFuZGxlciAtIEZ1bmN0aW9uIHRvIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlSGFuZGxlcjogZnVuY3Rpb24gKCBldmVudE5hbWUsIGhhbmRsZXIgKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50c1sgZXZlbnROYW1lIF0sXG4gICAgICAgICAgICBoYW5kbGVycyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKCAhZXZlbnRzICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICggJC5pc0FycmF5KCBldmVudHMgKSApIHtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggZXZlbnRzW2ldLmhhbmRsZXIgIT09IGhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goIGV2ZW50c1sgaSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudHNbIGV2ZW50TmFtZSBdID0gaGFuZGxlcnM7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciBhIGdpdmVuIGV2ZW50IHR5cGUuIElmIG5vIHR5cGUgaXMgZ2l2ZW4gYWxsXG4gICAgICogZXZlbnQgaGFuZGxlcnMgZm9yIGV2ZXJ5IGV2ZW50IHR5cGUgYXJlIHJlbW92ZWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgZXZlbnQgZm9yIHdoaWNoIGFsbCBoYW5kbGVycyBhcmUgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmVBbGxIYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcbiAgICAgICAgaWYgKCBldmVudE5hbWUgKXtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzWyBldmVudE5hbWUgXSA9IFtdO1xuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICBmb3IgKCB2YXIgZXZlbnRUeXBlIGluIHRoaXMuZXZlbnRzICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzWyBldmVudFR5cGUgXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGZ1bmN0aW9uIHdoaWNoIGl0ZXJhdGVzIHRoZSBsaXN0IG9mIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LCBjYWxsaW5nIHRoZSBoYW5kbGVyIGZvciBlYWNoLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIGV2ZW50IHRvIGdldCBoYW5kbGVycyBmb3IuXG4gICAgICovXG4gICAgZ2V0SGFuZGxlcjogZnVuY3Rpb24gKCBldmVudE5hbWUgKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50c1sgZXZlbnROYW1lIF07XG4gICAgICAgIGlmICggIWV2ZW50cyB8fCAhZXZlbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50cyA9IGV2ZW50cy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgWyBldmVudHNbIDAgXSBdIDpcbiAgICAgICAgICAgIEFycmF5LmFwcGx5KCBudWxsLCBldmVudHMgKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggc291cmNlLCBhcmdzICkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBldmVudHNbIGkgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5ldmVudFNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy51c2VyRGF0YSA9IGV2ZW50c1sgaSBdLnVzZXJEYXRhO1xuICAgICAgICAgICAgICAgICAgICBldmVudHNbIGkgXS5oYW5kbGVyKCBhcmdzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LCBvcHRpb25hbGx5IHBhc3NpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiBldmVudCB0byByZWdpc3Rlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRBcmdzIC0gRXZlbnQtc3BlY2lmaWMgZGF0YS5cbiAgICAgKi9cbiAgICByYWlzZUV2ZW50OiBmdW5jdGlvbiggZXZlbnROYW1lLCBldmVudEFyZ3MgKSB7XG4gICAgICAgIC8vdW5jb21tZW50IGlmIHlvdSB3YW50IHRvIGdldCBhIGxvZyBvZiBhbGwgZXZlbnRzXG4gICAgICAgIC8vJC5jb25zb2xlLmxvZyggZXZlbnROYW1lICk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5nZXRIYW5kbGVyKCBldmVudE5hbWUgKTtcblxuICAgICAgICBpZiAoIGhhbmRsZXIgKSB7XG4gICAgICAgICAgICBpZiAoICFldmVudEFyZ3MgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRBcmdzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZXIoIHRoaXMsIGV2ZW50QXJncyApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBNb3VzZVRyYWNrZXJcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uICggJCApIHtcblxuICAgIC8vIEFsbCBNb3VzZVRyYWNrZXIgaW5zdGFuY2VzXG4gICAgdmFyIE1PVVNFVFJBQ0tFUlMgID0gW107XG5cbiAgICAvLyBkaWN0aW9uYXJ5IGZyb20gaGFzaCB0byBwcml2YXRlIHByb3BlcnRpZXNcbiAgICB2YXIgVEhJUyAgICAgICAgICAgPSB7fTtcblxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIE1vdXNlVHJhY2tlclxuICAgICAqIEBjbGFzc2Rlc2MgUHJvdmlkZXMgc2ltcGxpZmllZCBoYW5kbGluZyBvZiBjb21tb24gcG9pbnRlciBkZXZpY2UgKG1vdXNlLCB0b3VjaCwgcGVuLCBldGMuKSBnZXN0dXJlc1xuICAgICAqICAgICAgICAgICAgYW5kIGtleWJvYXJkIGV2ZW50cyBvbiBhIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiAgICAgIEFsbG93cyBjb25maWd1cmFibGUgcHJvcGVydGllcyB0byBiZSBlbnRpcmVseSBzcGVjaWZpZWQgYnkgcGFzc2luZ1xuICAgICAqICAgICAgYW4gb3B0aW9ucyBvYmplY3QgdG8gdGhlIGNvbnN0cnVjdG9yLiAgVGhlIGNvbnN0cnVjdG9yIGFsc28gc3VwcG9ydHNcbiAgICAgKiAgICAgIHRoZSBvcmlnaW5hbCBwb3NpdGlvbmFsIGFyZ3VtZW50cyAnZWxlbWVudCcsICdjbGlja1RpbWVUaHJlc2hvbGQnLFxuICAgICAqICAgICAgYW5kICdjbGlja0Rpc3RUaHJlc2hvbGQnIGluIHRoYXQgb3JkZXIuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gb3B0aW9ucy5lbGVtZW50XG4gICAgICogICAgICBBIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50IG9yIGFuIGVsZW1lbnQgaWQgZm9yIHdoaWNoIHRoZSBwb2ludGVyL2tleVxuICAgICAqICAgICAgZXZlbnRzIHdpbGwgYmUgbW9uaXRvcmVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RhcnREaXNhYmxlZD1mYWxzZV1cbiAgICAgKiAgICAgIElmIHRydWUsIGV2ZW50IHRyYWNraW5nIG9uIHRoZSBlbGVtZW50IHdpbGwgbm90IHN0YXJ0IHVudGlsXG4gICAgICogICAgICB7QGxpbmsgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuc2V0VHJhY2tpbmd8c2V0VHJhY2tpbmd9IGlzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jbGlja1RpbWVUaHJlc2hvbGRcbiAgICAgKiAgICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHdpdGhpbiB3aGljaCBhIHBvaW50ZXIgZG93bi11cCBldmVudCBjb21iaW5hdGlvblxuICAgICAqICAgICAgd2lsbCBiZSB0cmVhdGVkIGFzIGEgY2xpY2sgZ2VzdHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jbGlja0Rpc3RUaHJlc2hvbGRcbiAgICAgKiAgICAgIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGFsbG93ZWQgYmV0d2VlbiBhIHBvaW50ZXIgZG93biBldmVudCBhbmQgYSBwb2ludGVyIHVwIGV2ZW50XG4gICAgICogICAgICB0byBiZSB0cmVhdGVkIGFzIGEgY2xpY2sgZ2VzdHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kYmxDbGlja1RpbWVUaHJlc2hvbGRcbiAgICAgKiAgICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHdpdGhpbiB3aGljaCB0d28gcG9pbnRlciBkb3duLXVwIGV2ZW50IGNvbWJpbmF0aW9uc1xuICAgICAqICAgICAgd2lsbCBiZSB0cmVhdGVkIGFzIGEgZG91YmxlLWNsaWNrIGdlc3R1cmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGJsQ2xpY2tEaXN0VGhyZXNob2xkXG4gICAgICogICAgICBUaGUgbWF4aW11bSBkaXN0YW5jZSBhbGxvd2VkIGJldHdlZW4gdHdvIHBvaW50ZXIgY2xpY2sgZXZlbnRzXG4gICAgICogICAgICB0byBiZSB0cmVhdGVkIGFzIGEgY2xpY2sgZ2VzdHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RvcERlbGF5PTUwXVxuICAgICAqICAgICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgd2l0aG91dCBwb2ludGVyIG1vdmUgYmVmb3JlIHRoZSBzdG9wXG4gICAgICogICAgICBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5lbnRlckhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgZW50ZXIuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMuZXhpdEhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgZXhpdC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5wcmVzc0hhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgcHJlc3MuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMubm9uUHJpbWFyeVByZXNzSGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3IgcG9pbnRlciBub24tcHJpbWFyeSBidXR0b24gcHJlc3MuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMucmVsZWFzZUhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgcmVsZWFzZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5ub25QcmltYXJ5UmVsZWFzZUhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgbm9uLXByaW1hcnkgYnV0dG9uIHJlbGVhc2UuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMubW92ZUhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHBvaW50ZXIgbW92ZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5zY3JvbGxIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBzY3JvbGwuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMuY2xpY2tIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBwb2ludGVyIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmRibENsaWNrSGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3IgcG9pbnRlciBkb3VibGUtY2xpY2suXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMuZHJhZ0hhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBkcmFnIGdlc3R1cmUuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMuZHJhZ0VuZEhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIGFmdGVyIGEgZHJhZyBnZXN0dXJlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLnBpbmNoSGFuZGxlcj1udWxsXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIHBpbmNoIGdlc3R1cmUuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMua2V5RG93bkhhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIGtleWRvd24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMua2V5VXBIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBrZXl1cC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5rZXlIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBrZXlwcmVzcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5mb2N1c0hhbmRsZXI9bnVsbF1cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGhhbmRsZXIgZm9yIGZvY3VzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLmJsdXJIYW5kbGVyPW51bGxdXG4gICAgICogICAgICBBbiBvcHRpb25hbCBoYW5kbGVyIGZvciBibHVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy51c2VyRGF0YT1udWxsXVxuICAgICAqICAgICAgQXJiaXRyYXJ5IG9iamVjdCB0byBiZSBwYXNzZWQgdW5jaGFuZ2VkIHRvIGFueSBhdHRhY2hlZCBoYW5kbGVyIG1ldGhvZHMuXG4gICAgICovXG4gICAgJC5Nb3VzZVRyYWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cbiAgICAgICAgTU9VU0VUUkFDS0VSUy5wdXNoKCB0aGlzICk7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgaWYgKCAhJC5pc1BsYWluT2JqZWN0KCBvcHRpb25zICkgKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgICAgICAgICAgYXJnc1sgMCBdLFxuICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogYXJnc1sgMSBdLFxuICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogYXJnc1sgMiBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNoICAgICAgICAgICAgICAgPSBNYXRoLnJhbmRvbSgpOyAvLyBBbiB1bmlxdWUgaGFzaCBmb3IgdGhpcyB0cmFja2VyLlxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVsZW1lbnQgZm9yIHdoaWNoIHBvaW50ZXIgZXZlbnRzIGFyZSBiZWluZyBtb25pdG9yZWQuXG4gICAgICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50ICAgICAgICAgICAgPSAkLmdldEVsZW1lbnQoIG9wdGlvbnMuZWxlbWVudCApO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgd2l0aGluIHdoaWNoIGEgcG9pbnRlciBkb3duLXVwIGV2ZW50IGNvbWJpbmF0aW9uXG4gICAgICAgICAqIHdpbGwgYmUgdHJlYXRlZCBhcyBhIGNsaWNrIGdlc3R1cmUuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY2xpY2tUaW1lVGhyZXNob2xkXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkID0gb3B0aW9ucy5jbGlja1RpbWVUaHJlc2hvbGQgfHwgJC5ERUZBVUxUX1NFVFRJTkdTLmNsaWNrVGltZVRocmVzaG9sZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGFsbG93ZWQgYmV0d2VlbiBhIHBvaW50ZXIgZG93biBldmVudCBhbmQgYSBwb2ludGVyIHVwIGV2ZW50XG4gICAgICAgICAqIHRvIGJlIHRyZWF0ZWQgYXMgYSBjbGljayBnZXN0dXJlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNsaWNrRGlzdFRocmVzaG9sZFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCA9IG9wdGlvbnMuY2xpY2tEaXN0VGhyZXNob2xkIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5jbGlja0Rpc3RUaHJlc2hvbGQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB3aXRoaW4gd2hpY2ggdHdvIHBvaW50ZXIgZG93bi11cCBldmVudCBjb21iaW5hdGlvbnNcbiAgICAgICAgICogd2lsbCBiZSB0cmVhdGVkIGFzIGEgZG91YmxlLWNsaWNrIGdlc3R1cmUuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGJsQ2xpY2tUaW1lVGhyZXNob2xkXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGJsQ2xpY2tUaW1lVGhyZXNob2xkID0gb3B0aW9ucy5kYmxDbGlja1RpbWVUaHJlc2hvbGQgfHwgJC5ERUZBVUxUX1NFVFRJTkdTLmRibENsaWNrVGltZVRocmVzaG9sZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGFsbG93ZWQgYmV0d2VlbiB0d28gcG9pbnRlciBjbGljayBldmVudHNcbiAgICAgICAgICogdG8gYmUgdHJlYXRlZCBhcyBhIGNsaWNrIGdlc3R1cmUuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY2xpY2tEaXN0VGhyZXNob2xkXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGJsQ2xpY2tEaXN0VGhyZXNob2xkID0gb3B0aW9ucy5kYmxDbGlja0Rpc3RUaHJlc2hvbGQgfHwgJC5ERUZBVUxUX1NFVFRJTkdTLmRibENsaWNrRGlzdFRocmVzaG9sZDtcbiAgICAgICAgdGhpcy51c2VyRGF0YSAgICAgICAgICAgICAgPSBvcHRpb25zLnVzZXJEYXRhICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcERlbGF5ICAgICAgICAgICAgID0gb3B0aW9ucy5zdG9wRGVsYXkgICAgICAgICB8fCA1MDtcblxuICAgICAgICB0aGlzLmVudGVySGFuZGxlciAgICAgICAgICAgICA9IG9wdGlvbnMuZW50ZXJIYW5kbGVyICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZXhpdEhhbmRsZXIgICAgICAgICAgICAgID0gb3B0aW9ucy5leGl0SGFuZGxlciAgICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5wcmVzc0hhbmRsZXIgICAgICAgICAgICAgPSBvcHRpb25zLnByZXNzSGFuZGxlciAgICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLm5vblByaW1hcnlQcmVzc0hhbmRsZXIgICA9IG9wdGlvbnMubm9uUHJpbWFyeVByZXNzSGFuZGxlciAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMucmVsZWFzZUhhbmRsZXIgICAgICAgICAgID0gb3B0aW9ucy5yZWxlYXNlSGFuZGxlciAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5ub25QcmltYXJ5UmVsZWFzZUhhbmRsZXIgPSBvcHRpb25zLm5vblByaW1hcnlSZWxlYXNlSGFuZGxlciB8fCBudWxsO1xuICAgICAgICB0aGlzLm1vdmVIYW5kbGVyICAgICAgICAgICAgICA9IG9wdGlvbnMubW92ZUhhbmRsZXIgICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlciAgICAgICAgICAgID0gb3B0aW9ucy5zY3JvbGxIYW5kbGVyICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jbGlja0hhbmRsZXIgICAgICAgICAgICAgPSBvcHRpb25zLmNsaWNrSGFuZGxlciAgICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLmRibENsaWNrSGFuZGxlciAgICAgICAgICA9IG9wdGlvbnMuZGJsQ2xpY2tIYW5kbGVyICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ0hhbmRsZXIgICAgICAgICAgICAgID0gb3B0aW9ucy5kcmFnSGFuZGxlciAgICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnRW5kSGFuZGxlciAgICAgICAgICAgPSBvcHRpb25zLmRyYWdFbmRIYW5kbGVyICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLnBpbmNoSGFuZGxlciAgICAgICAgICAgICA9IG9wdGlvbnMucGluY2hIYW5kbGVyICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcEhhbmRsZXIgICAgICAgICAgICAgID0gb3B0aW9ucy5zdG9wSGFuZGxlciAgICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5rZXlEb3duSGFuZGxlciAgICAgICAgICAgPSBvcHRpb25zLmtleURvd25IYW5kbGVyICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLmtleVVwSGFuZGxlciAgICAgICAgICAgICA9IG9wdGlvbnMua2V5VXBIYW5kbGVyICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgICAgIHRoaXMua2V5SGFuZGxlciAgICAgICAgICAgICAgID0gb3B0aW9ucy5rZXlIYW5kbGVyICAgICAgICAgICAgICAgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c0hhbmRsZXIgICAgICAgICAgICAgPSBvcHRpb25zLmZvY3VzSGFuZGxlciAgICAgICAgICAgICB8fCBudWxsO1xuICAgICAgICB0aGlzLmJsdXJIYW5kbGVyICAgICAgICAgICAgICA9IG9wdGlvbnMuYmx1ckhhbmRsZXIgICAgICAgICAgICAgIHx8IG51bGw7XG5cbiAgICAgICAgLy9TdG9yZSBwcml2YXRlIHByb3BlcnRpZXMgaW4gYSBzY29wZSBzZWFsZWQgaGFzaCBtYXBcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSB0cmFja2luZ1xuICAgICAgICAgKiAgICAgIEFyZSB3ZSBjdXJyZW50bHkgdHJhY2tpbmcgcG9pbnRlciBldmVudHMgZm9yIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdID0ge1xuICAgICAgICAgICAgY2xpY2s6ICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbkNsaWNrKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIGRibGNsaWNrOiAgICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25EYmxDbGljayggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBrZXlkb3duOiAgICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uS2V5RG93biggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBrZXl1cDogICAgICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uS2V5VXAoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAga2V5cHJlc3M6ICAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbktleVByZXNzKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIGZvY3VzOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Gb2N1cyggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBibHVyOiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uQmx1ciggX3RoaXMsIGV2ZW50ICk7IH0sXG5cbiAgICAgICAgICAgIHdoZWVsOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25XaGVlbCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBtb3VzZXdoZWVsOiAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VXaGVlbCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBET01Nb3VzZVNjcm9sbDogICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VXaGVlbCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBNb3pNb3VzZVBpeGVsU2Nyb2xsOiAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VXaGVlbCggX3RoaXMsIGV2ZW50ICk7IH0sXG5cbiAgICAgICAgICAgIG1vdXNlZW50ZXI6ICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Nb3VzZUVudGVyKCBfdGhpcywgZXZlbnQgKTsgfSwgLy8gVXNlZCBvbiBJRTggb25seVxuICAgICAgICAgICAgbW91c2VsZWF2ZTogICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlTGVhdmUoIF90aGlzLCBldmVudCApOyB9LCAvLyBVc2VkIG9uIElFOCBvbmx5XG4gICAgICAgICAgICBtb3VzZW92ZXI6ICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VPdmVyKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIG1vdXNlb3V0OiAgICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Nb3VzZU91dCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBtb3VzZWRvd246ICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VEb3duKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIG1vdXNldXA6ICAgICAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Nb3VzZVVwKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIG1vdXNldXBjYXB0dXJlZDogICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Nb3VzZVVwQ2FwdHVyZWQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgbW91c2Vtb3ZlOiAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbk1vdXNlTW92ZSggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBtb3VzZW1vdmVjYXB0dXJlZDogICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uTW91c2VNb3ZlQ2FwdHVyZWQoIF90aGlzLCBldmVudCApOyB9LFxuXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uVG91Y2hTdGFydCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICB0b3VjaGVuZDogICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uVG91Y2hFbmQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgdG91Y2hlbmRjYXB0dXJlZDogICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblRvdWNoRW5kQ2FwdHVyZWQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgdG91Y2htb3ZlOiAgICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblRvdWNoTW92ZSggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICB0b3VjaG1vdmVjYXB0dXJlZDogICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uVG91Y2hNb3ZlQ2FwdHVyZWQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgdG91Y2hjYW5jZWw6ICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblRvdWNoQ2FuY2VsKCBfdGhpcywgZXZlbnQgKTsgfSxcblxuICAgICAgICAgICAgZ2VzdHVyZXN0YXJ0OiAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvbkdlc3R1cmVTdGFydCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBnZXN0dXJlY2hhbmdlOiAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uR2VzdHVyZUNoYW5nZSggX3RoaXMsIGV2ZW50ICk7IH0sXG5cbiAgICAgICAgICAgIHBvaW50ZXJvdmVyOiAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyT3ZlciggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBNU1BvaW50ZXJPdmVyOiAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlck92ZXIoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgcG9pbnRlcm91dDogICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJPdXQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgTVNQb2ludGVyT3V0OiAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJPdXQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgcG9pbnRlcmRvd246ICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJEb3duKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIE1TUG9pbnRlckRvd246ICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyRG93biggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBwb2ludGVydXA6ICAgICAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlclVwKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIE1TUG9pbnRlclVwOiAgICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyVXAoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgcG9pbnRlcm1vdmU6ICAgICAgICAgICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJNb3ZlKCBfdGhpcywgZXZlbnQgKTsgfSxcbiAgICAgICAgICAgIE1TUG9pbnRlck1vdmU6ICAgICAgICAgZnVuY3Rpb24gKCBldmVudCApIHsgb25Qb2ludGVyTW92ZSggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBwb2ludGVyY2FuY2VsOiAgICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlckNhbmNlbCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBNU1BvaW50ZXJDYW5jZWw6ICAgICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlckNhbmNlbCggX3RoaXMsIGV2ZW50ICk7IH0sXG4gICAgICAgICAgICBwb2ludGVydXBjYXB0dXJlZDogICAgIGZ1bmN0aW9uICggZXZlbnQgKSB7IG9uUG9pbnRlclVwQ2FwdHVyZWQoIF90aGlzLCBldmVudCApOyB9LFxuICAgICAgICAgICAgcG9pbnRlcm1vdmVjYXB0dXJlZDogICBmdW5jdGlvbiAoIGV2ZW50ICkgeyBvblBvaW50ZXJNb3ZlQ2FwdHVyZWQoIF90aGlzLCBldmVudCApOyB9LFxuXG4gICAgICAgICAgICB0cmFja2luZzogICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBBY3RpdmUgcG9pbnRlcnMgbGlzdHMuIEFycmF5IG9mIEdlc3R1cmVQb2ludExpc3Qgb2JqZWN0cywgb25lIGZvciBlYWNoIHBvaW50ZXIgZGV2aWNlIHR5cGUuXG4gICAgICAgICAgICAvLyBHZXN0dXJlUG9pbnRMaXN0IG9iamVjdHMgYXJlIGFkZGVkIGVhY2ggdGltZSBhIHBvaW50ZXIgaXMgdHJhY2tlZCBieSBhIG5ldyBwb2ludGVyIGRldmljZSB0eXBlIChzZWUgZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCkpLlxuICAgICAgICAgICAgLy8gQWN0aXZlIHBvaW50ZXJzIGFyZSBhbnkgcG9pbnRlciBiZWluZyB0cmFja2VkIGZvciB0aGlzIGVsZW1lbnQgd2hpY2ggYXJlIGluIHRoZSBoaXQtdGVzdCBhcmVhXG4gICAgICAgICAgICAvLyAgICAgb2YgdGhlIGVsZW1lbnQgKGZvciBob3Zlci1jYXBhYmxlIGRldmljZXMpIGFuZC9vciBoYXZlIGNvbnRhY3Qgb3IgYSBidXR0b24gcHJlc3MgaW5pdGlhdGVkIGluIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgYWN0aXZlUG9pbnRlcnNMaXN0czogICBbXSxcblxuICAgICAgICAgICAgLy8gVHJhY2tpbmcgZm9yIGRvdWJsZS1jbGljayBnZXN0dXJlXG4gICAgICAgICAgICBsYXN0Q2xpY2tQb3M6ICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBkYmxDbGlja1RpbWVPdXQ6ICAgICAgIG51bGwsXG5cbiAgICAgICAgICAgIC8vIFRyYWNraW5nIGZvciBwaW5jaCBnZXN0dXJlXG4gICAgICAgICAgICBwaW5jaEdQb2ludHM6ICAgICAgICAgIFtdLFxuICAgICAgICAgICAgbGFzdFBpbmNoRGlzdDogICAgICAgICAwLFxuICAgICAgICAgICAgY3VycmVudFBpbmNoRGlzdDogICAgICAwLFxuICAgICAgICAgICAgbGFzdFBpbmNoQ2VudGVyOiAgICAgICBudWxsLFxuICAgICAgICAgICAgY3VycmVudFBpbmNoQ2VudGVyOiAgICBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCAhb3B0aW9ucy5zdGFydERpc2FibGVkICkge1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFja2luZyggdHJ1ZSApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIucHJvdG90eXBlICovXG4gICAgJC5Nb3VzZVRyYWNrZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhbiB1cCBhbnkgZXZlbnRzIG9yIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgdHJhY2tlci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgc3RvcFRyYWNraW5nKCB0aGlzICk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IE1PVVNFVFJBQ0tFUlMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBNT1VTRVRSQUNLRVJTWyBpIF0gPT09IHRoaXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIE1PVVNFVFJBQ0tFUlMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0gPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIFRISVNbIHRoaXMuaGFzaCBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcmUgd2UgY3VycmVudGx5IHRyYWNraW5nIGV2ZW50cyBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEp1c3QgdXNlIHRoaXMudHJhY2tpbmdcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBBcmUgd2UgY3VycmVudGx5IHRyYWNraW5nIGV2ZW50cyBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBpc1RyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVEhJU1sgdGhpcy5oYXNoIF0udHJhY2tpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHdoZXRoZXIgb3Igbm90IHdlIGFyZSB0cmFja2luZyBldmVudHMgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSB0cmFjayBUcnVlIHRvIHN0YXJ0IHRyYWNraW5nLCBmYWxzZSB0byBzdG9wIHRyYWNraW5nLlxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IENoYWluYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldFRyYWNraW5nOiBmdW5jdGlvbiAoIHRyYWNrICkge1xuICAgICAgICAgICAgaWYgKCB0cmFjayApIHtcbiAgICAgICAgICAgICAgICBzdGFydFRyYWNraW5nKCB0aGlzICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3BUcmFja2luZyggdGhpcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jaGFpblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0fEdlc3R1cmVQb2ludExpc3R9IGZvciB0aGUgZ2l2ZW4gcG9pbnRlciBkZXZpY2UgdHlwZSxcbiAgICAgICAgICogY3JlYXRpbmcgYW5kIGNhY2hpbmcgYSBuZXcge0BsaW5rIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3R8R2VzdHVyZVBvaW50TGlzdH0gaWYgb25lIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIHR5cGUuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBwb2ludGVyIGRldmljZSB0eXBlOiBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZTogZnVuY3Rpb24gKCB0eXBlICkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdGhpcy5oYXNoIF0sXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBsZW4gPSBkZWxlZ2F0ZS5hY3RpdmVQb2ludGVyc0xpc3RzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBsaXN0O1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggZGVsZWdhdGUuYWN0aXZlUG9pbnRlcnNMaXN0c1sgaSBdLnR5cGUgPT09IHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hY3RpdmVQb2ludGVyc0xpc3RzWyBpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0ID0gbmV3ICQuTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QoIHR5cGUgKTtcbiAgICAgICAgICAgIGRlbGVnYXRlLmFjdGl2ZVBvaW50ZXJzTGlzdHMucHVzaCggbGlzdCApO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBwb2ludGVycyBjdXJyZW50bHkgYWN0aXZlIG9uIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWN0aXZlUG9pbnRlckNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0aGlzLmhhc2ggXSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGxlbiA9IGRlbGVnYXRlLmFjdGl2ZVBvaW50ZXJzTGlzdHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSBkZWxlZ2F0ZS5hY3RpdmVQb2ludGVyc0xpc3RzWyBpIF0uZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LnBvc2l0aW9uXG4gICAgICAgICAqICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYnV0dG9uc1xuICAgICAgICAgKiAgICAgIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLlxuICAgICAgICAgKiAgICAgIENvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5wb2ludGVyc1xuICAgICAgICAgKiAgICAgIE51bWJlciBvZiBwb2ludGVycyAoYWxsIHR5cGVzKSBhY3RpdmUgaW4gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB3YXNcbiAgICAgICAgICogICAgICBpbml0aWF0ZWQgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5idXR0b25Eb3duQW55XG4gICAgICAgICAqICAgICAgV2FzIHRoZSBidXR0b24gZG93biBhbnl3aGVyZSBpbiB0aGUgc2NyZWVuIGR1cmluZyB0aGUgZXZlbnQuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBidXR0b25zIGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBlbnRlckhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnBvaW50ZXJUeXBlXG4gICAgICAgICAqICAgICBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LnBvc2l0aW9uXG4gICAgICAgICAqICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYnV0dG9uc1xuICAgICAgICAgKiAgICAgIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLlxuICAgICAgICAgKiAgICAgIENvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5wb2ludGVyc1xuICAgICAgICAgKiAgICAgIE51bWJlciBvZiBwb2ludGVycyAoYWxsIHR5cGVzKSBhY3RpdmUgaW4gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB3YXNcbiAgICAgICAgICogICAgICBpbml0aWF0ZWQgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5idXR0b25Eb3duQW55XG4gICAgICAgICAqICAgICAgV2FzIHRoZSBidXR0b24gZG93biBhbnl3aGVyZSBpbiB0aGUgc2NyZWVuIGR1cmluZyB0aGUgZXZlbnQuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBidXR0b25zIGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBleGl0SGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25zXG4gICAgICAgICAqICAgICAgQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJlc3NIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmJ1dHRvblxuICAgICAgICAgKiAgICAgIEJ1dHRvbiB3aGljaCBjYXVzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiAgICAgIC0xOiBub25lLCAwOiBwcmltYXJ5L2xlZnQsIDE6IGF1eC9taWRkbGUsIDI6IHNlY29uZGFyeS9yaWdodCwgMzogWDEvYmFjaywgNDogWDIvZm9yd2FyZCwgNTogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmJ1dHRvbnNcbiAgICAgICAgICogICAgICBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC5cbiAgICAgICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBub25QcmltYXJ5UHJlc3NIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmJ1dHRvbnNcbiAgICAgICAgICogICAgICBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC5cbiAgICAgICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkXG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYW5kIHdhc1xuICAgICAgICAgKiAgICAgIGluaXRpYXRlZCBpbnNpZGUgdGhlIHRyYWNrZWQgZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50Lmluc2lkZUVsZW1lbnRSZWxlYXNlZFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGN1cnNvciBpbnNpZGUgdGhlIHRyYWNrZWQgZWxlbWVudCB3aGVuIHRoZSBidXR0b24gd2FzIHJlbGVhc2VkLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByZWxlYXNlSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25cbiAgICAgICAgICogICAgICBCdXR0b24gd2hpY2ggY2F1c2VkIHRoZSBldmVudC5cbiAgICAgICAgICogICAgICAtMTogbm9uZSwgMDogcHJpbWFyeS9sZWZ0LCAxOiBhdXgvbWlkZGxlLCAyOiBzZWNvbmRhcnkvcmlnaHQsIDM6IFgxL2JhY2ssIDQ6IFgyL2ZvcndhcmQsIDU6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25zXG4gICAgICAgICAqICAgICAgQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbm9uUHJpbWFyeVJlbGVhc2VIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmJ1dHRvbnNcbiAgICAgICAgICogICAgICBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC5cbiAgICAgICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5zY3JvbGxcbiAgICAgICAgICogICAgICBUaGUgc2Nyb2xsIGRlbHRhIGZvciB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuc2hpZnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNUb3VjaEV2ZW50XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgb3JpZ2luYWwgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgb3RoZXJ3aXNlIGZhbHNlLiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgcG9pbnRlclR5cGUgYW5kL29yIG9yaWdpbmFsRXZlbnQgaW5zdGVhZC4gVG91Y2ggZGV2aWNlcyBubyBsb25nZXIgZ2VuZXJhdGUgc2Nyb2xsIGV2ZW50Ljwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucXVpY2tcbiAgICAgICAgICogICAgICBUcnVlIG9ubHkgaWYgdGhlIGNsaWNrRGlzdFRocmVzaG9sZCBhbmQgY2xpY2tUaW1lVGhyZXNob2xkIGFyZSBib3RoIHBhc3NlZC4gVXNlZnVsIGZvciBpZ25vcmluZyBkcmFnIGV2ZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5zaGlmdFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgY2xpY2tIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5zaGlmdFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZGJsQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmJ1dHRvbnNcbiAgICAgICAgICogICAgICBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC5cbiAgICAgICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LmRlbHRhXG4gICAgICAgICAqICAgICAgVGhlIHgseSBjb21wb25lbnRzIG9mIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIHRoZSBsYXN0IGRyYWcgZXZlbnQgcG9zaXRpb24uICBVc2VmdWwgZm9yIGlnbm9yaW5nIG9yIHdlaWdodGluZyB0aGUgZXZlbnRzLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuc3BlZWRcbiAgICAgICAgICogICAgIEN1cnJlbnQgY29tcHV0ZWQgc3BlZWQsIGluIHBpeGVscyBwZXIgc2Vjb25kLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuZGlyZWN0aW9uXG4gICAgICAgICAqICAgICBDdXJyZW50IGNvbXB1dGVkIGRpcmVjdGlvbiwgZXhwcmVzc2VkIGFzIGFuIGFuZ2xlIGNvdW50ZXJjbG9ja3dpc2UgcmVsYXRpdmUgdG8gdGhlIHBvc2l0aXZlIFggYXhpcyAoLXBpIHRvIHBpLCBpbiByYWRpYW5zKS4gT25seSB2YWxpZCBpZiBzcGVlZCA+IDAuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuc2hpZnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNUb3VjaEV2ZW50XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgb3JpZ2luYWwgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgb3RoZXJ3aXNlIGZhbHNlLiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgcG9pbnRlclR5cGUgYW5kL29yIG9yaWdpbmFsRXZlbnQgaW5zdGVhZC48L3NwYW4+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGRyYWdIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5wb2ludGVyVHlwZVxuICAgICAgICAgKiAgICAgXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBldmVudC5wb3NpdGlvblxuICAgICAgICAgKiAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LnNwZWVkXG4gICAgICAgICAqICAgICBTcGVlZCBhdCB0aGUgZW5kIG9mIGEgZHJhZyBnZXN0dXJlLCBpbiBwaXhlbHMgcGVyIHNlY29uZC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmRpcmVjdGlvblxuICAgICAgICAgKiAgICAgRGlyZWN0aW9uIGF0IHRoZSBlbmQgb2YgYSBkcmFnIGdlc3R1cmUsIGV4cHJlc3NlZCBhcyBhbiBhbmdsZSBjb3VudGVyY2xvY2t3aXNlIHJlbGF0aXZlIHRvIHRoZSBwb3NpdGl2ZSBYIGF4aXMgKC1waSB0byBwaSwgaW4gcmFkaWFucykuIE9ubHkgdmFsaWQgaWYgc3BlZWQgPiAwLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnNoaWZ0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzVG91Y2hFdmVudFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIGEgdG91Y2ggZXZlbnQsIG90aGVyd2lzZSBmYWxzZS4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIHBvaW50ZXJUeXBlIGFuZC9vciBvcmlnaW5hbEV2ZW50IGluc3RlYWQuPC9zcGFuPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRW5kSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludD59IGV2ZW50Lmdlc3R1cmVQb2ludHNcbiAgICAgICAgICogICAgICBHZXN0dXJlIHBvaW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdlc3R1cmUuIFZlbG9jaXR5IGRhdGEgY2FuIGJlIGZvdW5kIGhlcmUuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQubGFzdENlbnRlclxuICAgICAgICAgKiAgICAgIFRoZSBwcmV2aW91cyBjZW50ZXIgcG9pbnQgb2YgdGhlIHR3byBwaW5jaCBjb250YWN0IHBvaW50cyByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGV2ZW50LmNlbnRlclxuICAgICAgICAgKiAgICAgIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIHR3byBwaW5jaCBjb250YWN0IHBvaW50cyByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQubGFzdERpc3RhbmNlXG4gICAgICAgICAqICAgICAgVGhlIHByZXZpb3VzIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwaW5jaCBjb250YWN0IHBvaW50cyBpbiBDU1MgcGl4ZWxzLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuZGlzdGFuY2VcbiAgICAgICAgICogICAgICBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBpbmNoIGNvbnRhY3QgcG9pbnRzIGluIENTUyBwaXhlbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuc2hpZnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHBpbmNoSGFuZGxlcjogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnQgb3IgYXNzaWduIGltcGxlbWVudGF0aW9uIHRvIHRoZXNlIGhhbmRsZXJzIGR1cmluZyBvciBhZnRlclxuICAgICAgICAgKiBjYWxsaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSBldmVudC5ldmVudFNvdXJjZVxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQucG9pbnRlclR5cGVcbiAgICAgICAgICogICAgIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZXZlbnQucG9zaXRpb25cbiAgICAgICAgICogICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5idXR0b25zXG4gICAgICAgICAqICAgICAgQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICAgICAqICAgICAgQ29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1RvdWNoRXZlbnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBvcmlnaW5hbCBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBvdGhlcndpc2UgZmFsc2UuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBwb2ludGVyVHlwZSBhbmQvb3Igb3JpZ2luYWxFdmVudCBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmtleUNvZGVcbiAgICAgICAgICogICAgICBUaGUga2V5IGNvZGUgdGhhdCB3YXMgcHJlc3NlZC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5jdHJsXG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgY3RybCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuc2hpZnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuYWx0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgYWx0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5tZXRhXG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgbWV0YSBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGtleURvd25IYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5rZXlDb2RlXG4gICAgICAgICAqICAgICAgVGhlIGtleSBjb2RlIHRoYXQgd2FzIHByZXNzZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuY3RybFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGN0cmwga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnNoaWZ0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgc2hpZnQga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmFsdFxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIGFsdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQubWV0YVxuICAgICAgICAgKiAgICAgIFRydWUgaWYgdGhlIG1ldGEga2V5IHdhcyBwcmVzc2VkIGR1cmluZyB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgICAgKiAgICAgIFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb25cbiAgICAgICAgICogICAgICBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSB0cmFja2VyIHN1YnNjcmliZXIgZnJvbSBwZXJmb3JtaW5nIGl0cyBkZWZhdWx0IGFjdGlvbiAoc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQpLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnVzZXJEYXRhXG4gICAgICAgICAqICAgICAgQXJiaXRyYXJ5IHVzZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBrZXlVcEhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmtleUNvZGVcbiAgICAgICAgICogICAgICBUaGUga2V5IGNvZGUgdGhhdCB3YXMgcHJlc3NlZC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5jdHJsXG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgY3RybCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuc2hpZnRcbiAgICAgICAgICogICAgICBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuYWx0XG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgYWx0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5tZXRhXG4gICAgICAgICAqICAgICAgVHJ1ZSBpZiB0aGUgbWV0YSBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGtleUhhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50IG9yIGFzc2lnbiBpbXBsZW1lbnRhdGlvbiB0byB0aGVzZSBoYW5kbGVycyBkdXJpbmcgb3IgYWZ0ZXJcbiAgICAgICAgICogY2FsbGluZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gZXZlbnQuZXZlbnRTb3VyY2VcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgICogICAgICBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uXG4gICAgICAgICAqICAgICAgU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgdHJhY2tlciBzdWJzY3JpYmVyIGZyb20gcGVyZm9ybWluZyBpdHMgZGVmYXVsdCBhY3Rpb24gKHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50KS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC51c2VyRGF0YVxuICAgICAgICAgKiAgICAgIEFyYml0cmFyeSB1c2VyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXNIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCBvciBhc3NpZ24gaW1wbGVtZW50YXRpb24gdG8gdGhlc2UgaGFuZGxlcnMgZHVyaW5nIG9yIGFmdGVyXG4gICAgICAgICAqIGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IGV2ZW50LmV2ZW50U291cmNlXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICAgICAqICAgICAgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvblxuICAgICAgICAgKiAgICAgIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlIHRyYWNrZXIgc3Vic2NyaWJlciBmcm9tIHBlcmZvcm1pbmcgaXRzIGRlZmF1bHQgYWN0aW9uIChzdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudCkuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudXNlckRhdGFcbiAgICAgICAgICogICAgICBBcmJpdHJhcnkgdXNlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGJsdXJIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBjb250aW51b3VzIGNvbXB1dGF0aW9uIG9mIHZlbG9jaXR5IChzcGVlZCBhbmQgZGlyZWN0aW9uKSBvZiBhY3RpdmUgcG9pbnRlcnMuXG4gICAgICogVGhpcyBpcyBhIHNpbmdsZXRvbiwgdXNlZCBieSBhbGwgTW91c2VUcmFja2VyIGluc3RhbmNlcywgYXMgaXQgaXMgdW5saWtlbHkgdGhlcmUgd2lsbCBldmVyIGJlIG1vcmUgdGhhblxuICAgICAqIHR3byBhY3RpdmUgZ2VzdHVyZSBwb2ludGVycyBhdCBhIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIgZ2VzdHVyZVBvaW50VmVsb2NpdHlUcmFja2VyXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyXG4gICAgICovXG4gICAgJC5Nb3VzZVRyYWNrZXIuZ2VzdHVyZVBvaW50VmVsb2NpdHlUcmFja2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYWNrZXJQb2ludHMgPSBbXSxcbiAgICAgICAgICAgIGludGVydmFsSWQgPSAwLFxuICAgICAgICAgICAgbGFzdFRpbWUgPSAwO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBhIHRyYWNrZWQgZ2VzdHVyZSBwb2ludFxuICAgICAgICB2YXIgX2dlbmVyYXRlR3VpZCA9IGZ1bmN0aW9uICggdHJhY2tlciwgZ1BvaW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrZXIuaGFzaC50b1N0cmluZygpICsgZ1BvaW50LnR5cGUgKyBnUG9pbnQuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcnZhbCB0aW1lciBjYWxsYmFjay4gQ29tcHV0ZXMgdmVsb2NpdHkgZm9yIGFsbCB0cmFja2VkIGdlc3R1cmUgcG9pbnRzLlxuICAgICAgICB2YXIgX2RvVHJhY2tpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0cmFja2VyUG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0cmFja1BvaW50LFxuICAgICAgICAgICAgICAgIGdQb2ludCxcbiAgICAgICAgICAgICAgICBub3cgPSAkLm5vdygpLFxuICAgICAgICAgICAgICAgIGVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIHNwZWVkO1xuXG4gICAgICAgICAgICBlbGFwc2VkVGltZSA9IG5vdyAtIGxhc3RUaW1lO1xuICAgICAgICAgICAgbGFzdFRpbWUgPSBub3c7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tQb2ludCA9IHRyYWNrZXJQb2ludHNbIGkgXTtcbiAgICAgICAgICAgICAgICBnUG9pbnQgPSB0cmFja1BvaW50LmdQb2ludDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmF0YW4yIGdpdmVzIHVzIGp1c3Qgd2hhdCB3ZSBuZWVkIGZvciBhIHZlbG9jaXR5IHZlY3RvciwgYXMgd2UgY2FuIHNpbXBseVxuICAgICAgICAgICAgICAgIC8vICAgdXNlIGNvcygpL3NpbigpIHRvIGV4dHJhY3QgdGhlIHgveSB2ZWxvY2l0eSBjb21wb25lbnRzLlxuICAgICAgICAgICAgICAgIGdQb2ludC5kaXJlY3Rpb24gPSBNYXRoLmF0YW4yKCBnUG9pbnQuY3VycmVudFBvcy55IC0gdHJhY2tQb2ludC5sYXN0UG9zLnksIGdQb2ludC5jdXJyZW50UG9zLnggLSB0cmFja1BvaW50Lmxhc3RQb3MueCApO1xuICAgICAgICAgICAgICAgIC8vIHNwZWVkID0gZGlzdGFuY2UgLyBlbGFwc2VkIHRpbWVcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHRyYWNrUG9pbnQubGFzdFBvcy5kaXN0YW5jZVRvKCBnUG9pbnQuY3VycmVudFBvcyApO1xuICAgICAgICAgICAgICAgIHRyYWNrUG9pbnQubGFzdFBvcyA9IGdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIHNwZWVkID0gMTAwMCAqIGRpc3RhbmNlIC8gKCBlbGFwc2VkVGltZSArIDEgKTtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgYmlhc2VkIGF2ZXJhZ2UsIGZhdm9ycyB0aGUgbW9zdCByZWNlbnQgc3BlZWQgY29tcHV0YXRpb24uIFNtb290aHMgb3V0IGVycmF0aWMgZ2VzdHVyZXMgYSBiaXQuXG4gICAgICAgICAgICAgICAgZ1BvaW50LnNwZWVkID0gMC43NSAqIHNwZWVkICsgMC4yNSAqIGdQb2ludC5zcGVlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWMuIEFkZCBhIGdlc3R1cmUgcG9pbnQgdG8gYmUgdHJhY2tlZFxuICAgICAgICB2YXIgYWRkUG9pbnQgPSBmdW5jdGlvbiAoIHRyYWNrZXIsIGdQb2ludCApIHtcbiAgICAgICAgICAgIHZhciBndWlkID0gX2dlbmVyYXRlR3VpZCggdHJhY2tlciwgZ1BvaW50ICk7XG5cbiAgICAgICAgICAgIHRyYWNrZXJQb2ludHMucHVzaChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGd1aWQ6IGd1aWQsXG4gICAgICAgICAgICAgICAgICAgIGdQb2ludDogZ1BvaW50LFxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9zOiBnUG9pbnQuY3VycmVudFBvc1xuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLy8gT25seSBmaXJlIHVwIHRoZSBpbnRlcnZhbCB0aW1lciB3aGVuIHRoZXJlJ3MgZ2VzdHVyZSBwb2ludGVycyB0byB0cmFja1xuICAgICAgICAgICAgaWYgKCB0cmFja2VyUG9pbnRzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9ICQubm93KCk7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggX2RvVHJhY2tpbmcsIDUwICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljLiBTdG9wIHRyYWNraW5nIGEgZ2VzdHVyZSBwb2ludFxuICAgICAgICB2YXIgcmVtb3ZlUG9pbnQgPSBmdW5jdGlvbiAoIHRyYWNrZXIsIGdQb2ludCApIHtcbiAgICAgICAgICAgIHZhciBndWlkID0gX2dlbmVyYXRlR3VpZCggdHJhY2tlciwgZ1BvaW50ICksXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0cmFja2VyUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0cmFja2VyUG9pbnRzWyBpIF0uZ3VpZCA9PT0gZ3VpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlclBvaW50cy5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhlIGludGVydmFsIHRpbWVyIGlmIHRoZXJlcyBnZXN0dXJlIHBvaW50ZXJzIHRvIHRyYWNrXG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxlbiA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKCBpbnRlcnZhbElkICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRQb2ludDogICAgYWRkUG9pbnQsXG4gICAgICAgICAgICByZW1vdmVQb2ludDogcmVtb3ZlUG9pbnRcbiAgICAgICAgfTtcbiAgICB9ICkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQb2ludGVyIGV2ZW50IG1vZGVsIGFuZCBmZWF0dXJlIGRldGVjdGlvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQgPSBkb2N1bWVudDtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBhdmFpbGFibGUgbW91c2Ugd2hlZWwgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICAkLk1vdXNlVHJhY2tlci53aGVlbEV2ZW50TmFtZSA9ICggJC5Ccm93c2VyLnZlbmRvciA9PSAkLkJST1dTRVJTLklFICYmICQuQnJvd3Nlci52ZXJzaW9uID4gOCApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoICdvbndoZWVsJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApICkgPyAnd2hlZWwnIDogLy8gTW9kZXJuIGJyb3dzZXJzIHN1cHBvcnQgJ3doZWVsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgPyAnbW91c2V3aGVlbCcgOiAgICAgICAgICAgICAgICAgICAgIC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCAnbW91c2V3aGVlbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdET01Nb3VzZVNjcm9sbCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgb2xkIEZpcmVmb3hcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBsZWdhY3kgbW91c2UgY2FwdHVyZSBzdXBwb3J0LlxuICAgICAqL1xuICAgICQuTW91c2VUcmFja2VyLnN1cHBvcnRzTW91c2VDYXB0dXJlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuICAgICAgICByZXR1cm4gJC5pc0Z1bmN0aW9uKCBkaXZFbGVtZW50LnNldENhcHR1cmUgKSAmJiAkLmlzRnVuY3Rpb24oIGRpdkVsZW1lbnQucmVsZWFzZUNhcHR1cmUgKTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGJyb3dzZXIgcG9pbnRlciBkZXZpY2UgZXZlbnQgbW9kZWwocykgYW5kIGJ1aWxkIGFwcHJvcHJpYXRlIGxpc3Qgb2YgZXZlbnRzIHRvIHN1YnNjcmliZSB0by5cbiAgICAgKi9cbiAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMgPSBbIFwiY2xpY2tcIiwgXCJkYmxjbGlja1wiLCBcImtleWRvd25cIiwgXCJrZXl1cFwiLCBcImtleXByZXNzXCIsIFwiZm9jdXNcIiwgXCJibHVyXCIsICQuTW91c2VUcmFja2VyLndoZWVsRXZlbnROYW1lIF07XG5cbiAgICBpZiggJC5Nb3VzZVRyYWNrZXIud2hlZWxFdmVudE5hbWUgPT0gXCJET01Nb3VzZVNjcm9sbFwiICkge1xuICAgICAgICAvLyBPbGRlciBGaXJlZm94XG4gICAgICAgICQuTW91c2VUcmFja2VyLnN1YnNjcmliZUV2ZW50cy5wdXNoKCBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIiApO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZSBpcyBkZXByZWNhdGVkIG9uIElFIDExIGFuZCBub3QgcGFydCBvZiBXM0Mgc3BlYy5cbiAgICBpZiAoIHdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgKCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8ICQuQnJvd3Nlci52ZW5kb3IgIT09ICQuQlJPV1NFUlMuSUUgKSApIHtcbiAgICAgICAgLy8gSUUxMSBhbmQgb3RoZXIgVzNDIFBvaW50ZXIgRXZlbnQgaW1wbGVtZW50YXRpb25zIChzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cylcbiAgICAgICAgJC5Nb3VzZVRyYWNrZXIuaGF2ZVBvaW50ZXJFdmVudHMgPSB0cnVlO1xuICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJwb2ludGVyb3ZlclwiLCBcInBvaW50ZXJvdXRcIiwgXCJwb2ludGVyZG93blwiLCBcInBvaW50ZXJ1cFwiLCBcInBvaW50ZXJtb3ZlXCIsIFwicG9pbnRlcmNhbmNlbFwiICk7XG4gICAgICAgICQuTW91c2VUcmFja2VyLnVucHJlZml4ZWRQb2ludGVyRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgaWYoIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyApIHtcbiAgICAgICAgICAgICQuTW91c2VUcmFja2VyLm1heFRvdWNoUG9pbnRzID0gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIubWF4VG91Y2hQb2ludHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgICQuTW91c2VUcmFja2VyLmhhdmVNb3VzZUVudGVyID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICggd2luZG93Lk1TUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCApIHtcbiAgICAgICAgLy8gSUUxMFxuICAgICAgICAkLk1vdXNlVHJhY2tlci5oYXZlUG9pbnRlckV2ZW50cyA9IHRydWU7XG4gICAgICAgICQuTW91c2VUcmFja2VyLnN1YnNjcmliZUV2ZW50cy5wdXNoKCBcIk1TUG9pbnRlck92ZXJcIiwgXCJNU1BvaW50ZXJPdXRcIiwgXCJNU1BvaW50ZXJEb3duXCIsIFwiTVNQb2ludGVyVXBcIiwgXCJNU1BvaW50ZXJNb3ZlXCIsIFwiTVNQb2ludGVyQ2FuY2VsXCIgKTtcbiAgICAgICAgJC5Nb3VzZVRyYWNrZXIudW5wcmVmaXhlZFBvaW50ZXJFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgaWYoIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICkge1xuICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIubWF4VG91Y2hQb2ludHMgPSBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuTW91c2VUcmFja2VyLm1heFRvdWNoUG9pbnRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAkLk1vdXNlVHJhY2tlci5oYXZlTW91c2VFbnRlciA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlZ2FjeSBXM0MgbW91c2UgZXZlbnRzXG4gICAgICAgICQuTW91c2VUcmFja2VyLmhhdmVQb2ludGVyRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIGlmICggJC5Ccm93c2VyLnZlbmRvciA9PT0gJC5CUk9XU0VSUy5JRSAmJiAkLkJyb3dzZXIudmVyc2lvbiA8IDkgKSB7XG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJtb3VzZWVudGVyXCIsIFwibW91c2VsZWF2ZVwiICk7XG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5oYXZlTW91c2VFbnRlciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW91dFwiICk7XG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5oYXZlTW91c2VFbnRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgICQuTW91c2VUcmFja2VyLnN1YnNjcmliZUV2ZW50cy5wdXNoKCBcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJtb3VzZW1vdmVcIiApO1xuICAgICAgICBpZiAoICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyApIHtcbiAgICAgICAgICAgIC8vIGlPUywgQW5kcm9pZCwgYW5kIG90aGVyIFczYyBUb3VjaCBFdmVudCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgIC8vICAgIChzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzLylcbiAgICAgICAgICAgIC8vICAgIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvaW9zL2RvY3VtZW50YXRpb24vQXBwbGVBcHBsaWNhdGlvbnMvUmVmZXJlbmNlL1NhZmFyaVdlYkNvbnRlbnQvSGFuZGxpbmdFdmVudHMvSGFuZGxpbmdFdmVudHMuaHRtbClcbiAgICAgICAgICAgIC8vICAgIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvc2FmYXJpL2RvY3VtZW50YXRpb24vQXBwbGVBcHBsaWNhdGlvbnMvUmVmZXJlbmNlL1NhZmFyaVdlYkNvbnRlbnQvSGFuZGxpbmdFdmVudHMvSGFuZGxpbmdFdmVudHMuaHRtbClcbiAgICAgICAgICAgICQuTW91c2VUcmFja2VyLnN1YnNjcmliZUV2ZW50cy5wdXNoKCBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoY2FuY2VsXCIgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICdvbmdlc3R1cmVzdGFydCcgaW4gd2luZG93ICkge1xuICAgICAgICAgICAgLy8gaU9TIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvaW9zL2RvY3VtZW50YXRpb24vQXBwbGVBcHBsaWNhdGlvbnMvUmVmZXJlbmNlL1NhZmFyaVdlYkNvbnRlbnQvSGFuZGxpbmdFdmVudHMvSGFuZGxpbmdFdmVudHMuaHRtbClcbiAgICAgICAgICAgIC8vICAgU3Vic2NyaWJlIHRvIHRoZXNlIHRvIHByZXZlbnQgZGVmYXVsdCBnZXN0dXJlIGhhbmRsaW5nXG4gICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMucHVzaCggXCJnZXN0dXJlc3RhcnRcIiwgXCJnZXN0dXJlY2hhbmdlXCIgKTtcbiAgICAgICAgfVxuICAgICAgICAkLk1vdXNlVHJhY2tlci5tb3VzZVBvaW50ZXJJZCA9IFwibGVnYWN5LW1vdXNlXCI7XG4gICAgICAgICQuTW91c2VUcmFja2VyLm1heFRvdWNoUG9pbnRzID0gMTA7XG4gICAgfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENsYXNzZXMgYW5kIHR5cGVkZWZzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgcG9pbnQgb2YgY29udGFjdCBvbiB0aGUgc2NyZWVuIG1hZGUgYnkgYSBtb3VzZSBjdXJzb3IsIHBlbiwgdG91Y2gsIG9yIG90aGVyIHBvaW50ZXIgZGV2aWNlLlxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gR2VzdHVyZVBvaW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRcbiAgICAgKiAgICAgSWRlbnRpZmllciB1bmlxdWUgZnJvbSBhbGwgb3RoZXIgYWN0aXZlIEdlc3R1cmVQb2ludHMgZm9yIGEgZ2l2ZW4gcG9pbnRlciBkZXZpY2UuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGVcbiAgICAgKiAgICAgVGhlIHBvaW50ZXIgZGV2aWNlIHR5cGU6IFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjYXB0dXJlZFxuICAgICAqICAgICBUcnVlIGlmIGV2ZW50cyBmb3IgdGhlIGdlc3R1cmUgcG9pbnQgYXJlIGNhcHR1cmVkIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1ByaW1hcnlcbiAgICAgKiAgICAgVHJ1ZSBpZiB0aGUgZ2VzdHVyZSBwb2ludCBpcyBhIG1hc3RlciBwb2ludGVyIGFtb25nc3QgdGhlIHNldCBvZiBhY3RpdmUgcG9pbnRlcnMgZm9yIGVhY2ggcG9pbnRlciB0eXBlLiBUcnVlIGZvciBtb3VzZSBhbmQgcHJpbWFyeSAoZmlyc3QpIHRvdWNoL3BlbiBwb2ludGVycy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGluc2lkZUVsZW1lbnRQcmVzc2VkXG4gICAgICogICAgIFRydWUgaWYgYnV0dG9uIHByZXNzZWQgb3IgY29udGFjdCBwb2ludCBpbml0aWF0ZWQgaW5zaWRlIHRoZSBzY3JlZW4gYXJlYSBvZiB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW5zaWRlRWxlbWVudFxuICAgICAqICAgICBUcnVlIGlmIHBvaW50ZXIgb3IgY29udGFjdCBwb2ludCBpcyBjdXJyZW50bHkgaW5zaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3BlZWRcbiAgICAgKiAgICAgQ3VycmVudCBjb21wdXRlZCBzcGVlZCwgaW4gcGl4ZWxzIHBlciBzZWNvbmQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRpcmVjdGlvblxuICAgICAqICAgICBDdXJyZW50IGNvbXB1dGVkIGRpcmVjdGlvbiwgZXhwcmVzc2VkIGFzIGFuIGFuZ2xlIGNvdW50ZXJjbG9ja3dpc2UgcmVsYXRpdmUgdG8gdGhlIHBvc2l0aXZlIFggYXhpcyAoLXBpIHRvIHBpLCBpbiByYWRpYW5zKS4gT25seSB2YWxpZCBpZiBzcGVlZCA+IDAuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBjb250YWN0UG9zXG4gICAgICogICAgIFRoZSBpbml0aWFsIHBvaW50ZXIgY29udGFjdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHBhZ2UgaW5jbHVkaW5nIGFueSBzY3JvbGxpbmcuIE9ubHkgdmFsaWQgaWYgdGhlIHBvaW50ZXIgaGFzIGNvbnRhY3QgKHByZXNzZWQsIHRvdWNoIGNvbnRhY3QsIHBlbiBjb250YWN0KS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29udGFjdFRpbWVcbiAgICAgKiAgICAgVGhlIGluaXRpYWwgcG9pbnRlciBjb250YWN0IHRpbWUsIGluIG1pbGxpc2Vjb25kcy4gT25seSB2YWxpZCBpZiB0aGUgcG9pbnRlciBoYXMgY29udGFjdCAocHJlc3NlZCwgdG91Y2ggY29udGFjdCwgcGVuIGNvbnRhY3QpLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gbGFzdFBvc1xuICAgICAqICAgICBUaGUgbGFzdCBwb2ludGVyIHBvc2l0aW9uLCByZWxhdGl2ZSB0byB0aGUgcGFnZSBpbmNsdWRpbmcgYW55IHNjcm9sbGluZy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGFzdFRpbWVcbiAgICAgKiAgICAgVGhlIGxhc3QgcG9pbnRlciBjb250YWN0IHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IGN1cnJlbnRQb3NcbiAgICAgKiAgICAgVGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHBhZ2UgaW5jbHVkaW5nIGFueSBzY3JvbGxpbmcuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRUaW1lXG4gICAgICogICAgIFRoZSBjdXJyZW50IHBvaW50ZXIgY29udGFjdCB0aW1lLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBHZXN0dXJlUG9pbnRMaXN0XG4gICAgICogQGNsYXNzZGVzYyBQcm92aWRlcyBhbiBhYnN0cmFjdGlvbiBmb3IgYSBzZXQgb2YgYWN0aXZlIHtAbGluayBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnR8R2VzdHVyZVBvaW50fSBvYmplY3RzIGZvciBhIGdpdmVuIHBvaW50ZXIgZGV2aWNlIHR5cGUuXG4gICAgICogICAgICAgICAgICBBY3RpdmUgcG9pbnRlcnMgYXJlIGFueSBwb2ludGVyIGJlaW5nIHRyYWNrZWQgZm9yIHRoaXMgZWxlbWVudCB3aGljaCBhcmUgaW4gdGhlIGhpdC10ZXN0IGFyZWFcbiAgICAgKiAgICAgICAgICAgIG9mIHRoZSBlbGVtZW50IChmb3IgaG92ZXItY2FwYWJsZSBkZXZpY2VzKSBhbmQvb3IgaGF2ZSBjb250YWN0IG9yIGEgYnV0dG9uIHByZXNzIGluaXRpYXRlZCBpbiB0aGUgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBwb2ludGVyIGRldmljZSB0eXBlOiBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAqL1xuICAgICQuTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QgPSBmdW5jdGlvbiAoIHR5cGUgKSB7XG4gICAgICAgIHRoaXMuX2dQb2ludHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb2ludGVyIGRldmljZSB0eXBlOiBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBidXR0b25zIHByZXNzZWQgZm9yIHRoZSBkZXZpY2UuXG4gICAgICAgICAqIENvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYnV0dG9uc1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IG51bWJlciBvZiBjb250YWN0IHBvaW50cyAodG91Y2ggcG9pbnRzLCBtb3VzZSBkb3duLCBldGMuKSBmb3IgdGhlIGRldmljZS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb250YWN0c1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFjdHMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBudW1iZXIgb2YgY2xpY2tzIGZvciB0aGUgZGV2aWNlLiBVc2VkIGZvciBtdWx0aXBsZSBjbGljayBnZXN0dXJlIHRyYWNraW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNsaWNrc1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpY2tzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgbnVtYmVyIG9mIGNhcHR1cmVkIHBvaW50ZXJzIGZvciB0aGUgZGV2aWNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNhcHR1cmVDb3VudFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50TGlzdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ID0gMDtcbiAgICB9O1xuXG4gICAgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0LnByb3RvdHlwZSAqL1xuICAgICQuTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3QucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiBnZXN0dXJlIHBvaW50cyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dQb2ludHMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheS48T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50Pn0gVGhlIGxpc3Qgb2YgZ2VzdHVyZSBwb2ludHMgaW4gdGhlIGxpc3QgYXMgYW4gYXJyYXkgKHJlYWQtb25seSkuXG4gICAgICAgICAqL1xuICAgICAgICBhc0FycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ1BvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludH0gZ2VzdHVyZVBvaW50IC0gQSBnZXN0dXJlIHBvaW50IHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gTnVtYmVyIG9mIGdlc3R1cmUgcG9pbnRzIGluIHRoZSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoIGdwICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dQb2ludHMucHVzaCggZ3AgKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgLSBUaGUgaWQgb2YgdGhlIGdlc3R1cmUgcG9pbnQgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiBnZXN0dXJlIHBvaW50cyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9nUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLl9nUG9pbnRzWyBpIF0uaWQgPT09IGlkICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nUG9pbnRzLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ1BvaW50cy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBnZXN0dXJlIHBvaW50IHRvIHJldHJpZXZlIGZyb20gdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnR8bnVsbH0gVGhlIGdlc3R1cmUgcG9pbnQgYXQgdGhlIGdpdmVuIGluZGV4LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJ5SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG4gICAgICAgICAgICBpZiAoIGluZGV4IDwgdGhpcy5fZ1BvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ1BvaW50c1sgaW5kZXggXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIC0gVGhlIGlkIG9mIHRoZSBnZXN0dXJlIHBvaW50IHRvIHJldHJpZXZlIGZyb20gdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnR8bnVsbH0gVGhlIGdlc3R1cmUgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gaWQsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QnlJZDogZnVuY3Rpb24gKCBpZCApIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuX2dQb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuX2dQb2ludHNbIGkgXS5pZCA9PT0gaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nUG9pbnRzWyBpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludHxudWxsfSBUaGUgcHJpbWFyeSBnZXN0dXJlIHBvaW50IGluIHRoZSBsaXN0LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldFByaW1hcnk6IGZ1bmN0aW9uICggaWQgKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9nUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLl9nUG9pbnRzWyBpIF0uaXNQcmltYXJ5ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ1BvaW50c1sgaSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdHJhY2tlZCBwb2ludGVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyVHJhY2tlZFBvaW50ZXJzKCB0cmFja2VyICkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0cmFja2VyLmhhc2ggXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwb2ludGVyTGlzdENvdW50ID0gZGVsZWdhdGUuYWN0aXZlUG9pbnRlcnNMaXN0cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBwb2ludGVyTGlzdENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIGRlbGVnYXRlLmFjdGl2ZVBvaW50ZXJzTGlzdHNbIGkgXS5jYXB0dXJlQ291bnQgPiAwICkge1xuICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubW91c2Vtb3ZlY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLm1vdXNldXBjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudChcbiAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLnVucHJlZml4ZWRQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJtb3ZlJyA6ICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUucG9pbnRlcm1vdmVjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudChcbiAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLnVucHJlZml4ZWRQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJ1cCcgOiAnTVNQb2ludGVyVXAnLFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5wb2ludGVydXBjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudChcbiAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS50b3VjaG1vdmVjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudChcbiAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuY2FwdHVyZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLnRvdWNoZW5kY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZGVsZWdhdGUuYWN0aXZlUG9pbnRlcnNMaXN0c1sgaSBdLmNhcHR1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHBvaW50ZXJMaXN0Q291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgIGRlbGVnYXRlLmFjdGl2ZVBvaW50ZXJzTGlzdHMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJhY2tpbmcgcG9pbnRlciBldmVudHMgb24gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0VHJhY2tpbmcoIHRyYWNrZXIgKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IFRISVNbIHRyYWNrZXIuaGFzaCBdLFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmICggIWRlbGVnYXRlLnRyYWNraW5nICkge1xuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHNbIGkgXTtcbiAgICAgICAgICAgICAgICAkLmFkZEV2ZW50KFxuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZVsgZXZlbnQgXSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhclRyYWNrZWRQb2ludGVycyggdHJhY2tlciApO1xuXG4gICAgICAgICAgICBkZWxlZ2F0ZS50cmFja2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0cmFja2luZyBwb2ludGVyIGV2ZW50cyBvbiB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcFRyYWNraW5nKCB0cmFja2VyICkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0cmFja2VyLmhhc2ggXSxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAoIGRlbGVnYXRlLnRyYWNraW5nICkge1xuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSAkLk1vdXNlVHJhY2tlci5zdWJzY3JpYmVFdmVudHNbIGkgXTtcbiAgICAgICAgICAgICAgICAkLnJlbW92ZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZVsgZXZlbnQgXSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhclRyYWNrZWRQb2ludGVycyggdHJhY2tlciApO1xuXG4gICAgICAgICAgICBkZWxlZ2F0ZS50cmFja2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYXB0dXJlRXZlbnRQYXJhbXMoIHRyYWNrZXIsIHBvaW50ZXJUeXBlICkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0cmFja2VyLmhhc2ggXTtcblxuICAgICAgICBpZiAoIHBvaW50ZXJUeXBlID09PSAncG9pbnRlcmV2ZW50JyApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBOYW1lOiAkLk1vdXNlVHJhY2tlci51bnByZWZpeGVkUG9pbnRlckV2ZW50cyA/ICdwb2ludGVydXAnIDogJ01TUG9pbnRlclVwJyxcbiAgICAgICAgICAgICAgICB1cEhhbmRsZXI6IGRlbGVnYXRlLnBvaW50ZXJ1cGNhcHR1cmVkLFxuICAgICAgICAgICAgICAgIG1vdmVOYW1lOiAkLk1vdXNlVHJhY2tlci51bnByZWZpeGVkUG9pbnRlckV2ZW50cyA/ICdwb2ludGVybW92ZScgOiAnTVNQb2ludGVyTW92ZScsXG4gICAgICAgICAgICAgICAgbW92ZUhhbmRsZXI6IGRlbGVnYXRlLnBvaW50ZXJtb3ZlY2FwdHVyZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoIHBvaW50ZXJUeXBlID09PSAnbW91c2UnICkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cE5hbWU6ICdtb3VzZXVwJyxcbiAgICAgICAgICAgICAgICB1cEhhbmRsZXI6IGRlbGVnYXRlLm1vdXNldXBjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICBtb3ZlTmFtZTogJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgbW92ZUhhbmRsZXI6IGRlbGVnYXRlLm1vdXNlbW92ZWNhcHR1cmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBOYW1lOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICAgIHVwSGFuZGxlcjogZGVsZWdhdGUudG91Y2hlbmRjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICBtb3ZlTmFtZTogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgbW92ZUhhbmRsZXI6IGRlbGVnYXRlLnRvdWNobW92ZWNhcHR1cmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIk1vdXNlVHJhY2tlci5nZXRDYXB0dXJlRXZlbnRQYXJhbXM6IFVua25vd24gcG9pbnRlciB0eXBlLlwiICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZWdpbiBjYXB0dXJpbmcgcG9pbnRlciBldmVudHMgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcHR1cmVQb2ludGVyKCB0cmFja2VyLCBwb2ludGVyVHlwZSwgcG9pbnRlckNvdW50ICkge1xuICAgICAgICB2YXIgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCBwb2ludGVyVHlwZSApLFxuICAgICAgICAgICAgZXZlbnRQYXJhbXM7XG5cbiAgICAgICAgcG9pbnRzTGlzdC5jYXB0dXJlQ291bnQgKz0gKHBvaW50ZXJDb3VudCB8fCAxKTtcblxuICAgICAgICBpZiAoIHBvaW50c0xpc3QuY2FwdHVyZUNvdW50ID09PSAxICkge1xuICAgICAgICAgICAgaWYgKCAkLkJyb3dzZXIudmVuZG9yID09PSAkLkJST1dTRVJTLklFICYmICQuQnJvd3Nlci52ZXJzaW9uIDwgOSApIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLmVsZW1lbnQuc2V0Q2FwdHVyZSggdHJ1ZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudFBhcmFtcyA9IGdldENhcHR1cmVFdmVudFBhcmFtcyggdHJhY2tlciwgJC5Nb3VzZVRyYWNrZXIuaGF2ZVBvaW50ZXJFdmVudHMgPyAncG9pbnRlcmV2ZW50JyA6IHBvaW50ZXJUeXBlICk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZW11bGF0ZSBtb3VzZSBjYXB0dXJlIGJ5IGhhbmdpbmcgbGlzdGVuZXJzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gICAgKE5vdGUgd2UgbGlzdGVuIG9uIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHRoZSBjYXB0dXJlZCBoYW5kbGVycyB3aWxsIGdldCBjYWxsZWQgZmlyc3QpXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5JZnJhbWUgJiYgY2FuQWNjZXNzRXZlbnRzKHdpbmRvdy50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICQuYWRkRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkLmFkZEV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5jYXB0dXJlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudFBhcmFtcy51cEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQuYWRkRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICQuTW91c2VUcmFja2VyLmNhcHR1cmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBldmVudFBhcmFtcy5tb3ZlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMubW92ZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGNhcHR1cmluZyBwb2ludGVyIGV2ZW50cyB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVsZWFzZVBvaW50ZXIoIHRyYWNrZXIsIHBvaW50ZXJUeXBlLCBwb2ludGVyQ291bnQgKSB7XG4gICAgICAgIHZhciBwb2ludHNMaXN0ID0gdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoIHBvaW50ZXJUeXBlICksXG4gICAgICAgICAgICBldmVudFBhcmFtcztcblxuICAgICAgICBwb2ludHNMaXN0LmNhcHR1cmVDb3VudCAtPSAocG9pbnRlckNvdW50IHx8IDEpO1xuXG4gICAgICAgIGlmICggcG9pbnRzTGlzdC5jYXB0dXJlQ291bnQgPT09IDAgKSB7XG4gICAgICAgICAgICBpZiAoICQuQnJvd3Nlci52ZW5kb3IgPT09ICQuQlJPV1NFUlMuSUUgJiYgJC5Ccm93c2VyLnZlcnNpb24gPCA5ICkge1xuICAgICAgICAgICAgICAgIHRyYWNrZXIuZWxlbWVudC5yZWxlYXNlQ2FwdHVyZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudFBhcmFtcyA9IGdldENhcHR1cmVFdmVudFBhcmFtcyggdHJhY2tlciwgJC5Nb3VzZVRyYWNrZXIuaGF2ZVBvaW50ZXJFdmVudHMgPyAncG9pbnRlcmV2ZW50JyA6IHBvaW50ZXJUeXBlICk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZW11bGF0ZSBtb3VzZSBjYXB0dXJlIGJ5IGhhbmdpbmcgbGlzdGVuZXJzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gICAgKE5vdGUgd2UgbGlzdGVuIG9uIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHRoZSBjYXB0dXJlZCBoYW5kbGVycyB3aWxsIGdldCBjYWxsZWQgZmlyc3QpXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5JZnJhbWUgJiYgY2FuQWNjZXNzRXZlbnRzKHdpbmRvdy50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkLnJlbW92ZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5jYXB0dXJlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMubW92ZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zLm1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAkLnJlbW92ZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5jYXB0dXJlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMudXBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudFBhcmFtcy51cEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgVzNDIFBvaW50ZXIgRXZlbnRzIG1vZGVsIGNvbXBhdGlibGUgcG9pbnRlciB0eXBlIHN0cmluZyBmcm9tIGEgRE9NIHBvaW50ZXIgZXZlbnQuXG4gICAgICogSUUxMCB1c2VkIGEgbG9uZyBpbnRlZ2VyIHZhbHVlLCBidXQgdGhlIFczQyBzcGVjaWZpY2F0aW9uIChhbmQgSUUxMSspIHVzZSBhIHN0cmluZyBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UG9pbnRlclR5cGUoIGV2ZW50ICkge1xuICAgICAgICB2YXIgcG9pbnRlclR5cGVTdHI7XG4gICAgICAgIGlmICggJC5Nb3VzZVRyYWNrZXIudW5wcmVmaXhlZFBvaW50ZXJFdmVudHMgKSB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVN0ciA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSUUxMFxuICAgICAgICAgICAgLy8gIE1TUE9JTlRFUl9UWVBFX1RPVUNIOiAweDAwMDAwMDAyXG4gICAgICAgICAgICAvLyAgTVNQT0lOVEVSX1RZUEVfUEVOOiAgIDB4MDAwMDAwMDNcbiAgICAgICAgICAgIC8vICBNU1BPSU5URVJfVFlQRV9NT1VTRTogMHgwMDAwMDAwNFxuICAgICAgICAgICAgc3dpdGNoKCBldmVudC5wb2ludGVyVHlwZSApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSAweDAwMDAwMDAyOlxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZVN0ciA9ICd0b3VjaCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwMDAwMDAwMzpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGVTdHIgPSAncGVuJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweDAwMDAwMDA0OlxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZVN0ciA9ICdtb3VzZSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlU3RyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50ZXJUeXBlU3RyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApIHtcbiAgICAgICAgcmV0dXJuICQuZ2V0TW91c2VQb3NpdGlvbiggZXZlbnQgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1vdXNlUmVsYXRpdmUoIGV2ZW50LCBlbGVtZW50ICkge1xuICAgICAgICByZXR1cm4gZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksIGVsZW1lbnQgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCBwb2ludCwgZWxlbWVudCApIHtcbiAgICAgICAgdmFyIG9mZnNldCA9ICQuZ2V0RWxlbWVudE9mZnNldCggZWxlbWVudCApO1xuICAgICAgICByZXR1cm4gcG9pbnQubWludXMoIG9mZnNldCApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2VudGVyUG9pbnQoIHBvaW50MSwgcG9pbnQyICkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoICggcG9pbnQxLnggKyBwb2ludDIueCApIC8gMiwgKCBwb2ludDEueSArIHBvaW50Mi55ICkgLyAyICk7XG4gICAgfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERldmljZS1zcGVjaWZpYyBET00gZXZlbnQgaGFuZGxlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25DbGljayggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGlmICggdHJhY2tlci5jbGlja0hhbmRsZXIgKSB7XG4gICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRGJsQ2xpY2soIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBpZiAoIHRyYWNrZXIuZGJsQ2xpY2tIYW5kbGVyICkge1xuICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleURvd24oIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICAvLyQuY29uc29sZS5sb2coIFwia2V5ZG93biAlcyAlcyAlcyAlcyAlc1wiLCBldmVudC5rZXlDb2RlLCBldmVudC5jaGFyQ29kZSwgZXZlbnQuY3RybEtleSwgZXZlbnQuc2hpZnRLZXksIGV2ZW50LmFsdEtleSApO1xuICAgICAgICB2YXIgcHJvcGFnYXRlO1xuICAgICAgICBpZiAoIHRyYWNrZXIua2V5RG93bkhhbmRsZXIgKSB7XG4gICAgICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmtleURvd25IYW5kbGVyKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleUNvZGU6ICAgICAgICAgICAgICBldmVudC5rZXlDb2RlID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjdHJsOiAgICAgICAgICAgICAgICAgZXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICBhbHQ6ICAgICAgICAgICAgICAgICAgZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiAgICAgICAgICAgICAgICAgZXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICggIXByb3BhZ2F0ZSApIHtcbiAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5VXAoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICAvLyQuY29uc29sZS5sb2coIFwia2V5dXAgJXMgJXMgJXMgJXMgJXNcIiwgZXZlbnQua2V5Q29kZSwgZXZlbnQuY2hhckNvZGUsIGV2ZW50LmN0cmxLZXksIGV2ZW50LnNoaWZ0S2V5LCBldmVudC5hbHRLZXkgKTtcbiAgICAgICAgdmFyIHByb3BhZ2F0ZTtcbiAgICAgICAgaWYgKCB0cmFja2VyLmtleVVwSGFuZGxlciApIHtcbiAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIua2V5VXBIYW5kbGVyKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleUNvZGU6ICAgICAgICAgICAgICBldmVudC5rZXlDb2RlID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjdHJsOiAgICAgICAgICAgICAgICAgZXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICBhbHQ6ICAgICAgICAgICAgICAgICAgZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiAgICAgICAgICAgICAgICAgZXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICggIXByb3BhZ2F0ZSApIHtcbiAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5UHJlc3MoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICAvLyQuY29uc29sZS5sb2coIFwia2V5cHJlc3MgJXMgJXMgJXMgJXMgJXNcIiwgZXZlbnQua2V5Q29kZSwgZXZlbnQuY2hhckNvZGUsIGV2ZW50LmN0cmxLZXksIGV2ZW50LnNoaWZ0S2V5LCBldmVudC5hbHRLZXkgKTtcbiAgICAgICAgdmFyIHByb3BhZ2F0ZTtcbiAgICAgICAgaWYgKCB0cmFja2VyLmtleUhhbmRsZXIgKSB7XG4gICAgICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmtleUhhbmRsZXIoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAga2V5Q29kZTogICAgICAgICAgICAgIGV2ZW50LmtleUNvZGUgPyBldmVudC5rZXlDb2RlIDogZXZlbnQuY2hhckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIGN0cmw6ICAgICAgICAgICAgICAgICBldmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgICAgICAgICBzaGlmdDogICAgICAgICAgICAgICAgZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgICAgIGFsdDogICAgICAgICAgICAgICAgICBldmVudC5hbHRLZXksXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6ICAgICAgICAgICAgICAgICBldmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCAhcHJvcGFnYXRlICkge1xuICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Gb2N1cyggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coIFwiZm9jdXMgJXNcIiwgZXZlbnQgKTtcbiAgICAgICAgdmFyIHByb3BhZ2F0ZTtcbiAgICAgICAgaWYgKCB0cmFja2VyLmZvY3VzSGFuZGxlciApIHtcbiAgICAgICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIuZm9jdXNIYW5kbGVyKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkJsdXIoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCBcImJsdXIgJXNcIiwgZXZlbnQgKTtcbiAgICAgICAgdmFyIHByb3BhZ2F0ZTtcbiAgICAgICAgaWYgKCB0cmFja2VyLmJsdXJIYW5kbGVyICkge1xuICAgICAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5ibHVySGFuZGxlcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICd3aGVlbCcgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uV2hlZWwoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBoYW5kbGVXaGVlbEV2ZW50KCB0cmFja2VyLCBldmVudCwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgYW5kICdNb3pNb3VzZVBpeGVsU2Nyb2xsJyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIGEgJ3doZWVsJyBldmVudFxuICAgICAgICB2YXIgc2ltdWxhdGVkRXZlbnQgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6ICAgICBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgICAgIHR5cGU6ICAgICAgIFwid2hlZWxcIixcbiAgICAgICAgICAgIHNoaWZ0S2V5OiAgIGV2ZW50LnNoaWZ0S2V5IHx8IGZhbHNlLFxuICAgICAgICAgICAgY2xpZW50WDogICAgZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6ICAgIGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICBwYWdlWDogICAgICBldmVudC5wYWdlWCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIHBhZ2VZOiAgICAgIGV2ZW50LnBhZ2VZID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgZGVsdGFNb2RlOiAgZXZlbnQudHlwZSA9PSBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIiA/IDAgOiAxLCAvLyAwPXBpeGVsLCAxPWxpbmUsIDI9cGFnZVxuICAgICAgICAgICAgZGVsdGFYOiAgICAgMCxcbiAgICAgICAgICAgIGRlbHRhWjogICAgIDBcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgZGVsdGFZXG4gICAgICAgIGlmICggJC5Nb3VzZVRyYWNrZXIud2hlZWxFdmVudE5hbWUgPT0gXCJtb3VzZXdoZWVsXCIgKSB7XG4gICAgICAgICAgICBzaW11bGF0ZWRFdmVudC5kZWx0YVkgPSAtIDEgLyAkLkRFRkFVTFRfU0VUVElOR1MucGl4ZWxzUGVyV2hlZWxMaW5lICogZXZlbnQud2hlZWxEZWx0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpbXVsYXRlZEV2ZW50LmRlbHRhWSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZVdoZWVsRXZlbnQoIHRyYWNrZXIsIHNpbXVsYXRlZEV2ZW50LCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyAnd2hlZWwnIGV2ZW50cy5cbiAgICAgKiBUaGUgZXZlbnQgbWF5IGJlIHNpbXVsYXRlZCBieSB0aGUgbGVnYWN5IG1vdXNlIHdoZWVsIGV2ZW50IGhhbmRsZXIgKG9uTW91c2VXaGVlbCgpKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlV2hlZWxFdmVudCggdHJhY2tlciwgZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSB7XG4gICAgICAgIHZhciBuRGVsdGEgPSAwLFxuICAgICAgICAgICAgcHJvcGFnYXRlO1xuXG4gICAgICAgIC8vIFRoZSBuRGVsdGEgdmFyaWFibGUgaXMgZ2F0ZWQgdG8gcHJvdmlkZSBzbW9vdGggei1pbmRleCBzY3JvbGxpbmdcbiAgICAgICAgLy8gICBzaW5jZSB0aGUgbW91c2Ugd2hlZWwgYWxsb3dzIGZvciBzdWJzdGFudGlhbCBkZWx0YXMgbWVhbnQgZm9yIHJhcGlkXG4gICAgICAgIC8vICAgeS1pbmRleCBzY3JvbGxpbmcuXG4gICAgICAgIC8vIGV2ZW50LmRlbHRhTW9kZTogMD1waXhlbCwgMT1saW5lLCAyPXBhZ2VcbiAgICAgICAgLy8gVE9ETzogRGVsdGFzIGluIHBpeGVsIG1vZGUgc2hvdWxkIGJlIGFjY3VtdWxhdGVkIHRoZW4gYSBzY3JvbGwgdmFsdWUgY29tcHV0ZWQgYWZ0ZXIgJC5ERUZBVUxUX1NFVFRJTkdTLnBpeGVsc1BlcldoZWVsTGluZSB0aHJlc2hvbGQgcmVhY2hlZFxuICAgICAgICBuRGVsdGEgPSBldmVudC5kZWx0YVkgPCAwID8gMSA6IC0xO1xuXG4gICAgICAgIGlmICggdHJhY2tlci5zY3JvbGxIYW5kbGVyICkge1xuICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5zY3JvbGxIYW5kbGVyKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICAnbW91c2UnLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0TW91c2VSZWxhdGl2ZSggZXZlbnQsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6ICAgICAgICAgICAgICAgbkRlbHRhLFxuICAgICAgICAgICAgICAgICAgICBzaGlmdDogICAgICAgICAgICAgICAgZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIG9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BhcmVudENoaWxkKCBwYXJlbnQsIGNoaWxkIClcbiAgICB7XG4gICAgICAgaWYgKCBwYXJlbnQgPT09IGNoaWxkICkge1xuICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICAgIHdoaWxlICggY2hpbGQgJiYgY2hpbGQgIT09IHBhcmVudCApIHtcbiAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gY2hpbGQgPT09IHBhcmVudDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE9ubHkgdXNlZCBvbiBJRSA4XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlciggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICBoYW5kbGVNb3VzZUVudGVyKCB0cmFja2VyLCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlT3ZlciggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICBpZiAoIGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgaXNQYXJlbnRDaGlsZCggZXZlbnQuY3VycmVudFRhcmdldCwgZXZlbnQucmVsYXRlZFRhcmdldCApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlTW91c2VFbnRlciggdHJhY2tlciwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VFbnRlciggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogJC5Nb3VzZVRyYWNrZXIubW91c2VQb2ludGVySWQsXG4gICAgICAgICAgICB0eXBlOiAnbW91c2UnLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiB0cnVlLFxuICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQgKSxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiAkLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgdXBkYXRlUG9pbnRlcnNFbnRlciggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0gKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE9ubHkgdXNlZCBvbiBJRSA4XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZSggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICBoYW5kbGVNb3VzZUV4aXQoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VPdXQoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG5cbiAgICAgICAgaWYgKCBldmVudC5jdXJyZW50VGFyZ2V0ID09PSBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGlzUGFyZW50Q2hpbGQoIGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50LnJlbGF0ZWRUYXJnZXQgKSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZU1vdXNlRXhpdCggdHJhY2tlciwgZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VFeGl0KCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGdQb2ludCA9IHtcbiAgICAgICAgICAgIGlkOiAkLk1vdXNlVHJhY2tlci5tb3VzZVBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZScsXG4gICAgICAgICAgICBpc1ByaW1hcnk6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6ICQubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICB1cGRhdGVQb2ludGVyc0V4aXQoIHRyYWNrZXIsIGV2ZW50LCBbIGdQb2ludCBdICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgVzNDIERPTSBsZXZlbCAzIHN0YW5kYXJkIGJ1dHRvbiB2YWx1ZSBnaXZlbiBhbiBldmVudC5idXR0b24gcHJvcGVydHk6XG4gICAgICogICAtMSA9PSBub25lLCAwID09IHByaW1hcnkvbGVmdCwgMSA9PSBtaWRkbGUsIDIgPT0gc2Vjb25kYXJ5L3JpZ2h0LCAzID09IFgxL2JhY2ssIDQgPT0gWDIvZm9yd2FyZCwgNSA9PSBlcmFzZXIgKHBlbilcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0YW5kYXJkaXplZEJ1dHRvbiggYnV0dG9uICkge1xuICAgICAgICBpZiAoICQuQnJvd3Nlci52ZW5kb3IgPT09ICQuQlJPV1NFUlMuSUUgJiYgJC5Ccm93c2VyLnZlcnNpb24gPCA5ICkge1xuICAgICAgICAgICAgLy8gT24gSUUgOCwgMCA9PSBub25lLCAxID09IGxlZnQsIDIgPT0gcmlnaHQsIDMgPT0gbGVmdCBhbmQgcmlnaHQsIDQgPT0gbWlkZGxlLCA1ID09IGxlZnQgYW5kIG1pZGRsZSwgNiA9PSByaWdodCBhbmQgbWlkZGxlLCA3ID09IGFsbCB0aHJlZVxuICAgICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBjaG9yZGVkIChtdWx0aXBsZSkgYnV0dG9uIHByZXNzZXMgb24gSUUgOD9cbiAgICAgICAgICAgIGlmICggYnV0dG9uID09PSAxICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uID09PSAyICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uID09PSA0ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGdQb2ludDtcblxuICAgICAgICBldmVudCA9ICQuZ2V0RXZlbnQoIGV2ZW50ICk7XG5cbiAgICAgICAgZ1BvaW50ID0ge1xuICAgICAgICAgICAgaWQ6ICQuTW91c2VUcmFja2VyLm1vdXNlUG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIGlzUHJpbWFyeTogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggdXBkYXRlUG9pbnRlcnNEb3duKCB0cmFja2VyLCBldmVudCwgWyBnUG9pbnQgXSwgZ2V0U3RhbmRhcmRpemVkQnV0dG9uKCBldmVudC5idXR0b24gKSApICkge1xuICAgICAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBjYXB0dXJlUG9pbnRlciggdHJhY2tlciwgJ21vdXNlJyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0cmFja2VyLmNsaWNrSGFuZGxlciB8fCB0cmFja2VyLmRibENsaWNrSGFuZGxlciB8fCB0cmFja2VyLnByZXNzSGFuZGxlciB8fCB0cmFja2VyLmRyYWdIYW5kbGVyIHx8IHRyYWNrZXIuZHJhZ0VuZEhhbmRsZXIgKSB7XG4gICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZU1vdXNlVXAoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cgb2JqZWN0IChvbiB0aGUgY2FwdHVyZSBwaGFzZSkgdG8gZW11bGF0ZSBtb3VzZSBjYXB0dXJlLlxuICAgICAqIG9uTW91c2VVcCBpcyBzdGlsbCBhdHRhY2hlZCB0byB0aGUgdHJhY2tlZCBlbGVtZW50LCBzbyBzdG9wIHByb3BhZ2F0aW9uIHRvIGF2b2lkIHByb2Nlc3NpbmcgdHdpY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTW91c2VVcENhcHR1cmVkKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaGFuZGxlTW91c2VVcCggdHJhY2tlciwgZXZlbnQgKTtcbiAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgZ1BvaW50O1xuXG4gICAgICAgIGV2ZW50ID0gJC5nZXRFdmVudCggZXZlbnQgKTtcblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogJC5Nb3VzZVRyYWNrZXIubW91c2VQb2ludGVySWQsXG4gICAgICAgICAgICB0eXBlOiAnbW91c2UnLFxuICAgICAgICAgICAgaXNQcmltYXJ5OiB0cnVlLFxuICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQgKSxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiAkLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCB1cGRhdGVQb2ludGVyc1VwKCB0cmFja2VyLCBldmVudCwgWyBnUG9pbnQgXSwgZ2V0U3RhbmRhcmRpemVkQnV0dG9uKCBldmVudC5idXR0b24gKSApICkge1xuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXIoIHRyYWNrZXIsICdtb3VzZScgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZSggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZU1vdXNlTW92ZSggdHJhY2tlciwgZXZlbnQgKTtcbiAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cgb2JqZWN0IChvbiB0aGUgY2FwdHVyZSBwaGFzZSkgdG8gZW11bGF0ZSBtb3VzZSBjYXB0dXJlLlxuICAgICAqIG9uTW91c2VNb3ZlIGlzIHN0aWxsIGF0dGFjaGVkIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQsIHNvIHN0b3AgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvY2Vzc2luZyB0d2ljZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmVDYXB0dXJlZCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZU1vdXNlTW92ZSggdHJhY2tlciwgZXZlbnQgKTtcbiAgICAgICAgJC5zdG9wRXZlbnQoIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQ7XG5cbiAgICAgICAgZXZlbnQgPSAkLmdldEV2ZW50KCBldmVudCApO1xuXG4gICAgICAgIGdQb2ludCA9IHtcbiAgICAgICAgICAgIGlkOiAkLk1vdXNlVHJhY2tlci5tb3VzZVBvaW50ZXJJZCxcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZScsXG4gICAgICAgICAgICBpc1ByaW1hcnk6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudCApLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6ICQubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICB1cGRhdGVQb2ludGVyc01vdmUoIHRyYWNrZXIsIGV2ZW50LCBbIGdQb2ludCBdICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFib3J0VG91Y2hDb250YWN0cyggdHJhY2tlciwgZXZlbnQsIHBvaW50c0xpc3QgKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZ1BvaW50Q291bnQgPSBwb2ludHNMaXN0LmdldExlbmd0aCgpLFxuICAgICAgICAgICAgYWJvcnRHUG9pbnRzID0gW107XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBnUG9pbnRDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgYWJvcnRHUG9pbnRzLnB1c2goIHBvaW50c0xpc3QuZ2V0QnlJbmRleCggaSApICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGFib3J0R1BvaW50cy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgLy8gc2ltdWxhdGUgdG91Y2hlbmRcbiAgICAgICAgICAgIHVwZGF0ZVBvaW50ZXJzVXAoIHRyYWNrZXIsIGV2ZW50LCBhYm9ydEdQb2ludHMsIDAgKTsgLy8gMCBtZWFucyBwcmltYXJ5IGJ1dHRvbiBwcmVzcy9yZWxlYXNlIG9yIHRvdWNoIGNvbnRhY3RcbiAgICAgICAgICAgIC8vIHJlbGVhc2UgcG9pbnRlciBjYXB0dXJlXG4gICAgICAgICAgICBwb2ludHNMaXN0LmNhcHR1cmVDb3VudCA9IDE7XG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlciggdHJhY2tlciwgJ3RvdWNoJyApO1xuICAgICAgICAgICAgLy8gc2ltdWxhdGUgdG91Y2hsZWF2ZVxuICAgICAgICAgICAgdXBkYXRlUG9pbnRlcnNFeGl0KCB0cmFja2VyLCBldmVudCwgYWJvcnRHUG9pbnRzICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIHRpbWUsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHRvdWNoQ291bnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgsXG4gICAgICAgICAgICBnUG9pbnRzID0gW10sXG4gICAgICAgICAgICBwYXJlbnRHUG9pbnRzLFxuICAgICAgICAgICAgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCAndG91Y2gnICk7XG5cbiAgICAgICAgdGltZSA9ICQubm93KCk7XG5cbiAgICAgICAgaWYgKCBwb2ludHNMaXN0LmdldExlbmd0aCgpID4gZXZlbnQudG91Y2hlcy5sZW5ndGggLSB0b3VjaENvdW50ICkge1xuICAgICAgICAgICAgJC5jb25zb2xlLndhcm4oJ1RyYWNrZWQgdG91Y2ggY29udGFjdCBjb3VudCBkb2VzblxcJ3QgbWF0Y2ggZXZlbnQudG91Y2hlcy5sZW5ndGguIFJlbW92aW5nIGFsbCB0cmFja2VkIHRvdWNoIHBvaW50ZXJzLicpO1xuICAgICAgICAgICAgYWJvcnRUb3VjaENvbnRhY3RzKCB0cmFja2VyLCBldmVudCwgcG9pbnRzTGlzdCApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCB0b3VjaENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBnUG9pbnRzLnB1c2goIHtcbiAgICAgICAgICAgICAgICBpZDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbIGkgXS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgLy8gaXNQcmltYXJ5IG5vdCBzZXQgLSBsZXQgdGhlIHVwZGF0ZVBvaW50ZXJzIGZ1bmN0aW9ucyBkZXRlcm1pbmUgaXRcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zOiBnZXRNb3VzZUFic29sdXRlKCBldmVudC5jaGFuZ2VkVG91Y2hlc1sgaSBdICksXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6IHRpbWVcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbXVsYXRlIHRvdWNoZW50ZXIgb24gb3VyIHRyYWNrZWQgZWxlbWVudFxuICAgICAgICB1cGRhdGVQb2ludGVyc0VudGVyKCB0cmFja2VyLCBldmVudCwgZ1BvaW50cyApO1xuXG4gICAgICAgIC8vIHNpbXVsYXRlIHRvdWNoZW50ZXIgb24gb3VyIHRyYWNrZWQgZWxlbWVudCdzIHRyYWNrZWQgYW5jZXN0b3IgZWxlbWVudHNcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBNT1VTRVRSQUNLRVJTLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCBNT1VTRVRSQUNLRVJTWyBpIF0gIT09IHRyYWNrZXIgJiYgTU9VU0VUUkFDS0VSU1sgaSBdLmlzVHJhY2tpbmcoKSAmJiBpc1BhcmVudENoaWxkKCBNT1VTRVRSQUNLRVJTWyBpIF0uZWxlbWVudCwgdHJhY2tlci5lbGVtZW50ICkgKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50R1BvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgdG91Y2hDb3VudDsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRHUG9pbnRzLnB1c2goIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBldmVudC5jaGFuZ2VkVG91Y2hlc1sgaiBdLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNQcmltYXJ5IG5vdCBzZXQgLSBsZXQgdGhlIHVwZGF0ZVBvaW50ZXJzIGZ1bmN0aW9ucyBkZXRlcm1pbmUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50LmNoYW5nZWRUb3VjaGVzWyBqIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiB0aW1lXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlUG9pbnRlcnNFbnRlciggTU9VU0VUUkFDS0VSU1sgaSBdLCBldmVudCwgcGFyZW50R1BvaW50cyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB1cGRhdGVQb2ludGVyc0Rvd24oIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzLCAwICkgKSB7IC8vIDAgbWVhbnMgcHJpbWFyeSBidXR0b24gcHJlc3MvcmVsZWFzZSBvciB0b3VjaCBjb250YWN0XG4gICAgICAgICAgICAkLnN0b3BFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIGNhcHR1cmVQb2ludGVyKCB0cmFja2VyLCAndG91Y2gnLCB0b3VjaENvdW50ICk7XG4gICAgICAgIH1cblxuICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaGFuZGxlVG91Y2hFbmQoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhhbmRsZXIgaXMgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdyBvYmplY3QgKG9uIHRoZSBjYXB0dXJlIHBoYXNlKSB0byBlbXVsYXRlIHBvaW50ZXIgY2FwdHVyZS5cbiAgICAgKiBvblRvdWNoRW5kIGlzIHN0aWxsIGF0dGFjaGVkIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQsIHNvIHN0b3AgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvY2Vzc2luZyB0d2ljZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZENhcHR1cmVkKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaGFuZGxlVG91Y2hFbmQoIHRyYWNrZXIsIGV2ZW50ICk7XG4gICAgICAgICQuc3RvcEV2ZW50KCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciB0aW1lLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICB0b3VjaENvdW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgZ1BvaW50cyA9IFtdLFxuICAgICAgICAgICAgcGFyZW50R1BvaW50cztcblxuICAgICAgICB0aW1lID0gJC5ub3coKTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHRvdWNoQ291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgIGdQb2ludHMucHVzaCgge1xuICAgICAgICAgICAgICAgIGlkOiBldmVudC5jaGFuZ2VkVG91Y2hlc1sgaSBdLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAvLyBpc1ByaW1hcnkgbm90IHNldCAtIGxldCB0aGUgdXBkYXRlUG9pbnRlcnMgZnVuY3Rpb25zIGRldGVybWluZSBpdFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50LmNoYW5nZWRUb3VjaGVzWyBpIF0gKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZTogdGltZVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB1cGRhdGVQb2ludGVyc1VwKCB0cmFja2VyLCBldmVudCwgZ1BvaW50cywgMCApICkge1xuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXIoIHRyYWNrZXIsICd0b3VjaCcsIHRvdWNoQ291bnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbXVsYXRlIHRvdWNobGVhdmUgb24gb3VyIHRyYWNrZWQgZWxlbWVudFxuICAgICAgICB1cGRhdGVQb2ludGVyc0V4aXQoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzICk7XG5cbiAgICAgICAgLy8gc2ltdWxhdGUgdG91Y2hsZWF2ZSBvbiBvdXIgdHJhY2tlZCBlbGVtZW50J3MgdHJhY2tlZCBhbmNlc3RvciBlbGVtZW50c1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IE1PVVNFVFJBQ0tFUlMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIE1PVVNFVFJBQ0tFUlNbIGkgXSAhPT0gdHJhY2tlciAmJiBNT1VTRVRSQUNLRVJTWyBpIF0uaXNUcmFja2luZygpICYmIGlzUGFyZW50Q2hpbGQoIE1PVVNFVFJBQ0tFUlNbIGkgXS5lbGVtZW50LCB0cmFja2VyLmVsZW1lbnQgKSApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRHUG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCB0b3VjaENvdW50OyBqKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEdQb2ludHMucHVzaCgge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWyBqIF0uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpc1ByaW1hcnkgbm90IHNldCAtIGxldCB0aGUgdXBkYXRlUG9pbnRlcnMgZnVuY3Rpb25zIGRldGVybWluZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQuY2hhbmdlZFRvdWNoZXNbIGogXSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWU6IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVQb2ludGVyc0V4aXQoIE1PVVNFVFJBQ0tFUlNbIGkgXSwgZXZlbnQsIHBhcmVudEdQb2ludHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaGFuZGxlVG91Y2hNb3ZlKCB0cmFja2VyLCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cgb2JqZWN0IChvbiB0aGUgY2FwdHVyZSBwaGFzZSkgdG8gZW11bGF0ZSBwb2ludGVyIGNhcHR1cmUuXG4gICAgICogb25Ub3VjaE1vdmUgaXMgc3RpbGwgYXR0YWNoZWQgdG8gdGhlIHRyYWNrZWQgZWxlbWVudCwgc28gc3RvcCBwcm9wYWdhdGlvbiB0byBhdm9pZCBwcm9jZXNzaW5nIHR3aWNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZUNhcHR1cmVkKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaGFuZGxlVG91Y2hNb3ZlKCB0cmFja2VyLCBldmVudCApO1xuICAgICAgICAkLnN0b3BFdmVudCggZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB0b3VjaENvdW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgZ1BvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdG91Y2hDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgZ1BvaW50cy5wdXNoKCB7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWyBpIF0uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2gnLFxuICAgICAgICAgICAgICAgIC8vIGlzUHJpbWFyeSBub3Qgc2V0IC0gbGV0IHRoZSB1cGRhdGVQb2ludGVycyBmdW5jdGlvbnMgZGV0ZXJtaW5lIGl0XG4gICAgICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQuY2hhbmdlZFRvdWNoZXNbIGkgXSApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiAkLm5vdygpXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVQb2ludGVyc01vdmUoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzICk7XG5cbiAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Ub3VjaENhbmNlbCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdG91Y2hDb3VudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGdQb2ludHMgPSBbXSxcbiAgICAgICAgICAgIHBvaW50c0xpc3QgPSB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggJ3RvdWNoJyApO1xuICAgICAgICBcbiAgICAgICAgYWJvcnRUb3VjaENvbnRhY3RzKCB0cmFja2VyLCBldmVudCwgcG9pbnRzTGlzdCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkdlc3R1cmVTdGFydCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uR2VzdHVyZUNoYW5nZSggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck92ZXIoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgZ1BvaW50O1xuXG4gICAgICAgIGlmICggZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBpc1BhcmVudENoaWxkKCBldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudC5yZWxhdGVkVGFyZ2V0ICkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogZXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogZ2V0UG9pbnRlclR5cGUoIGV2ZW50ICksXG4gICAgICAgICAgICBpc1ByaW1hcnk6IGV2ZW50LmlzUHJpbWFyeSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJzRW50ZXIoIHRyYWNrZXIsIGV2ZW50LCBbIGdQb2ludCBdICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck91dCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBnUG9pbnQ7XG5cbiAgICAgICAgaWYgKCBldmVudC5jdXJyZW50VGFyZ2V0ID09PSBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGlzUGFyZW50Q2hpbGQoIGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50LnJlbGF0ZWRUYXJnZXQgKSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdQb2ludCA9IHtcbiAgICAgICAgICAgIGlkOiBldmVudC5wb2ludGVySWQsXG4gICAgICAgICAgICB0eXBlOiBnZXRQb2ludGVyVHlwZSggZXZlbnQgKSxcbiAgICAgICAgICAgIGlzUHJpbWFyeTogZXZlbnQuaXNQcmltYXJ5LFxuICAgICAgICAgICAgY3VycmVudFBvczogZ2V0TW91c2VBYnNvbHV0ZSggZXZlbnQgKSxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiAkLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgdXBkYXRlUG9pbnRlcnNFeGl0KCB0cmFja2VyLCBldmVudCwgWyBnUG9pbnQgXSApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGdQb2ludDtcblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogZXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogZ2V0UG9pbnRlclR5cGUoIGV2ZW50ICksXG4gICAgICAgICAgICBpc1ByaW1hcnk6IGV2ZW50LmlzUHJpbWFyeSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggdXBkYXRlUG9pbnRlcnNEb3duKCB0cmFja2VyLCBldmVudCwgWyBnUG9pbnQgXSwgZXZlbnQuYnV0dG9uICkgKSB7XG4gICAgICAgICAgICAkLnN0b3BFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIGNhcHR1cmVQb2ludGVyKCB0cmFja2VyLCBnUG9pbnQudHlwZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0cmFja2VyLmNsaWNrSGFuZGxlciB8fCB0cmFja2VyLmRibENsaWNrSGFuZGxlciB8fCB0cmFja2VyLnByZXNzSGFuZGxlciB8fCB0cmFja2VyLmRyYWdIYW5kbGVyIHx8IHRyYWNrZXIuZHJhZ0VuZEhhbmRsZXIgfHwgdHJhY2tlci5waW5jaEhhbmRsZXIgKSB7XG4gICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgaGFuZGxlUG9pbnRlclVwKCB0cmFja2VyLCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cgb2JqZWN0IChvbiB0aGUgY2FwdHVyZSBwaGFzZSkgdG8gZW11bGF0ZSBtb3VzZSBjYXB0dXJlLlxuICAgICAqIG9uUG9pbnRlclVwIGlzIHN0aWxsIGF0dGFjaGVkIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQsIHNvIHN0b3AgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvY2Vzc2luZyB0d2ljZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyVXBDYXB0dXJlZCggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIHZhciBwb2ludHNMaXN0ID0gdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoIGdldFBvaW50ZXJUeXBlKCBldmVudCApICk7XG4gICAgICAgIGlmICggcG9pbnRzTGlzdC5nZXRCeUlkKCBldmVudC5wb2ludGVySWQgKSApIHtcbiAgICAgICAgICAgIGhhbmRsZVBvaW50ZXJVcCggdHJhY2tlciwgZXZlbnQgKTtcbiAgICAgICAgfVxuICAgICAgICAkLnN0b3BFdmVudCggZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlclVwKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGdQb2ludDtcblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogZXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogZ2V0UG9pbnRlclR5cGUoIGV2ZW50ICksXG4gICAgICAgICAgICBpc1ByaW1hcnk6IGV2ZW50LmlzUHJpbWFyeSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggdXBkYXRlUG9pbnRlcnNVcCggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0sIGV2ZW50LmJ1dHRvbiApICkge1xuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXIoIHRyYWNrZXIsIGdQb2ludC50eXBlICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZSggdHJhY2tlciwgZXZlbnQgKSB7XG4gICAgICAgIGhhbmRsZVBvaW50ZXJNb3ZlKCB0cmFja2VyLCBldmVudCApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cgb2JqZWN0IChvbiB0aGUgY2FwdHVyZSBwaGFzZSkgdG8gZW11bGF0ZSBtb3VzZSBjYXB0dXJlLlxuICAgICAqIG9uUG9pbnRlck1vdmUgaXMgc3RpbGwgYXR0YWNoZWQgdG8gdGhlIHRyYWNrZWQgZWxlbWVudCwgc28gc3RvcCBwcm9wYWdhdGlvbiB0byBhdm9pZCBwcm9jZXNzaW5nIHR3aWNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlQ2FwdHVyZWQoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICB2YXIgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCBnZXRQb2ludGVyVHlwZSggZXZlbnQgKSApO1xuICAgICAgICBpZiAoIHBvaW50c0xpc3QuZ2V0QnlJZCggZXZlbnQucG9pbnRlcklkICkgKSB7XG4gICAgICAgICAgICBoYW5kbGVQb2ludGVyTW92ZSggdHJhY2tlciwgZXZlbnQgKTtcbiAgICAgICAgfVxuICAgICAgICAkLnN0b3BFdmVudCggZXZlbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmUoIHRyYWNrZXIsIGV2ZW50ICkge1xuICAgICAgICAvLyBQb2ludGVyIGNoYW5nZWQgY29vcmRpbmF0ZXMsIGJ1dHRvbiBzdGF0ZSwgcHJlc3N1cmUsIHRpbHQsIG9yIGNvbnRhY3QgZ2VvbWV0cnkgKGUuZy4gd2lkdGggYW5kIGhlaWdodClcbiAgICAgICAgdmFyIGdQb2ludDtcblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogZXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogZ2V0UG9pbnRlclR5cGUoIGV2ZW50ICksXG4gICAgICAgICAgICBpc1ByaW1hcnk6IGV2ZW50LmlzUHJpbWFyeSxcbiAgICAgICAgICAgIGN1cnJlbnRQb3M6IGdldE1vdXNlQWJzb2x1dGUoIGV2ZW50ICksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogJC5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJzTW92ZSggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0gKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyQ2FuY2VsKCB0cmFja2VyLCBldmVudCApIHtcbiAgICAgICAgdmFyIGdQb2ludDtcblxuICAgICAgICBnUG9pbnQgPSB7XG4gICAgICAgICAgICBpZDogZXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgdHlwZTogZ2V0UG9pbnRlclR5cGUoIGV2ZW50IClcbiAgICAgICAgfTtcblxuICAgICAgICB1cGRhdGVQb2ludGVyc0NhbmNlbCggdHJhY2tlciwgZXZlbnQsIFsgZ1BvaW50IF0gKTtcbiAgICB9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGV2aWNlLWFnbm9zdGljIERPTSBldmVudCBoYW5kbGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludExpc3R9IHBvaW50c0xpc3RcbiAgICAgKiAgICAgVGhlIEdlc3R1cmVQb2ludExpc3QgdG8gdHJhY2sgdGhlIHBvaW50ZXIgaW4uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnR9IGdQb2ludFxuICAgICAqICAgICAgR2VzdHVyZSBwb2ludCB0byB0cmFjay5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBOdW1iZXIgb2YgZ2VzdHVyZSBwb2ludHMgaW4gcG9pbnRzTGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydFRyYWNraW5nUG9pbnRlciggcG9pbnRzTGlzdCwgZ1BvaW50ICkge1xuXG4gICAgICAgIC8vIElmIGlzUHJpbWFyeSBpcyBub3Qga25vd24gZm9yIHRoZSBwb2ludGVyIHRoZW4gc2V0IGl0IGFjY29yZGluZyB0byBvdXIgcnVsZXM6XG4gICAgICAgIC8vICAgIHRydWUgaWYgdGhlIGZpcnN0IHBvaW50ZXIgaW4gdGhlIGdlc3R1cmUsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICBpZiAoICFnUG9pbnQuaGFzT3duUHJvcGVydHkoICdpc1ByaW1hcnknICkgKSB7XG4gICAgICAgICAgICBpZiAoIHBvaW50c0xpc3QuZ2V0TGVuZ3RoKCkgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgZ1BvaW50LmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdQb2ludC5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnUG9pbnQuc3BlZWQgPSAwO1xuICAgICAgICBnUG9pbnQuZGlyZWN0aW9uID0gMDtcbiAgICAgICAgZ1BvaW50LmNvbnRhY3RQb3MgPSBnUG9pbnQuY3VycmVudFBvcztcbiAgICAgICAgZ1BvaW50LmNvbnRhY3RUaW1lID0gZ1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICBnUG9pbnQubGFzdFBvcyA9IGdQb2ludC5jdXJyZW50UG9zO1xuICAgICAgICBnUG9pbnQubGFzdFRpbWUgPSBnUG9pbnQuY3VycmVudFRpbWU7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50c0xpc3QuYWRkKCBnUG9pbnQgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnRMaXN0fSBwb2ludHNMaXN0XG4gICAgICogICAgIFRoZSBHZXN0dXJlUG9pbnRMaXN0IHRvIHN0b3AgdHJhY2tpbmcgdGhlIHBvaW50ZXIgb24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnR9IGdQb2ludFxuICAgICAqICAgICAgR2VzdHVyZSBwb2ludCB0byBzdG9wIHRyYWNraW5nLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiBnZXN0dXJlIHBvaW50cyBpbiBwb2ludHNMaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3BUcmFja2luZ1BvaW50ZXIoIHBvaW50c0xpc3QsIGdQb2ludCApIHtcbiAgICAgICAgdmFyIGxpc3RMZW5ndGgsXG4gICAgICAgICAgICBwcmltYXJ5UG9pbnQ7XG5cbiAgICAgICAgaWYgKCBwb2ludHNMaXN0LmdldEJ5SWQoIGdQb2ludC5pZCApICkge1xuICAgICAgICAgICAgbGlzdExlbmd0aCA9IHBvaW50c0xpc3QucmVtb3ZlQnlJZCggZ1BvaW50LmlkICk7XG5cbiAgICAgICAgICAgIC8vIElmIGlzUHJpbWFyeSBpcyBub3Qga25vd24gZm9yIHRoZSBwb2ludGVyIGFuZCB3ZSBqdXN0IHJlbW92ZWQgdGhlIHByaW1hcnkgcG9pbnRlciBmcm9tIHRoZSBsaXN0IHRoZW4gd2UgbmVlZCB0byBzZXQgYW5vdGhlciBwb2ludGVyIGFzIHByaW1hcnlcbiAgICAgICAgICAgIGlmICggIWdQb2ludC5oYXNPd25Qcm9wZXJ0eSggJ2lzUHJpbWFyeScgKSApIHtcbiAgICAgICAgICAgICAgICBwcmltYXJ5UG9pbnQgPSBwb2ludHNMaXN0LmdldFByaW1hcnkoKTtcbiAgICAgICAgICAgICAgICBpZiAoICFwcmltYXJ5UG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlQb2ludCA9IHBvaW50c0xpc3QuZ2V0QnlJbmRleCggMCApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHByaW1hcnlQb2ludCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlQb2ludC5pc1ByaW1hcnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdExlbmd0aCA9IHBvaW50c0xpc3QuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdExlbmd0aDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlclxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYXRpbmcgRE9NIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludD59IGdQb2ludHNcbiAgICAgKiAgICAgIEdlc3R1cmUgcG9pbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlcnNFbnRlciggdHJhY2tlciwgZXZlbnQsIGdQb2ludHMgKSB7XG4gICAgICAgIHZhciBwb2ludHNMaXN0ID0gdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoIGdQb2ludHNbIDAgXS50eXBlICksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgZ1BvaW50Q291bnQgPSBnUG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1ckdQb2ludCxcbiAgICAgICAgICAgIHVwZGF0ZUdQb2ludCxcbiAgICAgICAgICAgIHByb3BhZ2F0ZTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGdQb2ludENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBjdXJHUG9pbnQgPSBnUG9pbnRzWyBpIF07XG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQgPSBwb2ludHNMaXN0LmdldEJ5SWQoIGN1ckdQb2ludC5pZCApO1xuXG4gICAgICAgICAgICBpZiAoIHVwZGF0ZUdQb2ludCApIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHRyYWNraW5nIHRoZSBwb2ludGVyLi4udXBkYXRlIGl0XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50Lmluc2lkZUVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0UG9zID0gdXBkYXRlR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50Lmxhc3RUaW1lID0gdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zID0gY3VyR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lID0gY3VyR1BvaW50LmN1cnJlbnRUaW1lO1xuXG4gICAgICAgICAgICAgICAgY3VyR1BvaW50ID0gdXBkYXRlR1BvaW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGZvciB0cmFja2luZyBhbmQgYWRkIHRvIHRoZSB0cmFja2luZyBsaXN0XG4gICAgICAgICAgICAgICAgY3VyR1BvaW50LmNhcHR1cmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VyR1BvaW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VyR1BvaW50Lmluc2lkZUVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXJ0VHJhY2tpbmdQb2ludGVyKCBwb2ludHNMaXN0LCBjdXJHUG9pbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW50ZXJcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5lbnRlckhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5lbnRlckhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgIGN1ckdQb2ludC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCBjdXJHUG9pbnQuY3VycmVudFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcnM6ICAgICAgICAgICAgIHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlckNvdW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogY3VyR1BvaW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRG93bkFueTogICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyAhPT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICBjdXJHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlclxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYXRpbmcgRE9NIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludD59IGdQb2ludHNcbiAgICAgKiAgICAgIEdlc3R1cmUgcG9pbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlcnNFeGl0KCB0cmFja2VyLCBldmVudCwgZ1BvaW50cyApIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gVEhJU1sgdHJhY2tlci5oYXNoIF0sXG4gICAgICAgICAgICBwb2ludHNMaXN0ID0gdHJhY2tlci5nZXRBY3RpdmVQb2ludGVyc0xpc3RCeVR5cGUoIGdQb2ludHNbIDAgXS50eXBlICksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgZ1BvaW50Q291bnQgPSBnUG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1ckdQb2ludCxcbiAgICAgICAgICAgIHVwZGF0ZUdQb2ludCxcbiAgICAgICAgICAgIHByb3BhZ2F0ZTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGdQb2ludENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBjdXJHUG9pbnQgPSBnUG9pbnRzWyBpIF07XG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQgPSBwb2ludHNMaXN0LmdldEJ5SWQoIGN1ckdQb2ludC5pZCApO1xuXG4gICAgICAgICAgICBpZiAoIHVwZGF0ZUdQb2ludCApIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHRyYWNraW5nIHRoZSBwb2ludGVyLiBJZiBjYXB0dXJlZCB0aGVuIHVwZGF0ZSBpdCwgZWxzZSBzdG9wIHRyYWNraW5nIGl0XG4gICAgICAgICAgICAgICAgaWYgKCB1cGRhdGVHUG9pbnQuY2FwdHVyZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0UG9zID0gdXBkYXRlR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0VGltZSA9IHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmN1cnJlbnRQb3MgPSBjdXJHUG9pbnQuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lID0gY3VyR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BUcmFja2luZ1BvaW50ZXIoIHBvaW50c0xpc3QsIHVwZGF0ZUdQb2ludCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1ckdQb2ludCA9IHVwZGF0ZUdQb2ludDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXhpdFxuICAgICAgICAgICAgaWYgKCB0cmFja2VyLmV4aXRIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIuZXhpdEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgIGN1ckdQb2ludC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCBjdXJHUG9pbnQuY3VycmVudFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcnM6ICAgICAgICAgICAgIHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlckNvdW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogdXBkYXRlR1BvaW50ID8gdXBkYXRlR1BvaW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Eb3duQW55OiAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zICE9PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiAgICAgICAgIGN1ckdQb2ludC50eXBlID09PSAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXJcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmF0aW5nIERPTSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnQ+fSBnUG9pbnRzXG4gICAgICogICAgICBHZXN0dXJlIHBvaW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBidXR0b25DaGFuZ2VkXG4gICAgICogICAgICBUaGUgYnV0dG9uIGludm9sdmVkIGluIHRoZSBldmVudDogLTE6IG5vbmUsIDA6IHByaW1hcnkvbGVmdCwgMTogYXV4L21pZGRsZSwgMjogc2Vjb25kYXJ5L3JpZ2h0LCAzOiBYMS9iYWNrLCA0OiBYMi9mb3J3YXJkLCA1OiBwZW4gZXJhc2VyLlxuICAgICAqICAgICAgTm90ZSBvbiBjaG9yZGVkIGJ1dHRvbiBwcmVzc2VzIChhIGJ1dHRvbiBwcmVzc2VkIHdoZW4gYW5vdGhlciBidXR0b24gaXMgYWxyZWFkeSBwcmVzc2VkKTogSW4gdGhlIFczQyBQb2ludGVyIEV2ZW50cyBtb2RlbCxcbiAgICAgKiAgICAgIG9ubHkgb25lIHBvaW50ZXJkb3duL3BvaW50ZXJ1cCBldmVudCBjb21ibyBpcyBmaXJlZC4gQ2hvcmRlZCBidXR0b24gc3RhdGUgY2hhbmdlcyBpbnN0ZWFkIGZpcmUgcG9pbnRlcm1vdmUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgcG9pbnRlcnMgc2hvdWxkIGJlIGNhcHR1cmVkIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyc0Rvd24oIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzLCBidXR0b25DaGFuZ2VkICkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0cmFja2VyLmhhc2ggXSxcbiAgICAgICAgICAgIHByb3BhZ2F0ZSxcbiAgICAgICAgICAgIHBvaW50c0xpc3QgPSB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggZ1BvaW50c1sgMCBdLnR5cGUgKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBnUG9pbnRDb3VudCA9IGdQb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgY3VyR1BvaW50LFxuICAgICAgICAgICAgdXBkYXRlR1BvaW50O1xuXG4gICAgICAgIGlmICggdHlwZW9mIGV2ZW50LmJ1dHRvbnMgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggJC5Ccm93c2VyLnZlbmRvciA9PT0gJC5CUk9XU0VSUy5JRSAmJiAkLkJyb3dzZXIudmVyc2lvbiA8IDkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBidXR0b25DaGFuZ2VkID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltYXJ5XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1eFxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgKz0gNDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmRhcnlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWDEgKEJhY2spXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyArPSA4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFgyIChGb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgKz0gMTY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gNSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVuIEVyYXNlclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgKz0gMzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1hcnlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIHw9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXV4XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyB8PSA0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlY29uZGFyeVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgfD0gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAzICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBYMSAoQmFjaylcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIHw9IDg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gNCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWDIgKEZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyB8PSAxNjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSA1ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQZW4gRXJhc2VyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyB8PSAzMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGNhcHR1cmUgYW5kIHRyYWNrIHByaW1hcnkgYnV0dG9uLCBwZW4sIGFuZCB0b3VjaCBjb250YWN0c1xuICAgICAgICBpZiAoIGJ1dHRvbkNoYW5nZWQgIT09IDAgKSB7XG4gICAgICAgICAgICAvLyBBdXggUHJlc3NcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5ub25QcmltYXJ5UHJlc3NIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIubm9uUHJpbWFyeVByZXNzSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgZ1BvaW50c1sgMCBdLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIGdQb2ludHNbIDAgXS5jdXJyZW50UG9zLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogICAgICAgICAgICAgICBidXR0b25DaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICBnUG9pbnRzWyAwIF0udHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZ1BvaW50Q291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgIGN1ckdQb2ludCA9IGdQb2ludHNbIGkgXTtcbiAgICAgICAgICAgIHVwZGF0ZUdQb2ludCA9IHBvaW50c0xpc3QuZ2V0QnlJZCggY3VyR1BvaW50LmlkICk7XG5cbiAgICAgICAgICAgIGlmICggdXBkYXRlR1BvaW50ICkge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgdHJhY2tpbmcgdGhlIHBvaW50ZXIuLi51cGRhdGUgaXRcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuY2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50UHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50Lmluc2lkZUVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jb250YWN0UG9zID0gY3VyR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmNvbnRhY3RUaW1lID0gY3VyR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0UG9zID0gdXBkYXRlR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50Lmxhc3RUaW1lID0gdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zID0gY3VyR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lID0gY3VyR1BvaW50LmN1cnJlbnRUaW1lO1xuXG4gICAgICAgICAgICAgICAgY3VyR1BvaW50ID0gdXBkYXRlR1BvaW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGZvciB0cmFja2luZyBhbmQgYWRkIHRvIHRoZSB0cmFja2luZyBsaXN0IChubyBwb2ludGVyb3ZlciBvciBwb2ludGVybW92ZSBldmVudCBvY2N1cnJlZCBiZWZvcmUgdGhpcylcbiAgICAgICAgICAgICAgICBjdXJHUG9pbnQuY2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN1ckdQb2ludC5pbnNpZGVFbGVtZW50UHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VyR1BvaW50Lmluc2lkZUVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXJ0VHJhY2tpbmdQb2ludGVyKCBwb2ludHNMaXN0LCBjdXJHUG9pbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9pbnRzTGlzdC5jb250YWN0cysrO1xuICAgICAgICAgICAgLy8kLmNvbnNvbGUubG9nKCdjb250YWN0cysrICcsIHBvaW50c0xpc3QuY29udGFjdHMpO1xuXG4gICAgICAgICAgICBpZiAoIHRyYWNrZXIuZHJhZ0hhbmRsZXIgfHwgdHJhY2tlci5kcmFnRW5kSGFuZGxlciB8fCB0cmFja2VyLnBpbmNoSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAkLk1vdXNlVHJhY2tlci5nZXN0dXJlUG9pbnRWZWxvY2l0eVRyYWNrZXIuYWRkUG9pbnQoIHRyYWNrZXIsIGN1ckdQb2ludCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHBvaW50c0xpc3QuY29udGFjdHMgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlc3NcbiAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIucHJlc3NIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLnByZXNzSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgY3VyR1BvaW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgIGdldFBvaW50UmVsYXRpdmVUb0Fic29sdXRlKCBjdXJHUG9pbnQuY29udGFjdFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgY3VyR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggcG9pbnRzTGlzdC5jb250YWN0cyA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIucGluY2hIYW5kbGVyICYmIGN1ckdQb2ludC50eXBlID09PSAndG91Y2gnICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGZvciBwaW5jaFxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5waW5jaEdQb2ludHMgPSBwb2ludHNMaXN0LmFzQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubGFzdFBpbmNoRGlzdCA9IGRlbGVnYXRlLmN1cnJlbnRQaW5jaERpc3QgPSBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDAgXS5jdXJyZW50UG9zLmRpc3RhbmNlVG8oIGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMSBdLmN1cnJlbnRQb3MgKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubGFzdFBpbmNoQ2VudGVyID0gZGVsZWdhdGUuY3VycmVudFBpbmNoQ2VudGVyID0gZ2V0Q2VudGVyUG9pbnQoIGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMCBdLmN1cnJlbnRQb3MsIGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMSBdLmN1cnJlbnRQb3MgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlclxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgICBBIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYXRpbmcgRE9NIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyLkdlc3R1cmVQb2ludD59IGdQb2ludHNcbiAgICAgKiAgICAgIEdlc3R1cmUgcG9pbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJ1dHRvbkNoYW5nZWRcbiAgICAgKiAgICAgIFRoZSBidXR0b24gaW52b2x2ZWQgaW4gdGhlIGV2ZW50OiAtMTogbm9uZSwgMDogcHJpbWFyeS9sZWZ0LCAxOiBhdXgvbWlkZGxlLCAyOiBzZWNvbmRhcnkvcmlnaHQsIDM6IFgxL2JhY2ssIDQ6IFgyL2ZvcndhcmQsIDU6IHBlbiBlcmFzZXIuXG4gICAgICogICAgICBOb3RlIG9uIGNob3JkZWQgYnV0dG9uIHByZXNzZXMgKGEgYnV0dG9uIHByZXNzZWQgd2hlbiBhbm90aGVyIGJ1dHRvbiBpcyBhbHJlYWR5IHByZXNzZWQpOiBJbiB0aGUgVzNDIFBvaW50ZXIgRXZlbnRzIG1vZGVsLFxuICAgICAqICAgICAgb25seSBvbmUgcG9pbnRlcmRvd24vcG9pbnRlcnVwIGV2ZW50IGNvbWJvIGlzIGZpcmVkLiBDaG9yZGVkIGJ1dHRvbiBzdGF0ZSBjaGFuZ2VzIGluc3RlYWQgZmlyZSBwb2ludGVybW92ZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBwb2ludGVyIGNhcHR1cmUgc2hvdWxkIGJlIHJlbGVhc2VkIGZyb20gdGhlIHRyYWNrZWQgZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJzVXAoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzLCBidXR0b25DaGFuZ2VkICkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBUSElTWyB0cmFja2VyLmhhc2ggXSxcbiAgICAgICAgICAgIHBvaW50c0xpc3QgPSB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggZ1BvaW50c1sgMCBdLnR5cGUgKSxcbiAgICAgICAgICAgIHByb3BhZ2F0ZSxcbiAgICAgICAgICAgIGluc2lkZUVsZW1lbnRSZWxlYXNlZCxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludCxcbiAgICAgICAgICAgIHJlbGVhc2VUaW1lLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGdQb2ludENvdW50ID0gZ1BvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjdXJHUG9pbnQsXG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQsXG4gICAgICAgICAgICByZWxlYXNlQ2FwdHVyZSA9IGZhbHNlLFxuICAgICAgICAgICAgd2FzQ2FwdHVyZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIHF1aWNrO1xuXG4gICAgICAgIGlmICggdHlwZW9mIGV2ZW50LmJ1dHRvbnMgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggJC5Ccm93c2VyLnZlbmRvciA9PT0gJC5CUk9XU0VSUy5JRSAmJiAkLkJyb3dzZXIudmVyc2lvbiA8IDkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBidXR0b25DaGFuZ2VkID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltYXJ5XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1eFxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgLT0gNDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmRhcnlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIC09IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWDEgKEJhY2spXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyAtPSA4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFgyIChGb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgLT0gMTY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gNSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVuIEVyYXNlclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgLT0gMzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1hcnlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIF49IH4xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1eFxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgXj0gfjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnV0dG9uQ2hhbmdlZCA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kYXJ5XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyBePSB+MjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBidXR0b25DaGFuZ2VkID09PSAzICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBYMSAoQmFjaylcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIF49IH44O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFgyIChGb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMgXj0gfjE2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ1dHRvbkNoYW5nZWQgPT09IDUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlbiBFcmFzZXJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zIF49IH4zMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGNhcHR1cmUgYW5kIHRyYWNrIHByaW1hcnkgYnV0dG9uLCBwZW4sIGFuZCB0b3VjaCBjb250YWN0c1xuICAgICAgICBpZiAoIGJ1dHRvbkNoYW5nZWQgIT09IDAgKSB7XG4gICAgICAgICAgICAvLyBBdXggUmVsZWFzZVxuICAgICAgICAgICAgaWYgKCB0cmFja2VyLm5vblByaW1hcnlSZWxlYXNlSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLm5vblByaW1hcnlSZWxlYXNlSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgICBnUG9pbnRzWyAwIF0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoICBnUG9pbnRzWyAwIF0uY3VycmVudFBvcywgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246ICAgICAgICAgICAgICAgIGJ1dHRvbkNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiAgICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICAgZ1BvaW50c1sgMCBdLnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246ICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGdQb2ludENvdW50OyBpKysgKSB7XG4gICAgICAgICAgICBjdXJHUG9pbnQgPSBnUG9pbnRzWyBpIF07XG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQgPSBwb2ludHNMaXN0LmdldEJ5SWQoIGN1ckdQb2ludC5pZCApO1xuXG4gICAgICAgICAgICBpZiAoIHVwZGF0ZUdQb2ludCApIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBvaW50ZXIsIHN0b3AgdHJhY2tpbmcgaXQgaWYgbm90IHN0aWxsIGluIHRoaXMgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICggdXBkYXRlR1BvaW50LmNhcHR1cmVkICkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQuY2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUNhcHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3YXNDYXB0dXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0UG9zID0gdXBkYXRlR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50Lmxhc3RUaW1lID0gdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zID0gY3VyR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lID0gY3VyR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIGlmICggIXVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wVHJhY2tpbmdQb2ludGVyKCBwb2ludHNMaXN0LCB1cGRhdGVHUG9pbnQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWxlYXNlUG9pbnQgPSB1cGRhdGVHUG9pbnQuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICByZWxlYXNlVGltZSA9IHVwZGF0ZUdQb2ludC5jdXJyZW50VGltZTtcblxuICAgICAgICAgICAgICAgIGlmICggd2FzQ2FwdHVyZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvaW50ZXIgd2FzIGFjdGl2YXRlZCBpbiBvdXIgZWxlbWVudCBidXQgY291bGQgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gYW55IGVsZW1lbnQgc2luY2UgZXZlbnRzIGFyZSBjYXB0dXJlZCB0byBvdXIgZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0xpc3QuY29udGFjdHMtLTtcbiAgICAgICAgICAgICAgICAgICAgLy8kLmNvbnNvbGUubG9nKCdjb250YWN0cy0tICcsIHBvaW50c0xpc3QuY29udGFjdHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHJhY2tlci5kcmFnSGFuZGxlciB8fCB0cmFja2VyLmRyYWdFbmRIYW5kbGVyIHx8IHRyYWNrZXIucGluY2hIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5Nb3VzZVRyYWNrZXIuZ2VzdHVyZVBvaW50VmVsb2NpdHlUcmFja2VyLnJlbW92ZVBvaW50KCB0cmFja2VyLCB1cGRhdGVHUG9pbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcG9pbnRzTGlzdC5jb250YWN0cyA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVsZWFzZSAocHJlc3NlZCBpbiBvdXIgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHJhY2tlci5yZWxlYXNlSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLnJlbGVhc2VIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgIHVwZGF0ZUdQb2ludC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggcmVsZWFzZVBvaW50LCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlRWxlbWVudFByZXNzZWQ6ICB1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudFByZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVFbGVtZW50UmVsZWFzZWQ6IHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiAgICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERyYWcgRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIuZHJhZ0VuZEhhbmRsZXIgJiYgIXVwZGF0ZUdQb2ludC5jdXJyZW50UG9zLmVxdWFscyggdXBkYXRlR1BvaW50LmNvbnRhY3RQb3MgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmRyYWdFbmRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggdXBkYXRlR1BvaW50LmN1cnJlbnRQb3MsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWQ6ICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5zcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogICAgICAgICAgICB1cGRhdGVHUG9pbnQuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiAgICAgICAgIHVwZGF0ZUdQb2ludC50eXBlID09PSAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xpY2sgLyBEb3VibGUtQ2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB0cmFja2VyLmNsaWNrSGFuZGxlciB8fCB0cmFja2VyLmRibENsaWNrSGFuZGxlciApICYmIHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1aWNrID0gcmVsZWFzZVRpbWUgLSB1cGRhdGVHUG9pbnQuY29udGFjdFRpbWUgPD0gdHJhY2tlci5jbGlja1RpbWVUaHJlc2hvbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmNvbnRhY3RQb3MuZGlzdGFuY2VUbyggcmVsZWFzZVBvaW50ICkgPD0gdHJhY2tlci5jbGlja0Rpc3RUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHJhY2tlci5jbGlja0hhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIuY2xpY2tIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWljazogICAgICAgICAgICAgICAgcXVpY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb3VibGUtQ2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYWNrZXIuZGJsQ2xpY2tIYW5kbGVyICYmIHF1aWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmNsaWNrcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBvaW50c0xpc3QuY2xpY2tzID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubGFzdENsaWNrUG9zID0gcmVsZWFzZVBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5kYmxDbGlja1RpbWVPdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmNsaWNrcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0cmFja2VyLmRibENsaWNrVGltZVRocmVzaG9sZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6ZmFsc2UqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBwb2ludHNMaXN0LmNsaWNrcyA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggZGVsZWdhdGUuZGJsQ2xpY2tUaW1lT3V0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNMaXN0LmNsaWNrcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRlbGVnYXRlLmxhc3RDbGlja1Bvcy5kaXN0YW5jZVRvKCByZWxlYXNlUG9pbnQgKSA8PSB0cmFja2VyLmRibENsaWNrRGlzdFRocmVzaG9sZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLmRibENsaWNrSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0OiAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5sYXN0Q2xpY2tQb3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBwb2ludHNMaXN0LmNvbnRhY3RzID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0cmFja2VyLnBpbmNoSGFuZGxlciAmJiB1cGRhdGVHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBmb3IgcGluY2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5waW5jaEdQb2ludHMgPSBwb2ludHNMaXN0LmFzQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5sYXN0UGluY2hEaXN0ID0gZGVsZWdhdGUuY3VycmVudFBpbmNoRGlzdCA9IGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMCBdLmN1cnJlbnRQb3MuZGlzdGFuY2VUbyggZGVsZWdhdGUucGluY2hHUG9pbnRzWyAxIF0uY3VycmVudFBvcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmxhc3RQaW5jaENlbnRlciA9IGRlbGVnYXRlLmN1cnJlbnRQaW5jaENlbnRlciA9IGdldENlbnRlclBvaW50KCBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDAgXS5jdXJyZW50UG9zLCBkZWxlZ2F0ZS5waW5jaEdQb2ludHNbIDEgXS5jdXJyZW50UG9zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQb2ludGVyIHdhcyBhY3RpdmF0ZWQgaW4gYW5vdGhlciBlbGVtZW50IGJ1dCByZW1vdmVkIGluIG91ciBlbGVtZW50XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVsZWFzZSAocHJlc3NlZCBpbiBhbm90aGVyIGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHJhY2tlci5yZWxlYXNlSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIucmVsZWFzZUhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIHJlbGVhc2VQb2ludCwgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogIHVwZGF0ZUdQb2ludC5pbnNpZGVFbGVtZW50UHJlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlRWxlbWVudFJlbGVhc2VkOiB1cGRhdGVHUG9pbnQuaW5zaWRlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiAgICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246ICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmNhbmNlbEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbGVhc2VDYXB0dXJlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB3aGVuIHBvaW50ZXIocykgY2hhbmdlIGNvb3JkaW5hdGVzLCBidXR0b24gc3RhdGUsIHByZXNzdXJlLCB0aWx0LCBvciBjb250YWN0IGdlb21ldHJ5IChlLmcuIHdpZHRoIGFuZCBoZWlnaHQpXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXJcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgICAgQSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmF0aW5nIERPTSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnQ+fSBnUG9pbnRzXG4gICAgICogICAgICBHZXN0dXJlIHBvaW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJzTW92ZSggdHJhY2tlciwgZXZlbnQsIGdQb2ludHMgKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IFRISVNbIHRyYWNrZXIuaGFzaCBdLFxuICAgICAgICAgICAgcG9pbnRzTGlzdCA9IHRyYWNrZXIuZ2V0QWN0aXZlUG9pbnRlcnNMaXN0QnlUeXBlKCBnUG9pbnRzWyAwIF0udHlwZSApLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGdQb2ludENvdW50ID0gZ1BvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjdXJHUG9pbnQsXG4gICAgICAgICAgICB1cGRhdGVHUG9pbnQsXG4gICAgICAgICAgICBnUG9pbnRBcnJheSxcbiAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgcHJvcGFnYXRlO1xuXG4gICAgICAgIGlmICggdHlwZW9mIGV2ZW50LmJ1dHRvbnMgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgcG9pbnRzTGlzdC5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZ1BvaW50Q291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgIGN1ckdQb2ludCA9IGdQb2ludHNbIGkgXTtcbiAgICAgICAgICAgIHVwZGF0ZUdQb2ludCA9IHBvaW50c0xpc3QuZ2V0QnlJZCggY3VyR1BvaW50LmlkICk7XG5cbiAgICAgICAgICAgIGlmICggdXBkYXRlR1BvaW50ICkge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgdHJhY2tpbmcgdGhlIHBvaW50ZXIuLi51cGRhdGUgaXRcbiAgICAgICAgICAgICAgICBpZiAoIGN1ckdQb2ludC5oYXNPd25Qcm9wZXJ0eSggJ2lzUHJpbWFyeScgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmlzUHJpbWFyeSA9IGN1ckdQb2ludC5pc1ByaW1hcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5sYXN0UG9zID0gdXBkYXRlR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50Lmxhc3RUaW1lID0gdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zID0gY3VyR1BvaW50LmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LmN1cnJlbnRUaW1lID0gY3VyR1BvaW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGZvciB0cmFja2luZyBhbmQgYWRkIHRvIHRoZSB0cmFja2luZyBsaXN0IChubyBwb2ludGVyb3ZlciBvciBwb2ludGVyZG93biBldmVudCBvY2N1cnJlZCBiZWZvcmUgdGhpcylcbiAgICAgICAgICAgICAgICBjdXJHUG9pbnQuY2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjdXJHUG9pbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjdXJHUG9pbnQuaW5zaWRlRWxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhcnRUcmFja2luZ1BvaW50ZXIoIHBvaW50c0xpc3QsIGN1ckdQb2ludCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcCAobW91c2Ugb25seSlcbiAgICAgICAgaWYgKCB0cmFja2VyLnN0b3BIYW5kbGVyICYmIGdQb2ludHNbIDAgXS50eXBlID09PSAnbW91c2UnICkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0cmFja2VyLnN0b3BUaW1lT3V0ICk7XG4gICAgICAgICAgICB0cmFja2VyLnN0b3BUaW1lT3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUG9pbnRlclN0b3AoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzWyAwIF0udHlwZSApO1xuICAgICAgICAgICAgfSwgdHJhY2tlci5zdG9wRGVsYXkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcG9pbnRzTGlzdC5jb250YWN0cyA9PT0gMCApIHtcbiAgICAgICAgICAgIC8vIE1vdmUgKG5vIGNvbnRhY3RzOiBob3ZlcmluZyBtb3VzZSBvciBvdGhlciBob3Zlci1jYXBhYmxlIGRldmljZSlcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5tb3ZlSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLm1vdmVIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICBnUG9pbnRzWyAwIF0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggZ1BvaW50c1sgMCBdLmN1cnJlbnRQb3MsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICBnUG9pbnRzWyAwIF0udHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIHBvaW50c0xpc3QuY29udGFjdHMgPT09IDEgKSB7XG4gICAgICAgICAgICAvLyBNb3ZlICgxIGNvbnRhY3QpXG4gICAgICAgICAgICBpZiAoIHRyYWNrZXIubW92ZUhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50ID0gcG9pbnRzTGlzdC5hc0FycmF5KClbIDAgXTtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLm1vdmVIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggdXBkYXRlR1BvaW50LmN1cnJlbnRQb3MsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICB1cGRhdGVHUG9pbnQudHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICggcHJvcGFnYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERyYWdcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5kcmFnSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVHUG9pbnQgPSBwb2ludHNMaXN0LmFzQXJyYXkoKVsgMCBdO1xuICAgICAgICAgICAgICAgIGRlbHRhID0gdXBkYXRlR1BvaW50LmN1cnJlbnRQb3MubWludXMoIHVwZGF0ZUdQb2ludC5sYXN0UG9zICk7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlID0gdHJhY2tlci5kcmFnSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2U6ICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIHVwZGF0ZUdQb2ludC5jdXJyZW50UG9zLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICBwb2ludHNMaXN0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogICAgICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVlZDogICAgICAgICAgICAgICAgdXBkYXRlR1BvaW50LnNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAgICAgICAgICAgIHVwZGF0ZUdQb2ludC5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdDogICAgICAgICAgICAgICAgZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6ICAgICAgICAgdXBkYXRlR1BvaW50LnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCBwb2ludHNMaXN0LmNvbnRhY3RzID09PSAyICkge1xuICAgICAgICAgICAgLy8gTW92ZSAoMiBjb250YWN0cywgdXNlIGNlbnRlcilcbiAgICAgICAgICAgIGlmICggdHJhY2tlci5tb3ZlSGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICBnUG9pbnRBcnJheSA9IHBvaW50c0xpc3QuYXNBcnJheSgpO1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSA9IHRyYWNrZXIubW92ZUhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICAgICAgICAgIGdQb2ludEFycmF5WyAwIF0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggZ2V0Q2VudGVyUG9pbnQoIGdQb2ludEFycmF5WyAwIF0uY3VycmVudFBvcywgZ1BvaW50QXJyYXlbIDEgXS5jdXJyZW50UG9zICksIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogICAgICAgICAgICAgIHBvaW50c0xpc3QuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICBnUG9pbnRBcnJheVsgMCBdLnR5cGUgPT09ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogICAgICAgICAgICAgdHJhY2tlci51c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BhZ2F0ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuY2FuY2VsRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQaW5jaFxuICAgICAgICAgICAgaWYgKCB0cmFja2VyLnBpbmNoSGFuZGxlciAmJiBnUG9pbnRzWyAwIF0udHlwZSA9PT0gJ3RvdWNoJyApIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IGRlbGVnYXRlLnBpbmNoR1BvaW50c1sgMCBdLmN1cnJlbnRQb3MuZGlzdGFuY2VUbyggZGVsZWdhdGUucGluY2hHUG9pbnRzWyAxIF0uY3VycmVudFBvcyApO1xuICAgICAgICAgICAgICAgIGlmICggZGVsdGEgIT0gZGVsZWdhdGUuY3VycmVudFBpbmNoRGlzdCApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubGFzdFBpbmNoRGlzdCA9IGRlbGVnYXRlLmN1cnJlbnRQaW5jaERpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmN1cnJlbnRQaW5jaERpc3QgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUubGFzdFBpbmNoQ2VudGVyID0gZGVsZWdhdGUuY3VycmVudFBpbmNoQ2VudGVyO1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5jdXJyZW50UGluY2hDZW50ZXIgPSBnZXRDZW50ZXJQb2ludCggZGVsZWdhdGUucGluY2hHUG9pbnRzWyAwIF0uY3VycmVudFBvcywgZGVsZWdhdGUucGluY2hHUG9pbnRzWyAxIF0uY3VycmVudFBvcyApO1xuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgPSB0cmFja2VyLnBpbmNoSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZTogICAgICAgICAgdHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogICAgICAgICAgJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXN0dXJlUG9pbnRzOiAgICAgICAgZGVsZWdhdGUucGluY2hHUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDZW50ZXI6ICAgICAgICAgICBnZXRQb2ludFJlbGF0aXZlVG9BYnNvbHV0ZSggZGVsZWdhdGUubGFzdFBpbmNoQ2VudGVyLCB0cmFja2VyLmVsZW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6ICAgICAgICAgICAgICAgZ2V0UG9pbnRSZWxhdGl2ZVRvQWJzb2x1dGUoIGRlbGVnYXRlLmN1cnJlbnRQaW5jaENlbnRlciwgdHJhY2tlci5lbGVtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERpc3RhbmNlOiAgICAgICAgIGRlbGVnYXRlLmxhc3RQaW5jaERpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6ICAgICAgICAgICAgIGRlbGVnYXRlLmN1cnJlbnRQaW5jaERpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6ICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGE6ICAgICAgICAgICAgIHRyYWNrZXIudXNlckRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9wYWdhdGUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5jYW5jZWxFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyXG4gICAgICogICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hdGluZyBET00gZXZlbnQuXG4gICAgICogQHBhcmFtIHtBcnJheS48T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXIuR2VzdHVyZVBvaW50Pn0gZ1BvaW50c1xuICAgICAqICAgICAgR2VzdHVyZSBwb2ludHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyc0NhbmNlbCggdHJhY2tlciwgZXZlbnQsIGdQb2ludHMgKSB7XG4gICAgICAgIHVwZGF0ZVBvaW50ZXJzVXAoIHRyYWNrZXIsIGV2ZW50LCBnUG9pbnRzLCAwICk7XG4gICAgICAgIHVwZGF0ZVBvaW50ZXJzRXhpdCggdHJhY2tlciwgZXZlbnQsIGdQb2ludHMgKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlclN0b3AoIHRyYWNrZXIsIG9yaWdpbmFsTW92ZUV2ZW50LCBwb2ludGVyVHlwZSApIHtcbiAgICAgICAgaWYgKCB0cmFja2VyLnN0b3BIYW5kbGVyICkge1xuICAgICAgICAgICAgdHJhY2tlci5zdG9wSGFuZGxlcigge1xuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiAgICAgICAgICB0cmFja2VyLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiAgICAgICAgICBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgZ2V0TW91c2VSZWxhdGl2ZSggb3JpZ2luYWxNb3ZlRXZlbnQsIHRyYWNrZXIuZWxlbWVudCApLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgICB0cmFja2VyLmdldEFjdGl2ZVBvaW50ZXJzTGlzdEJ5VHlwZSggcG9pbnRlclR5cGUgKS5idXR0b25zLFxuICAgICAgICAgICAgICAgIGlzVG91Y2hFdmVudDogICAgICAgICBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiAgICAgICAgb3JpZ2luYWxNb3ZlRXZlbnQsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVzZXJEYXRhOiAgICAgICAgICAgICB0cmFja2VyLnVzZXJEYXRhXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVHJ1ZSBpZiBpbnNpZGUgYW4gaWZyYW1lLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgLy8gQG1lbWJlciB7Qm9vbGVhbn0gaXNJbklmcmFtZVxuICAgIC8vIEBwcml2YXRlXG4gICAgLy8gQGlubmVyXG4gICAgdmFyIGlzSW5JZnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnNlbGYgIT09IHdpbmRvdy50b3A7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiBcbiAgICAvLyBAZnVuY3Rpb25cbiAgICAvLyBAcHJpdmF0ZVxuICAgIC8vIEBpbm5lclxuICAgIC8vIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0YXJnZXQgaGFzIGFjY2VzcyByaWdodHMgdG8gZXZlbnRzLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgZnVuY3Rpb24gY2FuQWNjZXNzRXZlbnRzICh0YXJnZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciAmJiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG59ICggT3BlblNlYWRyYWdvbiApICk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gQ29udHJvbFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgbG9jYXRpb25zIHdoZXJlIGNvbnRyb2xzIGNhbiBiZSBhbmNob3JlZC5cbiAqIFRoZSBhbmNob3JpbmcgaXMgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIuXG4gKiBAbWVtYmVyIENvbnRyb2xBbmNob3JcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IE5PTkVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBUT1BfTEVGVFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFRPUF9SSUdIVFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPVFRPTV9MRUZUXG4gKiBAcHJvcGVydHkge051bWJlcn0gQk9UVE9NX1JJR0hUXG4gKiBAcHJvcGVydHkge051bWJlcn0gQUJTT0xVVEVcbiAqL1xuJC5Db250cm9sQW5jaG9yID0ge1xuICAgIE5PTkU6IDAsXG4gICAgVE9QX0xFRlQ6IDEsXG4gICAgVE9QX1JJR0hUOiAyLFxuICAgIEJPVFRPTV9SSUdIVDogMyxcbiAgICBCT1RUT01fTEVGVDogNCxcbiAgICBBQlNPTFVURTogNVxufTtcblxuLyoqXG4gKiBAY2xhc3MgQ29udHJvbFxuICogQGNsYXNzZGVzYyBBIENvbnRyb2wgcmVwcmVzZW50cyBhbnkgaW50ZXJmYWNlIGVsZW1lbnQgd2hpY2ggaXMgbWVhbnQgdG8gYWxsb3cgdGhlIHVzZXJcbiAqIHRvIGludGVyYWN0IHdpdGggdGhlIHpvb21hYmxlIGludGVyZmFjZS4gQW55IGNvbnRyb2wgY2FuIGJlIGFuY2hvcmVkIHRvIGFueVxuICogZWxlbWVudC5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGNvbnRyb2wgZWxlbWVudCB0byBiZSBhbmNob3JlZCBpbiB0aGUgY29udGFpbmVyLlxuICogQHBhcmFtIHtPYmplY3QgfSBvcHRpb25zIC0gQWxsIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBzZXR0aW5ncyBmb3IgY29uZmlndXJpbmcgYSBjb250cm9sIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uQ29udHJvbEFuY2hvcn0gW29wdGlvbnMuYW5jaG9yPU9wZW5TZWFkcmFnb24uQ29udHJvbEFuY2hvci5OT05FXSAtIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbFxuICogIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF0dGFjaFRvVmlld2VyPXRydWVdIC0gV2hldGhlciB0aGUgY29udHJvbCBzaG91bGQgYmUgYWRkZWQgZGlyZWN0bHkgdG8gdGhlIHZpZXdlciwgb3JcbiAqICBkaXJlY3RseSB0byB0aGUgY29udGFpbmVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9GYWRlPXRydWVdIC0gV2hldGhlciB0aGUgY29udHJvbCBzaG91bGQgaGF2ZSB0aGUgYXV0b2ZhZGUgYmVoYXZpb3JcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIC0gdGhlIGVsZW1lbnQgdG8gY29udHJvbCB3aWxsIGJlIGFuY2hvcmVkIHRvby5cbiAqL1xuJC5Db250cm9sID0gZnVuY3Rpb24gKCBlbGVtZW50LCBvcHRpb25zLCBjb250YWluZXIgKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKFwiUGFzc2luZyBhbiBhbmNob3IgZGlyZWN0bHkgaW50byB0aGUgT3BlblNlYWRyYWdvbi5Db250cm9sIGNvbnN0cnVjdG9yIGlzIGRlcHJlY2F0ZWQ7IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicGxlYXNlIHVzZSBhbiBvcHRpb25zIG9iamVjdCBpbnN0ZWFkLiAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJTdXBwb3J0IGZvciB0aGlzIGRlcHJlY2F0ZWQgdmFyaWFudCBpcyBzY2hlZHVsZWQgZm9yIHJlbW92YWwgaW4gRGVjZW1iZXIgMjAxM1wiKTtcbiAgICAgICAgIG9wdGlvbnMgPSB7YW5jaG9yOiBvcHRpb25zfTtcbiAgICB9XG4gICAgb3B0aW9ucy5hdHRhY2hUb1ZpZXdlciA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hUb1ZpZXdlciA9PT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IG9wdGlvbnMuYXR0YWNoVG9WaWV3ZXI7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgY29udHJvbCBzaG91bGQgaGF2ZSBhdXRvZmFkZSBiZWhhdmlvci5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvRmFkZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkNvbnRyb2wjXG4gICAgICovXG4gICAgdGhpcy5hdXRvRmFkZSA9ICh0eXBlb2Ygb3B0aW9ucy5hdXRvRmFkZSA9PT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IG9wdGlvbnMuYXV0b0ZhZGU7XG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgcHJvdmlkaW5nIHRoZSB1c2VyIGludGVyZmFjZSB3aXRoIHNvbWUgdHlwZSBvZiBjb250cm9sIChlLmcuIGEgem9vbS1pbiBidXR0b24pLlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Db250cm9sI1xuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCAgICA9IGVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBDb250cm9sIHJlbGF0aXZlIHRvIGl0cyBjb250YWluZXIuXG4gICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5Db250cm9sQW5jaG9yfSBhbmNob3JcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5Db250cm9sI1xuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yICAgICA9IG9wdGlvbnMuYW5jaG9yO1xuICAgIC8qKlxuICAgICAqIFRoZSBDb250cm9sJ3MgY29udGFpbmluZyBlbGVtZW50LlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkNvbnRyb2wjXG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgID0gY29udGFpbmVyO1xuICAgIC8qKlxuICAgICAqIEEgbmV1dHJhbCBlbGVtZW50IHN1cnJvdW5kaW5nIHRoZSBjb250cm9sIGVsZW1lbnQuXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gd3JhcHBlclxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkNvbnRyb2wjXG4gICAgICovXG4gICAgaWYgKCB0aGlzLmFuY2hvciA9PSAkLkNvbnRyb2xBbmNob3IuQUJTT0xVVEUgKSB7XG4gICAgICAgIHRoaXMud3JhcHBlciAgICA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IHR5cGVvZiAoIG9wdGlvbnMudG9wICkgID09IFwibnVtYmVyXCIgPyAoIG9wdGlvbnMudG9wICsgJ3B4JyApIDogb3B0aW9ucy50b3A7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ICA9IHR5cGVvZiAoIG9wdGlvbnMubGVmdCApICA9PSBcIm51bWJlclwiID8gIChvcHRpb25zLmxlZnQgKyAncHgnICkgOiBvcHRpb25zLmxlZnQ7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5oZWlnaHQgPSB0eXBlb2YgKCBvcHRpb25zLmhlaWdodCApICA9PSBcIm51bWJlclwiID8gKCBvcHRpb25zLmhlaWdodCArICdweCcgKSA6IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUud2lkdGggID0gdHlwZW9mICggb3B0aW9ucy53aWR0aCApICA9PSBcIm51bWJlclwiID8gKCBvcHRpb25zLndpZHRoICsgJ3B4JyApIDogb3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5wYWRkaW5nID0gXCIwcHhcIjtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53cmFwcGVyICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiZGl2XCIgKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICBpZiAoIHRoaXMuYW5jaG9yID09ICQuQ29udHJvbEFuY2hvci5OT05FICkge1xuICAgICAgICAgICAgLy8gSUU2IGZpeFxuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLndpZHRoID0gdGhpcy53cmFwcGVyLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCggdGhpcy5lbGVtZW50ICk7XG5cbiAgICBpZiAob3B0aW9ucy5hdHRhY2hUb1ZpZXdlciApIHtcbiAgICAgICAgaWYgKCB0aGlzLmFuY2hvciA9PSAkLkNvbnRyb2xBbmNob3IuVE9QX1JJR0hUIHx8XG4gICAgICAgICAgICAgdGhpcy5hbmNob3IgPT0gJC5Db250cm9sQW5jaG9yLkJPVFRPTV9SSUdIVCApIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmlyc3RDaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLndyYXBwZXIgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCggdGhpcy53cmFwcGVyICk7XG4gICAgfVxufTtcblxuLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLkNvbnRyb2wucHJvdG90eXBlICovXG4kLkNvbnRyb2wucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBjb250YWluZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVDaGlsZCggdGhpcy5lbGVtZW50ICk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKCB0aGlzLndyYXBwZXIgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY29udHJvbCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGN1cnJlbmx5IHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLnN0eWxlLmRpc3BsYXkgIT0gXCJub25lXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbnRyb2wuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIC0gdHJ1ZSB0byBtYWtlIHZpc2libGUsIGZhbHNlIHRvIGhpZGUuXG4gICAgICovXG4gICAgc2V0VmlzaWJsZTogZnVuY3Rpb24oIHZpc2libGUgKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/XG4gICAgICAgICAgICAoIHRoaXMuYW5jaG9yID09ICQuQ29udHJvbEFuY2hvci5BQlNPTFVURSA/ICdibG9jaycgOiAnaW5saW5lLWJsb2NrJyApIDpcbiAgICAgICAgICAgIFwibm9uZVwiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IGxldmVsIGZvciB0aGUgY29udHJvbC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY3RpeSAtIGEgdmFsdWUgYmV0d2VlbiAxIGFuZCAwIGluY2x1c2l2ZWx5LlxuICAgICAqL1xuICAgIHNldE9wYWNpdHk6IGZ1bmN0aW9uKCBvcGFjaXR5ICkge1xuICAgICAgICBpZiAoIHRoaXMuZWxlbWVudFsgJC5TSUdOQUwgXSAmJiAkLkJyb3dzZXIudmVuZG9yID09ICQuQlJPV1NFUlMuSUUgKSB7XG4gICAgICAgICAgICAkLnNldEVsZW1lbnRPcGFjaXR5KCB0aGlzLmVsZW1lbnQsIG9wYWNpdHksIHRydWUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIHRoaXMud3JhcHBlciwgb3BhY2l0eSwgdHJ1ZSApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBDb250cm9sRG9ja1xuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcbiAgICAvKipcbiAgICAgKiBAY2xhc3MgQ29udHJvbERvY2tcbiAgICAgKiBAY2xhc3NkZXNjIFByb3ZpZGVzIGEgY29udGFpbmVyIGVsZW1lbnQgKGEgJmx0O2Zvcm0mZ3Q7IGVsZW1lbnQpIHdpdGggc3VwcG9ydCBmb3IgdGhlIGxheW91dCBvZiBjb250cm9sIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKi9cbiAgICAkLkNvbnRyb2xEb2NrID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgICAgdmFyIGxheW91dHMgPSBbICd0b3BsZWZ0JywgJ3RvcHJpZ2h0JywgJ2JvdHRvbXJpZ2h0JywgJ2JvdHRvbWxlZnQnXSxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIHtcbiAgICAgICAgICAgIGlkOiAnY29udHJvbGRvY2stJyskLm5vdygpKyctJytNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTAwMDAwMCksXG4gICAgICAgICAgICBjb250YWluZXI6ICQubWFrZU5ldXRyYWxFbGVtZW50KCAnZGl2JyApLFxuICAgICAgICAgICAgY29udHJvbHM6IFtdXG4gICAgICAgIH0sIG9wdGlvbnMgKTtcblxuICAgICAgICAvLyBEaXNhYmxlIHRoZSBmb3JtJ3Mgc3VibWl0OyBvdGhlcndpc2UgYnV0dG9uIGNsaWNrcyBhbmQgcmV0dXJuIGtleXNcbiAgICAgICAgLy8gY2FuIHRyaWdnZXIgaXQuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLm9uc3VibWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHRoaXMuZWxlbWVudCApe1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gJC5nZXRFbGVtZW50KCB0aGlzLmVsZW1lbnQgKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy5jb250YWluZXIgKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggaSA9IDA7IGkgPCBsYXlvdXRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBsYXlvdXQgPSBsYXlvdXRzWyBpIF07XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzWyBsYXlvdXQgXSA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzWyBsYXlvdXQgXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBpZiAoIGxheW91dC5tYXRjaCggJ2xlZnQnICkgKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzWyBsYXlvdXQgXS5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGxheW91dC5tYXRjaCggJ3JpZ2h0JyApICl7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1sgbGF5b3V0IF0uc3R5bGUucmlnaHQgPSAnMHB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggbGF5b3V0Lm1hdGNoKCAndG9wJyApICl7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1sgbGF5b3V0IF0uc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGxheW91dC5tYXRjaCggJ2JvdHRvbScgKSApe1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbIGxheW91dCBdLnN0eWxlLmJvdHRvbSA9ICcwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuY29udHJvbHMudG9wbGVmdCApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5jb250cm9scy50b3ByaWdodCApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5jb250cm9scy5ib3R0b21yaWdodCApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5jb250cm9scy5ib3R0b21sZWZ0ICk7XG4gICAgfTtcblxuICAgIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5Db250cm9sRG9jay5wcm90b3R5cGUgKi9cbiAgICAkLkNvbnRyb2xEb2NrLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDb250cm9sOiBmdW5jdGlvbiAoIGVsZW1lbnQsIGNvbnRyb2xPcHRpb25zICkge1xuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICAgICAgdmFyIGRpdiA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICggZ2V0Q29udHJvbEluZGV4KCB0aGlzLCBlbGVtZW50ICkgPj0gMCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAgICAvLyB0aGV5J3JlIHRyeWluZyB0byBhZGQgYSBkdXBsaWNhdGUgY29udHJvbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKCBjb250cm9sT3B0aW9ucy5hbmNob3IgKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAkLkNvbnRyb2xBbmNob3IuVE9QX1JJR0hUOlxuICAgICAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmNvbnRyb2xzLnRvcHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJC5Db250cm9sQW5jaG9yLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5jb250cm9scy5ib3R0b21yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICQuQ29udHJvbEFuY2hvci5CT1RUT01fTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5jb250cm9scy5ib3R0b21sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nQm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAkLkNvbnRyb2xBbmNob3IuVE9QX0xFRlQ6XG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuY29udHJvbHMudG9wbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJC5Db250cm9sQW5jaG9yLkFCU09MVVRFOlxuICAgICAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhc2UgJC5Db250cm9sQW5jaG9yLk5PTkU6XG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3ICQuQ29udHJvbCggZWxlbWVudCwgY29udHJvbE9wdGlvbnMsIGRpdiApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5Db250cm9sRG9ja30gQ2hhaW5hYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICAgICAgdmFyIGkgPSBnZXRDb250cm9sSW5kZXgoIHRoaXMsIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgaWYgKCBpID49IDAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1sgaSBdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uQ29udHJvbERvY2t9IENoYWluYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyQ29udHJvbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdoaWxlICggdGhpcy5jb250cm9scy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMucG9wKCkuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGFyZUNvbnRyb2xzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSB0aGlzLmNvbnRyb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5jb250cm9sc1sgaSBdLmlzVmlzaWJsZSgpICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5Db250cm9sRG9ja30gQ2hhaW5hYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q29udHJvbHNFbmFibGVkOiBmdW5jdGlvbiggZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gdGhpcy5jb250cm9scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzWyBpIF0uc2V0VmlzaWJsZSggZW5hYmxlZCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFV0aWxpdHkgbWV0aG9kc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBmdW5jdGlvbiBnZXRDb250cm9sSW5kZXgoIGRvY2ssIGVsZW1lbnQgKSB7XG4gICAgICAgIHZhciBjb250cm9scyA9IGRvY2suY29udHJvbHMsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoIGkgPSBjb250cm9scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICAgIGlmICggY29udHJvbHNbIGkgXS5lbGVtZW50ID09IGVsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFBsYWNlbWVudFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE2IE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbigkKSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBlbnVtZXJhdGlvbiBvZiBwb3NpdGlvbnMgdG8gYW5jaG9yIGFuIGVsZW1lbnQuXG4gICAgICogQG1lbWJlciBQbGFjZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgT3BlblNlYWRyYWdvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBDRU5URVJcbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBUT1BfTEVGVFxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IFRPUFxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IFRPUF9SSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IFJJR0hUXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gQk9UVE9NX1JJR0hUXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gQk9UVE9NXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gQk9UVE9NX0xFRlRcbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBMRUZUXG4gICAgICovXG4gICAgJC5QbGFjZW1lbnQgPSAkLmZyZWV6ZU9iamVjdCh7XG4gICAgICAgIENFTlRFUjogICAgICAgMCxcbiAgICAgICAgVE9QX0xFRlQ6ICAgICAxLFxuICAgICAgICBUT1A6ICAgICAgICAgIDIsXG4gICAgICAgIFRPUF9SSUdIVDogICAgMyxcbiAgICAgICAgUklHSFQ6ICAgICAgICA0LFxuICAgICAgICBCT1RUT01fUklHSFQ6IDUsXG4gICAgICAgIEJPVFRPTTogICAgICAgNixcbiAgICAgICAgQk9UVE9NX0xFRlQ6ICA3LFxuICAgICAgICBMRUZUOiAgICAgICAgIDgsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIDA6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNSaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNUb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQm90dG9tOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNIb3Jpem9udGFsbHlDZW50ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNSaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNUb3A6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQm90dG9tOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDI6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNSaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNUb3A6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQm90dG9tOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDM6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNUb3A6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQm90dG9tOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDQ6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNUb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQm90dG9tOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDU6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNUb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDY6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbGx5Q2VudGVyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNSaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNUb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDc6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNIb3Jpem9udGFsbHlDZW50ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNSaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNUb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0JvdHRvbTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDg6IHtcbiAgICAgICAgICAgICAgICBpc0xlZnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNIb3Jpem9udGFsbHlDZW50ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNSaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNUb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWxseUNlbnRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQm90dG9tOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0oT3BlblNlYWRyYWdvbikpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFZpZXdlclxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLy8gZGljdGlvbmFyeSBmcm9tIGhhc2ggdG8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG52YXIgVEhJUyA9IHt9O1xudmFyIG5leHRIYXNoID0gMTtcblxuLyoqXG4gKlxuICogVGhlIG1haW4gcG9pbnQgb2YgZW50cnkgaW50byBjcmVhdGluZyBhIHpvb21hYmxlIGltYWdlIG9uIHRoZSBwYWdlLjxicj5cbiAqIDxicj5cbiAqIFdlIGhhdmUgcHJvdmlkZWQgYW4gaWRpb21hdGljIGphdmFzY3JpcHQgY29uc3RydWN0b3Igd2hpY2ggdGFrZXNcbiAqIGEgc2luZ2xlIG9iamVjdCwgYnV0IHN0aWxsIHN1cHBvcnQgdGhlIGxlZ2FjeSBwb3NpdGlvbmFsIGFyZ3VtZW50cy48YnI+XG4gKiA8YnI+XG4gKiBUaGUgb3B0aW9ucyBiZWxvdyBhcmUgZ2l2ZW4gaW4gb3JkZXIgdGhhdCB0aGV5IGFwcGVhcmVkIGluIHRoZSBjb25zdHJ1Y3RvclxuICogYXMgYXJndW1lbnRzIGFuZCB3ZSB0cmFuc2xhdGUgYSBwb3NpdGlvbmFsIGNhbGwgaW50byBhbiBpZGlvbWF0aWMgY2FsbC48YnI+XG4gKiA8YnI+XG4gKiBUbyBjcmVhdGUgYSB2aWV3ZXIsIHlvdSBjYW4gdXNlIGVpdGhlciBvZiB0aGlzIG1ldGhvZHM6PGJyPlxuICogPHVsPlxuICogPGxpPjxjb2RlPnZhciB2aWV3ZXIgPSBuZXcgT3BlblNlYWRyYWdvbi5WaWV3ZXIob3B0aW9ucyk7PC9jb2RlPjwvbGk+XG4gKiA8bGk+PGNvZGU+dmFyIHZpZXdlciA9IE9wZW5TZWFkcmFnb24ob3B0aW9ucyk7PC9jb2RlPjwvbGk+XG4gKiA8L3VsPlxuICogQGNsYXNzIFZpZXdlclxuICogQGNsYXNzZGVzYyBUaGUgbWFpbiBPcGVuU2VhZHJhZ29uIHZpZXdlciBjbGFzcy5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5FdmVudFNvdXJjZVxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5Db250cm9sRG9ja1xuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLk9wdGlvbnN9IG9wdGlvbnMgLSBWaWV3ZXIgb3B0aW9ucy5cbiAqXG4gKiovXG4kLlZpZXdlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgdmFyIGFyZ3MgID0gYXJndW1lbnRzLFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGk7XG5cblxuICAgIC8vYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3IgcG9zaXRpb25hbCBhcmdzIHdoaWxlIHByZWZlcmluZyBtb3JlXG4gICAgLy9pZGlvbWF0aWMgamF2YXNjcmlwdCBvcHRpb25zIG9iamVjdCBhcyB0aGUgb25seSBhcmd1bWVudFxuICAgIGlmKCAhJC5pc1BsYWluT2JqZWN0KCBvcHRpb25zICkgKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiAgICAgICAgICAgICAgICAgYXJnc1sgMCBdLFxuICAgICAgICAgICAgeG1sUGF0aDogICAgICAgICAgICBhcmdzLmxlbmd0aCA+IDEgPyBhcmdzWyAxIF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVmaXhVcmw6ICAgICAgICAgIGFyZ3MubGVuZ3RoID4gMiA/IGFyZ3NbIDIgXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnRyb2xzOiAgICAgICAgICAgYXJncy5sZW5ndGggPiAzID8gYXJnc1sgMyBdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3ZlcmxheXM6ICAgICAgICAgICBhcmdzLmxlbmd0aCA+IDQgPyBhcmdzWyA0IF0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvL29wdGlvbnMuY29uZmlnIGFuZCB0aGUgZ2VuZXJhbCBjb25maWcgYXJndW1lbnQgYXJlIGRlcHJlY2F0ZWRcbiAgICAvL2luIGZhdm9yIG9mIHRoZSBtb3JlIGRpcmVjdCBzcGVjaWZpY2F0aW9uIG9mIG9wdGlvbmFsIHNldHRpbmdzXG4gICAgLy9iZWluZyBwYXNzIGRpcmVjdGx5IG9uIHRoZSBvcHRpb25zIG9iamVjdFxuICAgIGlmICggb3B0aW9ucy5jb25maWcgKXtcbiAgICAgICAgJC5leHRlbmQoIHRydWUsIG9wdGlvbnMsIG9wdGlvbnMuY29uZmlnICk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNvbmZpZztcbiAgICB9XG5cbiAgICAvL1B1YmxpYyBwcm9wZXJ0aWVzXG4gICAgLy9BbGxvdyB0aGUgb3B0aW9ucyBvYmplY3QgdG8gb3ZlcnJpZGUgZ2xvYmFsIGRlZmF1bHRzXG4gICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIHtcblxuICAgICAgICAvL2ludGVybmFsIHN0YXRlIGFuZCBkb20gaWRlbnRpZmllcnNcbiAgICAgICAgaWQ6ICAgICAgICAgICAgIG9wdGlvbnMuaWQsXG4gICAgICAgIGhhc2g6ICAgICAgICAgICBvcHRpb25zLmhhc2ggfHwgbmV4dEhhc2grKyxcblxuICAgICAgICAvL2RvbSBub2Rlc1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCBlbGVtZW50IG9mIHRoaXMgVmlld2VyIGluc3RhbmNlLCBwYXNzZWQgaW4gd2hlbiB0aGUgVmlld2VyIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlciNcbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnQ6ICAgICAgICBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSAmbHQ7ZGl2Jmd0OyBlbGVtZW50IChwcm92aWRlZCBieSB7QGxpbmsgT3BlblNlYWRyYWdvbi5Db250cm9sRG9ja30pLCB0aGUgYmFzZSBlbGVtZW50IG9mIHRoaXMgVmlld2VyIGluc3RhbmNlLjxicj48YnI+XG4gICAgICAgICAqIENoaWxkIGVsZW1lbnQgb2Yge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2VsZW1lbnR9LlxuICAgICAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBjb250YWluZXJcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyI1xuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyOiAgICAgIG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBICZsdDtkaXYmZ3Q7IGVsZW1lbnQsIHRoZSBlbGVtZW50IHdoZXJlIHVzZXItaW5wdXQgZXZlbnRzIGFyZSBoYW5kbGVkIGZvciBwYW5uaW5nIGFuZCB6b29taW5nLjxicj48YnI+XG4gICAgICAgICAqIENoaWxkIGVsZW1lbnQgb2Yge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NvbnRhaW5lcn0sXG4gICAgICAgICAqIHBvc2l0aW9uZWQgb24gdG9wIG9mIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNrZXlib2FyZENvbW1hbmRBcmVhfS48YnI+PGJyPlxuICAgICAgICAgKiBUaGUgcGFyZW50IG9mIHtAbGluayBPcGVuU2VhZHJhZ29uLkRyYXdlciNjYW52YXN9IGluc3RhbmNlcy5cbiAgICAgICAgICogQG1lbWJlciB7RWxlbWVudH0gY2FudmFzXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlciNcbiAgICAgICAgICovXG4gICAgICAgIGNhbnZhczogICAgICAgICBudWxsLFxuXG4gICAgICAgIC8vIE92ZXJsYXlzIGxpc3QuIEFuIG92ZXJsYXkgYWxsb3dzIHRvIGFkZCBodG1sIG9uIHRvcCBvZiB0aGUgdmlld2VyLlxuICAgICAgICBvdmVybGF5czogICAgICAgICAgIFtdLFxuICAgICAgICAvLyBDb250YWluZXIgaW5zaWRlIHRoZSBjYW52YXMgd2hlcmUgb3ZlcmxheXMgYXJlIGRyYXduLlxuICAgICAgICBvdmVybGF5c0NvbnRhaW5lcjogIG51bGwsXG5cbiAgICAgICAgLy9wcml2YXRlIHN0YXRlIHByb3BlcnRpZXNcbiAgICAgICAgcHJldmlvdXNCb2R5OiAgIFtdLFxuXG4gICAgICAgIC8vVGhpcyB3YXMgb3JpZ2luYWxseSBpbml0aWFsaXplZCBpbiB0aGUgY29uc3RydWN0b3IgYW5kIHNvIGNvdWxkIG5ldmVyXG4gICAgICAgIC8vaGF2ZSBhbnl0aGluZyBpbiBpdC4gIG5vdyBpdCBjYW4gYmVjYXVzZSB3ZSBhbGxvdyBpdCB0byBiZSBzcGVjaWZpZWRcbiAgICAgICAgLy9pbiB0aGUgb3B0aW9ucyBhbmQgaXMgb25seSBlbXB0eSBieSBkZWZhdWx0IGlmIG5vdCBzcGVjaWZpZWQuIEFsc29cbiAgICAgICAgLy90aGlzIGFycmF5IHdhcyByZXR1cm5lZCBmcm9tIGdldF9jb250cm9scyB3aGljaCBJIGZpbmQgY29uZnVzaW5nXG4gICAgICAgIC8vc2luY2UgdGhpcyBvYmplY3QgaGFzIGEgY29udHJvbHMgcHJvcGVydHkgd2hpY2ggaXMgdHJlYXRlZCBpbiBvdGhlclxuICAgICAgICAvL2Z1bmN0aW9ucyBsaWtlIGNsZWFyQ29udHJvbHMuICBJJ20gcmVtb3ZpbmcgdGhlIGFjY2Vzc29ycy5cbiAgICAgICAgY3VzdG9tQ29udHJvbHM6IFtdLFxuXG4gICAgICAgIC8vVGhlc2UgYXJlIG9yaWdpbmFsbHkgbm90IHBhcnQgb3B0aW9ucyBidXQgZGVjbGFyZWQgYXMgbWVtYmVyc1xuICAgICAgICAvL2luIGluaXRpYWxpemUuICBJdCdzIHN0aWxsIGNvbnNpZGVyZWQgaWRpb21hdGljIHRvIHB1dCB0aGVtIGhlcmVcbiAgICAgICAgc291cmNlOiAgICAgICAgIG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHJlbmRlcmluZyBvZiB0aWxlcyBpbiB0aGUgdmlld2VyLiBDcmVhdGVkIGZvciBlYWNoIFRpbGVTb3VyY2Ugb3BlbmVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtPcGVuU2VhZHJhZ29uLkRyYXdlcn0gZHJhd2VyXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlciNcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdlcjogICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgd29ybGQ6ICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBjb29yZGluYXRlLXJlbGF0ZWQgZnVuY3Rpb25hbGl0eSAtIHpvb20sIHBhbiwgcm90YXRpb24sIGV0Yy4gQ3JlYXRlZCBmb3IgZWFjaCBUaWxlU291cmNlIG9wZW5lZC5cbiAgICAgICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gdmlld3BvcnRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyI1xuICAgICAgICAgKi9cbiAgICAgICAgdmlld3BvcnQ6ICAgICAgIG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPcGVuU2VhZHJhZ29uLk5hdmlnYXRvcn0gbmF2aWdhdG9yXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlciNcbiAgICAgICAgICovXG4gICAgICAgIG5hdmlnYXRvcjogICAgICBudWxsLFxuXG4gICAgICAgIC8vQSBjb2xsZWN0aW9uIHZpZXdwb3J0IGlzIGEgc2VwYXJhdGUgdmlld3BvcnQgdXNlZCB0byBwcm92aWRlXG4gICAgICAgIC8vc2ltdWx0YW5lb3VzIHJlbmRlcmluZyBvZiBzZXRzIG9mIHRpbGVzXG4gICAgICAgIGNvbGxlY3Rpb25WaWV3cG9ydDogICAgIG51bGwsXG4gICAgICAgIGNvbGxlY3Rpb25EcmF3ZXI6ICAgICAgIG51bGwsXG5cbiAgICAgICAgLy9VSSBpbWFnZSByZXNvdXJjZXNcbiAgICAgICAgLy9UT0RPOiByZW5hbWUgbmF2SW1hZ2VzIHRvIHVpSW1hZ2VzXG4gICAgICAgIG5hdkltYWdlczogICAgICBudWxsLFxuXG4gICAgICAgIC8vaW50ZXJmYWNlIGJ1dHRvbiBjb250cm9sc1xuICAgICAgICBidXR0b25zOiAgICAgICAgbnVsbCxcblxuICAgICAgICAvL1RPRE86IHRoaXMgaXMgZGVmdW5jdCBzbyBzYWZlbHkgcmVtb3ZlIGl0XG4gICAgICAgIHByb2ZpbGVyOiAgICAgICBudWxsXG5cbiAgICB9LCAkLkRFRkFVTFRfU0VUVElOR1MsIG9wdGlvbnMgKTtcblxuICAgIGlmICggdHlwZW9mKCB0aGlzLmhhc2gpID09PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhhc2ggbXVzdCBiZSBkZWZpbmVkLCBlaXRoZXIgYnkgc3BlY2lmeWluZyBvcHRpb25zLmlkIG9yIG9wdGlvbnMuaGFzaC5cIik7XG4gICAgfVxuICAgIGlmICggdHlwZW9mKCBUSElTWyB0aGlzLmhhc2ggXSApICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRocm93IGFuIGVycm9yIGhlcmUsIGFzIHRoZSB1c2VyIG1pZ2h0IGhhdmUgZGlzY2FyZGVkXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyB2aWV3ZXIgd2l0aCB0aGUgc2FtZSBoYXNoIGFuZCBub3cgd2FudCB0byByZWNyZWF0ZSBpdC5cbiAgICAgICAgJC5jb25zb2xlLndhcm4oXCJIYXNoIFwiICsgdGhpcy5oYXNoICsgXCIgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICB9XG5cbiAgICAvL1ByaXZhdGUgc3RhdGUgcHJvcGVydGllc1xuICAgIFRISVNbIHRoaXMuaGFzaCBdID0ge1xuICAgICAgICBcImZzQm91bmRzRGVsdGFcIjogICAgIG5ldyAkLlBvaW50KCAxLCAxICksXG4gICAgICAgIFwicHJldkNvbnRhaW5lclNpemVcIjogbnVsbCxcbiAgICAgICAgXCJhbmltYXRpbmdcIjogICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJmb3JjZVJlZHJhd1wiOiAgICAgICBmYWxzZSxcbiAgICAgICAgXCJtb3VzZUluc2lkZVwiOiAgICAgICBmYWxzZSxcbiAgICAgICAgXCJncm91cFwiOiAgICAgICAgICAgICBudWxsLFxuICAgICAgICAvLyB3aGV0aGVyIHdlIHNob3VsZCBiZSBjb250aW51b3VzbHkgem9vbWluZ1xuICAgICAgICBcInpvb21pbmdcIjogICAgICAgICAgIGZhbHNlLFxuICAgICAgICAvLyBob3cgbXVjaCB3ZSBzaG91bGQgYmUgY29udGludW91c2x5IHpvb21pbmcgYnlcbiAgICAgICAgXCJ6b29tRmFjdG9yXCI6ICAgICAgICBudWxsLFxuICAgICAgICBcImxhc3Rab29tVGltZVwiOiAgICAgIG51bGwsXG4gICAgICAgIFwiZnVsbFBhZ2VcIjogICAgICAgICAgZmFsc2UsXG4gICAgICAgIFwib25mdWxsc2NyZWVuY2hhbmdlXCI6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5fc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgdGhpcy5fZmlyc3RPcGVuID0gdHJ1ZTtcbiAgICB0aGlzLl91cGRhdGVSZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuY3VycmVudE92ZXJsYXlzID0gW107XG5cbiAgICB0aGlzLl9sYXN0U2Nyb2xsVGltZSA9ICQubm93KCk7IC8vIHZhcmlhYmxlIHVzZWQgdG8gaGVscCBub3JtYWxpemUgdGhlIHNjcm9sbCBldmVudCBzcGVlZCBvZiBkaWZmZXJlbnQgZGV2aWNlc1xuXG4gICAgLy9Jbmhlcml0IHNvbWUgYmVoYXZpb3JzIGFuZCBwcm9wZXJ0aWVzXG4gICAgJC5FdmVudFNvdXJjZS5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLmFkZEhhbmRsZXIoICdvcGVuLWZhaWxlZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgIHZhciBtc2cgPSAkLmdldFN0cmluZyggXCJFcnJvcnMuT3BlbkZhaWxlZFwiLCBldmVudC5ldmVudFNvdXJjZSwgZXZlbnQubWVzc2FnZSk7XG4gICAgICAgIF90aGlzLl9zaG93TWVzc2FnZSggbXNnICk7XG4gICAgfSk7XG5cbiAgICAkLkNvbnRyb2xEb2NrLmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblxuICAgIC8vRGVhbCB3aXRoIHRpbGUgc291cmNlc1xuICAgIGlmICggdGhpcy54bWxQYXRoICApe1xuICAgICAgICAvL0RlcHJlY2F0ZWQgb3B0aW9uLiAgTm93IGl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIHRpbGVTb3VyY2VzIG9wdGlvblxuICAgICAgICB0aGlzLnRpbGVTb3VyY2VzID0gWyB0aGlzLnhtbFBhdGggXTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQgICAgICAgICAgICAgID0gdGhpcy5lbGVtZW50IHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCB0aGlzLmlkICk7XG4gICAgdGhpcy5jYW52YXMgICAgICAgICAgICAgICA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGFzc05hbWUgPSBcIm9wZW5zZWFkcmFnb24tY2FudmFzXCI7XG4gICAgKGZ1bmN0aW9uKCBzdHlsZSApe1xuICAgICAgICBzdHlsZS53aWR0aCAgICA9IFwiMTAwJVwiO1xuICAgICAgICBzdHlsZS5oZWlnaHQgICA9IFwiMTAwJVwiO1xuICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBzdHlsZS50b3AgICAgICA9IFwiMHB4XCI7XG4gICAgICAgIHN0eWxlLmxlZnQgICAgID0gXCIwcHhcIjtcbiAgICB9KHRoaXMuY2FudmFzLnN0eWxlKSk7XG4gICAgJC5zZXRFbGVtZW50VG91Y2hBY3Rpb25Ob25lKCB0aGlzLmNhbnZhcyApO1xuICAgIGlmIChvcHRpb25zLnRhYkluZGV4ICE9PSBcIlwiKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnRhYkluZGV4ID0gKG9wdGlvbnMudGFiSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLnRhYkluZGV4KTtcbiAgICB9XG5cbiAgICAvL3RoZSBjb250YWluZXIgaXMgY3JlYXRlZCB0aHJvdWdoIGFwcGx5aW5nIHRoZSBDb250cm9sRG9jayBjb25zdHJ1Y3RvciBhYm92ZVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwib3BlbnNlYWRyYWdvbi1jb250YWluZXJcIjtcbiAgICAoZnVuY3Rpb24oIHN0eWxlICl7XG4gICAgICAgIHN0eWxlLndpZHRoICAgICA9IFwiMTAwJVwiO1xuICAgICAgICBzdHlsZS5oZWlnaHQgICAgPSBcIjEwMCVcIjtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICBzdHlsZS5vdmVyZmxvdyAgPSBcImhpZGRlblwiO1xuICAgICAgICBzdHlsZS5sZWZ0ICAgICAgPSBcIjBweFwiO1xuICAgICAgICBzdHlsZS50b3AgICAgICAgPSBcIjBweFwiO1xuICAgICAgICBzdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjsgIC8vIG5lZWRlZCB0byBwcm90ZWN0IGFnYWluc3RcbiAgICB9KCB0aGlzLmNvbnRhaW5lci5zdHlsZSApKTtcblxuICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZSggdGhpcy5jYW52YXMsIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQgKTtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuY29udGFpbmVyICk7XG5cbiAgICAvL1VzZWQgZm9yIHRvZ2dsaW5nIGJldHdlZW4gZnVsbHNjcmVlbiBhbmQgZGVmYXVsdCBjb250YWluZXIgc2l6ZVxuICAgIC8vVE9ETzogdGhlc2UgY2FuIGJlIGNsb3N1cmUgcHJpdmF0ZSBhbmQgc2hhcmVkIGFjcm9zcyBWaWV3ZXJcbiAgICAvLyAgICAgIGluc3RhbmNlcy5cbiAgICB0aGlzLmJvZHlXaWR0aCAgICAgID0gZG9jdW1lbnQuYm9keS5zdHlsZS53aWR0aDtcbiAgICB0aGlzLmJvZHlIZWlnaHQgICAgID0gZG9jdW1lbnQuYm9keS5zdHlsZS5oZWlnaHQ7XG4gICAgdGhpcy5ib2R5T3ZlcmZsb3cgICA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgdGhpcy5kb2NPdmVyZmxvdyAgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdztcblxuICAgIHRoaXMuaW5uZXJUcmFja2VyID0gbmV3ICQuTW91c2VUcmFja2VyKHtcbiAgICAgICAgZWxlbWVudDogICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyxcbiAgICAgICAgc3RhcnREaXNhYmxlZDogICAgICAgICAgICB0aGlzLm1vdXNlTmF2RW5hYmxlZCA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiAgICAgICB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiAgICAgICB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgZGJsQ2xpY2tUaW1lVGhyZXNob2xkOiAgICB0aGlzLmRibENsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgZGJsQ2xpY2tEaXN0VGhyZXNob2xkOiAgICB0aGlzLmRibENsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAga2V5RG93bkhhbmRsZXI6ICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0tleURvd24gKSxcbiAgICAgICAga2V5SGFuZGxlcjogICAgICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0tleVByZXNzICksXG4gICAgICAgIGNsaWNrSGFuZGxlcjogICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNDbGljayApLFxuICAgICAgICBkYmxDbGlja0hhbmRsZXI6ICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzRGJsQ2xpY2sgKSxcbiAgICAgICAgZHJhZ0hhbmRsZXI6ICAgICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0RyYWcgKSxcbiAgICAgICAgZHJhZ0VuZEhhbmRsZXI6ICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0RyYWdFbmQgKSxcbiAgICAgICAgZW50ZXJIYW5kbGVyOiAgICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc0VudGVyICksXG4gICAgICAgIGV4aXRIYW5kbGVyOiAgICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNFeGl0ICksXG4gICAgICAgIHByZXNzSGFuZGxlcjogICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNQcmVzcyApLFxuICAgICAgICByZWxlYXNlSGFuZGxlcjogICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzUmVsZWFzZSApLFxuICAgICAgICBub25QcmltYXJ5UHJlc3NIYW5kbGVyOiAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzTm9uUHJpbWFyeVByZXNzICksXG4gICAgICAgIG5vblByaW1hcnlSZWxlYXNlSGFuZGxlcjogJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNOb25QcmltYXJ5UmVsZWFzZSApLFxuICAgICAgICBzY3JvbGxIYW5kbGVyOiAgICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzU2Nyb2xsICksXG4gICAgICAgIHBpbmNoSGFuZGxlcjogICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25DYW52YXNQaW5jaCApXG4gICAgfSk7XG5cbiAgICB0aGlzLm91dGVyVHJhY2tlciA9IG5ldyAkLk1vdXNlVHJhY2tlcih7XG4gICAgICAgIGVsZW1lbnQ6ICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIsXG4gICAgICAgIHN0YXJ0RGlzYWJsZWQ6ICAgICAgICAgdGhpcy5tb3VzZU5hdkVuYWJsZWQgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogICAgdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogICAgdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgIGRibENsaWNrVGltZVRocmVzaG9sZDogdGhpcy5kYmxDbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgIGRibENsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5kYmxDbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgIGVudGVySGFuZGxlcjogICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25Db250YWluZXJFbnRlciApLFxuICAgICAgICBleGl0SGFuZGxlcjogICAgICAgICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ29udGFpbmVyRXhpdCApXG4gICAgfSk7XG5cbiAgICBpZiggdGhpcy50b29sYmFyICl7XG4gICAgICAgIHRoaXMudG9vbGJhciA9IG5ldyAkLkNvbnRyb2xEb2NrKHsgZWxlbWVudDogdGhpcy50b29sYmFyIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYmluZFN0YW5kYXJkQ29udHJvbHMoKTtcblxuICAgIFRISVNbIHRoaXMuaGFzaCBdLnByZXZDb250YWluZXJTaXplID0gX2dldFNhZmVFbGVtU2l6ZSggdGhpcy5jb250YWluZXIgKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgd29ybGRcbiAgICB0aGlzLndvcmxkID0gbmV3ICQuV29ybGQoe1xuICAgICAgICB2aWV3ZXI6IHRoaXNcbiAgICB9KTtcblxuICAgIHRoaXMud29ybGQuYWRkSGFuZGxlcignYWRkLWl0ZW0nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdlIG1haW50YWluIHRoZSBzb3VyY2UgcHJvcGVydHlcbiAgICAgICAgX3RoaXMuc291cmNlID0gX3RoaXMud29ybGQuZ2V0SXRlbUF0KDApLnNvdXJjZTtcblxuICAgICAgICBUSElTWyBfdGhpcy5oYXNoIF0uZm9yY2VSZWRyYXcgPSB0cnVlO1xuXG4gICAgICAgIGlmICghX3RoaXMuX3VwZGF0ZVJlcXVlc3RJZCkge1xuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVJlcXVlc3RJZCA9IHNjaGVkdWxlVXBkYXRlKCBfdGhpcywgdXBkYXRlTXVsdGkgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy53b3JsZC5hZGRIYW5kbGVyKCdyZW1vdmUtaXRlbScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2UgbWFpbnRhaW4gdGhlIHNvdXJjZSBwcm9wZXJ0eVxuICAgICAgICBpZiAoX3RoaXMud29ybGQuZ2V0SXRlbUNvdW50KCkpIHtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZSA9IF90aGlzLndvcmxkLmdldEl0ZW1BdCgwKS5zb3VyY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgVEhJU1sgX3RoaXMuaGFzaCBdLmZvcmNlUmVkcmF3ID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMud29ybGQuYWRkSGFuZGxlcignbWV0cmljcy1jaGFuZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMudmlld3BvcnQpIHtcbiAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0Ll9zZXRDb250ZW50Qm91bmRzKF90aGlzLndvcmxkLmdldEhvbWVCb3VuZHMoKSwgX3RoaXMud29ybGQuZ2V0Q29udGVudEZhY3RvcigpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy53b3JsZC5hZGRIYW5kbGVyKCdpdGVtLWluZGV4LWNoYW5nZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2UgbWFpbnRhaW4gdGhlIHNvdXJjZSBwcm9wZXJ0eVxuICAgICAgICBfdGhpcy5zb3VyY2UgPSBfdGhpcy53b3JsZC5nZXRJdGVtQXQoMCkuc291cmNlO1xuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSB2aWV3cG9ydFxuICAgIHRoaXMudmlld3BvcnQgPSBuZXcgJC5WaWV3cG9ydCh7XG4gICAgICAgIGNvbnRhaW5lclNpemU6ICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ucHJldkNvbnRhaW5lclNpemUsXG4gICAgICAgIHNwcmluZ1N0aWZmbmVzczogICAgdGhpcy5zcHJpbmdTdGlmZm5lc3MsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6ICAgICAgdGhpcy5hbmltYXRpb25UaW1lLFxuICAgICAgICBtaW5ab29tSW1hZ2VSYXRpbzogIHRoaXMubWluWm9vbUltYWdlUmF0aW8sXG4gICAgICAgIG1heFpvb21QaXhlbFJhdGlvOiAgdGhpcy5tYXhab29tUGl4ZWxSYXRpbyxcbiAgICAgICAgdmlzaWJpbGl0eVJhdGlvOiAgICB0aGlzLnZpc2liaWxpdHlSYXRpbyxcbiAgICAgICAgd3JhcEhvcml6b250YWw6ICAgICB0aGlzLndyYXBIb3Jpem9udGFsLFxuICAgICAgICB3cmFwVmVydGljYWw6ICAgICAgIHRoaXMud3JhcFZlcnRpY2FsLFxuICAgICAgICBkZWZhdWx0Wm9vbUxldmVsOiAgIHRoaXMuZGVmYXVsdFpvb21MZXZlbCxcbiAgICAgICAgbWluWm9vbUxldmVsOiAgICAgICB0aGlzLm1pblpvb21MZXZlbCxcbiAgICAgICAgbWF4Wm9vbUxldmVsOiAgICAgICB0aGlzLm1heFpvb21MZXZlbCxcbiAgICAgICAgdmlld2VyOiAgICAgICAgICAgICB0aGlzLFxuICAgICAgICBkZWdyZWVzOiAgICAgICAgICAgIHRoaXMuZGVncmVlcyxcbiAgICAgICAgbmF2aWdhdG9yUm90YXRlOiAgICB0aGlzLm5hdmlnYXRvclJvdGF0ZSxcbiAgICAgICAgaG9tZUZpbGxzVmlld2VyOiAgICB0aGlzLmhvbWVGaWxsc1ZpZXdlcixcbiAgICAgICAgbWFyZ2luczogICAgICAgICAgICB0aGlzLnZpZXdwb3J0TWFyZ2luc1xuICAgIH0pO1xuXG4gICAgdGhpcy52aWV3cG9ydC5fc2V0Q29udGVudEJvdW5kcyh0aGlzLndvcmxkLmdldEhvbWVCb3VuZHMoKSwgdGhpcy53b3JsZC5nZXRDb250ZW50RmFjdG9yKCkpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBpbWFnZSBsb2FkZXJcbiAgICB0aGlzLmltYWdlTG9hZGVyID0gbmV3ICQuSW1hZ2VMb2FkZXIoe1xuICAgICAgICBqb2JMaW1pdDogdGhpcy5pbWFnZUxvYWRlckxpbWl0XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHRpbGUgY2FjaGVcbiAgICB0aGlzLnRpbGVDYWNoZSA9IG5ldyAkLlRpbGVDYWNoZSh7XG4gICAgICAgIG1heEltYWdlQ2FjaGVDb3VudDogdGhpcy5tYXhJbWFnZUNhY2hlQ291bnRcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0aGUgZHJhd2VyXG4gICAgdGhpcy5kcmF3ZXIgPSBuZXcgJC5EcmF3ZXIoe1xuICAgICAgICB2aWV3ZXI6ICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgIHZpZXdwb3J0OiAgICAgICAgICAgdGhpcy52aWV3cG9ydCxcbiAgICAgICAgZWxlbWVudDogICAgICAgICAgICB0aGlzLmNhbnZhcyxcbiAgICAgICAgZGVidWdHcmlkQ29sb3I6ICAgICB0aGlzLmRlYnVnR3JpZENvbG9yXG4gICAgfSk7XG5cbiAgICAvLyBPdmVybGF5IGNvbnRhaW5lclxuICAgIHRoaXMub3ZlcmxheXNDb250YWluZXIgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuICAgIHRoaXMuY2FudmFzLmFwcGVuZENoaWxkKCB0aGlzLm92ZXJsYXlzQ29udGFpbmVyICk7XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGEgZHJhd2VyLCBzZWUgaWYgaXQgc3VwcG9ydHMgcm90YXRlLiBJZiBub3Qgd2UgbmVlZCB0byByZW1vdmUgdGhlIHJvdGF0ZSBidXR0b25zXG4gICAgaWYgKCF0aGlzLmRyYXdlci5jYW5Sb3RhdGUoKSkge1xuICAgICAgICAvLyBEaXNhYmxlL3JlbW92ZSB0aGUgcm90YXRlIGxlZnQvcmlnaHQgYnV0dG9ucyBzaW5jZSB0aGV5IGFyZW4ndCBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKHRoaXMucm90YXRlTGVmdCkge1xuICAgICAgICAgICAgaSA9IHRoaXMuYnV0dG9ucy5idXR0b25zLmluZGV4T2YodGhpcy5yb3RhdGVMZWZ0KTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ucy5idXR0b25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ucy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMucm90YXRlTGVmdC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3RhdGVSaWdodCkge1xuICAgICAgICAgICAgaSA9IHRoaXMuYnV0dG9ucy5idXR0b25zLmluZGV4T2YodGhpcy5yb3RhdGVSaWdodCk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuYnV0dG9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnJvdGF0ZVJpZ2h0LmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9JbnN0YW50aWF0ZSBhIG5hdmlnYXRvciBpZiBjb25maWd1cmVkXG4gICAgaWYgKCB0aGlzLnNob3dOYXZpZ2F0b3Ipe1xuICAgICAgICB0aGlzLm5hdmlnYXRvciA9IG5ldyAkLk5hdmlnYXRvcih7XG4gICAgICAgICAgICBpZDogICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0b3JJZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgICB0aGlzLm5hdmlnYXRvclBvc2l0aW9uLFxuICAgICAgICAgICAgc2l6ZVJhdGlvOiAgICAgICAgIHRoaXMubmF2aWdhdG9yU2l6ZVJhdGlvLFxuICAgICAgICAgICAgbWFpbnRhaW5TaXplUmF0aW86IHRoaXMubmF2aWdhdG9yTWFpbnRhaW5TaXplUmF0aW8sXG4gICAgICAgICAgICB0b3A6ICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0b3JUb3AsXG4gICAgICAgICAgICBsZWZ0OiAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0b3JMZWZ0LFxuICAgICAgICAgICAgd2lkdGg6ICAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6ICAgICAgICAgICAgdGhpcy5uYXZpZ2F0b3JIZWlnaHQsXG4gICAgICAgICAgICBhdXRvUmVzaXplOiAgICAgICAgdGhpcy5uYXZpZ2F0b3JBdXRvUmVzaXplLFxuICAgICAgICAgICAgYXV0b0ZhZGU6ICAgICAgICAgIHRoaXMubmF2aWdhdG9yQXV0b0ZhZGUsXG4gICAgICAgICAgICBwcmVmaXhVcmw6ICAgICAgICAgdGhpcy5wcmVmaXhVcmwsXG4gICAgICAgICAgICB2aWV3ZXI6ICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5hdmlnYXRvclJvdGF0ZTogICB0aGlzLm5hdmlnYXRvclJvdGF0ZSxcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luUG9saWN5OiB0aGlzLmNyb3NzT3JpZ2luUG9saWN5XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNlcXVlbmNlIG1vZGVcbiAgICBpZiAodGhpcy5zZXF1ZW5jZU1vZGUpIHtcbiAgICAgICAgdGhpcy5iaW5kU2VxdWVuY2VDb250cm9scygpO1xuICAgIH1cblxuICAgIC8vIE9wZW4gaW5pdGlhbCB0aWxlc291cmNlc1xuICAgIGlmICh0aGlzLnRpbGVTb3VyY2VzKSB7XG4gICAgICAgIHRoaXMub3BlbiggdGhpcy50aWxlU291cmNlcyApO1xuICAgIH1cblxuICAgIC8vIEFkZCBjdXN0b20gY29udHJvbHNcbiAgICBmb3IgKCBpID0gMDsgaSA8IHRoaXMuY3VzdG9tQ29udHJvbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udHJvbHNbIGkgXS5pZCxcbiAgICAgICAgICAgIHthbmNob3I6IHRoaXMuY3VzdG9tQ29udHJvbHNbIGkgXS5hbmNob3J9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbCBmYWRlIG91dFxuICAgICQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmdW5jdGlvbigpe1xuICAgICAgICBiZWdpbkNvbnRyb2xzQXV0b0hpZGUoIF90aGlzICk7XG4gICAgfSApO1xufTtcblxuJC5leHRlbmQoICQuVmlld2VyLnByb3RvdHlwZSwgJC5FdmVudFNvdXJjZS5wcm90b3R5cGUsICQuQ29udHJvbERvY2sucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uVmlld2VyLnByb3RvdHlwZSAqL3tcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIG9wZW5Eemk6IGZ1bmN0aW9uICggZHppICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW1ZpZXdlci5vcGVuRHppXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBWaWV3ZXIub3BlbigpIGluc3RlYWQuXCIgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbiggZHppICk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBvcGVuVGlsZVNvdXJjZTogZnVuY3Rpb24gKCB0aWxlU291cmNlICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW1ZpZXdlci5vcGVuVGlsZVNvdXJjZV0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgVmlld2VyLm9wZW4oKSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW4oIHRpbGVTb3VyY2UgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aWxlZCBpbWFnZXMgaW50byB0aGUgdmlld2VyLCBjbG9zaW5nIGFueSBvdGhlcnMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSB0aWxlU291cmNlcyAtIFRoaXMgY2FuIGJlIGEgVGlsZWRJbWFnZVxuICAgICAqIHNwZWNpZmllciwgYSBUaWxlU291cmNlIHNwZWNpZmllciwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLiBBIFRpbGVkSW1hZ2Ugc3BlY2lmaWVyXG4gICAgICogaXMgdGhlIHNhbWUgYXMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIGZvciB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjYWRkVGlsZWRJbWFnZX0sXG4gICAgICogZXhjZXB0IGZvciB0aGUgaW5kZXggcHJvcGVydHk7IGltYWdlcyBhcmUgYWRkZWQgaW4gc2VxdWVuY2UuXG4gICAgICogQSBUaWxlU291cmNlIHNwZWNpZmllciBpcyBhbnl0aGluZyB5b3UgY291bGQgcGFzcyBhcyB0aGUgdGlsZVNvdXJjZSBwcm9wZXJ0eVxuICAgICAqIG9mIHRoZSBvcHRpb25zIHBhcmFtZXRlciBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZFRpbGVkSW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50Om9wZW5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6b3Blbi1mYWlsZWRcbiAgICAgKi9cbiAgICBvcGVuOiBmdW5jdGlvbiAodGlsZVNvdXJjZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgaWYgKCF0aWxlU291cmNlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VxdWVuY2VNb2RlICYmICQuaXNBcnJheSh0aWxlU291cmNlcykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZVN0cmlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdHJpcC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdHJpcCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGlsZVNvdXJjZXMgPSB0aWxlU291cmNlcztcbiAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnRpbGVTb3VyY2VzLmxlbmd0aCAtIDEsIHRoaXMuaW5pdGlhbFBhZ2UpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbGVTb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3Blbih0aGlzLnRpbGVTb3VyY2VzW3RoaXMuX3NlcXVlbmNlSW5kZXhdKTtcblxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5zaG93UmVmZXJlbmNlU3RyaXAgKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdHJpcCA9IG5ldyAkLlJlZmVyZW5jZVN0cmlwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAgICAgICAgICB0aGlzLnJlZmVyZW5jZVN0cmlwRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAgICB0aGlzLnJlZmVyZW5jZVN0cmlwUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplUmF0aW86ICAgdGhpcy5yZWZlcmVuY2VTdHJpcFNpemVSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbDogICAgICB0aGlzLnJlZmVyZW5jZVN0cmlwU2Nyb2xsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAgICAgIHRoaXMucmVmZXJlbmNlU3RyaXBIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogICAgICAgdGhpcy5yZWZlcmVuY2VTdHJpcFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVNvdXJjZXM6IHRoaXMudGlsZVNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhVcmw6ICAgdGhpcy5wcmVmaXhVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3ZXI6ICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlcXVlbmNlQnV0dG9ucyggdGhpcy5fc2VxdWVuY2VJbmRleCApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEkLmlzQXJyYXkodGlsZVNvdXJjZXMpKSB7XG4gICAgICAgICAgICB0aWxlU291cmNlcyA9IFt0aWxlU291cmNlc107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRpbGVTb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3BlbmluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkID0gdGlsZVNvdXJjZXMubGVuZ3RoO1xuICAgICAgICB2YXIgc3VjY2Vzc2VzID0gMDtcbiAgICAgICAgdmFyIGZhaWx1cmVzID0gMDtcbiAgICAgICAgdmFyIGZhaWxFdmVudDtcblxuICAgICAgICB2YXIgY2hlY2tDb21wbGV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2ZpcnN0T3BlbiB8fCAhX3RoaXMucHJlc2VydmVWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3BvcnQuZ29Ib21lKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3cG9ydC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9maXJzdE9wZW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGlsZVNvdXJjZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UudGlsZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnRpbGVTb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBHbG9iYWwgb3ZlcmxheXNcbiAgICAgICAgICAgICAgICAgICAgaWYoIF90aGlzLm92ZXJsYXlzICYmICFfdGhpcy5wcmVzZXJ2ZU92ZXJsYXlzICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5vdmVybGF5cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50T3ZlcmxheXNbIGkgXSA9IGdldE92ZXJsYXlPYmplY3QoIF90aGlzLCBfdGhpcy5vdmVybGF5c1sgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZHJhd092ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vcGVuaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIgaGFzIG9wZW5lZCBhbmQgbG9hZGVkIG9uZSBvciBtb3JlIFRpbGVTb3VyY2VzLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgb3BlblxuICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlU291cmNlfSBzb3VyY2UgLSBUaGUgdGlsZSBzb3VyY2UgdGhhdCB3YXMgb3BlbmVkLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBzb3VyY2VzP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCAnb3BlbicsIHsgc291cmNlOiBzb3VyY2UgfSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vcGVuaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBsb2FkaW5nIGEgVGlsZVNvdXJjZS5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IG9wZW4tZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1lc3NhZ2UgLSBJbmZvcm1hdGlvbiBhYm91dCB3aGF0IGZhaWxlZC5cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHNvdXJjZSAtIFRoZSB0aWxlIHNvdXJjZSB0aGF0IGZhaWxlZC5cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggJ29wZW4tZmFpbGVkJywgZmFpbEV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkb09uZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghJC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpIHx8ICFvcHRpb25zLnRpbGVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB0aWxlU291cmNlOiBvcHRpb25zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICQuY29uc29sZS5lcnJvcignW1ZpZXdlci5vcGVuXSBzZXR0aW5nIGluZGV4ZXMgaGVyZSBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYWRkVGlsZWRJbWFnZSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb25JbW1lZGlhdGVseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uSW1tZWRpYXRlbHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzZXMrKztcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG5vdyB0aGF0IG9wdGlvbnMgaGFzIG90aGVyIHRoaW5ncyBiZXNpZGVzIHRpbGVTb3VyY2UsIHRoZSBvdmVybGF5c1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBwcm9iYWJseSBiZSBhdCB0aGUgb3B0aW9ucyBsZXZlbCwgbm90IHRoZSB0aWxlU291cmNlIGxldmVsLlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbGVTb3VyY2Uub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnRpbGVTb3VyY2Uub3ZlcmxheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZE92ZXJsYXkob3B0aW9ucy50aWxlU291cmNlLm92ZXJsYXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdWNjZXNzKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaGVja0NvbXBsZXRpb24oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGZhaWx1cmVzKys7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZhaWxFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaGVja0NvbXBsZXRpb24oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF90aGlzLmFkZFRpbGVkSW1hZ2Uob3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGlsZVNvdXJjZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWxlU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZG9PbmUodGlsZVNvdXJjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6Y2xvc2VcbiAgICAgKi9cbiAgICBjbG9zZTogZnVuY3Rpb24gKCApIHtcbiAgICAgICAgaWYgKCAhVEhJU1sgdGhpcy5oYXNoIF0gKSB7XG4gICAgICAgICAgICAvL3RoaXMgdmlld2VyIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkOiByZXR1cm5pbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICggdGhpcy5uYXZpZ2F0b3IgKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRvci5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICEgdGhpcy5wcmVzZXJ2ZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyT3ZlcmxheXMoKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheXNDb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndvcmxkLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLmltYWdlTG9hZGVyLmNsZWFyKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIgaXMgY2xvc2VkIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2Nsb3NlfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBjbG9zZVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCggJ2Nsb3NlJyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGRlc3Ryb3kgdGhlIHZpZXdlciBhbmQgY2xlYW4gdXAgZXZlcnl0aGluZyBjcmVhdGVkIGJ5IE9wZW5TZWFkcmFnb24uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIHZhciB2aWV3ZXIgPSBPcGVuU2VhZHJhZ29uKHtcbiAgICAgKiAgIFsuLi5dXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvL3doZW4geW91IGFyZSBkb25lIHdpdGggdGhlIHZpZXdlcjpcbiAgICAgKiB2aWV3ZXIuZGVzdHJveSgpO1xuICAgICAqIHZpZXdlciA9IG51bGw7IC8vaW1wb3J0YW50XG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiggKSB7XG4gICAgICAgIGlmICggIVRISVNbIHRoaXMuaGFzaCBdICkge1xuICAgICAgICAgICAgLy90aGlzIHZpZXdlciBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZDogcmV0dXJuaW5nIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgdGhpcy5jbGVhck92ZXJsYXlzKCk7XG4gICAgICAgIHRoaXMub3ZlcmxheXNDb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAvL1RPRE86IGltcGxlbWVudCB0aGlzLi4uXG4gICAgICAgIC8vdGhpcy51bmJpbmRTZXF1ZW5jZUNvbnRyb2xzKClcbiAgICAgICAgLy90aGlzLnVuYmluZFN0YW5kYXJkQ29udHJvbHMoKVxuXG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZVN0cmlwKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZVN0cmlwLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RyaXAgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLl91cGRhdGVSZXF1ZXN0SWQgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAkLmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl91cGRhdGVSZXF1ZXN0SWQgKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuZHJhd2VyICkge1xuICAgICAgICAgICAgdGhpcy5kcmF3ZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxIYW5kbGVycygpO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggdG9wIGVsZW1lbnQgKHBhc3NlZCB0byB1cykgYW5kIHJlbW92ZSBhbGwgY2hpbGRyZW5cbiAgICAgICAgLy8gVXNlIHJlbW92ZUNoaWxkIHRvIG1ha2Ugc3VyZSBpdCBoYW5kbGVzIFNWRyBvciBhbnkgbm9uLWh0bWxcbiAgICAgICAgLy8gYWxzbyBpdCBwZXJmb3JtcyBiZXR0ZXIgLSBodHRwOi8vanNwZXJmLmNvbS9pbm5lcmh0bWwtdnMtcmVtb3ZlY2hpbGQvMTVcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCl7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSB0aGUgbW91c2UgdHJhY2tlcnNcbiAgICAgICAgaWYgKHRoaXMuaW5uZXJUcmFja2VyKXtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJUcmFja2VyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRlclRyYWNrZXIpe1xuICAgICAgICAgICAgdGhpcy5vdXRlclRyYWNrZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0gPSBudWxsO1xuICAgICAgICBkZWxldGUgVEhJU1sgdGhpcy5oYXNoIF07XG5cbiAgICAgICAgLy8gY2xlYXIgYWxsIG91ciByZWZlcmVuY2VzIHRvIGRvbSBvYmplY3RzXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIGNsZWFyIG91ciByZWZlcmVuY2UgdG8gdGhlIG1haW4gZWxlbWVudCAtIHRoZXkgd2lsbCBuZWVkIHRvIHBhc3MgaXQgaW4gYWdhaW4sIGNyZWF0aW5nIGEgbmV3IHZpZXdlclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTW91c2VOYXZFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyVHJhY2tlci5pc1RyYWNraW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZCAtIHRydWUgdG8gZW5hYmxlLCBmYWxzZSB0byBkaXNhYmxlXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6bW91c2UtZW5hYmxlZFxuICAgICAqL1xuICAgIHNldE1vdXNlTmF2RW5hYmxlZDogZnVuY3Rpb24oIGVuYWJsZWQgKXtcbiAgICAgICAgdGhpcy5pbm5lclRyYWNrZXIuc2V0VHJhY2tpbmcoIGVuYWJsZWQgKTtcbiAgICAgICAgdGhpcy5vdXRlclRyYWNrZXIuc2V0VHJhY2tpbmcoIGVuYWJsZWQgKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIG1vdXNlL3RvdWNoIG5hdmlnYXRpb24gaXMgZW5hYmxlZCBvciBkaXNhYmxlZCAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNzZXRNb3VzZU5hdkVuYWJsZWR9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IG1vdXNlLWVuYWJsZWRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAnbW91c2UtZW5hYmxlZCcsIHsgZW5hYmxlZDogZW5hYmxlZCB9ICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgYXJlQ29udHJvbHNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbmFibGVkID0gdGhpcy5jb250cm9scy5sZW5ndGgsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IoIGkgPSAwOyBpIDwgdGhpcy5jb250cm9scy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgZW5hYmxlZCA9IGVuYWJsZWQgJiYgdGhpcy5jb250cm9sc1sgaSBdLmlzVmlzaWJpbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5hYmxlZDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBvciBoaWRlcyB0aGUgY29udHJvbHMgKGUuZy4gdGhlIGRlZmF1bHQgbmF2aWdhdGlvbiBidXR0b25zKS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZSB0byBzaG93LCBmYWxzZSB0byBoaWRlLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmNvbnRyb2xzLWVuYWJsZWRcbiAgICAgKi9cbiAgICBzZXRDb250cm9sc0VuYWJsZWQ6IGZ1bmN0aW9uKCBlbmFibGVkICkge1xuICAgICAgICBpZiggZW5hYmxlZCApe1xuICAgICAgICAgICAgYWJvcnRDb250cm9sc0F1dG9IaWRlKCB0aGlzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZWdpbkNvbnRyb2xzQXV0b0hpZGUoIHRoaXMgKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIG5hdmlnYXRpb24gY29udHJvbHMgYXJlIHNob3duIG9yIGhpZGRlbiAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNzZXRDb250cm9sc0VuYWJsZWR9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGNvbnRyb2xzLWVuYWJsZWRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAnY29udHJvbHMtZW5hYmxlZCcsIHsgZW5hYmxlZDogZW5hYmxlZCB9ICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRnVsbFBhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFRISVNbIHRoaXMuaGFzaCBdLmZ1bGxQYWdlO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBmdWxsIHBhZ2UgbW9kZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGxQYWdlXG4gICAgICogICAgICBJZiB0cnVlLCBlbnRlciBmdWxsIHBhZ2UgbW9kZS4gIElmIGZhbHNlLCBleGl0IGZ1bGwgcGFnZSBtb2RlLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnByZS1mdWxsLXBhZ2VcbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6ZnVsbC1wYWdlXG4gICAgICovXG4gICAgc2V0RnVsbFBhZ2U6IGZ1bmN0aW9uKCBmdWxsUGFnZSApIHtcblxuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICBib2R5U3R5bGUgPSBib2R5LnN0eWxlLFxuICAgICAgICAgICAgZG9jU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vZG9udCBib3RoZXIgbW9kaWZ5aW5nIHRoZSBET00gaWYgd2UgYXJlIGFscmVhZHkgaW4gZnVsbCBwYWdlIG1vZGUuXG4gICAgICAgIGlmICggZnVsbFBhZ2UgPT0gdGhpcy5pc0Z1bGxQYWdlKCkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmdWxsUGFnZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIGZ1bGxQYWdlOiBmdWxsUGFnZSxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QWN0aW9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdlciBpcyBhYm91dCB0byBjaGFuZ2UgdG8vZnJvbSBmdWxsLXBhZ2UgbW9kZSAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNzZXRGdWxsUGFnZX0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgcHJlLWZ1bGwtcGFnZVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZnVsbFBhZ2UgLSBUcnVlIGlmIGVudGVyaW5nIGZ1bGwtcGFnZSBtb2RlLCBmYWxzZSBpZiBleGl0aW5nIGZ1bGwtcGFnZSBtb2RlLlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHByZXZlbnREZWZhdWx0QWN0aW9uIC0gU2V0IHRvIHRydWUgdG8gcHJldmVudCBmdWxsLXBhZ2UgbW9kZSBjaGFuZ2UuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdwcmUtZnVsbC1wYWdlJywgZnVsbFBhZ2VFdmVudEFyZ3MgKTtcbiAgICAgICAgaWYgKCBmdWxsUGFnZUV2ZW50QXJncy5wcmV2ZW50RGVmYXVsdEFjdGlvbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBmdWxsUGFnZSApIHtcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50U2l6ZSA9ICQuZ2V0RWxlbWVudFNpemUoIHRoaXMuZWxlbWVudCApO1xuICAgICAgICAgICAgdGhpcy5wYWdlU2Nyb2xsID0gJC5nZXRQYWdlU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudE1hcmdpbiA9IHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luID0gXCIwXCI7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRQYWRkaW5nID0gdGhpcy5lbGVtZW50LnN0eWxlLnBhZGRpbmc7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xuXG4gICAgICAgICAgICB0aGlzLmJvZHlNYXJnaW4gPSBib2R5U3R5bGUubWFyZ2luO1xuICAgICAgICAgICAgdGhpcy5kb2NNYXJnaW4gPSBkb2NTdHlsZS5tYXJnaW47XG4gICAgICAgICAgICBib2R5U3R5bGUubWFyZ2luID0gXCIwXCI7XG4gICAgICAgICAgICBkb2NTdHlsZS5tYXJnaW4gPSBcIjBcIjtcblxuICAgICAgICAgICAgdGhpcy5ib2R5UGFkZGluZyA9IGJvZHlTdHlsZS5wYWRkaW5nO1xuICAgICAgICAgICAgdGhpcy5kb2NQYWRkaW5nID0gZG9jU3R5bGUucGFkZGluZztcbiAgICAgICAgICAgIGJvZHlTdHlsZS5wYWRkaW5nID0gXCIwXCI7XG4gICAgICAgICAgICBkb2NTdHlsZS5wYWRkaW5nID0gXCIwXCI7XG5cbiAgICAgICAgICAgIHRoaXMuYm9keVdpZHRoID0gYm9keVN0eWxlLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5kb2NXaWR0aCA9IGRvY1N0eWxlLndpZHRoO1xuICAgICAgICAgICAgYm9keVN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICBkb2NTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuXG4gICAgICAgICAgICB0aGlzLmJvZHlIZWlnaHQgPSBib2R5U3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kb2NIZWlnaHQgPSBkb2NTdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICBib2R5U3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgICAgICBkb2NTdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcblxuICAgICAgICAgICAgLy93aGVuIGVudGVyaW5nIGZ1bGwgc2NyZWVuIG9uIHRoZSBpcGFkIGl0IHdhc250IHN1ZmZpY2llbnQgdG8gbGVhdmVcbiAgICAgICAgICAgIC8vdGhlIGJvZHkgaW50YWN0IGFzIG9ubHkgb25seSB0aGUgdG9wIGhhbGYgb2YgdGhlIHNjcmVlbiB3b3VsZFxuICAgICAgICAgICAgLy9yZXNwb25kIHRvIHRvdWNoIGV2ZW50cyBvbiB0aGUgY2FudmFzLCB3aGlsZSB0aGUgYm90dG9tIGhhbGYgdHJlYXRlZFxuICAgICAgICAgICAgLy90aGVtIGFzIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgYm9keS4gIFRodXMgd2UgcmVtb3ZlIGFuZCBzdG9yZVxuICAgICAgICAgICAgLy90aGUgYm9kaWVzIGVsZW1lbnRzIGFuZCByZXBsYWNlIHRoZW0gd2hlbiB3ZSBsZWF2ZSBmdWxsIHNjcmVlbi5cbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNCb2R5ID0gW107XG4gICAgICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5wcmV2RWxlbWVudFBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ucHJldk5leHRTaWJsaW5nID0gdGhpcy5lbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ucHJldkVsZW1lbnRXaWR0aCA9IHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLnByZXZFbGVtZW50SGVpZ2h0ID0gdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIG5vZGVzID0gYm9keS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbm9kZXM7IGkrKyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQm9keS5wdXNoKCBib2R5LmNoaWxkTm9kZXNbIDAgXSApO1xuICAgICAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoIGJvZHkuY2hpbGROb2Rlc1sgMCBdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vSWYgd2UndmUgZ290IGEgdG9vbGJhciwgd2UgbmVlZCB0byBlbmFibGUgdGhlIHVzZXIgdG8gdXNlIGNzcyB0b1xuICAgICAgICAgICAgLy9wcmVzZXJ2ZSBpdCBpbiBmdWxscGFnZSBtb2RlXG4gICAgICAgICAgICBpZiAoIHRoaXMudG9vbGJhciAmJiB0aGlzLnRvb2xiYXIuZWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICAvL3NhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcbiAgICAgICAgICAgICAgICAvL2luIHRoZSBsb25nIHJ1biB3ZSBuZWVkIGEgYmV0dGVyIHN0cmF0ZWd5XG4gICAgICAgICAgICAgICAgdGhpcy50b29sYmFyLnBhcmVudE5vZGUgPSB0aGlzLnRvb2xiYXIuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci5uZXh0U2libGluZyA9IHRoaXMudG9vbGJhci5lbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoIHRoaXMudG9vbGJhci5lbGVtZW50ICk7XG5cbiAgICAgICAgICAgICAgICAvL01ha2Ugc3VyZSB0aGUgdXNlciBoYXMgc29tZSBhYmlsaXR5IHRvIHN0eWxlIHRoZSB0b29sYmFyIGJhc2VkXG4gICAgICAgICAgICAgICAgLy9vbiB0aGUgbW9kZVxuICAgICAgICAgICAgICAgICQuYWRkQ2xhc3MoIHRoaXMudG9vbGJhci5lbGVtZW50LCAnZnVsbHBhZ2UnICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuYWRkQ2xhc3MoIHRoaXMuZWxlbWVudCwgJ2Z1bGxwYWdlJyApO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZCggdGhpcy5lbGVtZW50ICk7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAkLmdldFdpbmRvd1NpemUoKS55ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICQuZ2V0V2luZG93U2l6ZSgpLnggKyAncHgnO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMudG9vbGJhciAmJiB0aGlzLnRvb2xiYXIuZWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKFxuICAgICAgICAgICAgICAgICAgICAkLmdldEVsZW1lbnRTaXplKCB0aGlzLmVsZW1lbnQgKS55IC0gJC5nZXRFbGVtZW50U2l6ZSggdGhpcy50b29sYmFyLmVsZW1lbnQgKS55XG4gICAgICAgICAgICAgICAgKSArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLmZ1bGxQYWdlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gbW91c2Ugd2lsbCBiZSBpbnNpZGUgY29udGFpbmVyIG5vd1xuICAgICAgICAgICAgJC5kZWxlZ2F0ZSggdGhpcywgb25Db250YWluZXJFbnRlciApKCB7fSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW4gPSB0aGlzLmVsZW1lbnRNYXJnaW47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucGFkZGluZyA9IHRoaXMuZWxlbWVudFBhZGRpbmc7XG5cbiAgICAgICAgICAgIGJvZHlTdHlsZS5tYXJnaW4gPSB0aGlzLmJvZHlNYXJnaW47XG4gICAgICAgICAgICBkb2NTdHlsZS5tYXJnaW4gPSB0aGlzLmRvY01hcmdpbjtcblxuICAgICAgICAgICAgYm9keVN0eWxlLnBhZGRpbmcgPSB0aGlzLmJvZHlQYWRkaW5nO1xuICAgICAgICAgICAgZG9jU3R5bGUucGFkZGluZyA9IHRoaXMuZG9jUGFkZGluZztcblxuICAgICAgICAgICAgYm9keVN0eWxlLndpZHRoID0gdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgICAgICBkb2NTdHlsZS53aWR0aCA9IHRoaXMuZG9jV2lkdGg7XG5cbiAgICAgICAgICAgIGJvZHlTdHlsZS5oZWlnaHQgPSB0aGlzLmJvZHlIZWlnaHQ7XG4gICAgICAgICAgICBkb2NTdHlsZS5oZWlnaHQgPSB0aGlzLmRvY0hlaWdodDtcblxuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZCggdGhpcy5lbGVtZW50ICk7XG4gICAgICAgICAgICBub2RlcyA9IHRoaXMucHJldmlvdXNCb2R5Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbm9kZXM7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKCB0aGlzLnByZXZpb3VzQm9keS5zaGlmdCgpICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQucmVtb3ZlQ2xhc3MoIHRoaXMuZWxlbWVudCwgJ2Z1bGxwYWdlJyApO1xuICAgICAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ucHJldkVsZW1lbnRQYXJlbnQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5wcmV2TmV4dFNpYmxpbmdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vSWYgd2UndmUgZ290IGEgdG9vbGJhciwgd2UgbmVlZCB0byBlbmFibGUgdGhlIHVzZXIgdG8gdXNlIGNzcyB0b1xuICAgICAgICAgICAgLy9yZXNldCBpdCB0byBpdHMgb3JpZ2luYWwgc3RhdGVcbiAgICAgICAgICAgIGlmICggdGhpcy50b29sYmFyICYmIHRoaXMudG9vbGJhci5lbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoIHRoaXMudG9vbGJhci5lbGVtZW50ICk7XG5cbiAgICAgICAgICAgICAgICAvL01ha2Ugc3VyZSB0aGUgdXNlciBoYXMgc29tZSBhYmlsaXR5IHRvIHN0eWxlIHRoZSB0b29sYmFyIGJhc2VkXG4gICAgICAgICAgICAgICAgLy9vbiB0aGUgbW9kZVxuICAgICAgICAgICAgICAgICQucmVtb3ZlQ2xhc3MoIHRoaXMudG9vbGJhci5lbGVtZW50LCAnZnVsbHBhZ2UnICk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRvb2xiYXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50b29sYmFyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBUSElTWyB0aGlzLmhhc2ggXS5wcmV2RWxlbWVudFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IFRISVNbIHRoaXMuaGFzaCBdLnByZXZFbGVtZW50SGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBBZnRlciBleGl0aW5nIGZ1bGxQYWdlIG9yIGZ1bGxTY3JlZW4sIGl0IGNhbiB0YWtlIHNvbWUgdGltZVxuICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSBicm93c2VyIGNhbiBhY3R1YWxseSBzZXQgdGhlIHNjcm9sbC5cbiAgICAgICAgICAgIHZhciByZXN0b3JlU2Nyb2xsQ291bnRlciA9IDA7XG4gICAgICAgICAgICB2YXIgcmVzdG9yZVNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQuc2V0UGFnZVNjcm9sbCggX3RoaXMucGFnZVNjcm9sbCApO1xuICAgICAgICAgICAgICAgIHZhciBwYWdlU2Nyb2xsID0gJC5nZXRQYWdlU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgcmVzdG9yZVNjcm9sbENvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBpZiAoIHJlc3RvcmVTY3JvbGxDb3VudGVyIDwgMTAgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNjcm9sbC54ICE9PSBfdGhpcy5wYWdlU2Nyb2xsLnggfHxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNjcm9sbC55ICE9PSBfdGhpcy5wYWdlU2Nyb2xsLnkgKSB7XG4gICAgICAgICAgICAgICAgICAgICQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZXN0b3JlU2Nyb2xsICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZXN0b3JlU2Nyb2xsICk7XG5cbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLmZ1bGxQYWdlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIG1vdXNlIHdpbGwgbGlrZWx5IGJlIG91dHNpZGUgbm93XG4gICAgICAgICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNvbnRhaW5lckV4aXQgKSggeyB9ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5uYXZpZ2F0b3IgJiYgdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yLnVwZGF0ZSggdGhpcy52aWV3cG9ydCApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIgaGFzIGNoYW5nZWQgdG8vZnJvbSBmdWxsLXBhZ2UgbW9kZSAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNzZXRGdWxsUGFnZX0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgZnVsbC1wYWdlXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmdWxsUGFnZSAtIFRydWUgaWYgY2hhbmdlZCB0byBmdWxsLXBhZ2UgbW9kZSwgZmFsc2UgaWYgZXhpdGVkIGZ1bGwtcGFnZSBtb2RlLlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdmdWxsLXBhZ2UnLCB7IGZ1bGxQYWdlOiBmdWxsUGFnZSB9ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBmdWxsIHNjcmVlbiBtb2RlIGlmIHN1cHBvcnRlZC4gVG9nZ2xlIGZ1bGwgcGFnZSBtb2RlIG90aGVyd2lzZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGxTY3JlZW5cbiAgICAgKiAgICAgIElmIHRydWUsIGVudGVyIGZ1bGwgc2NyZWVuIG1vZGUuICBJZiBmYWxzZSwgZXhpdCBmdWxsIHNjcmVlbiBtb2RlLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnByZS1mdWxsLXNjcmVlblxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpmdWxsLXNjcmVlblxuICAgICAqL1xuICAgIHNldEZ1bGxTY3JlZW46IGZ1bmN0aW9uKCBmdWxsU2NyZWVuICkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICggISQuc3VwcG9ydHNGdWxsU2NyZWVuICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnVsbFBhZ2UoIGZ1bGxTY3JlZW4gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggJC5pc0Z1bGxTY3JlZW4oKSA9PT0gZnVsbFNjcmVlbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZ1bGxTY3JlZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIGZ1bGxTY3JlZW46IGZ1bGxTY3JlZW4sXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdEFjdGlvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSB2aWV3ZXIgaXMgYWJvdXQgdG8gY2hhbmdlIHRvL2Zyb20gZnVsbC1zY3JlZW4gbW9kZSAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNzZXRGdWxsU2NyZWVufSkuXG4gICAgICAgICAqIE5vdGU6IHRoZSBwcmUtZnVsbC1zY3JlZW4gZXZlbnQgaXMgbm90IHJhaXNlZCB3aGVuIHRoZSB1c2VyIGlzIGV4aXRpbmdcbiAgICAgICAgICogZnVsbC1zY3JlZW4gbW9kZSBieSBwcmVzc2luZyB0aGUgRXNjIGtleS4gSW4gdGhhdCBjYXNlLCBjb25zaWRlciB1c2luZ1xuICAgICAgICAgKiB0aGUgZnVsbC1zY3JlZW4sIHByZS1mdWxsLXBhZ2Ugb3IgZnVsbC1wYWdlIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IHByZS1mdWxsLXNjcmVlblxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZnVsbFNjcmVlbiAtIFRydWUgaWYgZW50ZXJpbmcgZnVsbC1zY3JlZW4gbW9kZSwgZmFsc2UgaWYgZXhpdGluZyBmdWxsLXNjcmVlbiBtb2RlLlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHByZXZlbnREZWZhdWx0QWN0aW9uIC0gU2V0IHRvIHRydWUgdG8gcHJldmVudCBmdWxsLXNjcmVlbiBtb2RlIGNoYW5nZS4gRGVmYXVsdDogZmFsc2UuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCggJ3ByZS1mdWxsLXNjcmVlbicsIGZ1bGxTY3JlZUV2ZW50QXJncyApO1xuICAgICAgICBpZiAoIGZ1bGxTY3JlZUV2ZW50QXJncy5wcmV2ZW50RGVmYXVsdEFjdGlvbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBmdWxsU2NyZWVuICkge1xuXG4gICAgICAgICAgICB0aGlzLnNldEZ1bGxQYWdlKCB0cnVlICk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZnVsbCBwYWdlIG1vZGUgaXMgbm90IGFjdHVhbGx5IGVudGVyZWQsIHdlIG5lZWQgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gdGhlIGZ1bGwgc2NyZWVuIG1vZGUuXG4gICAgICAgICAgICBpZiAoICF0aGlzLmlzRnVsbFBhZ2UoKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mdWxsUGFnZVN0eWxlV2lkdGggPSB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmZ1bGxQYWdlU3R5bGVIZWlnaHQgPSB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgICAgICAgICAgdmFyIG9uRnVsbFNjcmVlbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0Z1bGxTY3JlZW4gPSAkLmlzRnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgICAgIGlmICggIWlzRnVsbFNjcmVlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5yZW1vdmVFdmVudCggZG9jdW1lbnQsICQuZnVsbFNjcmVlbkV2ZW50TmFtZSwgb25GdWxsU2NyZWVuQ2hhbmdlICk7XG4gICAgICAgICAgICAgICAgICAgICQucmVtb3ZlRXZlbnQoIGRvY3VtZW50LCAkLmZ1bGxTY3JlZW5FcnJvckV2ZW50TmFtZSwgb25GdWxsU2NyZWVuQ2hhbmdlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0RnVsbFBhZ2UoIGZhbHNlICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggX3RoaXMuaXNGdWxsUGFnZSgpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IF90aGlzLmZ1bGxQYWdlU3R5bGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gX3RoaXMuZnVsbFBhZ2VTdHlsZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIF90aGlzLm5hdmlnYXRvciAmJiBfdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdG9yLnVwZGF0ZSggX3RoaXMudmlld3BvcnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdlciBoYXMgY2hhbmdlZCB0by9mcm9tIGZ1bGwtc2NyZWVuIG1vZGUgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjc2V0RnVsbFNjcmVlbn0pLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IGZ1bGwtc2NyZWVuXG4gICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGZ1bGxTY3JlZW4gLSBUcnVlIGlmIGNoYW5nZWQgdG8gZnVsbC1zY3JlZW4gbW9kZSwgZmFsc2UgaWYgZXhpdGVkIGZ1bGwtc2NyZWVuIG1vZGUuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoICdmdWxsLXNjcmVlbicsIHsgZnVsbFNjcmVlbjogaXNGdWxsU2NyZWVuIH0gKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkLmFkZEV2ZW50KCBkb2N1bWVudCwgJC5mdWxsU2NyZWVuRXZlbnROYW1lLCBvbkZ1bGxTY3JlZW5DaGFuZ2UgKTtcbiAgICAgICAgICAgICQuYWRkRXZlbnQoIGRvY3VtZW50LCAkLmZ1bGxTY3JlZW5FcnJvckV2ZW50TmFtZSwgb25GdWxsU2NyZWVuQ2hhbmdlICk7XG5cbiAgICAgICAgICAgICQucmVxdWVzdEZ1bGxTY3JlZW4oIGRvY3VtZW50LmJvZHkgKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5leGl0RnVsbFNjcmVlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSAhPSBcImhpZGRlblwiO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnZpc2libGVcbiAgICAgKi9cbiAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiggdmlzaWJsZSApe1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJsZSA/IFwiXCIgOiBcImhpZGRlblwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdlciBpcyBzaG93biBvciBoaWRkZW4gKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjc2V0VmlzaWJsZX0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgdmlzaWJsZVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdmlzaWJsZVxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICd2aXNpYmxlJywgeyB2aXNpYmxlOiB2aXNpYmxlIH0gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHRpbGVkIGltYWdlIHRvIHRoZSB2aWV3ZXIuXG4gICAgICogb3B0aW9ucy50aWxlU291cmNlIGNhbiBiZSBhbnl0aGluZyB0aGF0IHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNvcGVufVxuICAgICAqICBzdXBwb3J0cyBleGNlcHQgYXJyYXlzIG9mIGltYWdlcy5cbiAgICAgKiBOb3RlIHRoYXQgeW91IGNhbiBzcGVjaWZ5IG9wdGlvbnMud2lkdGggb3Igb3B0aW9ucy5oZWlnaHQsIGJ1dCBub3QgYm90aC5cbiAgICAgKiBUaGUgb3RoZXIgZGltZW5zaW9uIHdpbGwgYmUgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGl0ZW0ncyBhc3BlY3QgcmF0aW8uXG4gICAgICogSWYgY29sbGVjdGlvbk1vZGUgaXMgb24gKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfSksIHRoZSBuZXcgaW1hZ2UgaXNcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGFycmFuZ2VkIHdpdGggdGhlIG90aGVycy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gb3B0aW9ucy50aWxlU291cmNlIC0gVGhlIFRpbGVTb3VyY2Ugc3BlY2lmaWVyLlxuICAgICAqIEEgU3RyaW5nIGltcGxpZXMgYSB1cmwgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHRpbGVTb3VyY2UgaW1wbGVtZW50YXRpb25cbiAgICAgKiAgICAgIGJhc2VkIG9uIHRoZSBmaWxlIGV4dGVuc2lvbiBvZiB1cmwuIEpTT05QIGlzIGltcGxpZWQgYnkgKi5qcyxcbiAgICAgKiAgICAgIG90aGVyd2lzZSB0aGUgdXJsIGlzIHJldHJpZXZlZCBhcyB0ZXh0IGFuZCB0aGUgcmVzdWx0aW5nIHRleHQgaXNcbiAgICAgKiAgICAgIGludHJvc3BlY3RlZCB0byBkZXRlcm1pbmUgaWYgaXRzIGpzb24sIHhtbCwgb3IgdGV4dCBhbmQgcGFyc2VkLlxuICAgICAqIEFuIE9iamVjdCBpbXBsaWVzIGFuIGlubGluZSBjb25maWd1cmF0aW9uIHdoaWNoIGhhcyBhIHNpbmdsZVxuICAgICAqICAgICAgcHJvcGVydHkgc3VmZmljaWVudCBmb3IgYmVpbmcgYWJsZSB0byBkZXRlcm1pbmUgdGlsZVNvdXJjZVxuICAgICAqICAgICAgaW1wbGVtZW50YXRpb24uIElmIHRoZSBvYmplY3QgaGFzIGEgcHJvcGVydHkgd2hpY2ggaXMgYSBmdW5jdGlvblxuICAgICAqICAgICAgbmFtZWQgJ2dldFRpbGVVcmwnLCBpdCBpcyB0cmVhdGVkIGFzIGEgY3VzdG9tIFRpbGVTb3VyY2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmluZGV4XSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0uIEFkZGVkIG9uIHRvcCBvZlxuICAgICAqIGFsbCBvdGhlciBpdGVtcyBpZiBub3Qgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVwbGFjZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGl0ZW0gYXQgb3B0aW9ucy5pbmRleCB3aWxsIGJlXG4gICAgICogcmVtb3ZlZCBhbmQgdGhlIG5ldyBpdGVtIGlzIGFkZGVkIGluIGl0cyBwbGFjZS4gb3B0aW9ucy50aWxlU291cmNlIHdpbGwgYmVcbiAgICAgKiBpbnRlcnByZXRlZCBhbmQgZmV0Y2hlZCBpZiBuZWNlc3NhcnkgYmVmb3JlIHRoZSBvbGQgaXRlbSBpcyByZW1vdmVkIHRvIGF2b2lkIGxlYXZpbmdcbiAgICAgKiBhIGdhcCBpbiB0aGUgd29ybGQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLng9MF0gVGhlIFggcG9zaXRpb24gZm9yIHRoZSBpbWFnZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueT0wXSBUaGUgWSBwb3NpdGlvbiBmb3IgdGhlIGltYWdlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD0xXSBUaGUgd2lkdGggZm9yIHRoZSBpbWFnZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBUaGUgaGVpZ2h0IGZvciB0aGUgaW1hZ2UgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFtvcHRpb25zLmZpdEJvdW5kc10gVGhlIGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlc1xuICAgICAqIHRvIGZpdCB0aGUgaW1hZ2UgaW50by4gSWYgc3BlY2lmaWVkLCB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0IGdldCBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IFtvcHRpb25zLmZpdEJvdW5kc1BsYWNlbWVudD1PcGVuU2VhZHJhZ29uLlBsYWNlbWVudC5DRU5URVJdXG4gICAgICogSG93IHRvIGFuY2hvciB0aGUgaW1hZ2UgaW4gdGhlIGJvdW5kcyBpZiBvcHRpb25zLmZpdEJvdW5kcyBpcyBzZXQuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFtvcHRpb25zLmNsaXBdIC0gQW4gYXJlYSwgaW4gaW1hZ2UgcGl4ZWxzLCB0byBjbGlwIHRvXG4gICAgICogKHBvcnRpb25zIG9mIHRoZSBpbWFnZSBvdXRzaWRlIG9mIHRoaXMgYXJlYSB3aWxsIG5vdCBiZSB2aXNpYmxlKS4gT25seSB3b3JrcyBvblxuICAgICAqIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0aGUgSFRNTDUgY2FudmFzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vcGFjaXR5XSBPcGFjaXR5IHRoZSB0aWxlZCBpbWFnZSBzaG91bGQgYmUgZHJhd24gYXQgYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29tcG9zaXRlT3BlcmF0aW9uXSBIb3cgdGhlIGltYWdlIGlzIGNvbXBvc2l0ZWQgb250byBvdGhlciBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuc3VjY2Vzc10gQSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGltYWdlIGlzXG4gICAgICogc3VjY2Vzc2Z1bGx5IGFkZGVkLiBJdCdzIHBhc3NlZCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGEgc2luZ2xlIHByb3BlcnR5OlxuICAgICAqIFwiaXRlbVwiLCB0aGUgcmVzdWx0aW5nIFRpbGVkSW1hZ2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZXJyb3JdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBpZiB0aGUgaW1hZ2UgaXNcbiAgICAgKiB1bmFibGUgdG8gYmUgYWRkZWQuIEl0J3MgcGFzc2VkIHRoZSBlcnJvciBldmVudCBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIFwibWVzc2FnZVwiXG4gICAgICogYW5kIFwic291cmNlXCIgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbGxlY3Rpb25JbW1lZGlhdGVseT1mYWxzZV0gSWYgY29sbGVjdGlvbk1vZGUgaXMgb24sXG4gICAgICogc3BlY2lmaWVzIHdoZXRoZXIgdG8gc25hcCB0byB0aGUgbmV3IGFycmFuZ2VtZW50IGltbWVkaWF0ZWx5IG9yIHRvIGFuaW1hdGUgdG8gaXQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8Q2FudmFzR3JhZGllbnR8Q2FudmFzUGF0dGVybnxGdW5jdGlvbn0gW29wdGlvbnMucGxhY2Vob2xkZXJGaWxsU3R5bGVdIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLldvcmxkLmV2ZW50OmFkZC1pdGVtXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmFkZC1pdGVtLWZhaWxlZFxuICAgICAqL1xuICAgIGFkZFRpbGVkSW1hZ2U6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KG9wdGlvbnMsIFwiW1ZpZXdlci5hZGRUaWxlZEltYWdlXSBvcHRpb25zIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KG9wdGlvbnMudGlsZVNvdXJjZSwgXCJbVmlld2VyLmFkZFRpbGVkSW1hZ2VdIG9wdGlvbnMudGlsZVNvdXJjZSBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCghb3B0aW9ucy5yZXBsYWNlIHx8IChvcHRpb25zLmluZGV4ID4gLTEgJiYgb3B0aW9ucy5pbmRleCA8IHRoaXMud29ybGQuZ2V0SXRlbUNvdW50KCkpLFxuICAgICAgICAgICAgXCJbVmlld2VyLmFkZFRpbGVkSW1hZ2VdIGlmIG9wdGlvbnMucmVwbGFjZSBpcyB1c2VkLCBvcHRpb25zLmluZGV4IG11c3QgYmUgYSB2YWxpZCBpbmRleCBpbiBWaWV3ZXIud29ybGRcIik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGxhY2VJdGVtID0gX3RoaXMud29ybGQuZ2V0SXRlbUF0KG9wdGlvbnMuaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGlkZU1lc3NhZ2UoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlckZpbGxTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBsYWNlaG9sZGVyRmlsbFN0eWxlID0gdGhpcy5wbGFjZWhvbGRlckZpbGxTdHlsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jb21wb3NpdGVPcGVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBteVF1ZXVlSXRlbSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiByYWlzZUFkZEl0ZW1GYWlsZWQoIGV2ZW50ICkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9sb2FkUXVldWVbaV0gPT09IG15UXVldWVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hXb3JsZChteVF1ZXVlSXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBpdGVtLlxuICAgICAgICAgICAgICogQGV2ZW50IGFkZC1pdGVtLWZhaWxlZFxuICAgICAgICAgICAgICogQG1lbWJlck9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHNvdXJjZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhZGRUaWxlZEltYWdlIG1ldGhvZC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggJ2FkZC1pdGVtLWZhaWxlZCcsIGV2ZW50ICk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWZyZXNoV29ybGQodGhlSXRlbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbGxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud29ybGQuYXJyYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5OiB0aGVJdGVtLm9wdGlvbnMuY29sbGVjdGlvbkltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgICAgICAgICByb3dzOiBfdGhpcy5jb2xsZWN0aW9uUm93cyxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uczogX3RoaXMuY29sbGVjdGlvbkNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDogX3RoaXMuY29sbGVjdGlvbkxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNpemU6IF90aGlzLmNvbGxlY3Rpb25UaWxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGlsZU1hcmdpbjogX3RoaXMuY29sbGVjdGlvblRpbGVNYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy53b3JsZC5zZXRBdXRvUmVmaWd1cmVTaXplcyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkLmlzQXJyYXkob3B0aW9ucy50aWxlU291cmNlKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByYWlzZUFkZEl0ZW1GYWlsZWQoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIltWaWV3ZXIuYWRkVGlsZWRJbWFnZV0gU2VxdWVuY2VzIGNhbiBub3QgYmUgYWRkZWQ7IGFkZCB0aGVtIG9uZSBhdCBhIHRpbWUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBvcHRpb25zLnRpbGVTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9hZFF1ZXVlLnB1c2gobXlRdWV1ZUl0ZW0pO1xuXG4gICAgICAgIGdldFRpbGVTb3VyY2VJbXBsZW1lbnRhdGlvbiggdGhpcywgb3B0aW9ucy50aWxlU291cmNlLCBmdW5jdGlvbiggdGlsZVNvdXJjZSApIHtcblxuICAgICAgICAgICAgbXlRdWV1ZUl0ZW0udGlsZVNvdXJjZSA9IHRpbGVTb3VyY2U7XG5cbiAgICAgICAgICAgIC8vIGFkZCBldmVyeWJvZHkgYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZSB0aGF0J3MgcmVhZHkgdG8gZ29cbiAgICAgICAgICAgIHZhciBxdWV1ZUl0ZW0sIHRpbGVkSW1hZ2UsIG9wdGlvbnNDbG9uZTtcbiAgICAgICAgICAgIHdoaWxlIChfdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbSA9IF90aGlzLl9sb2FkUXVldWVbMF07XG4gICAgICAgICAgICAgICAgaWYgKCFxdWV1ZUl0ZW0udGlsZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZFF1ZXVlLnNwbGljZSgwLCAxKTtcblxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZUl0ZW0ub3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IF90aGlzLndvcmxkLmdldEluZGV4T2ZJdGVtKHF1ZXVlSXRlbS5vcHRpb25zLnJlcGxhY2VJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0ub3B0aW9ucy5pbmRleCA9IG5ld0luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLndvcmxkLnJlbW92ZUl0ZW0ocXVldWVJdGVtLm9wdGlvbnMucmVwbGFjZUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRpbGVkSW1hZ2UgPSBuZXcgJC5UaWxlZEltYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyOiBfdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBxdWV1ZUl0ZW0udGlsZVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQ6IF90aGlzLnZpZXdwb3J0LFxuICAgICAgICAgICAgICAgICAgICBkcmF3ZXI6IF90aGlzLmRyYXdlcixcbiAgICAgICAgICAgICAgICAgICAgdGlsZUNhY2hlOiBfdGhpcy50aWxlQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlTG9hZGVyOiBfdGhpcy5pbWFnZUxvYWRlcixcbiAgICAgICAgICAgICAgICAgICAgeDogcXVldWVJdGVtLm9wdGlvbnMueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcXVldWVJdGVtLm9wdGlvbnMueSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHF1ZXVlSXRlbS5vcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHF1ZXVlSXRlbS5vcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZml0Qm91bmRzOiBxdWV1ZUl0ZW0ub3B0aW9ucy5maXRCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgIGZpdEJvdW5kc1BsYWNlbWVudDogcXVldWVJdGVtLm9wdGlvbnMuZml0Qm91bmRzUGxhY2VtZW50LFxuICAgICAgICAgICAgICAgICAgICBjbGlwOiBxdWV1ZUl0ZW0ub3B0aW9ucy5jbGlwLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckZpbGxTdHlsZTogcXVldWVJdGVtLm9wdGlvbnMucGxhY2Vob2xkZXJGaWxsU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHF1ZXVlSXRlbS5vcHRpb25zLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZU9wZXJhdGlvbjogcXVldWVJdGVtLm9wdGlvbnMuY29tcG9zaXRlT3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzcHJpbmdTdGlmZm5lc3M6IF90aGlzLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uVGltZTogX3RoaXMuYW5pbWF0aW9uVGltZSxcbiAgICAgICAgICAgICAgICAgICAgbWluWm9vbUltYWdlUmF0aW86IF90aGlzLm1pblpvb21JbWFnZVJhdGlvLFxuICAgICAgICAgICAgICAgICAgICB3cmFwSG9yaXpvbnRhbDogX3RoaXMud3JhcEhvcml6b250YWwsXG4gICAgICAgICAgICAgICAgICAgIHdyYXBWZXJ0aWNhbDogX3RoaXMud3JhcFZlcnRpY2FsLFxuICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IF90aGlzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRUaW1lOiBfdGhpcy5ibGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c0JsZW5kOiBfdGhpcy5hbHdheXNCbGVuZCxcbiAgICAgICAgICAgICAgICAgICAgbWluUGl4ZWxSYXRpbzogX3RoaXMubWluUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoVGlsZUVkZ2VzTWluWm9vbTogX3RoaXMuc21vb3RoVGlsZUVkZ2VzTWluWm9vbSxcbiAgICAgICAgICAgICAgICAgICAgaU9TRGV2aWNlOiBfdGhpcy5pT1NEZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luUG9saWN5OiBfdGhpcy5jcm9zc09yaWdpblBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgZGVidWdNb2RlOiBfdGhpcy5kZWJ1Z01vZGVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb2xsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy53b3JsZC5zZXRBdXRvUmVmaWd1cmVTaXplcyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLndvcmxkLmFkZEl0ZW0oIHRpbGVkSW1hZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHF1ZXVlSXRlbS5vcHRpb25zLmluZGV4XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2xvYWRRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzIHJlc3RvcmVzIHRoZSBhdXRvUmVmaWd1cmVTaXplcyBmbGFnIHRvIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hXb3JsZChxdWV1ZUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy53b3JsZC5nZXRJdGVtQ291bnQoKSA9PT0gMSAmJiAhX3RoaXMucHJlc2VydmVWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3cG9ydC5nb0hvbWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm5hdmlnYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zQ2xvbmUgPSAkLmV4dGVuZCh7fSwgcXVldWVJdGVtLm9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2U6IGZhbHNlLCAvLyBuYXZpZ2F0b3IgYWxyZWFkeSByZW1vdmVkIHRoZSBsYXllciwgbm90aGluZyB0byByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFRpbGVkSW1hZ2U6IHRpbGVkSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlU291cmNlOiBxdWV1ZUl0ZW0udGlsZVNvdXJjZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0b3IuYWRkVGlsZWRJbWFnZShvcHRpb25zQ2xvbmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZUl0ZW0ub3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5vcHRpb25zLnN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogdGlsZWRJbWFnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGV2ZW50Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgcmFpc2VBZGRJdGVtRmFpbGVkKGV2ZW50KTtcbiAgICAgICAgfSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzaW1wbGUgaW1hZ2UgdG8gdGhlIHZpZXdlci5cbiAgICAgKiBUaGUgb3B0aW9ucyBhcmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZFRpbGVkSW1hZ2V9XG4gICAgICogZXhjZXB0IGZvciBvcHRpb25zLnRpbGVTb3VyY2Ugd2hpY2ggaXMgcmVwbGFjZWQgYnkgb3B0aW9ucy51cmwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZFRpbGVkSW1hZ2V9XG4gICAgICogZm9yIGFsbCB0aGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIFRoZSBVUkwgb2YgdGhlIGltYWdlIHRvIGFkZC5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5Xb3JsZC5ldmVudDphZGQtaXRlbVxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDphZGQtaXRlbS1mYWlsZWRcbiAgICAgKi9cbiAgICBhZGRTaW1wbGVJbWFnZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KG9wdGlvbnMsIFwiW1ZpZXdlci5hZGRTaW1wbGVJbWFnZV0gb3B0aW9ucyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChvcHRpb25zLnVybCwgXCJbVmlld2VyLmFkZFNpbXBsZUltYWdlXSBvcHRpb25zLnVybCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgICB2YXIgb3B0cyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICB0aWxlU291cmNlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICBvcHRpb25zLnVybFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIG9wdHMudXJsO1xuICAgICAgICB0aGlzLmFkZFRpbGVkSW1hZ2Uob3B0cyk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBhZGRMYXllcjogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgJC5jb25zb2xlLmVycm9yKCBcIltWaWV3ZXIuYWRkTGF5ZXJdIHRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIFZpZXdlci5hZGRUaWxlZEltYWdlKCkgaW5zdGVhZC5cIiApO1xuXG4gICAgICAgIHZhciBvcHRpb25zQ2xvbmUgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KFwiYWRkLWxheWVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyOiBldmVudC5pdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudChcImFkZC1sYXllci1mYWlsZWRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZFRpbGVkSW1hZ2Uob3B0aW9uc0Nsb25lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBnZXRMYXllckF0TGV2ZWw6IGZ1bmN0aW9uKCBsZXZlbCApIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKCBcIltWaWV3ZXIuZ2V0TGF5ZXJBdExldmVsXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBXb3JsZC5nZXRJdGVtQXQoKSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmdldEl0ZW1BdChsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBnZXRMZXZlbE9mTGF5ZXI6IGZ1bmN0aW9uKCBkcmF3ZXIgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbVmlld2VyLmdldExldmVsT2ZMYXllcl0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgV29ybGQuZ2V0SW5kZXhPZkl0ZW0oKSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmdldEluZGV4T2ZJdGVtKGRyYXdlcik7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBnZXRMYXllcnNDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbVmlld2VyLmdldExheWVyc0NvdW50XSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBXb3JsZC5nZXRJdGVtQ291bnQoKSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmdldEl0ZW1Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgc2V0TGF5ZXJMZXZlbDogZnVuY3Rpb24oIGRyYXdlciwgbGV2ZWwgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbVmlld2VyLnNldExheWVyTGV2ZWxdIHRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIFdvcmxkLnNldEl0ZW1JbmRleCgpIGluc3RlYWQuXCIgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGQuc2V0SXRlbUluZGV4KGRyYXdlciwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uKCBkcmF3ZXIgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbVmlld2VyLnJlbW92ZUxheWVyXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBXb3JsZC5yZW1vdmVJdGVtKCkgaW5zdGVhZC5cIiApO1xuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5yZW1vdmVJdGVtKGRyYXdlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcmNlIHRoZSB2aWV3ZXIgdG8gcmVkcmF3IGl0cyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IENoYWluYWJsZS5cbiAgICAgKi9cbiAgICBmb3JjZVJlZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLmZvcmNlUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgYmluZFNlcXVlbmNlQ29udHJvbHM6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gSW1hZ2UgU2VxdWVuY2UgQ29udHJvbHNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgdmFyIG9uRm9jdXNIYW5kbGVyICAgICAgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgb25Gb2N1cyApLFxuICAgICAgICAgICAgb25CbHVySGFuZGxlciAgICAgICAgICAgPSAkLmRlbGVnYXRlKCB0aGlzLCBvbkJsdXIgKSxcbiAgICAgICAgICAgIG9uTmV4dEhhbmRsZXIgICAgICAgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgb25OZXh0ICksXG4gICAgICAgICAgICBvblByZXZpb3VzSGFuZGxlciAgICAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIG9uUHJldmlvdXMgKSxcbiAgICAgICAgICAgIG5hdkltYWdlcyAgICAgICAgICAgICAgID0gdGhpcy5uYXZJbWFnZXMsXG4gICAgICAgICAgICB1c2VHcm91cCAgICAgICAgICAgICAgICA9IHRydWUgO1xuXG4gICAgICAgIGlmKCB0aGlzLnNob3dTZXF1ZW5jZUNvbnRyb2wgKXtcblxuICAgICAgICAgICAgaWYoIHRoaXMucHJldmlvdXNCdXR0b24gfHwgdGhpcy5uZXh0QnV0dG9uICl7XG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBhcmUgYmluZGluZyB0byBjdXN0b20gYnV0dG9ucyB0aGVuIGxheW91dCBhbmRcbiAgICAgICAgICAgICAgICAvL2dyb3VwaW5nIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgcGFnZSBhdXRob3JcbiAgICAgICAgICAgICAgICB1c2VHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uID0gbmV3ICQuQnV0dG9uKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiAgICB0aGlzLnByZXZpb3VzQnV0dG9uID8gJC5nZXRFbGVtZW50KCB0aGlzLnByZXZpb3VzQnV0dG9uICkgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiAgICAkLmdldFN0cmluZyggXCJUb29sdGlwcy5QcmV2aW91c1BhZ2VcIiApLFxuICAgICAgICAgICAgICAgIHNyY1Jlc3Q6ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMucHJldmlvdXMuUkVTVCApLFxuICAgICAgICAgICAgICAgIHNyY0dyb3VwOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMucHJldmlvdXMuR1JPVVAgKSxcbiAgICAgICAgICAgICAgICBzcmNIb3ZlcjogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnByZXZpb3VzLkhPVkVSICksXG4gICAgICAgICAgICAgICAgc3JjRG93bjogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5wcmV2aW91cy5ET1dOICksXG4gICAgICAgICAgICAgICAgb25SZWxlYXNlOiAgb25QcmV2aW91c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25Gb2N1czogICAgb25Gb2N1c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25CbHVyOiAgICAgb25CbHVySGFuZGxlclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubmV4dEJ1dHRvbiA9IG5ldyAkLkJ1dHRvbih7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogICAgdGhpcy5uZXh0QnV0dG9uID8gJC5nZXRFbGVtZW50KCB0aGlzLm5leHRCdXR0b24gKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6IHRoaXMuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6ICAgICQuZ2V0U3RyaW5nKCBcIlRvb2x0aXBzLk5leHRQYWdlXCIgKSxcbiAgICAgICAgICAgICAgICBzcmNSZXN0OiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLm5leHQuUkVTVCApLFxuICAgICAgICAgICAgICAgIHNyY0dyb3VwOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMubmV4dC5HUk9VUCApLFxuICAgICAgICAgICAgICAgIHNyY0hvdmVyOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMubmV4dC5IT1ZFUiApLFxuICAgICAgICAgICAgICAgIHNyY0Rvd246ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMubmV4dC5ET1dOICksXG4gICAgICAgICAgICAgICAgb25SZWxlYXNlOiAgb25OZXh0SGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiAgICBvbkZvY3VzSGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbkJsdXI6ICAgICBvbkJsdXJIYW5kbGVyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYoICF0aGlzLm5hdlByZXZOZXh0V3JhcCApe1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24uZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMudGlsZVNvdXJjZXMgfHwgIXRoaXMudGlsZVNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0QnV0dG9uLmRpc2FibGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHVzZUdyb3VwICl7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdpbmcgPSBuZXcgJC5CdXR0b25Hcm91cCh7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdpbmdDb250cm9sID0gdGhpcy5wYWdpbmcuZWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLnRvb2xiYXIgKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sYmFyLmFkZENvbnRyb2woXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2luZ0NvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICB7YW5jaG9yOiAkLkNvbnRyb2xBbmNob3IuQk9UVE9NX1JJR0hUfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbnRyb2woXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2luZ0NvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICB7YW5jaG9yOiB0aGlzLnNlcXVlbmNlQ29udHJvbEFuY2hvciB8fCAkLkNvbnRyb2xBbmNob3IuVE9QX0xFRlR9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgYmluZFN0YW5kYXJkQ29udHJvbHM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIE5hdmlnYXRpb24gQ29udHJvbHNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgdmFyIGJlZ2luWm9vbWluZ0luSGFuZGxlciAgID0gJC5kZWxlZ2F0ZSggdGhpcywgYmVnaW5ab29taW5nSW4gKSxcbiAgICAgICAgICAgIGVuZFpvb21pbmdIYW5kbGVyICAgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgZW5kWm9vbWluZyApLFxuICAgICAgICAgICAgZG9TaW5nbGVab29tSW5IYW5kbGVyICAgPSAkLmRlbGVnYXRlKCB0aGlzLCBkb1NpbmdsZVpvb21JbiApLFxuICAgICAgICAgICAgYmVnaW5ab29taW5nT3V0SGFuZGxlciAgPSAkLmRlbGVnYXRlKCB0aGlzLCBiZWdpblpvb21pbmdPdXQgKSxcbiAgICAgICAgICAgIGRvU2luZ2xlWm9vbU91dEhhbmRsZXIgID0gJC5kZWxlZ2F0ZSggdGhpcywgZG9TaW5nbGVab29tT3V0ICksXG4gICAgICAgICAgICBvbkhvbWVIYW5kbGVyICAgICAgICAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIG9uSG9tZSApLFxuICAgICAgICAgICAgb25GdWxsU2NyZWVuSGFuZGxlciAgICAgPSAkLmRlbGVnYXRlKCB0aGlzLCBvbkZ1bGxTY3JlZW4gKSxcbiAgICAgICAgICAgIG9uUm90YXRlTGVmdEhhbmRsZXIgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgb25Sb3RhdGVMZWZ0ICksXG4gICAgICAgICAgICBvblJvdGF0ZVJpZ2h0SGFuZGxlciAgICA9ICQuZGVsZWdhdGUoIHRoaXMsIG9uUm90YXRlUmlnaHQgKSxcbiAgICAgICAgICAgIG9uRm9jdXNIYW5kbGVyICAgICAgICAgID0gJC5kZWxlZ2F0ZSggdGhpcywgb25Gb2N1cyApLFxuICAgICAgICAgICAgb25CbHVySGFuZGxlciAgICAgICAgICAgPSAkLmRlbGVnYXRlKCB0aGlzLCBvbkJsdXIgKSxcbiAgICAgICAgICAgIG5hdkltYWdlcyAgICAgICAgICAgICAgID0gdGhpcy5uYXZJbWFnZXMsXG4gICAgICAgICAgICBidXR0b25zICAgICAgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgdXNlR3JvdXAgICAgICAgICAgICAgICAgPSB0cnVlIDtcblxuXG4gICAgICAgIGlmICggdGhpcy5zaG93TmF2aWdhdGlvbkNvbnRyb2wgKSB7XG5cbiAgICAgICAgICAgIGlmKCB0aGlzLnpvb21JbkJ1dHRvbiB8fCB0aGlzLnpvb21PdXRCdXR0b24gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmhvbWVCdXR0b24gfHwgdGhpcy5mdWxsUGFnZUJ1dHRvbiB8fFxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlTGVmdEJ1dHRvbiB8fCB0aGlzLnJvdGF0ZVJpZ2h0QnV0dG9uICkge1xuICAgICAgICAgICAgICAgIC8vaWYgd2UgYXJlIGJpbmRpbmcgdG8gY3VzdG9tIGJ1dHRvbnMgdGhlbiBsYXlvdXQgYW5kXG4gICAgICAgICAgICAgICAgLy9ncm91cGluZyBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHBhZ2UgYXV0aG9yXG4gICAgICAgICAgICAgICAgdXNlR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0aGlzLnNob3dab29tQ29udHJvbCApIHtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goIHRoaXMuem9vbUluQnV0dG9uID0gbmV3ICQuQnV0dG9uKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogICAgdGhpcy56b29tSW5CdXR0b24gPyAkLmdldEVsZW1lbnQoIHRoaXMuem9vbUluQnV0dG9uICkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6IHRoaXMuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAgICAkLmdldFN0cmluZyggXCJUb29sdGlwcy5ab29tSW5cIiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNSZXN0OiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnpvb21Jbi5SRVNUICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0dyb3VwOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuem9vbUluLkdST1VQICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0hvdmVyOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuem9vbUluLkhPVkVSICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0Rvd246ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuem9vbUluLkRPV04gKSxcbiAgICAgICAgICAgICAgICAgICAgb25QcmVzczogICAgYmVnaW5ab29taW5nSW5IYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvblJlbGVhc2U6ICBlbmRab29taW5nSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogICAgZG9TaW5nbGVab29tSW5IYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkVudGVyOiAgICBiZWdpblpvb21pbmdJbkhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdDogICAgIGVuZFpvb21pbmdIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzOiAgICBvbkZvY3VzSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25CbHVyOiAgICAgb25CbHVySGFuZGxlclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCggdGhpcy56b29tT3V0QnV0dG9uID0gbmV3ICQuQnV0dG9uKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogICAgdGhpcy56b29tT3V0QnV0dG9uID8gJC5nZXRFbGVtZW50KCB0aGlzLnpvb21PdXRCdXR0b24gKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICAgICQuZ2V0U3RyaW5nKCBcIlRvb2x0aXBzLlpvb21PdXRcIiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNSZXN0OiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnpvb21PdXQuUkVTVCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNHcm91cDogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnpvb21PdXQuR1JPVVAgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjSG92ZXI6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy56b29tT3V0LkhPVkVSICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0Rvd246ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuem9vbU91dC5ET1dOICksXG4gICAgICAgICAgICAgICAgICAgIG9uUHJlc3M6ICAgIGJlZ2luWm9vbWluZ091dEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVsZWFzZTogIGVuZFpvb21pbmdIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAgICBkb1NpbmdsZVpvb21PdXRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkVudGVyOiAgICBiZWdpblpvb21pbmdPdXRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQ6ICAgICBlbmRab29taW5nSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1czogICAgb25Gb2N1c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cjogICAgIG9uQmx1ckhhbmRsZXJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5zaG93SG9tZUNvbnRyb2wgKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9ucy5wdXNoKCB0aGlzLmhvbWVCdXR0b24gPSBuZXcgJC5CdXR0b24oe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAgICB0aGlzLmhvbWVCdXR0b24gPyAkLmdldEVsZW1lbnQoIHRoaXMuaG9tZUJ1dHRvbiApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogICAgJC5nZXRTdHJpbmcoIFwiVG9vbHRpcHMuSG9tZVwiICksXG4gICAgICAgICAgICAgICAgICAgIHNyY1Jlc3Q6ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuaG9tZS5SRVNUICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0dyb3VwOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuaG9tZS5HUk9VUCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNIb3ZlcjogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLmhvbWUuSE9WRVIgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjRG93bjogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5ob21lLkRPV04gKSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWxlYXNlOiAgb25Ib21lSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1czogICAgb25Gb2N1c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cjogICAgIG9uQmx1ckhhbmRsZXJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5zaG93RnVsbFBhZ2VDb250cm9sICkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCggdGhpcy5mdWxsUGFnZUJ1dHRvbiA9IG5ldyAkLkJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgIHRoaXMuZnVsbFBhZ2VCdXR0b24gPyAkLmdldEVsZW1lbnQoIHRoaXMuZnVsbFBhZ2VCdXR0b24gKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICAgICQuZ2V0U3RyaW5nKCBcIlRvb2x0aXBzLkZ1bGxQYWdlXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjUmVzdDogICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5mdWxscGFnZS5SRVNUICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0dyb3VwOiAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMuZnVsbHBhZ2UuR1JPVVAgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjSG92ZXI6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5mdWxscGFnZS5IT1ZFUiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNEb3duOiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLmZ1bGxwYWdlLkRPV04gKSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWxlYXNlOiAgb25GdWxsU2NyZWVuSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1czogICAgb25Gb2N1c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cjogICAgIG9uQmx1ckhhbmRsZXJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5zaG93Um90YXRpb25Db250cm9sICkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCggdGhpcy5yb3RhdGVMZWZ0QnV0dG9uID0gbmV3ICQuQnV0dG9uKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogICAgdGhpcy5yb3RhdGVMZWZ0QnV0dG9uID8gJC5nZXRFbGVtZW50KCB0aGlzLnJvdGF0ZUxlZnRCdXR0b24gKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogdGhpcy5jbGlja1RpbWVUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRGlzdFRocmVzaG9sZDogdGhpcy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICAgICQuZ2V0U3RyaW5nKCBcIlRvb2x0aXBzLlJvdGF0ZUxlZnRcIiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNSZXN0OiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnJvdGF0ZWxlZnQuUkVTVCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNHcm91cDogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnJvdGF0ZWxlZnQuR1JPVVAgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjSG92ZXI6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5yb3RhdGVsZWZ0LkhPVkVSICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0Rvd246ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMucm90YXRlbGVmdC5ET1dOICksXG4gICAgICAgICAgICAgICAgICAgIG9uUmVsZWFzZTogIG9uUm90YXRlTGVmdEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM6ICAgIG9uRm9jdXNIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI6ICAgICBvbkJsdXJIYW5kbGVyXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgYnV0dG9ucy5wdXNoKCB0aGlzLnJvdGF0ZVJpZ2h0QnV0dG9uID0gbmV3ICQuQnV0dG9uKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogICAgdGhpcy5yb3RhdGVSaWdodEJ1dHRvbiA/ICQuZ2V0RWxlbWVudCggdGhpcy5yb3RhdGVSaWdodEJ1dHRvbiApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogICAgJC5nZXRTdHJpbmcoIFwiVG9vbHRpcHMuUm90YXRlUmlnaHRcIiApLFxuICAgICAgICAgICAgICAgICAgICBzcmNSZXN0OiAgICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnJvdGF0ZXJpZ2h0LlJFU1QgKSxcbiAgICAgICAgICAgICAgICAgICAgc3JjR3JvdXA6ICAgcmVzb2x2ZVVybCggdGhpcy5wcmVmaXhVcmwsIG5hdkltYWdlcy5yb3RhdGVyaWdodC5HUk9VUCApLFxuICAgICAgICAgICAgICAgICAgICBzcmNIb3ZlcjogICByZXNvbHZlVXJsKCB0aGlzLnByZWZpeFVybCwgbmF2SW1hZ2VzLnJvdGF0ZXJpZ2h0LkhPVkVSICksXG4gICAgICAgICAgICAgICAgICAgIHNyY0Rvd246ICAgIHJlc29sdmVVcmwoIHRoaXMucHJlZml4VXJsLCBuYXZJbWFnZXMucm90YXRlcmlnaHQuRE9XTiApLFxuICAgICAgICAgICAgICAgICAgICBvblJlbGVhc2U6ICBvblJvdGF0ZVJpZ2h0SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1czogICAgb25Gb2N1c0hhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cjogICAgIG9uQmx1ckhhbmRsZXJcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB1c2VHcm91cCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnMgPSBuZXcgJC5CdXR0b25Hcm91cCh7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6ICAgICAgICAgICAgYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5uYXZDb250cm9sICA9IHRoaXMuYnV0dG9ucy5lbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSGFuZGxlciggJ29wZW4nLCAkLmRlbGVnYXRlKCB0aGlzLCBsaWdodFVwICkgKTtcblxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLnRvb2xiYXIgKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sYmFyLmFkZENvbnRyb2woXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdkNvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICB7YW5jaG9yOiAkLkNvbnRyb2xBbmNob3IuVE9QX0xFRlR9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb250cm9sKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZDb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAge2FuY2hvcjogdGhpcy5uYXZpZ2F0aW9uQ29udHJvbEFuY2hvciB8fCAkLkNvbnRyb2xBbmNob3IuVE9QX0xFRlR9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjdGl2ZSBwYWdlIG9mIGEgc2VxdWVuY2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgY3VycmVudFBhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VxdWVuY2VJbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6cGFnZVxuICAgICAqL1xuICAgIGdvVG9QYWdlOiBmdW5jdGlvbiggcGFnZSApe1xuICAgICAgICBpZiggdGhpcy50aWxlU291cmNlcyAmJiBwYWdlID49IDAgJiYgcGFnZSA8IHRoaXMudGlsZVNvdXJjZXMubGVuZ3RoICl7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBwYWdlIGlzIGNoYW5nZWQgb24gYSB2aWV3ZXIgY29uZmlndXJlZCB3aXRoIG11bHRpcGxlIGltYWdlIHNvdXJjZXMgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjZ29Ub1BhZ2V9KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgcGFnZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcGFnZSAtIFRoZSBwYWdlIGluZGV4LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdwYWdlJywgeyBwYWdlOiBwYWdlIH0gKTtcblxuICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2VJbmRleCA9IHBhZ2U7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlcXVlbmNlQnV0dG9ucyggcGFnZSApO1xuXG4gICAgICAgICAgICB0aGlzLm9wZW4oIHRoaXMudGlsZVNvdXJjZXNbIHBhZ2UgXSApO1xuXG4gICAgICAgICAgICBpZiggdGhpcy5yZWZlcmVuY2VTdHJpcCApe1xuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RyaXAuc2V0Rm9jdXMoIHBhZ2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICAqIEFkZHMgYW4gaHRtbCBlbGVtZW50IGFzIGFuIG92ZXJsYXkgdG8gdGhlIGN1cnJlbnQgdmlld3BvcnQuICBVc2VmdWwgZm9yXG4gICAgICogaGlnaGxpZ2h0aW5nIHdvcmRzIG9yIGFyZWFzIG9mIGludGVyZXN0IG9uIGFuIGltYWdlIG9yIG90aGVyIHpvb21hYmxlXG4gICAgICogaW50ZXJmYWNlLiBUaGUgb3ZlcmxheXMgYWRkZWQgdmlhIHRoaXMgbWV0aG9kIGFyZSByZW1vdmVkIHdoZW4gdGhlIHZpZXdwb3J0XG4gICAgICogaXMgY2xvc2VkIHdoaWNoIGluY2x1ZGUgd2hlbiBjaGFuZ2luZyBwYWdlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfE9iamVjdH0gZWxlbWVudCAtIEEgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQgb3IgYW4gaWQgZm9yXG4gICAgICogICAgICB0aGUgZWxlbWVudCB3aGljaCB3aWxsIGJlIG92ZXJsYXllZC4gT3IgYW4gT2JqZWN0IHNwZWNpZnlpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBvdmVybGF5LlxuICAgICAqICAgICAgSWYgdXNpbmcgYW4gb2JqZWN0LCBzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3ZlcmxheX0gZm9yIGEgbGlzdCBvZlxuICAgICAqICAgICAgYWxsIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludHxPcGVuU2VhZHJhZ29uLlJlY3R9IGxvY2F0aW9uIC0gVGhlIHBvaW50IG9yXG4gICAgICogICAgICByZWN0YW5nbGUgd2hpY2ggd2lsbCBiZSBvdmVybGF5ZWQuIFRoaXMgaXMgYSB2aWV3cG9ydCByZWxhdGl2ZSBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBwbGFjZW1lbnQgLSBUaGUgcG9zaXRpb24gb2YgdGhlXG4gICAgICogICAgICB2aWV3cG9ydCB3aGljaCB0aGUgbG9jYXRpb24gY29vcmRpbmF0ZXMgd2lsbCBiZSB0cmVhdGVkIGFzIHJlbGF0aXZlXG4gICAgICogICAgICB0by5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkRyYXcgLSBJZiBzdXBwbGllZCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIG92ZXJsYXlcbiAgICAgKiAgICAgIG5lZWRzIHRvIGJlIGRyYXduLiBJdCBpdCB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxiYWNrIHRvIGRvIGFueSBkcmF3aW5nL3Bvc2l0aW9uaW5nLlxuICAgICAqICAgICAgSXQgaXMgcGFzc2VkIHBvc2l0aW9uLCBzaXplIGFuZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmFkZC1vdmVybGF5XG4gICAgICovXG4gICAgYWRkT3ZlcmxheTogZnVuY3Rpb24oIGVsZW1lbnQsIGxvY2F0aW9uLCBwbGFjZW1lbnQsIG9uRHJhdyApIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmKCAkLmlzUGxhaW5PYmplY3QoIGVsZW1lbnQgKSApe1xuICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICAgICAgICAgIG9uRHJhdzogb25EcmF3XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggb3B0aW9ucy5lbGVtZW50ICk7XG5cbiAgICAgICAgaWYgKCBnZXRPdmVybGF5SW5kZXgoIHRoaXMuY3VycmVudE92ZXJsYXlzLCBlbGVtZW50ICkgPj0gMCApIHtcbiAgICAgICAgICAgIC8vIHRoZXkncmUgdHJ5aW5nIHRvIGFkZCBhIGR1cGxpY2F0ZSBvdmVybGF5XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdmVybGF5ID0gZ2V0T3ZlcmxheU9iamVjdCggdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXlzLnB1c2gob3ZlcmxheSk7XG4gICAgICAgIG92ZXJsYXkuZHJhd0hUTUwoIHRoaXMub3ZlcmxheXNDb250YWluZXIsIHRoaXMudmlld3BvcnQgKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gYW4gb3ZlcmxheSBpcyBhZGRlZCB0byB0aGUgdmlld2VyIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZE92ZXJsYXl9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGFkZC1vdmVybGF5XG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIG92ZXJsYXkgZWxlbWVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fE9wZW5TZWFkcmFnb24uUmVjdH0gbG9jYXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gcGxhY2VtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCggJ2FkZC1vdmVybGF5Jywge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBvcHRpb25zLmxvY2F0aW9uLFxuICAgICAgICAgICAgcGxhY2VtZW50OiBvcHRpb25zLnBsYWNlbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG92ZXJsYXkgcmVwcmVzZW50ZWQgYnkgdGhlIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBvclxuICAgICAqIGVsZW1lbnQgaWQgbW92aW5nIGl0IHRvIHRoZSBuZXcgbG9jYXRpb24sIHJlbGF0aXZlIHRvIHRoZSBuZXcgcGxhY2VtZW50LlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50IC0gQSByZWZlcmVuY2UgdG8gYW4gZWxlbWVudCBvciBhbiBpZCBmb3JcbiAgICAgKiAgICAgIHRoZSBlbGVtZW50IHdoaWNoIGlzIG92ZXJsYXllZC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR8T3BlblNlYWRyYWdvbi5SZWN0fSBsb2NhdGlvbiAtIFRoZSBwb2ludCBvclxuICAgICAqICAgICAgcmVjdGFuZ2xlIHdoaWNoIHdpbGwgYmUgb3ZlcmxheWVkLiBUaGlzIGlzIGEgdmlld3BvcnQgcmVsYXRpdmUgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gcGxhY2VtZW50IC0gVGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgICAqICAgICAgdmlld3BvcnQgd2hpY2ggdGhlIGxvY2F0aW9uIGNvb3JkaW5hdGVzIHdpbGwgYmUgdHJlYXRlZCBhcyByZWxhdGl2ZVxuICAgICAqICAgICAgdG8uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6dXBkYXRlLW92ZXJsYXlcbiAgICAgKi9cbiAgICB1cGRhdGVPdmVybGF5OiBmdW5jdGlvbiggZWxlbWVudCwgbG9jYXRpb24sIHBsYWNlbWVudCApIHtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICBpID0gZ2V0T3ZlcmxheUluZGV4KCB0aGlzLmN1cnJlbnRPdmVybGF5cywgZWxlbWVudCApO1xuXG4gICAgICAgIGlmICggaSA+PSAwICkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheXNbIGkgXS51cGRhdGUoIGxvY2F0aW9uLCBwbGFjZW1lbnQgKTtcbiAgICAgICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLmZvcmNlUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gYW4gb3ZlcmxheSdzIGxvY2F0aW9uIG9yIHBsYWNlbWVudCBjaGFuZ2VzXG4gICAgICAgICAgICAgKiAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciN1cGRhdGVPdmVybGF5fSkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IHVwZGF0ZS1vdmVybGF5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAgICAgICogVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludHxPcGVuU2VhZHJhZ29uLlJlY3R9IGxvY2F0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCAndXBkYXRlLW92ZXJsYXknLCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG92ZXJsYXkgaWRlbnRpZmllZCBieSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3IgZWxlbWVudCBpZFxuICAgICAqIGFuZCBzY2hlZHVsZXMgYW4gdXBkYXRlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50IC0gQSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgb3IgYW5cbiAgICAgKiAgICAgIGVsZW1lbnQgaWQgd2hpY2ggcmVwcmVzZW50IHRoZSBvdmVsYXkgY29udGVudCB0byBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnJlbW92ZS1vdmVybGF5XG4gICAgICovXG4gICAgcmVtb3ZlT3ZlcmxheTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGVsZW1lbnQgPSAkLmdldEVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICAgICAgaSA9IGdldE92ZXJsYXlJbmRleCggdGhpcy5jdXJyZW50T3ZlcmxheXMsIGVsZW1lbnQgKTtcblxuICAgICAgICBpZiAoIGkgPj0gMCApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXlzWyBpIF0uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheXMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICBUSElTWyB0aGlzLmhhc2ggXS5mb3JjZVJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIG92ZXJsYXkgaXMgcmVtb3ZlZCBmcm9tIHRoZSB2aWV3ZXJcbiAgICAgICAgICAgICAqIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI3JlbW92ZU92ZXJsYXl9KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgcmVtb3ZlLW92ZXJsYXlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgICAgICAgKiBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBvdmVybGF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmFpc2VFdmVudCggJ3JlbW92ZS1vdmVybGF5Jywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjdXJyZW50bHkgY29uZmlndXJlZCBPdmVybGF5cyBmcm9tIHRoaXMgVmlld2VyIGFuZCBzY2hlZHVsZXNcbiAgICAgKiBhbiB1cGRhdGUuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld2VyfSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmNsZWFyLW92ZXJsYXlcbiAgICAgKi9cbiAgICBjbGVhck92ZXJsYXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgd2hpbGUgKCB0aGlzLmN1cnJlbnRPdmVybGF5cy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T3ZlcmxheXMucG9wKCkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLmZvcmNlUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIGFsbCBvdmVybGF5cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB2aWV3ZXIgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5EcmF3ZXIjY2xlYXJPdmVybGF5c30pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgY2xlYXItb3ZlcmxheVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCggJ2NsZWFyLW92ZXJsYXknLCB7fSApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgIC8qKlxuICAgICAqIEZpbmRzIGFuIG92ZXJsYXkgaWRlbnRpZmllZCBieSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3IgZWxlbWVudCBpZFxuICAgICAqIGFuZCByZXR1cm5zIGl0IGFzIGFuIG9iamVjdCwgcmV0dXJuIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50IC0gQSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgb3IgYW5cbiAgICAgKiAgICAgIGVsZW1lbnQgaWQgd2hpY2ggcmVwcmVzZW50cyB0aGUgb3ZlcmxheSBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uT3ZlcmxheX0gdGhlIG1hdGNoaW5nIG92ZXJsYXkgb3IgbnVsbCBpZiBub25lIGZvdW5kLlxuICAgICAqL1xuICAgIGdldE92ZXJsYXlCeUlkOiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggZWxlbWVudCApO1xuICAgICAgICBpID0gZ2V0T3ZlcmxheUluZGV4KCB0aGlzLmN1cnJlbnRPdmVybGF5cywgZWxlbWVudCApO1xuXG4gICAgICAgIGlmIChpPj0wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50T3ZlcmxheXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzZXF1ZW5jZSBidXR0b25zLlxuICAgICAqIEBmdW5jdGlvbiBPcGVuU2VhZHJhZ29uLlZpZXdlci5wcm90b3R5cGUuX3VwZGF0ZVNlcXVlbmNlQnV0dG9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFNlcXVlbmNlIFZhbHVlXG4gICAgICovXG4gICAgX3VwZGF0ZVNlcXVlbmNlQnV0dG9uczogZnVuY3Rpb24oIHBhZ2UgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5uZXh0QnV0dG9uICkge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLnRpbGVTb3VyY2VzIHx8IHRoaXMudGlsZVNvdXJjZXMubGVuZ3RoIC0gMSA9PT0gcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAvL0Rpc2FibGUgbmV4dCBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhdGhpcy5uYXZQcmV2TmV4dFdyYXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRCdXR0b24uZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0QnV0dG9uLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggdGhpcy5wcmV2aW91c0J1dHRvbiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHBhZ2UgPiAwICkge1xuICAgICAgICAgICAgICAgICAgICAvL0VuYWJsZSBwcmV2aW91cyBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0J1dHRvbi5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICF0aGlzLm5hdlByZXZOZXh0V3JhcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24uZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgYSBtZXNzYWdlIGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBmdW5jdGlvbiBPcGVuU2VhZHJhZ29uLlZpZXdlci5wcm90b3R5cGUuX3Nob3dNZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBtZXNzYWdlXG4gICAgICovXG4gICAgX3Nob3dNZXNzYWdlOiBmdW5jdGlvbiAoIG1lc3NhZ2UgKSB7XG4gICAgICAgIHRoaXMuX2hpZGVNZXNzYWdlKCk7XG5cbiAgICAgICAgdmFyIGRpdiA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIG1lc3NhZ2UgKSApO1xuXG4gICAgICAgIHRoaXMubWVzc2FnZURpdiA9ICQubWFrZUNlbnRlcmVkTm9kZSggZGl2ICk7XG5cbiAgICAgICAgJC5hZGRDbGFzcyh0aGlzLm1lc3NhZ2VEaXYsIFwib3BlbnNlYWRyYWdvbi1tZXNzYWdlXCIpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLm1lc3NhZ2VEaXYgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBhbnkgY3VycmVudGx5IGRpc3BsYXllZCB2aWV3cG9ydCBtZXNzYWdlXG4gICAgICogQGZ1bmN0aW9uIE9wZW5TZWFkcmFnb24uVmlld2VyLnByb3RvdHlwZS5faGlkZU1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlTWVzc2FnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGl2ID0gdGhpcy5tZXNzYWdlRGl2O1xuICAgICAgICBpZiAoZGl2KSB7XG4gICAgICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWVzc2FnZURpdjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoaXMgdmlld2VyJ3MgZ2VzdHVyZSBzZXR0aW5ncyBmb3IgdGhlIGdpdmVuIHBvaW50ZXIgZGV2aWNlIHR5cGUuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHBvaW50ZXIgZGV2aWNlIHR5cGUgdG8gZ2V0IHRoZSBnZXN0dXJlIHNldHRpbmdzIGZvciAoXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy4pLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uR2VzdHVyZVNldHRpbmdzfVxuICAgICAqL1xuICAgIGdlc3R1cmVTZXR0aW5nc0J5RGV2aWNlVHlwZTogZnVuY3Rpb24gKCB0eXBlICkge1xuICAgICAgICBzd2l0Y2ggKCB0eXBlICkge1xuICAgICAgICAgICAgY2FzZSAnbW91c2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdlc3R1cmVTZXR0aW5nc01vdXNlO1xuICAgICAgICAgICAgY2FzZSAndG91Y2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdlc3R1cmVTZXR0aW5nc1RvdWNoO1xuICAgICAgICAgICAgY2FzZSAncGVuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXN0dXJlU2V0dGluZ3NQZW47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdlc3R1cmVTZXR0aW5nc1Vua25vd247XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9kcmF3T3ZlcmxheXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuY3VycmVudE92ZXJsYXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE92ZXJsYXlzWyBpIF0uZHJhd0hUTUwoIHRoaXMub3ZlcmxheXNDb250YWluZXIsIHRoaXMudmlld3BvcnQgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhlIFwiaW4gZmxpZ2h0XCIgaW1hZ2VzLlxuICAgICAqL1xuICAgIF9jYW5jZWxQZW5kaW5nSW1hZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbG9hZFF1ZXVlID0gW107XG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBfZ2V0U2FmZUVsZW1TaXplIGlzIGxpa2UgZ2V0RWxlbWVudFNpemUoKSwgYnV0IHJlZnVzZXMgdG8gcmV0dXJuIDAgZm9yIHggb3IgeSxcbiAqIHdoaWNoIHdhcyBjYXVzaW5nIHNvbWUgY2FsbGluZyBvcGVyYXRpb25zIHRvIHJldHVybiBOYU4uXG4gKiBAcmV0dXJucyB7UG9pbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0U2FmZUVsZW1TaXplIChvRWxlbWVudCkge1xuICAgIG9FbGVtZW50ID0gJC5nZXRFbGVtZW50KCBvRWxlbWVudCApO1xuXG4gICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAob0VsZW1lbnQuY2xpZW50V2lkdGggPT09IDAgPyAxIDogb0VsZW1lbnQuY2xpZW50V2lkdGgpLFxuICAgICAgICAob0VsZW1lbnQuY2xpZW50SGVpZ2h0ID09PSAwID8gMSA6IG9FbGVtZW50LmNsaWVudEhlaWdodClcbiAgICApO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VGlsZVNvdXJjZUltcGxlbWVudGF0aW9uKCB2aWV3ZXIsIHRpbGVTb3VyY2UsIHN1Y2Nlc3NDYWxsYmFjayxcbiAgICBmYWlsQ2FsbGJhY2sgKSB7XG4gICAgdmFyIF90aGlzID0gdmlld2VyO1xuXG4gICAgLy9hbGxvdyBwbGFpbiB4bWwgc3RyaW5ncyBvciBqc29uIHN0cmluZ3MgdG8gYmUgcGFyc2VkIGhlcmVcbiAgICBpZiAoICQudHlwZSggdGlsZVNvdXJjZSApID09ICdzdHJpbmcnICkge1xuICAgICAgICBpZiAoIHRpbGVTb3VyY2UubWF0Y2goIC9cXHMqPC4qLyApICkge1xuICAgICAgICAgICAgdGlsZVNvdXJjZSA9ICQucGFyc2VYbWwoIHRpbGVTb3VyY2UgKTtcbiAgICAgICAgfSBlbHNlIGlmICggdGlsZVNvdXJjZS5tYXRjaCggL1xccypbXFx7XFxbXS4qLyApICkge1xuICAgICAgICAgICAgdGlsZVNvdXJjZSA9ICQucGFyc2VKU09OKHRpbGVTb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2FpdFVudGlsUmVhZHkodGlsZVNvdXJjZSwgb3JpZ2luYWxUaWxlU291cmNlKSB7XG4gICAgICAgIGlmICh0aWxlU291cmNlLnJlYWR5KSB7XG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodGlsZVNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlU291cmNlLmFkZEhhbmRsZXIoJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh0aWxlU291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGlsZVNvdXJjZS5hZGRIYW5kbGVyKCdvcGVuLWZhaWxlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGZhaWxDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWxUaWxlU291cmNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoICQudHlwZSggdGlsZVNvdXJjZSApID09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgLy9JZiBpdHMgc3RpbGwgYSBzdHJpbmcgaXQgbWVhbnMgaXQgbXVzdCBiZSBhIHVybCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICB0aWxlU291cmNlID0gbmV3ICQuVGlsZVNvdXJjZSh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aWxlU291cmNlLFxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luUG9saWN5OiB2aWV3ZXIuY3Jvc3NPcmlnaW5Qb2xpY3ksXG4gICAgICAgICAgICAgICAgYWpheFdpdGhDcmVkZW50aWFsczogdmlld2VyLmFqYXhXaXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICAgICAgdXNlQ2FudmFzOiB2aWV3ZXIudXNlQ2FudmFzLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKCBldmVudC50aWxlU291cmNlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aWxlU291cmNlLmFkZEhhbmRsZXIoICdvcGVuLWZhaWxlZCcsIGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICBmYWlsQ2FsbGJhY2soIGV2ZW50ICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QodGlsZVNvdXJjZSkgfHwgdGlsZVNvdXJjZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgaWYgKCF0aWxlU291cmNlLmNyb3NzT3JpZ2luUG9saWN5ICYmIHZpZXdlci5jcm9zc09yaWdpblBvbGljeSkge1xuICAgICAgICAgICAgICAgIHRpbGVTb3VyY2UuY3Jvc3NPcmlnaW5Qb2xpY3kgPSB2aWV3ZXIuY3Jvc3NPcmlnaW5Qb2xpY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGlsZVNvdXJjZS5hamF4V2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aWxlU291cmNlLmFqYXhXaXRoQ3JlZGVudGlhbHMgPSB2aWV3ZXIuYWpheFdpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aWxlU291cmNlLnVzZUNhbnZhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGlsZVNvdXJjZS51c2VDYW52YXMgPSB2aWV3ZXIudXNlQ2FudmFzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiggdGlsZVNvdXJjZS5nZXRUaWxlVXJsICkgKSB7XG4gICAgICAgICAgICAgICAgLy9DdXN0b20gdGlsZSBzb3VyY2VcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tVGlsZVNvdXJjZSA9IG5ldyAkLlRpbGVTb3VyY2UoIHRpbGVTb3VyY2UgKTtcbiAgICAgICAgICAgICAgICBjdXN0b21UaWxlU291cmNlLmdldFRpbGVVcmwgPSB0aWxlU291cmNlLmdldFRpbGVVcmw7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKCBjdXN0b21UaWxlU291cmNlICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vaW5saW5lIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICB2YXIgJFRpbGVTb3VyY2UgPSAkLlRpbGVTb3VyY2UuZGV0ZXJtaW5lVHlwZSggX3RoaXMsIHRpbGVTb3VyY2UgKTtcbiAgICAgICAgICAgICAgICBpZiAoICEkVGlsZVNvdXJjZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbENhbGxiYWNrKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlVuYWJsZSB0byBsb2FkIFRpbGVTb3VyY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGlsZVNvdXJjZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICRUaWxlU291cmNlLnByb3RvdHlwZS5jb25maWd1cmUuYXBwbHkoIF90aGlzLCBbIHRpbGVTb3VyY2UgXSApO1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbFJlYWR5KG5ldyAkVGlsZVNvdXJjZShvcHRpb25zKSwgdGlsZVNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2NhbiBhc3N1bWUgaXQncyBhbHJlYWR5IGEgdGlsZSBzb3VyY2UgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIHdhaXRVbnRpbFJlYWR5KHRpbGVTb3VyY2UsIHRpbGVTb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE92ZXJsYXlPYmplY3QoIHZpZXdlciwgb3ZlcmxheSApIHtcbiAgICBpZiAoIG92ZXJsYXkgaW5zdGFuY2VvZiAkLk92ZXJsYXkgKSB7XG4gICAgICAgIHJldHVybiBvdmVybGF5O1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcbiAgICBpZiAoIG92ZXJsYXkuZWxlbWVudCApIHtcbiAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggb3ZlcmxheS5lbGVtZW50ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkID0gb3ZlcmxheS5pZCA/XG4gICAgICAgICAgICBvdmVybGF5LmlkIDpcbiAgICAgICAgICAgIFwib3BlbnNlYWRyYWdvbi1vdmVybGF5LVwiICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwICk7XG5cbiAgICAgICAgZWxlbWVudCA9ICQuZ2V0RWxlbWVudCggb3ZlcmxheS5pZCApO1xuICAgICAgICBpZiAoICFlbGVtZW50ICkge1xuICAgICAgICAgICAgZWxlbWVudCAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcbiAgICAgICAgICAgIGVsZW1lbnQuaHJlZiAgICA9IFwiIy9vdmVybGF5L1wiICsgaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5pZCA9IGlkO1xuICAgICAgICAkLmFkZENsYXNzKCBlbGVtZW50LCBvdmVybGF5LmNsYXNzTmFtZSA/XG4gICAgICAgICAgICBvdmVybGF5LmNsYXNzTmFtZSA6XG4gICAgICAgICAgICBcIm9wZW5zZWFkcmFnb24tb3ZlcmxheVwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gb3ZlcmxheS5sb2NhdGlvbjtcbiAgICB2YXIgd2lkdGggPSBvdmVybGF5LndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBvdmVybGF5LmhlaWdodDtcbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgIHZhciB4ID0gb3ZlcmxheS54O1xuICAgICAgICB2YXIgeSA9IG92ZXJsYXkueTtcbiAgICAgICAgaWYgKG92ZXJsYXkucHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB2aWV3ZXIudmlld3BvcnQuaW1hZ2VUb1ZpZXdwb3J0UmVjdGFuZ2xlKG5ldyAkLlJlY3QoXG4gICAgICAgICAgICAgICAgb3ZlcmxheS5weCxcbiAgICAgICAgICAgICAgICBvdmVybGF5LnB5LFxuICAgICAgICAgICAgICAgIHdpZHRoIHx8IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0IHx8IDApKTtcbiAgICAgICAgICAgIHggPSByZWN0Lng7XG4gICAgICAgICAgICB5ID0gcmVjdC55O1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gcmVjdC53aWR0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gcmVjdC5oZWlnaHQgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYXRpb24gPSBuZXcgJC5Qb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICB2YXIgcGxhY2VtZW50ID0gb3ZlcmxheS5wbGFjZW1lbnQ7XG4gICAgaWYgKHBsYWNlbWVudCAmJiAkLnR5cGUocGxhY2VtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwbGFjZW1lbnQgPSAkLlBsYWNlbWVudFtvdmVybGF5LnBsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3ICQuT3ZlcmxheSh7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIG9uRHJhdzogb3ZlcmxheS5vbkRyYXcsXG4gICAgICAgIGNoZWNrUmVzaXplOiBvdmVybGF5LmNoZWNrUmVzaXplLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICByb3RhdGlvbk1vZGU6IG92ZXJsYXkucm90YXRpb25Nb2RlXG4gICAgfSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogRGV0ZXJtaW5lcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIG92ZXJsYXkgaW4gdGhlIGdpdmVuIG92ZXJsYXlzIGFycmF5LlxuICovXG5mdW5jdGlvbiBnZXRPdmVybGF5SW5kZXgoIG92ZXJsYXlzLCBlbGVtZW50ICkge1xuICAgIHZhciBpO1xuICAgIGZvciAoIGkgPSBvdmVybGF5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgaWYgKCBvdmVybGF5c1sgaSBdLmVsZW1lbnQgPT09IGVsZW1lbnQgKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2NoZWR1bGVycyBwcm92aWRlIHRoZSBnZW5lcmFsIGVuZ2luZSBmb3IgYW5pbWF0aW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZSggdmlld2VyLCB1cGRhdGVGdW5jICl7XG4gICAgcmV0dXJuICQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmdW5jdGlvbigpe1xuICAgICAgICB1cGRhdGVGdW5jKCB2aWV3ZXIgKTtcbiAgICB9ICk7XG59XG5cblxuLy9wcm92aWRlcyBhIHNlcXVlbmNlIGluIHRoZSBmYWRlIGFuaW1hdGlvblxuZnVuY3Rpb24gc2NoZWR1bGVDb250cm9sc0ZhZGUoIHZpZXdlciApIHtcbiAgICAkLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnVuY3Rpb24oKXtcbiAgICAgICAgdXBkYXRlQ29udHJvbHNGYWRlKCB2aWV3ZXIgKTtcbiAgICB9KTtcbn1cblxuXG4vL2luaXRpYXRlcyBhbiBhbmltYXRpb24gdG8gaGlkZSB0aGUgY29udHJvbHNcbmZ1bmN0aW9uIGJlZ2luQ29udHJvbHNBdXRvSGlkZSggdmlld2VyICkge1xuICAgIGlmICggIXZpZXdlci5hdXRvSGlkZUNvbnRyb2xzICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZpZXdlci5jb250cm9sc1Nob3VsZEZhZGUgPSB0cnVlO1xuICAgIHZpZXdlci5jb250cm9sc0ZhZGVCZWdpblRpbWUgPVxuICAgICAgICAkLm5vdygpICtcbiAgICAgICAgdmlld2VyLmNvbnRyb2xzRmFkZURlbGF5O1xuXG4gICAgd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNjaGVkdWxlQ29udHJvbHNGYWRlKCB2aWV3ZXIgKTtcbiAgICB9LCB2aWV3ZXIuY29udHJvbHNGYWRlRGVsYXkgKTtcbn1cblxuXG4vL2RldGVybWluZXMgaWYgZmFkZSBhbmltYXRpb24gaXMgZG9uZSBvciBjb250aW51ZXMgdGhlIGFuaW1hdGlvblxuZnVuY3Rpb24gdXBkYXRlQ29udHJvbHNGYWRlKCB2aWV3ZXIgKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lLFxuICAgICAgICBkZWx0YVRpbWUsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGk7XG4gICAgaWYgKCB2aWV3ZXIuY29udHJvbHNTaG91bGRGYWRlICkge1xuICAgICAgICBjdXJyZW50VGltZSA9ICQubm93KCk7XG4gICAgICAgIGRlbHRhVGltZSA9IGN1cnJlbnRUaW1lIC0gdmlld2VyLmNvbnRyb2xzRmFkZUJlZ2luVGltZTtcbiAgICAgICAgb3BhY2l0eSA9IDEuMCAtIGRlbHRhVGltZSAvIHZpZXdlci5jb250cm9sc0ZhZGVMZW5ndGg7XG5cbiAgICAgICAgb3BhY2l0eSA9IE1hdGgubWluKCAxLjAsIG9wYWNpdHkgKTtcbiAgICAgICAgb3BhY2l0eSA9IE1hdGgubWF4KCAwLjAsIG9wYWNpdHkgKTtcblxuICAgICAgICBmb3IgKCBpID0gdmlld2VyLmNvbnRyb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodmlld2VyLmNvbnRyb2xzWyBpIF0uYXV0b0ZhZGUpIHtcbiAgICAgICAgICAgICAgICB2aWV3ZXIuY29udHJvbHNbIGkgXS5zZXRPcGFjaXR5KCBvcGFjaXR5ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9wYWNpdHkgPiAwICkge1xuICAgICAgICAgICAgLy8gZmFkZSBhZ2FpblxuICAgICAgICAgICAgc2NoZWR1bGVDb250cm9sc0ZhZGUoIHZpZXdlciApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8vc3RvcCB0aGUgZmFkZSBhbmltYXRpb24gb24gdGhlIGNvbnRyb2xzIGFuZCBzaG93IHRoZW1cbmZ1bmN0aW9uIGFib3J0Q29udHJvbHNBdXRvSGlkZSggdmlld2VyICkge1xuICAgIHZhciBpO1xuICAgIHZpZXdlci5jb250cm9sc1Nob3VsZEZhZGUgPSBmYWxzZTtcbiAgICBmb3IgKCBpID0gdmlld2VyLmNvbnRyb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICB2aWV3ZXIuY29udHJvbHNbIGkgXS5zZXRPcGFjaXR5KCAxLjAgKTtcbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEZWZhdWx0IHZpZXcgZXZlbnQgaGFuZGxlcnMuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBvbkZvY3VzKCl7XG4gICAgYWJvcnRDb250cm9sc0F1dG9IaWRlKCB0aGlzICk7XG59XG5cbmZ1bmN0aW9uIG9uQmx1cigpe1xuICAgIGJlZ2luQ29udHJvbHNBdXRvSGlkZSggdGhpcyApO1xuXG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzS2V5RG93biggZXZlbnQgKSB7XG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgIWV2ZW50LmN0cmwgJiYgIWV2ZW50LmFsdCAmJiAhZXZlbnQubWV0YSApIHtcbiAgICAgICAgc3dpdGNoKCBldmVudC5rZXlDb2RlICl7XG4gICAgICAgICAgICBjYXNlIDM4Oi8vdXAgYXJyb3dcbiAgICAgICAgICAgICAgICBpZiAoIGV2ZW50LnNoaWZ0ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeSgxLjEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucGFuQnkodGhpcy52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMobmV3ICQuUG9pbnQoMCwgLTQwKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDQwOi8vZG93biBhcnJvd1xuICAgICAgICAgICAgICAgIGlmICggZXZlbnQuc2hpZnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuem9vbUJ5KDAuOSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wYW5CeSh0aGlzLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhuZXcgJC5Qb2ludCgwLCA0MCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAzNzovL2xlZnQgYXJyb3dcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKG5ldyAkLlBvaW50KC00MCwgMCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDM5Oi8vcmlnaHQgYXJyb3dcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKG5ldyAkLlBvaW50KDQwLCAwKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ25hdmlnYXRvciBrZXljb2RlICVzJywgZXZlbnQua2V5Q29kZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvbkNhbnZhc0tleVByZXNzKCBldmVudCApIHtcbiAgICBpZiAoICFldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvbiAmJiAhZXZlbnQuY3RybCAmJiAhZXZlbnQuYWx0ICYmICFldmVudC5tZXRhICkge1xuICAgICAgICBzd2l0Y2goIGV2ZW50LmtleUNvZGUgKXtcbiAgICAgICAgICAgIGNhc2UgNDM6Ly89fCtcbiAgICAgICAgICAgIGNhc2UgNjE6Ly89fCtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeSgxLjEpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgNDU6Ly8tfF9cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeSgwLjkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgNDg6Ly8wfClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmdvSG9tZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMTE5Oi8vd1xuICAgICAgICAgICAgY2FzZSA4NzovL1dcbiAgICAgICAgICAgICAgICBpZiAoIGV2ZW50LnNoaWZ0ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeSgxLjEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucGFuQnkodGhpcy52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMobmV3ICQuUG9pbnQoMCwgLTQwKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDExNTovL3NcbiAgICAgICAgICAgIGNhc2UgODM6Ly9TXG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC5zaGlmdCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoMC45KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKG5ldyAkLlBvaW50KDAsIDQwKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDk3Oi8vYVxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucGFuQnkodGhpcy52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMobmV3ICQuUG9pbnQoLTQwLCAwKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMTAwOi8vZFxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucGFuQnkodGhpcy52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMobmV3ICQuUG9pbnQoNDAsIDApKSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5hcHBseUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAnbmF2aWdhdG9yIGtleWNvZGUgJXMnLCBldmVudC5rZXlDb2RlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzQ2xpY2soIGV2ZW50ICkge1xuICAgIHZhciBnZXN0dXJlU2V0dGluZ3M7XG5cbiAgICB2YXIgaGF2ZUtleWJvYXJkRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY2FudmFzO1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBrZXlib2FyZCBmb2N1cywgcmVxdWVzdCBpdC5cbiAgICBpZiAoICFoYXZlS2V5Ym9hcmRGb2N1cyApIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBpZiAoICFldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvbiAmJiB0aGlzLnZpZXdwb3J0ICYmIGV2ZW50LnF1aWNrICkge1xuICAgICAgICBnZXN0dXJlU2V0dGluZ3MgPSB0aGlzLmdlc3R1cmVTZXR0aW5nc0J5RGV2aWNlVHlwZSggZXZlbnQucG9pbnRlclR5cGUgKTtcbiAgICAgICAgaWYgKCBnZXN0dXJlU2V0dGluZ3MuY2xpY2tUb1pvb20gKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeShcbiAgICAgICAgICAgICAgICBldmVudC5zaGlmdCA/IDEuMCAvIHRoaXMuem9vbVBlckNsaWNrIDogdGhpcy56b29tUGVyQ2xpY2ssXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wb2ludEZyb21QaXhlbCggZXZlbnQucG9zaXRpb24sIHRydWUgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGEgbW91c2UgcHJlc3MvcmVsZWFzZSBvciB0b3VjaC9yZW1vdmUgb2NjdXJzIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY2FudmFzfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy1jbGlja1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcXVpY2sgLSBUcnVlIG9ubHkgaWYgdGhlIGNsaWNrRGlzdFRocmVzaG9sZCBhbmQgY2xpY2tUaW1lVGhyZXNob2xkIGFyZSBib3RoIHBhc3NlZC4gVXNlZnVsIGZvciBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiBjbGlja3MgYW5kIGRyYWdzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hpZnQgLSBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjYW52YXMtY2xpY2snLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIHF1aWNrOiBldmVudC5xdWljayxcbiAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzRGJsQ2xpY2soIGV2ZW50ICkge1xuICAgIHZhciBnZXN0dXJlU2V0dGluZ3M7XG5cbiAgICBpZiAoICFldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvbiAmJiB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICBnZXN0dXJlU2V0dGluZ3MgPSB0aGlzLmdlc3R1cmVTZXR0aW5nc0J5RGV2aWNlVHlwZSggZXZlbnQucG9pbnRlclR5cGUgKTtcbiAgICAgICAgaWYgKCBnZXN0dXJlU2V0dGluZ3MuZGJsQ2xpY2tUb1pvb20gKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeShcbiAgICAgICAgICAgICAgICBldmVudC5zaGlmdCA/IDEuMCAvIHRoaXMuem9vbVBlckNsaWNrIDogdGhpcy56b29tUGVyQ2xpY2ssXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wb2ludEZyb21QaXhlbCggZXZlbnQucG9zaXRpb24sIHRydWUgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGEgZG91YmxlIG1vdXNlIHByZXNzL3JlbGVhc2Ugb3IgdG91Y2gvcmVtb3ZlIG9jY3VycyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtZG91YmxlLWNsaWNrXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgd2hpY2ggb3JpZ2luYXRlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzaGlmdCAtIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCggJ2NhbnZhcy1kb3VibGUtY2xpY2snLCB7XG4gICAgICAgIHRyYWNrZXI6IGV2ZW50LmV2ZW50U291cmNlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvbkNhbnZhc0RyYWcoIGV2ZW50ICkge1xuICAgIHZhciBnZXN0dXJlU2V0dGluZ3M7XG5cbiAgICBpZiAoICFldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvbiAmJiB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICBnZXN0dXJlU2V0dGluZ3MgPSB0aGlzLmdlc3R1cmVTZXR0aW5nc0J5RGV2aWNlVHlwZSggZXZlbnQucG9pbnRlclR5cGUgKTtcbiAgICAgICAgaWYoICF0aGlzLnBhbkhvcml6b250YWwgKXtcbiAgICAgICAgICAgIGV2ZW50LmRlbHRhLnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhdGhpcy5wYW5WZXJ0aWNhbCApe1xuICAgICAgICAgICAgZXZlbnQuZGVsdGEueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydC5wYW5CeSggdGhpcy52aWV3cG9ydC5kZWx0YVBvaW50c0Zyb21QaXhlbHMoIGV2ZW50LmRlbHRhLm5lZ2F0ZSgpICksIGdlc3R1cmVTZXR0aW5ncy5mbGlja0VuYWJsZWQgKTtcbiAgICAgICAgaWYoIHRoaXMuY29uc3RyYWluRHVyaW5nUGFuICl7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiBhIG1vdXNlIG9yIHRvdWNoIGRyYWcgb3BlcmF0aW9uIG9jY3VycyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtZHJhZ1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZGVsdGEgLSBUaGUgeCx5IGNvbXBvbmVudHMgb2YgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzdGFydCBkcmFnIGFuZCBlbmQgZHJhZy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3BlZWQgLSBDdXJyZW50IGNvbXB1dGVkIHNwZWVkLCBpbiBwaXhlbHMgcGVyIHNlY29uZC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZGlyZWN0aW9uIC0gQ3VycmVudCBjb21wdXRlZCBkaXJlY3Rpb24sIGV4cHJlc3NlZCBhcyBhbiBhbmdsZSBjb3VudGVyY2xvY2t3aXNlIHJlbGF0aXZlIHRvIHRoZSBwb3NpdGl2ZSBYIGF4aXMgKC1waSB0byBwaSwgaW4gcmFkaWFucykuIE9ubHkgdmFsaWQgaWYgc3BlZWQgPiAwLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hpZnQgLSBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjYW52YXMtZHJhZycsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgZGVsdGE6IGV2ZW50LmRlbHRhLFxuICAgICAgICBzcGVlZDogZXZlbnQuc3BlZWQsXG4gICAgICAgIGRpcmVjdGlvbjogZXZlbnQuZGlyZWN0aW9uLFxuICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnQsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNEcmFnRW5kKCBldmVudCApIHtcbiAgICBpZiAoIWV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uICYmIHRoaXMudmlld3BvcnQpIHtcbiAgICAgICAgdmFyIGdlc3R1cmVTZXR0aW5ncyA9IHRoaXMuZ2VzdHVyZVNldHRpbmdzQnlEZXZpY2VUeXBlKGV2ZW50LnBvaW50ZXJUeXBlKTtcbiAgICAgICAgaWYgKGdlc3R1cmVTZXR0aW5ncy5mbGlja0VuYWJsZWQgJiZcbiAgICAgICAgICAgIGV2ZW50LnNwZWVkID49IGdlc3R1cmVTZXR0aW5ncy5mbGlja01pblNwZWVkKSB7XG4gICAgICAgICAgICB2YXIgYW1wbGl0dWRlWCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgYW1wbGl0dWRlWCA9IGdlc3R1cmVTZXR0aW5ncy5mbGlja01vbWVudHVtICogZXZlbnQuc3BlZWQgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyhldmVudC5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFtcGxpdHVkZVkgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFuVmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICBhbXBsaXR1ZGVZID0gZ2VzdHVyZVNldHRpbmdzLmZsaWNrTW9tZW50dW0gKiBldmVudC5zcGVlZCAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGV2ZW50LmRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy52aWV3cG9ydC5waXhlbEZyb21Qb2ludChcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmdldENlbnRlcih0cnVlKSk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy52aWV3cG9ydC5wb2ludEZyb21QaXhlbChcbiAgICAgICAgICAgICAgICBuZXcgJC5Qb2ludChjZW50ZXIueCAtIGFtcGxpdHVkZVgsIGNlbnRlci55IC0gYW1wbGl0dWRlWSkpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5wYW5Ubyh0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gYSBtb3VzZSBvciB0b3VjaCBkcmFnIG9wZXJhdGlvbiBlbmRzIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY2FudmFzfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy1kcmFnLWVuZFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzcGVlZCAtIFNwZWVkIGF0IHRoZSBlbmQgb2YgYSBkcmFnIGdlc3R1cmUsIGluIHBpeGVscyBwZXIgc2Vjb25kLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBEaXJlY3Rpb24gYXQgdGhlIGVuZCBvZiBhIGRyYWcgZ2VzdHVyZSwgZXhwcmVzc2VkIGFzIGFuIGFuZ2xlIGNvdW50ZXJjbG9ja3dpc2UgcmVsYXRpdmUgdG8gdGhlIHBvc2l0aXZlIFggYXhpcyAoLXBpIHRvIHBpLCBpbiByYWRpYW5zKS4gT25seSB2YWxpZCBpZiBzcGVlZCA+IDAuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzaGlmdCAtIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCgnY2FudmFzLWRyYWctZW5kJywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBzcGVlZDogZXZlbnQuc3BlZWQsXG4gICAgICAgIGRpcmVjdGlvbjogZXZlbnQuZGlyZWN0aW9uLFxuICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnQsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNFbnRlciggZXZlbnQgKSB7XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gYSBwb2ludGVyIGVudGVycyB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtZW50ZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBvaW50ZXJUeXBlIC0gXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBidXR0b25zIC0gQ3VycmVudCBidXR0b25zIHByZXNzZWQuIEEgY29tYmluYXRpb24gb2YgYml0IGZsYWdzIDA6IG5vbmUsIDE6IHByaW1hcnkgKG9yIHRvdWNoIGNvbnRhY3QpLCAyOiBzZWNvbmRhcnksIDQ6IGF1eCAob2Z0ZW4gbWlkZGxlKSwgODogWDEgKG9mdGVuIGJhY2spLCAxNjogWDIgKG9mdGVuIGZvcndhcmQpLCAzMjogcGVuIGVyYXNlci5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcG9pbnRlcnMgLSBOdW1iZXIgb2YgcG9pbnRlcnMgKGFsbCB0eXBlcykgYWN0aXZlIGluIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbnNpZGVFbGVtZW50UHJlc3NlZCAtIFRydWUgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB3YXMgaW5pdGlhdGVkIGluc2lkZSB0aGUgdHJhY2tlZCBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBidXR0b25Eb3duQW55IC0gV2FzIHRoZSBidXR0b24gZG93biBhbnl3aGVyZSBpbiB0aGUgc2NyZWVuIGR1cmluZyB0aGUgZXZlbnQuIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPkRlcHJlY2F0ZWQuIFVzZSBidXR0b25zIGluc3RlYWQuPC9zcGFuPlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLWVudGVyJywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgcG9pbnRlclR5cGU6IGV2ZW50LnBvaW50ZXJUeXBlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIGJ1dHRvbnM6IGV2ZW50LmJ1dHRvbnMsXG4gICAgICAgIHBvaW50ZXJzOiBldmVudC5wb2ludGVycyxcbiAgICAgICAgaW5zaWRlRWxlbWVudFByZXNzZWQ6IGV2ZW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkLFxuICAgICAgICBidXR0b25Eb3duQW55OiBldmVudC5idXR0b25Eb3duQW55LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ2FudmFzRXhpdCggZXZlbnQgKSB7XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gYSBwb2ludGVyIGxlYXZlcyB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtZXhpdFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcG9pbnRlclR5cGUgLSBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJ1dHRvbnMgLSBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC4gQSBjb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwb2ludGVycyAtIE51bWJlciBvZiBwb2ludGVycyAoYWxsIHR5cGVzKSBhY3RpdmUgaW4gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGluc2lkZUVsZW1lbnRQcmVzc2VkIC0gVHJ1ZSBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYW5kIHdhcyBpbml0aWF0ZWQgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ1dHRvbkRvd25BbnkgLSBXYXMgdGhlIGJ1dHRvbiBkb3duIGFueXdoZXJlIGluIHRoZSBzY3JlZW4gZHVyaW5nIHRoZSBldmVudC4gPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+RGVwcmVjYXRlZC4gVXNlIGJ1dHRvbnMgaW5zdGVhZC48L3NwYW4+XG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjYW52YXMtZXhpdCcsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiBldmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBidXR0b25zOiBldmVudC5idXR0b25zLFxuICAgICAgICBwb2ludGVyczogZXZlbnQucG9pbnRlcnMsXG4gICAgICAgIGluc2lkZUVsZW1lbnRQcmVzc2VkOiBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCxcbiAgICAgICAgYnV0dG9uRG93bkFueTogZXZlbnQuYnV0dG9uRG93bkFueSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvbkNhbnZhc1ByZXNzKCBldmVudCApIHtcbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiB0aGUgcHJpbWFyeSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCBvciB0b3VjaCBzdGFydHMgb24gdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjYW52YXN9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLXByZXNzXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgd2hpY2ggb3JpZ2luYXRlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwb2ludGVyVHlwZSAtIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGluc2lkZUVsZW1lbnRQcmVzc2VkIC0gVHJ1ZSBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYW5kIHdhcyBpbml0aWF0ZWQgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGluc2lkZUVsZW1lbnRSZWxlYXNlZCAtIFRydWUgaWYgdGhlIGN1cnNvciBzdGlsbCBpbnNpZGUgdGhlIHRyYWNrZWQgZWxlbWVudCB3aGVuIHRoZSBidXR0b24gd2FzIHJlbGVhc2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLXByZXNzJywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgcG9pbnRlclR5cGU6IGV2ZW50LnBvaW50ZXJUeXBlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIGluc2lkZUVsZW1lbnRQcmVzc2VkOiBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCxcbiAgICAgICAgaW5zaWRlRWxlbWVudFJlbGVhc2VkOiBldmVudC5pbnNpZGVFbGVtZW50UmVsZWFzZWQsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNSZWxlYXNlKCBldmVudCApIHtcbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiB0aGUgcHJpbWFyeSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQgb3IgdG91Y2ggZW5kcyBvbiB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NhbnZhc30gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjYW52YXMtcmVsZWFzZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcG9pbnRlclR5cGUgLSBcIm1vdXNlXCIsIFwidG91Y2hcIiwgXCJwZW5cIiwgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbnNpZGVFbGVtZW50UHJlc3NlZCAtIFRydWUgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB3YXMgaW5pdGlhdGVkIGluc2lkZSB0aGUgdHJhY2tlZCBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbnNpZGVFbGVtZW50UmVsZWFzZWQgLSBUcnVlIGlmIHRoZSBjdXJzb3Igc3RpbGwgaW5zaWRlIHRoZSB0cmFja2VkIGVsZW1lbnQgd2hlbiB0aGUgYnV0dG9uIHdhcyByZWxlYXNlZC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCggJ2NhbnZhcy1yZWxlYXNlJywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgcG9pbnRlclR5cGU6IGV2ZW50LnBvaW50ZXJUeXBlLFxuICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgIGluc2lkZUVsZW1lbnRQcmVzc2VkOiBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCxcbiAgICAgICAgaW5zaWRlRWxlbWVudFJlbGVhc2VkOiBldmVudC5pbnNpZGVFbGVtZW50UmVsZWFzZWQsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNOb25QcmltYXJ5UHJlc3MoIGV2ZW50ICkge1xuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGFueSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiBpcyBwcmVzc2VkIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY2FudmFzfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy1ub25wcmltYXJ5LXByZXNzXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBNb3VzZVRyYWNrZXIgd2hpY2ggb3JpZ2luYXRlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBvaW50ZXJUeXBlIC0gXCJtb3VzZVwiLCBcInRvdWNoXCIsIFwicGVuXCIsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYnV0dG9uIC0gQnV0dG9uIHdoaWNoIGNhdXNlZCB0aGUgZXZlbnQuXG4gICAgICogICAgICAtMTogbm9uZSwgMDogcHJpbWFyeS9sZWZ0LCAxOiBhdXgvbWlkZGxlLCAyOiBzZWNvbmRhcnkvcmlnaHQsIDM6IFgxL2JhY2ssIDQ6IFgyL2ZvcndhcmQsIDU6IHBlbiBlcmFzZXIuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJ1dHRvbnMgLSBDdXJyZW50IGJ1dHRvbnMgcHJlc3NlZC5cbiAgICAgKiAgICAgIENvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnJhaXNlRXZlbnQoICdjYW52YXMtbm9ucHJpbWFyeS1wcmVzcycsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgcG9pbnRlclR5cGU6IGV2ZW50LnBvaW50ZXJUeXBlLFxuICAgICAgICBidXR0b246IGV2ZW50LmJ1dHRvbixcbiAgICAgICAgYnV0dG9uczogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvbkNhbnZhc05vblByaW1hcnlSZWxlYXNlKCBldmVudCApIHtcbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiBhbnkgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gaXMgcmVsZWFzZWQgb24gdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjYW52YXN9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2FudmFzLW5vbnByaW1hcnktcmVsZWFzZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwb2ludGVyVHlwZSAtIFwibW91c2VcIiwgXCJ0b3VjaFwiLCBcInBlblwiLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJ1dHRvbiAtIEJ1dHRvbiB3aGljaCBjYXVzZWQgdGhlIGV2ZW50LlxuICAgICAqICAgICAgLTE6IG5vbmUsIDA6IHByaW1hcnkvbGVmdCwgMTogYXV4L21pZGRsZSwgMjogc2Vjb25kYXJ5L3JpZ2h0LCAzOiBYMS9iYWNrLCA0OiBYMi9mb3J3YXJkLCA1OiBwZW4gZXJhc2VyLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBidXR0b25zIC0gQ3VycmVudCBidXR0b25zIHByZXNzZWQuXG4gICAgICogICAgICBDb21iaW5hdGlvbiBvZiBiaXQgZmxhZ3MgMDogbm9uZSwgMTogcHJpbWFyeSAob3IgdG91Y2ggY29udGFjdCksIDI6IHNlY29uZGFyeSwgNDogYXV4IChvZnRlbiBtaWRkbGUpLCA4OiBYMSAob2Z0ZW4gYmFjayksIDE2OiBYMiAob2Z0ZW4gZm9yd2FyZCksIDMyOiBwZW4gZXJhc2VyLlxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5yYWlzZUV2ZW50KCAnY2FudmFzLW5vbnByaW1hcnktcmVsZWFzZScsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgcG9pbnRlclR5cGU6IGV2ZW50LnBvaW50ZXJUeXBlLFxuICAgICAgICBidXR0b246IGV2ZW50LmJ1dHRvbixcbiAgICAgICAgYnV0dG9uczogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvbkNhbnZhc1BpbmNoKCBldmVudCApIHtcbiAgICB2YXIgZ2VzdHVyZVNldHRpbmdzLFxuICAgICAgICBjZW50ZXJQdCxcbiAgICAgICAgbGFzdENlbnRlclB0LFxuICAgICAgICBwYW5CeVB0O1xuXG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgZ2VzdHVyZVNldHRpbmdzID0gdGhpcy5nZXN0dXJlU2V0dGluZ3NCeURldmljZVR5cGUoIGV2ZW50LnBvaW50ZXJUeXBlICk7XG4gICAgICAgIGlmICggZ2VzdHVyZVNldHRpbmdzLnBpbmNoVG9ab29tICkge1xuICAgICAgICAgICAgY2VudGVyUHQgPSB0aGlzLnZpZXdwb3J0LnBvaW50RnJvbVBpeGVsKCBldmVudC5jZW50ZXIsIHRydWUgKTtcbiAgICAgICAgICAgIGxhc3RDZW50ZXJQdCA9IHRoaXMudmlld3BvcnQucG9pbnRGcm9tUGl4ZWwoIGV2ZW50Lmxhc3RDZW50ZXIsIHRydWUgKTtcbiAgICAgICAgICAgIHBhbkJ5UHQgPSBsYXN0Q2VudGVyUHQubWludXMoIGNlbnRlclB0ICk7XG4gICAgICAgICAgICBpZiggIXRoaXMucGFuSG9yaXpvbnRhbCApIHtcbiAgICAgICAgICAgICAgICBwYW5CeVB0LnggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoICF0aGlzLnBhblZlcnRpY2FsICkge1xuICAgICAgICAgICAgICAgIHBhbkJ5UHQueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeSggZXZlbnQuZGlzdGFuY2UgLyBldmVudC5sYXN0RGlzdGFuY2UsIGNlbnRlclB0LCB0cnVlICk7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBhbkJ5KCBwYW5CeVB0LCB0cnVlICk7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGdlc3R1cmVTZXR0aW5ncy5waW5jaFJvdGF0ZSApIHtcbiAgICAgICAgICAgIC8vIFBpbmNoIHJvdGF0ZVxuICAgICAgICAgICAgdmFyIGFuZ2xlMSA9IE1hdGguYXRhbjIoZXZlbnQuZ2VzdHVyZVBvaW50c1swXS5jdXJyZW50UG9zLnkgLSBldmVudC5nZXN0dXJlUG9pbnRzWzFdLmN1cnJlbnRQb3MueSxcbiAgICAgICAgICAgICAgICBldmVudC5nZXN0dXJlUG9pbnRzWzBdLmN1cnJlbnRQb3MueCAtIGV2ZW50Lmdlc3R1cmVQb2ludHNbMV0uY3VycmVudFBvcy54KTtcbiAgICAgICAgICAgIHZhciBhbmdsZTIgPSBNYXRoLmF0YW4yKGV2ZW50Lmdlc3R1cmVQb2ludHNbMF0ubGFzdFBvcy55IC0gZXZlbnQuZ2VzdHVyZVBvaW50c1sxXS5sYXN0UG9zLnksXG4gICAgICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZVBvaW50c1swXS5sYXN0UG9zLnggLSBldmVudC5nZXN0dXJlUG9pbnRzWzFdLmxhc3RQb3MueCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnNldFJvdGF0aW9uKHRoaXMudmlld3BvcnQuZ2V0Um90YXRpb24oKSArICgoYW5nbGUxIC0gYW5nbGUyKSAqICgxODAgLyBNYXRoLlBJKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhaXNlZCB3aGVuIGEgcGluY2ggZXZlbnQgb2NjdXJzIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY2FudmFzfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNhbnZhcy1waW5jaFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlci5HZXN0dXJlUG9pbnQ+fSBnZXN0dXJlUG9pbnRzIC0gR2VzdHVyZSBwb2ludHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnZXN0dXJlLiBWZWxvY2l0eSBkYXRhIGNhbiBiZSBmb3VuZCBoZXJlLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gbGFzdENlbnRlciAtIFRoZSBwcmV2aW91cyBjZW50ZXIgcG9pbnQgb2YgdGhlIHR3byBwaW5jaCBjb250YWN0IHBvaW50cyByZWxhdGl2ZSB0byB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gY2VudGVyIC0gVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgdHdvIHBpbmNoIGNvbnRhY3QgcG9pbnRzIHJlbGF0aXZlIHRvIHRoZSB0cmFja2VkIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxhc3REaXN0YW5jZSAtIFRoZSBwcmV2aW91cyBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcGluY2ggY29udGFjdCBwb2ludHMgaW4gQ1NTIHBpeGVscy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZGlzdGFuY2UgLSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBpbmNoIGNvbnRhY3QgcG9pbnRzIGluIENTUyBwaXhlbHMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzaGlmdCAtIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCgnY2FudmFzLXBpbmNoJywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgZ2VzdHVyZVBvaW50czogZXZlbnQuZ2VzdHVyZVBvaW50cyxcbiAgICAgICAgbGFzdENlbnRlcjogZXZlbnQubGFzdENlbnRlcixcbiAgICAgICAgY2VudGVyOiBldmVudC5jZW50ZXIsXG4gICAgICAgIGxhc3REaXN0YW5jZTogZXZlbnQubGFzdERpc3RhbmNlLFxuICAgICAgICBkaXN0YW5jZTogZXZlbnQuZGlzdGFuY2UsXG4gICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xuICAgIC8vY2FuY2VscyBldmVudFxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25DYW52YXNTY3JvbGwoIGV2ZW50ICkge1xuICAgIHZhciBnZXN0dXJlU2V0dGluZ3MsXG4gICAgICAgIGZhY3RvcixcbiAgICAgICAgdGhpc1Njcm9sbFRpbWUsXG4gICAgICAgIGRlbHRhU2Nyb2xsVGltZTtcblxuICAgIC8qIENlcnRhaW4gc2Nyb2xsIGRldmljZXMgZmlyZSB0aGUgc2Nyb2xsIGV2ZW50IHdheSB0b28gZmFzdCBzbyB3ZSBhcmUgaW5qZWN0aW5nIGEgc2ltcGxlIGFkanVzdG1lbnQgdG8ga2VlcCB0aGluZ3NcbiAgICAgKiBwYXJ0aWFsbHkgbm9ybWFsaXplZC4gSWYgd2UgaGF2ZSBhbHJlYWR5IGZpcmVkIGFuIGV2ZW50IHdpdGhpbiB0aGUgbGFzdCAnbWluU2Nyb2xsRGVsdGEnIG1pbGxpc2Vjb25kcyB3ZSBza2lwXG4gICAgICogdGhpcyBvbmUgYW5kIHdhaXQgZm9yIHRoZSBuZXh0IGV2ZW50LiAqL1xuICAgIHRoaXNTY3JvbGxUaW1lID0gJC5ub3coKTtcbiAgICBkZWx0YVNjcm9sbFRpbWUgPSB0aGlzU2Nyb2xsVGltZSAtIHRoaXMuX2xhc3RTY3JvbGxUaW1lO1xuICAgIGlmIChkZWx0YVNjcm9sbFRpbWUgPiB0aGlzLm1pblNjcm9sbERlbHRhVGltZSkge1xuICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsVGltZSA9IHRoaXNTY3JvbGxUaW1lO1xuXG4gICAgICAgIGlmICggIWV2ZW50LnByZXZlbnREZWZhdWx0QWN0aW9uICYmIHRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgICAgICBnZXN0dXJlU2V0dGluZ3MgPSB0aGlzLmdlc3R1cmVTZXR0aW5nc0J5RGV2aWNlVHlwZSggZXZlbnQucG9pbnRlclR5cGUgKTtcbiAgICAgICAgICAgIGlmICggZ2VzdHVyZVNldHRpbmdzLnNjcm9sbFRvWm9vbSApIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSBNYXRoLnBvdyggdGhpcy56b29tUGVyU2Nyb2xsLCBldmVudC5zY3JvbGwgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeShcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnBvaW50RnJvbVBpeGVsKCBldmVudC5wb3NpdGlvbiwgdHJ1ZSApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gYSBzY3JvbGwgZXZlbnQgb2NjdXJzIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjY2FudmFzfSBlbGVtZW50IChtb3VzZSB3aGVlbCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBjYW52YXMtc2Nyb2xsXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgTW91c2VUcmFja2VyIHdoaWNoIG9yaWdpbmF0ZWQgdGhpcyBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbCAtIFRoZSBzY3JvbGwgZGVsdGEgZm9yIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzaGlmdCAtIFRydWUgaWYgdGhlIHNoaWZ0IGtleSB3YXMgcHJlc3NlZCBkdXJpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdjYW52YXMtc2Nyb2xsJywge1xuICAgICAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogZXZlbnQucG9zaXRpb24sXG4gICAgICAgICAgICBzY3JvbGw6IGV2ZW50LnNjcm9sbCxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChnZXN0dXJlU2V0dGluZ3MgJiYgZ2VzdHVyZVNldHRpbmdzLnNjcm9sbFRvWm9vbSkge1xuICAgICAgICAgICAgLy9jYW5jZWxzIGV2ZW50XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlc3R1cmVTZXR0aW5ncyA9IHRoaXMuZ2VzdHVyZVNldHRpbmdzQnlEZXZpY2VUeXBlKCBldmVudC5wb2ludGVyVHlwZSApO1xuICAgICAgICBpZiAoZ2VzdHVyZVNldHRpbmdzICYmIGdlc3R1cmVTZXR0aW5ncy5zY3JvbGxUb1pvb20pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgICAvLyBXZSBhcmUgc3dhbGxvd2luZyB0aGlzIGV2ZW50XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29udGFpbmVyRW50ZXIoIGV2ZW50ICkge1xuICAgIFRISVNbIHRoaXMuaGFzaCBdLm1vdXNlSW5zaWRlID0gdHJ1ZTtcbiAgICBhYm9ydENvbnRyb2xzQXV0b0hpZGUoIHRoaXMgKTtcbiAgICAvKipcbiAgICAgKiBSYWlzZWQgd2hlbiB0aGUgY3Vyc29yIGVudGVycyB0aGUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2NvbnRhaW5lcn0gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBjb250YWluZXItZW50ZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYnV0dG9ucyAtIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLiBBIGNvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHBvaW50ZXJzIC0gTnVtYmVyIG9mIHBvaW50ZXJzIChhbGwgdHlwZXMpIGFjdGl2ZSBpbiB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW5zaWRlRWxlbWVudFByZXNzZWQgLSBUcnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgd2FzIGluaXRpYXRlZCBpbnNpZGUgdGhlIHRyYWNrZWQgZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYnV0dG9uRG93bkFueSAtIFdhcyB0aGUgYnV0dG9uIGRvd24gYW55d2hlcmUgaW4gdGhlIHNjcmVlbiBkdXJpbmcgdGhlIGV2ZW50LiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgYnV0dG9ucyBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCggJ2NvbnRhaW5lci1lbnRlcicsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgYnV0dG9uczogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgcG9pbnRlcnM6IGV2ZW50LnBvaW50ZXJzLFxuICAgICAgICBpbnNpZGVFbGVtZW50UHJlc3NlZDogZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQsXG4gICAgICAgIGJ1dHRvbkRvd25Bbnk6IGV2ZW50LmJ1dHRvbkRvd25BbnksXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25Db250YWluZXJFeGl0KCBldmVudCApIHtcbiAgICBpZiAoIGV2ZW50LnBvaW50ZXJzIDwgMSApIHtcbiAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ubW91c2VJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCAhVEhJU1sgdGhpcy5oYXNoIF0uYW5pbWF0aW5nICkge1xuICAgICAgICAgICAgYmVnaW5Db250cm9sc0F1dG9IaWRlKCB0aGlzICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gdGhlIGN1cnNvciBsZWF2ZXMgdGhlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNjb250YWluZXJ9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY29udGFpbmVyLWV4aXRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYnV0dG9ucyAtIEN1cnJlbnQgYnV0dG9ucyBwcmVzc2VkLiBBIGNvbWJpbmF0aW9uIG9mIGJpdCBmbGFncyAwOiBub25lLCAxOiBwcmltYXJ5IChvciB0b3VjaCBjb250YWN0KSwgMjogc2Vjb25kYXJ5LCA0OiBhdXggKG9mdGVuIG1pZGRsZSksIDg6IFgxIChvZnRlbiBiYWNrKSwgMTY6IFgyIChvZnRlbiBmb3J3YXJkKSwgMzI6IHBlbiBlcmFzZXIuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHBvaW50ZXJzIC0gTnVtYmVyIG9mIHBvaW50ZXJzIChhbGwgdHlwZXMpIGFjdGl2ZSBpbiB0aGUgdHJhY2tlZCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW5zaWRlRWxlbWVudFByZXNzZWQgLSBUcnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgd2FzIGluaXRpYXRlZCBpbnNpZGUgdGhlIHRyYWNrZWQgZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYnV0dG9uRG93bkFueSAtIFdhcyB0aGUgYnV0dG9uIGRvd24gYW55d2hlcmUgaW4gdGhlIHNjcmVlbiBkdXJpbmcgdGhlIGV2ZW50LiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj5EZXByZWNhdGVkLiBVc2UgYnV0dG9ucyBpbnN0ZWFkLjwvc3Bhbj5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMucmFpc2VFdmVudCggJ2NvbnRhaW5lci1leGl0Jywge1xuICAgICAgICB0cmFja2VyOiBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgcG9zaXRpb246IGV2ZW50LnBvc2l0aW9uLFxuICAgICAgICBidXR0b25zOiBldmVudC5idXR0b25zLFxuICAgICAgICBwb2ludGVyczogZXZlbnQucG9pbnRlcnMsXG4gICAgICAgIGluc2lkZUVsZW1lbnRQcmVzc2VkOiBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCxcbiAgICAgICAgYnV0dG9uRG93bkFueTogZXZlbnQuYnV0dG9uRG93bkFueSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFBhZ2UgdXBkYXRlIHJvdXRpbmVzICggYWthIFZpZXdzIC0gZm9yIGZ1dHVyZSByZWZlcmVuY2UgKVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiB1cGRhdGVNdWx0aSggdmlld2VyICkge1xuICAgIHVwZGF0ZU9uY2UoIHZpZXdlciApO1xuXG4gICAgLy8gUmVxdWVzdCB0aGUgbmV4dCBmcmFtZSwgdW5sZXNzIHdlJ3ZlIGJlZW4gY2xvc2VkXG4gICAgaWYgKCB2aWV3ZXIuaXNPcGVuKCkgKSB7XG4gICAgICAgIHZpZXdlci5fdXBkYXRlUmVxdWVzdElkID0gc2NoZWR1bGVVcGRhdGUoIHZpZXdlciwgdXBkYXRlTXVsdGkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3ZXIuX3VwZGF0ZVJlcXVlc3RJZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT25jZSggdmlld2VyICkge1xuXG4gICAgLy92aWV3ZXIucHJvZmlsZXIuYmVnaW5VcGRhdGUoKTtcblxuICAgIGlmICh2aWV3ZXIuX29wZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2aWV3ZXIuYXV0b1Jlc2l6ZSkge1xuICAgICAgICB2YXIgY29udGFpbmVyU2l6ZSA9IF9nZXRTYWZlRWxlbVNpemUodmlld2VyLmNvbnRhaW5lcik7XG4gICAgICAgIHZhciBwcmV2Q29udGFpbmVyU2l6ZSA9IFRISVNbdmlld2VyLmhhc2hdLnByZXZDb250YWluZXJTaXplO1xuICAgICAgICBpZiAoIWNvbnRhaW5lclNpemUuZXF1YWxzKHByZXZDb250YWluZXJTaXplKSkge1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gdmlld2VyLnZpZXdwb3J0O1xuICAgICAgICAgICAgaWYgKHZpZXdlci5wcmVzZXJ2ZUltYWdlU2l6ZU9uUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZVJhdGlvID0gcHJldkNvbnRhaW5lclNpemUueCAvIGNvbnRhaW5lclNpemUueDtcbiAgICAgICAgICAgICAgICB2YXIgem9vbSA9IHZpZXdwb3J0LmdldFpvb20oKSAqIHJlc2l6ZVJhdGlvO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB2aWV3cG9ydC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5yZXNpemUoY29udGFpbmVyU2l6ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0Lnpvb21Ubyh6b29tLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5wYW5UbyhjZW50ZXIsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYWludGFpbiBpbWFnZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHZhciBvbGRCb3VuZHMgPSB2aWV3cG9ydC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5yZXNpemUoY29udGFpbmVyU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQuZml0Qm91bmRzV2l0aENvbnN0cmFpbnRzKG9sZEJvdW5kcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUSElTW3ZpZXdlci5oYXNoXS5wcmV2Q29udGFpbmVyU2l6ZSA9IGNvbnRhaW5lclNpemU7XG4gICAgICAgICAgICBUSElTW3ZpZXdlci5oYXNoXS5mb3JjZVJlZHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlld3BvcnRDaGFuZ2UgPSB2aWV3ZXIudmlld3BvcnQudXBkYXRlKCk7XG4gICAgdmFyIGFuaW1hdGVkID0gdmlld2VyLndvcmxkLnVwZGF0ZSgpIHx8IHZpZXdwb3J0Q2hhbmdlO1xuXG4gICAgaWYgKHZpZXdwb3J0Q2hhbmdlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbnkgc3ByaW5nIGFuaW1hdGlvbiB1cGRhdGUgb2NjdXJzICh6b29tLCBwYW4sIGV0Yy4pLFxuICAgICAgICAgKiBiZWZvcmUgdGhlIHZpZXdlciBoYXMgZHJhd24gdGhlIG5ldyBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IHZpZXdwb3J0LWNoYW5nZVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB2aWV3ZXIucmFpc2VFdmVudCgndmlld3BvcnQtY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgaWYoIHZpZXdlci5yZWZlcmVuY2VTdHJpcCApe1xuICAgICAgICBhbmltYXRlZCA9IHZpZXdlci5yZWZlcmVuY2VTdHJpcC51cGRhdGUoIHZpZXdlci52aWV3cG9ydCApIHx8IGFuaW1hdGVkO1xuICAgIH1cblxuICAgIGlmICggIVRISVNbIHZpZXdlci5oYXNoIF0uYW5pbWF0aW5nICYmIGFuaW1hdGVkICkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gYW55IHNwcmluZyBhbmltYXRpb24gc3RhcnRzICh6b29tLCBwYW4sIGV0Yy4pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgYW5pbWF0aW9uLXN0YXJ0XG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHZpZXdlci5yYWlzZUV2ZW50KCBcImFuaW1hdGlvbi1zdGFydFwiICk7XG4gICAgICAgIGFib3J0Q29udHJvbHNBdXRvSGlkZSggdmlld2VyICk7XG4gICAgfVxuXG4gICAgaWYgKCBhbmltYXRlZCB8fCBUSElTWyB2aWV3ZXIuaGFzaCBdLmZvcmNlUmVkcmF3IHx8IHZpZXdlci53b3JsZC5uZWVkc0RyYXcoKSApIHtcbiAgICAgICAgZHJhd1dvcmxkKCB2aWV3ZXIgKTtcbiAgICAgICAgdmlld2VyLl9kcmF3T3ZlcmxheXMoKTtcbiAgICAgICAgaWYoIHZpZXdlci5uYXZpZ2F0b3IgKXtcbiAgICAgICAgICAgIHZpZXdlci5uYXZpZ2F0b3IudXBkYXRlKCB2aWV3ZXIudmlld3BvcnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRISVNbIHZpZXdlci5oYXNoIF0uZm9yY2VSZWRyYXcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gYW55IHNwcmluZyBhbmltYXRpb24gdXBkYXRlIG9jY3VycyAoem9vbSwgcGFuLCBldGMuKSxcbiAgICAgICAgICAgICAqIGFmdGVyIHRoZSB2aWV3ZXIgaGFzIGRyYXduIHRoZSBuZXcgbG9jYXRpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IGFuaW1hdGlvblxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aWV3ZXIucmFpc2VFdmVudCggXCJhbmltYXRpb25cIiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCBUSElTWyB2aWV3ZXIuaGFzaCBdLmFuaW1hdGluZyAmJiAhYW5pbWF0ZWQgKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbnkgc3ByaW5nIGFuaW1hdGlvbiBlbmRzICh6b29tLCBwYW4sIGV0Yy4pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgYW5pbWF0aW9uLWZpbmlzaFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB2aWV3ZXIucmFpc2VFdmVudCggXCJhbmltYXRpb24tZmluaXNoXCIgKTtcblxuICAgICAgICBpZiAoICFUSElTWyB2aWV3ZXIuaGFzaCBdLm1vdXNlSW5zaWRlICkge1xuICAgICAgICAgICAgYmVnaW5Db250cm9sc0F1dG9IaWRlKCB2aWV3ZXIgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFRISVNbIHZpZXdlci5oYXNoIF0uYW5pbWF0aW5nID0gYW5pbWF0ZWQ7XG5cbiAgICAvL3ZpZXdlci5wcm9maWxlci5lbmRVcGRhdGUoKTtcbn1cblxuZnVuY3Rpb24gZHJhd1dvcmxkKCB2aWV3ZXIgKSB7XG4gICAgdmlld2VyLmltYWdlTG9hZGVyLmNsZWFyKCk7XG4gICAgdmlld2VyLmRyYXdlci5jbGVhcigpO1xuICAgIHZpZXdlci53b3JsZC5kcmF3KCk7XG5cbiAgICAvKipcbiAgICAgKiA8ZW0+LSBOZWVkcyBkb2N1bWVudGF0aW9uIC08L2VtPlxuICAgICAqXG4gICAgICogQGV2ZW50IHVwZGF0ZS12aWV3cG9ydFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZpZXdlci5yYWlzZUV2ZW50KCAndXBkYXRlLXZpZXdwb3J0Jywge30gKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTmF2aWdhdGlvbiBDb250cm9sc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gcmVzb2x2ZVVybCggcHJlZml4LCB1cmwgKSB7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIHVybCA6IHVybDtcbn1cblxuXG5cbmZ1bmN0aW9uIGJlZ2luWm9vbWluZ0luKCkge1xuICAgIFRISVNbIHRoaXMuaGFzaCBdLmxhc3Rab29tVGltZSA9ICQubm93KCk7XG4gICAgVEhJU1sgdGhpcy5oYXNoIF0uem9vbUZhY3RvciA9IHRoaXMuem9vbVBlclNlY29uZDtcbiAgICBUSElTWyB0aGlzLmhhc2ggXS56b29taW5nID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVpvb20oIHRoaXMgKTtcbn1cblxuXG5mdW5jdGlvbiBiZWdpblpvb21pbmdPdXQoKSB7XG4gICAgVEhJU1sgdGhpcy5oYXNoIF0ubGFzdFpvb21UaW1lID0gJC5ub3coKTtcbiAgICBUSElTWyB0aGlzLmhhc2ggXS56b29tRmFjdG9yID0gMS4wIC8gdGhpcy56b29tUGVyU2Vjb25kO1xuICAgIFRISVNbIHRoaXMuaGFzaCBdLnpvb21pbmcgPSB0cnVlO1xuICAgIHNjaGVkdWxlWm9vbSggdGhpcyApO1xufVxuXG5cbmZ1bmN0aW9uIGVuZFpvb21pbmcoKSB7XG4gICAgVEhJU1sgdGhpcy5oYXNoIF0uem9vbWluZyA9IGZhbHNlO1xufVxuXG5cbmZ1bmN0aW9uIHNjaGVkdWxlWm9vbSggdmlld2VyICkge1xuICAgICQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCAkLmRlbGVnYXRlKCB2aWV3ZXIsIGRvWm9vbSApICk7XG59XG5cblxuZnVuY3Rpb24gZG9ab29tKCkge1xuICAgIHZhciBjdXJyZW50VGltZSxcbiAgICAgICAgZGVsdGFUaW1lLFxuICAgICAgICBhZGp1c3RlZEZhY3RvcjtcblxuICAgIGlmICggVEhJU1sgdGhpcy5oYXNoIF0uem9vbWluZyAmJiB0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgIGN1cnJlbnRUaW1lICAgICA9ICQubm93KCk7XG4gICAgICAgIGRlbHRhVGltZSAgICAgICA9IGN1cnJlbnRUaW1lIC0gVEhJU1sgdGhpcy5oYXNoIF0ubGFzdFpvb21UaW1lO1xuICAgICAgICBhZGp1c3RlZEZhY3RvciAgPSBNYXRoLnBvdyggVEhJU1sgdGhpcy5oYXNoIF0uem9vbUZhY3RvciwgZGVsdGFUaW1lIC8gMTAwMCApO1xuXG4gICAgICAgIHRoaXMudmlld3BvcnQuem9vbUJ5KCBhZGp1c3RlZEZhY3RvciApO1xuICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0ubGFzdFpvb21UaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIHNjaGVkdWxlWm9vbSggdGhpcyApO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBkb1NpbmdsZVpvb21JbigpIHtcbiAgICBpZiAoIHRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgIFRISVNbIHRoaXMuaGFzaCBdLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC56b29tQnkoXG4gICAgICAgICAgICB0aGlzLnpvb21QZXJDbGljayAvIDEuMFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnZpZXdwb3J0LmFwcGx5Q29uc3RyYWludHMoKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZG9TaW5nbGVab29tT3V0KCkge1xuICAgIGlmICggdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgVEhJU1sgdGhpcy5oYXNoIF0uem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXdwb3J0Lnpvb21CeShcbiAgICAgICAgICAgIDEuMCAvIHRoaXMuem9vbVBlckNsaWNrXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBsaWdodFVwKCkge1xuICAgIHRoaXMuYnV0dG9ucy5lbXVsYXRlRW50ZXIoKTtcbiAgICB0aGlzLmJ1dHRvbnMuZW11bGF0ZUV4aXQoKTtcbn1cblxuXG5mdW5jdGlvbiBvbkhvbWUoKSB7XG4gICAgaWYgKCB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0LmdvSG9tZSgpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBvbkZ1bGxTY3JlZW4oKSB7XG4gICAgaWYgKCB0aGlzLmlzRnVsbFBhZ2UoKSAmJiAhJC5pc0Z1bGxTY3JlZW4oKSApIHtcbiAgICAgICAgLy8gSXMgZnVsbFBhZ2UgYnV0IG5vdCBmdWxsU2NyZWVuXG4gICAgICAgIHRoaXMuc2V0RnVsbFBhZ2UoIGZhbHNlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRGdWxsU2NyZWVuKCAhdGhpcy5pc0Z1bGxQYWdlKCkgKTtcbiAgICB9XG4gICAgLy8gY29ycmVjdCBmb3Igbm8gbW91c2VvdXQgZXZlbnQgb24gY2hhbmdlXG4gICAgaWYgKCB0aGlzLmJ1dHRvbnMgKSB7XG4gICAgICAgIHRoaXMuYnV0dG9ucy5lbXVsYXRlRXhpdCgpO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxQYWdlQnV0dG9uLmVsZW1lbnQuZm9jdXMoKTtcbiAgICBpZiAoIHRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgIHRoaXMudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBOb3RlOiBUaGUgY3VycmVudCByb3RhdGlvbiBmZWF0dXJlIGlzIGxpbWl0ZWQgdG8gOTAgZGVncmVlIHR1cm5zLlxuICovXG5mdW5jdGlvbiBvblJvdGF0ZUxlZnQoKSB7XG4gICAgaWYgKCB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICB2YXIgY3VyclJvdGF0aW9uID0gdGhpcy52aWV3cG9ydC5nZXRSb3RhdGlvbigpO1xuICAgICAgICBpZiAoY3VyclJvdGF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICBjdXJyUm90YXRpb24gPSAyNzA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyUm90YXRpb24gLT0gOTA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRSb3RhdGlvbihjdXJyUm90YXRpb24pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBOb3RlOiBUaGUgY3VycmVudCByb3RhdGlvbiBmZWF0dXJlIGlzIGxpbWl0ZWQgdG8gOTAgZGVncmVlIHR1cm5zLlxuICovXG5mdW5jdGlvbiBvblJvdGF0ZVJpZ2h0KCkge1xuICAgIGlmICggdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgdmFyIGN1cnJSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQuZ2V0Um90YXRpb24oKTtcbiAgICAgICAgaWYgKGN1cnJSb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICAgICAgICBjdXJyUm90YXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyclJvdGF0aW9uICs9IDkwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Um90YXRpb24oY3VyclJvdGF0aW9uKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gb25QcmV2aW91cygpe1xuICAgIHZhciBwcmV2aW91cyA9IHRoaXMuX3NlcXVlbmNlSW5kZXggLSAxO1xuICAgIGlmKHRoaXMubmF2UHJldk5leHRXcmFwICYmIHByZXZpb3VzIDwgMCl7XG4gICAgICAgIHByZXZpb3VzICs9IHRoaXMudGlsZVNvdXJjZXMubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLmdvVG9QYWdlKCBwcmV2aW91cyApO1xufVxuXG5cbmZ1bmN0aW9uIG9uTmV4dCgpe1xuICAgIHZhciBuZXh0ID0gdGhpcy5fc2VxdWVuY2VJbmRleCArIDE7XG4gICAgaWYodGhpcy5uYXZQcmV2TmV4dFdyYXAgJiYgbmV4dCA+PSB0aGlzLnRpbGVTb3VyY2VzLmxlbmd0aCl7XG4gICAgICAgIG5leHQgPSAwO1xuICAgIH1cbiAgICB0aGlzLmdvVG9QYWdlKCBuZXh0ICk7XG59XG5cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBOYXZpZ2F0b3JcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogQGNsYXNzIE5hdmlnYXRvclxuICogQGNsYXNzZGVzYyBUaGUgTmF2aWdhdG9yIHByb3ZpZGVzIGEgc21hbGwgdmlldyBvZiB0aGUgY3VycmVudCBpbWFnZSBhcyBmaXhlZFxuICogd2hpbGUgcmVwcmVzZW50aW5nIHRoZSB2aWV3cG9ydCBhcyBhIG1vdmluZyBib3ggc2VydmluZyBhcyBhIGZyYW1lXG4gKiBvZiByZWZlcmVuY2UgaW4gdGhlIGxhcmdlciB2aWV3cG9ydCBhcyB0byB3aGljaCBwb3J0aW9uIG9mIHRoZSBpbWFnZVxuICogaXMgY3VycmVudGx5IGJlaW5nIGV4YW1pbmVkLiAgVGhlIG5hdmlnYXRvcidzIHZpZXdwb3J0IGNhbiBiZSBpbnRlcmFjdGVkXG4gKiB3aXRoIHVzaW5nIHRoZSBrZXlib2FyZCBvciB0aGUgbW91c2UuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLkV2ZW50U291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG4kLk5hdmlnYXRvciA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG5cbiAgICB2YXIgdmlld2VyICAgICAgPSBvcHRpb25zLnZpZXdlcixcbiAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICB2aWV3ZXJTaXplLFxuICAgICAgICBuYXZpZ2F0b3JTaXplO1xuXG4gICAgLy9XZSBtYXkgbmVlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudCBhbmQgaWQgaWYgdGhleSBkaWQgbm90XG4gICAgLy9wcm92aWRlIHRoZSBpZCBmb3IgdGhlIGV4aXN0aW5nIGVsZW1lbnRcbiAgICBpZiggIW9wdGlvbnMuaWQgKXtcbiAgICAgICAgb3B0aW9ucy5pZCAgICAgICAgICAgICAgPSAnbmF2aWdhdG9yLScgKyAkLm5vdygpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgICAgICAgICAgICA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG4gICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnMgID0ge1xuICAgICAgICAgICAgYW5jaG9yOiAgICAgICAgICAgJC5Db250cm9sQW5jaG9yLlRPUF9SSUdIVCxcbiAgICAgICAgICAgIGF0dGFjaFRvVmlld2VyOiAgIHRydWUsXG4gICAgICAgICAgICBhdXRvRmFkZTogICAgICAgICBvcHRpb25zLmF1dG9GYWRlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIG9wdGlvbnMucG9zaXRpb24gKXtcbiAgICAgICAgICAgIGlmKCAnQk9UVE9NX1JJR0hUJyA9PSBvcHRpb25zLnBvc2l0aW9uICl7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmFuY2hvciA9ICQuQ29udHJvbEFuY2hvci5CT1RUT01fUklHSFQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYoICdCT1RUT01fTEVGVCcgPT0gb3B0aW9ucy5wb3NpdGlvbiApe1xuICAgICAgICAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucy5hbmNob3IgPSAkLkNvbnRyb2xBbmNob3IuQk9UVE9NX0xFRlQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYoICdUT1BfUklHSFQnID09IG9wdGlvbnMucG9zaXRpb24gKXtcbiAgICAgICAgICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnMuYW5jaG9yID0gJC5Db250cm9sQW5jaG9yLlRPUF9SSUdIVDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggJ1RPUF9MRUZUJyA9PSBvcHRpb25zLnBvc2l0aW9uICl7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmFuY2hvciA9ICQuQ29udHJvbEFuY2hvci5UT1BfTEVGVDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggJ0FCU09MVVRFJyA9PSBvcHRpb25zLnBvc2l0aW9uICl7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmFuY2hvciA9ICQuQ29udHJvbEFuY2hvci5BQlNPTFVURTtcbiAgICAgICAgICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnMudG9wID0gb3B0aW9ucy50b3A7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmxlZnQgPSBvcHRpb25zLmxlZnQ7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucy53aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAgICAgICAgICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG9wdGlvbnMuaWQgKTtcbiAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9ucyAgPSB7XG4gICAgICAgICAgICBhbmNob3I6ICAgICAgICAgICAkLkNvbnRyb2xBbmNob3IuTk9ORSxcbiAgICAgICAgICAgIGF0dGFjaFRvVmlld2VyOiAgIGZhbHNlLFxuICAgICAgICAgICAgYXV0b0ZhZGU6ICAgICAgICAgZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50LmlkICAgICAgICAgPSBvcHRpb25zLmlkO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgICs9ICcgbmF2aWdhdG9yJztcblxuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCggdHJ1ZSwge1xuICAgICAgICBzaXplUmF0aW86ICAgICAkLkRFRkFVTFRfU0VUVElOR1MubmF2aWdhdG9yU2l6ZVJhdGlvXG4gICAgfSwgb3B0aW9ucywge1xuICAgICAgICBlbGVtZW50OiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgIHRhYkluZGV4OiAgICAgICAgICAgICAgIC0xLCAvLyBObyBrZXlib2FyZCBuYXZpZ2F0aW9uLCBvbWl0IGZyb20gdGFiIG9yZGVyXG4gICAgICAgIC8vVGhlc2UgbmVlZCB0byBiZSBvdmVycmlkZGVuIHRvIHByZXZlbnQgcmVjdXJzaW9uIHNpbmNlXG4gICAgICAgIC8vdGhlIG5hdmlnYXRvciBpcyBhIHZpZXdlciBhbmQgYSB2aWV3ZXIgaGFzIGEgbmF2aWdhdG9yXG4gICAgICAgIHNob3dOYXZpZ2F0b3I6ICAgICAgICAgIGZhbHNlLFxuICAgICAgICBtb3VzZU5hdkVuYWJsZWQ6ICAgICAgICBmYWxzZSxcbiAgICAgICAgc2hvd05hdmlnYXRpb25Db250cm9sOiAgZmFsc2UsXG4gICAgICAgIHNob3dTZXF1ZW5jZUNvbnRyb2w6ICAgIGZhbHNlLFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6ICAgICAgICB0cnVlLFxuICAgICAgICBibGVuZFRpbWU6ICAgICAgICAgICAgICAwLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAgICAgICAgICAwLFxuICAgICAgICBhdXRvUmVzaXplOiAgICAgICAgICAgICBvcHRpb25zLmF1dG9SZXNpemUsXG4gICAgICAgIC8vIHByZXZlbnQgcmVzaXppbmcgdGhlIG5hdmlnYXRvciBmcm9tIGFkZGluZyB1bndhbnRlZCBzcGFjZSBhcm91bmQgdGhlIGltYWdlXG4gICAgICAgIG1pblpvb21JbWFnZVJhdGlvOiAgICAgIDEuMFxuICAgIH0pO1xuXG4gICAgb3B0aW9ucy5taW5QaXhlbFJhdGlvID0gdGhpcy5taW5QaXhlbFJhdGlvID0gdmlld2VyLm1pblBpeGVsUmF0aW87XG5cbiAgICAkLnNldEVsZW1lbnRUb3VjaEFjdGlvbk5vbmUoIHRoaXMuZWxlbWVudCApO1xuXG4gICAgdGhpcy5ib3JkZXJXaWR0aCA9IDI7XG4gICAgLy9BdCBzb21lIGJyb3dzZXIgbWFnbmlmaWNhdGlvbiBsZXZlbHMgdGhlIGRpc3BsYXkgcmVnaW9ucyBsaW5lcyB1cCBjb3JyZWN0bHksIGJ1dCBhdCBzb21lIHRoZXJlIGFwcGVhcnMgdG9cbiAgICAvL2JlIGEgb25lIHBpeGVsIGdhcC5cbiAgICB0aGlzLmZ1ZGdlID0gbmV3ICQuUG9pbnQoMSwgMSk7XG4gICAgdGhpcy50b3RhbEJvcmRlcldpZHRocyA9IG5ldyAkLlBvaW50KHRoaXMuYm9yZGVyV2lkdGgqMiwgdGhpcy5ib3JkZXJXaWR0aCoyKS5taW51cyh0aGlzLmZ1ZGdlKTtcblxuXG4gICAgaWYgKCBvcHRpb25zLmNvbnRyb2xPcHRpb25zLmFuY2hvciAhPSAkLkNvbnRyb2xBbmNob3IuTk9ORSApIHtcbiAgICAgICAgKGZ1bmN0aW9uKCBzdHlsZSwgYm9yZGVyV2lkdGggKXtcbiAgICAgICAgICAgIHN0eWxlLm1hcmdpbiAgICAgICAgPSAnMHB4JztcbiAgICAgICAgICAgIHN0eWxlLmJvcmRlciAgICAgICAgPSBib3JkZXJXaWR0aCArICdweCBzb2xpZCAjNTU1JztcbiAgICAgICAgICAgIHN0eWxlLnBhZGRpbmcgICAgICAgPSAnMHB4JztcbiAgICAgICAgICAgIHN0eWxlLmJhY2tncm91bmQgICAgPSAnIzAwMCc7XG4gICAgICAgICAgICBzdHlsZS5vcGFjaXR5ICAgICAgID0gMC44O1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgICAgICA9ICdoaWRkZW4nO1xuICAgICAgICB9KCB0aGlzLmVsZW1lbnQuc3R5bGUsIHRoaXMuYm9yZGVyV2lkdGgpKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BsYXlSZWdpb24gICAgICAgICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiZGl2XCIgKTtcbiAgICB0aGlzLmRpc3BsYXlSZWdpb24uaWQgICAgICAgID0gdGhpcy5lbGVtZW50LmlkICsgJy1kaXNwbGF5cmVnaW9uJztcbiAgICB0aGlzLmRpc3BsYXlSZWdpb24uY2xhc3NOYW1lID0gJ2Rpc3BsYXlyZWdpb24nO1xuXG4gICAgKGZ1bmN0aW9uKCBzdHlsZSwgYm9yZGVyV2lkdGggKXtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gICAgICA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIHN0eWxlLnRvcCAgICAgICAgICAgPSAnMHB4JztcbiAgICAgICAgc3R5bGUubGVmdCAgICAgICAgICA9ICcwcHgnO1xuICAgICAgICBzdHlsZS5mb250U2l6ZSAgICAgID0gJzBweCc7XG4gICAgICAgIHN0eWxlLm92ZXJmbG93ICAgICAgPSAnaGlkZGVuJztcbiAgICAgICAgc3R5bGUuYm9yZGVyICAgICAgICA9IGJvcmRlcldpZHRoICsgJ3B4IHNvbGlkICM5MDAnO1xuICAgICAgICBzdHlsZS5tYXJnaW4gICAgICAgID0gJzBweCc7XG4gICAgICAgIHN0eWxlLnBhZGRpbmcgICAgICAgPSAnMHB4JztcbiAgICAgICAgLy9UT0RPOiBJRSBkb2VzbnQgbGlrZSB0aGlzIHByb3BlcnR5IGJlaW5nIHNldFxuICAgICAgICAvL3RyeXsgc3R5bGUub3V0bGluZSAgPSAnMnB4IGF1dG8gIzkwOSc7IH1jYXRjaChlKXsvKmlnbm9yZSovfVxuXG4gICAgICAgIHN0eWxlLmJhY2tncm91bmQgICAgPSAndHJhbnNwYXJlbnQnO1xuXG4gICAgICAgIC8vIFdlIHVzZSBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiBvbiB0aGUgc3RhdGVtZW50IGJlbG93LCBiZWNhdXNlIGZsb2F0IGlzIGEga2V5d29yZC5cbiAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHRoZSBHb29nbGUgQ2xvc3VyZSBjb21waWxlciwgaWYgbm90aGluZyBlbHNlLlxuICAgICAgICAvKmpzaGludCBzdWI6dHJ1ZSAqL1xuICAgICAgICBzdHlsZVsnZmxvYXQnXSAgICAgID0gJ2xlZnQnOyAvL1dlYmtpdFxuXG4gICAgICAgIHN0eWxlLmNzc0Zsb2F0ICAgICAgPSAnbGVmdCc7IC8vRmlyZWZveFxuICAgICAgICBzdHlsZS5zdHlsZUZsb2F0ICAgID0gJ2xlZnQnOyAvL0lFXG4gICAgICAgIHN0eWxlLnpJbmRleCAgICAgICAgPSA5OTk5OTk5OTk7XG4gICAgICAgIHN0eWxlLmN1cnNvciAgICAgICAgPSAnZGVmYXVsdCc7XG4gICAgfSggdGhpcy5kaXNwbGF5UmVnaW9uLnN0eWxlLCB0aGlzLmJvcmRlcldpZHRoICkpO1xuXG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uQ29udGFpbmVyID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uQ29udGFpbmVyLmlkID0gdGhpcy5lbGVtZW50LmlkICsgJy1kaXNwbGF5cmVnaW9uY29udGFpbmVyJztcbiAgICB0aGlzLmRpc3BsYXlSZWdpb25Db250YWluZXIuY2xhc3NOYW1lID0gXCJkaXNwbGF5cmVnaW9uY29udGFpbmVyXCI7XG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uQ29udGFpbmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgdGhpcy5kaXNwbGF5UmVnaW9uQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuXG4gICAgdmlld2VyLmFkZENvbnRyb2woXG4gICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucy5jb250cm9sT3B0aW9uc1xuICAgICk7XG5cbiAgICB0aGlzLl9yZXNpemVXaXRoVmlld2VyID0gb3B0aW9ucy5jb250cm9sT3B0aW9ucy5hbmNob3IgIT0gJC5Db250cm9sQW5jaG9yLkFCU09MVVRFICYmXG4gICAgICAgIG9wdGlvbnMuY29udHJvbE9wdGlvbnMuYW5jaG9yICE9ICQuQ29udHJvbEFuY2hvci5OT05FO1xuXG4gICAgaWYgKCB0aGlzLl9yZXNpemVXaXRoVmlld2VyICkge1xuICAgICAgICBpZiAoIG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdHlwZW9mICggb3B0aW9ucy5oZWlnaHQgKSAgPT0gXCJudW1iZXJcIiA/ICggb3B0aW9ucy5oZWlnaHQgKyAncHgnICkgOiBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCAgPSB0eXBlb2YgKCBvcHRpb25zLndpZHRoICkgID09IFwibnVtYmVyXCIgPyAoIG9wdGlvbnMud2lkdGggKyAncHgnICkgOiBvcHRpb25zLndpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlld2VyU2l6ZSA9ICQuZ2V0RWxlbWVudFNpemUoIHZpZXdlci5lbGVtZW50ICk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gTWF0aC5yb3VuZCggdmlld2VyU2l6ZS55ICogb3B0aW9ucy5zaXplUmF0aW8gKSArICdweCc7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggID0gTWF0aC5yb3VuZCggdmlld2VyU2l6ZS54ICogb3B0aW9ucy5zaXplUmF0aW8gKSArICdweCc7XG4gICAgICAgICAgICB0aGlzLm9sZFZpZXdlclNpemUgPSB2aWV3ZXJTaXplO1xuICAgICAgICB9XG4gICAgICAgIG5hdmlnYXRvclNpemUgPSAkLmdldEVsZW1lbnRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgICAgICAgdGhpcy5lbGVtZW50QXJlYSA9IG5hdmlnYXRvclNpemUueCAqIG5hdmlnYXRvclNpemUueTtcbiAgICB9XG5cbiAgICB0aGlzLm9sZENvbnRhaW5lclNpemUgPSBuZXcgJC5Qb2ludCggMCwgMCApO1xuXG4gICAgJC5WaWV3ZXIuYXBwbHkoIHRoaXMsIFsgb3B0aW9ucyBdICk7XG5cbiAgICB0aGlzLmRpc3BsYXlSZWdpb25Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kaXNwbGF5UmVnaW9uKTtcbiAgICB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpWzBdLmFwcGVuZENoaWxkKHRoaXMuZGlzcGxheVJlZ2lvbkNvbnRhaW5lcik7XG5cbiAgICBmdW5jdGlvbiByb3RhdGUoZGVncmVlcykge1xuICAgICAgICBfc2V0VHJhbnNmb3JtUm90YXRlKF90aGlzLmRpc3BsYXlSZWdpb25Db250YWluZXIsIGRlZ3JlZXMpO1xuICAgICAgICBfc2V0VHJhbnNmb3JtUm90YXRlKF90aGlzLmRpc3BsYXlSZWdpb24sIC1kZWdyZWVzKTtcbiAgICAgICAgX3RoaXMudmlld3BvcnQuc2V0Um90YXRpb24oZGVncmVlcyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5hdmlnYXRvclJvdGF0ZSkge1xuICAgICAgICB2YXIgZGVncmVlcyA9IG9wdGlvbnMudmlld2VyLnZpZXdwb3J0ID9cbiAgICAgICAgICAgIG9wdGlvbnMudmlld2VyLnZpZXdwb3J0LmdldFJvdGF0aW9uKCkgOlxuICAgICAgICAgICAgb3B0aW9ucy52aWV3ZXIuZGVncmVlcyB8fCAwO1xuICAgICAgICByb3RhdGUoZGVncmVlcyk7XG4gICAgICAgIG9wdGlvbnMudmlld2VyLmFkZEhhbmRsZXIoXCJyb3RhdGVcIiwgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHJvdGF0ZShhcmdzLmRlZ3JlZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIGJhc2UgY2xhc3MnIChWaWV3ZXIncykgaW5uZXJUcmFja2VyIGFuZCByZXBsYWNlIGl0IHdpdGggb3VyIG93blxuICAgIHRoaXMuaW5uZXJUcmFja2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlubmVyVHJhY2tlciA9IG5ldyAkLk1vdXNlVHJhY2tlcih7XG4gICAgICAgIGVsZW1lbnQ6ICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICBkcmFnSGFuZGxlcjogICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzRHJhZyApLFxuICAgICAgICBjbGlja0hhbmRsZXI6ICAgICQuZGVsZWdhdGUoIHRoaXMsIG9uQ2FudmFzQ2xpY2sgKSxcbiAgICAgICAgcmVsZWFzZUhhbmRsZXI6ICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc1JlbGVhc2UgKSxcbiAgICAgICAgc2Nyb2xsSGFuZGxlcjogICAkLmRlbGVnYXRlKCB0aGlzLCBvbkNhbnZhc1Njcm9sbCApXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZEhhbmRsZXIoXCJyZXNldC1zaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX3RoaXMudmlld3BvcnQpIHtcbiAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0LmdvSG9tZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmlld2VyLndvcmxkLmFkZEhhbmRsZXIoXCJpdGVtLWluZGV4LWNoYW5nZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgaXRlbSA9IF90aGlzLndvcmxkLmdldEl0ZW1BdChldmVudC5wcmV2aW91c0luZGV4KTtcbiAgICAgICAgX3RoaXMud29ybGQuc2V0SXRlbUluZGV4KGl0ZW0sIGV2ZW50Lm5ld0luZGV4KTtcbiAgICB9KTtcblxuICAgIHZpZXdlci53b3JsZC5hZGRIYW5kbGVyKFwicmVtb3ZlLWl0ZW1cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHRoZWlySXRlbSA9IGV2ZW50Lml0ZW07XG4gICAgICAgIHZhciBteUl0ZW0gPSBfdGhpcy5fZ2V0TWF0Y2hpbmdJdGVtKHRoZWlySXRlbSk7XG4gICAgICAgIGlmIChteUl0ZW0pIHtcbiAgICAgICAgICAgIF90aGlzLndvcmxkLnJlbW92ZUl0ZW0obXlJdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGUodmlld2VyLnZpZXdwb3J0KTtcbn07XG5cbiQuZXh0ZW5kKCAkLk5hdmlnYXRvci5wcm90b3R5cGUsICQuRXZlbnRTb3VyY2UucHJvdG90eXBlLCAkLlZpZXdlci5wcm90b3R5cGUsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5OYXZpZ2F0b3IucHJvdG90eXBlICove1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBub3RpZnkgdGhlIG5hdmlnYXRvciB3aGVuIGl0cyBzaXplIGhhcyBjaGFuZ2VkLlxuICAgICAqIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30ubmF2aWdhdG9yQXV0b1Jlc2l6ZSBpcyBzZXQgdG8gZmFsc2UgYW5kIHRoZSBuYXZpZ2F0b3IgaXMgcmVzaXphYmxlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCB0aGlzLnZpZXdwb3J0ICkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclNpemUgPSBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoID09PSAwID8gMSA6IHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCA9PT0gMCA/IDEgOiB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCAhY29udGFpbmVyU2l6ZS5lcXVhbHMoIHRoaXMub2xkQ29udGFpbmVyU2l6ZSApICkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQucmVzaXplKCBjb250YWluZXJTaXplLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5nb0hvbWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRDb250YWluZXJTaXplID0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdlci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMud29ybGQuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdXBkYXRlIHRoZSBuYXZpZ2F0b3IgbWluaW1hcCdzIHZpZXdwb3J0IHJlY3RhbmdsZSB3aGVuIGEgY2hhbmdlIGluIHRoZSB2aWV3ZXIncyB2aWV3cG9ydCBvY2N1cnMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBUaGUgdmlld3BvcnQgdGhpcyBuYXZpZ2F0b3IgaXMgdHJhY2tpbmcuXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbiggdmlld3BvcnQgKSB7XG5cbiAgICAgICAgdmFyIHZpZXdlclNpemUsXG4gICAgICAgICAgICBuZXdXaWR0aCxcbiAgICAgICAgICAgIG5ld0hlaWdodCxcbiAgICAgICAgICAgIGJvdW5kcyxcbiAgICAgICAgICAgIHRvcGxlZnQsXG4gICAgICAgICAgICBib3R0b21yaWdodDtcblxuICAgICAgICB2aWV3ZXJTaXplID0gJC5nZXRFbGVtZW50U2l6ZSggdGhpcy52aWV3ZXIuZWxlbWVudCApO1xuICAgICAgICBpZiAoIHRoaXMuX3Jlc2l6ZVdpdGhWaWV3ZXIgJiYgdmlld2VyU2l6ZS54ICYmIHZpZXdlclNpemUueSAmJiAhdmlld2VyU2l6ZS5lcXVhbHMoIHRoaXMub2xkVmlld2VyU2l6ZSApICkge1xuICAgICAgICAgICAgdGhpcy5vbGRWaWV3ZXJTaXplID0gdmlld2VyU2l6ZTtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLm1haW50YWluU2l6ZVJhdGlvIHx8ICF0aGlzLmVsZW1lbnRBcmVhKSB7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggID0gdmlld2VyU2l6ZS54ICogdGhpcy5zaXplUmF0aW87XG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdmlld2VyU2l6ZS55ICogdGhpcy5zaXplUmF0aW87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gTWF0aC5zcXJ0KHRoaXMuZWxlbWVudEFyZWEgKiAodmlld2VyU2l6ZS54IC8gdmlld2VyU2l6ZS55KSk7XG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdGhpcy5lbGVtZW50QXJlYSAvIG5ld1dpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggID0gTWF0aC5yb3VuZCggbmV3V2lkdGggKSArICdweCc7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gTWF0aC5yb3VuZCggbmV3SGVpZ2h0ICkgKyAncHgnO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWxlbWVudEFyZWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRBcmVhID0gbmV3V2lkdGggKiBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHRoaXMudmlld3BvcnQpIHtcbiAgICAgICAgICAgIGJvdW5kcyAgICAgID0gdmlld3BvcnQuZ2V0Qm91bmRzTm9Sb3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICB0b3BsZWZ0ICAgICA9IHRoaXMudmlld3BvcnQucGl4ZWxGcm9tUG9pbnROb1JvdGF0ZShib3VuZHMuZ2V0VG9wTGVmdCgpLCBmYWxzZSk7XG4gICAgICAgICAgICBib3R0b21yaWdodCA9IHRoaXMudmlld3BvcnQucGl4ZWxGcm9tUG9pbnROb1JvdGF0ZShib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgLm1pbnVzKCB0aGlzLnRvdGFsQm9yZGVyV2lkdGhzICk7XG5cbiAgICAgICAgICAgIC8vdXBkYXRlIHN0eWxlIGZvciBuYXZpZ2F0b3ItYm94XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmRpc3BsYXlSZWdpb24uc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gdGhpcy53b3JsZC5nZXRJdGVtQ291bnQoKSA/ICdibG9jaycgOiAnbm9uZSc7XG5cbiAgICAgICAgICAgIHN0eWxlLnRvcCAgICA9IE1hdGgucm91bmQoIHRvcGxlZnQueSApICsgJ3B4JztcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgICA9IE1hdGgucm91bmQoIHRvcGxlZnQueCApICsgJ3B4JztcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5hYnMoIHRvcGxlZnQueCAtIGJvdHRvbXJpZ2h0LnggKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyggdG9wbGVmdC55IC0gYm90dG9tcmlnaHQueSApO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG5vbi1uZWdhdGl2ZSBzbyBJRSBkb2Vzbid0IHRocm93XG4gICAgICAgICAgICBzdHlsZS53aWR0aCAgPSBNYXRoLnJvdW5kKCBNYXRoLm1heCggd2lkdGgsIDAgKSApICsgJ3B4JztcbiAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IE1hdGgucm91bmQoIE1hdGgubWF4KCBoZWlnaHQsIDAgKSApICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIG92ZXJyaWRlcyBWaWV3ZXIuYWRkVGlsZWRJbWFnZVxuICAgIGFkZFRpbGVkSW1hZ2U6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBvcHRpb25zLm9yaWdpbmFsVGlsZWRJbWFnZTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMub3JpZ2luYWw7XG5cbiAgICAgICAgdmFyIG9wdGlvbnNDbG9uZSA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBteUl0ZW0gPSBldmVudC5pdGVtO1xuICAgICAgICAgICAgICAgIG15SXRlbS5fb3JpZ2luYWxGb3JOYXZpZ2F0b3IgPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWF0Y2hCb3VuZHMobXlJdGVtLCBvcmlnaW5hbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5hZGRIYW5kbGVyKCdib3VuZHMtY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXRjaEJvdW5kcyhteUl0ZW0sIG9yaWdpbmFsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICQuVmlld2VyLnByb3RvdHlwZS5hZGRUaWxlZEltYWdlLmFwcGx5KHRoaXMsIFtvcHRpb25zQ2xvbmVdKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9nZXRNYXRjaGluZ0l0ZW06IGZ1bmN0aW9uKHRoZWlySXRlbSkge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLndvcmxkLmdldEl0ZW1Db3VudCgpO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy53b3JsZC5nZXRJdGVtQXQoaSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5fb3JpZ2luYWxGb3JOYXZpZ2F0b3IgPT09IHRoZWlySXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfbWF0Y2hCb3VuZHM6IGZ1bmN0aW9uKG15SXRlbSwgdGhlaXJJdGVtLCBpbW1lZGlhdGVseSkge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhlaXJJdGVtLmdldEJvdW5kcygpO1xuICAgICAgICBteUl0ZW0uc2V0UG9zaXRpb24oYm91bmRzLmdldFRvcExlZnQoKSwgaW1tZWRpYXRlbHkpO1xuICAgICAgICBteUl0ZW0uc2V0V2lkdGgoYm91bmRzLndpZHRoLCBpbW1lZGlhdGVseSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uQ2FudmFzQ2xpY2soIGV2ZW50ICkge1xuICAgIGlmICggZXZlbnQucXVpY2sgJiYgdGhpcy52aWV3ZXIudmlld3BvcnQgKSB7XG4gICAgICAgIHRoaXMudmlld2VyLnZpZXdwb3J0LnBhblRvKHRoaXMudmlld3BvcnQucG9pbnRGcm9tUGl4ZWwoZXZlbnQucG9zaXRpb24pKTtcbiAgICAgICAgdGhpcy52aWV3ZXIudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gb25DYW52YXNEcmFnKCBldmVudCApIHtcbiAgICBpZiAoIHRoaXMudmlld2VyLnZpZXdwb3J0ICkge1xuICAgICAgICBpZiggIXRoaXMucGFuSG9yaXpvbnRhbCApe1xuICAgICAgICAgICAgZXZlbnQuZGVsdGEueCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYoICF0aGlzLnBhblZlcnRpY2FsICl7XG4gICAgICAgICAgICBldmVudC5kZWx0YS55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdlci52aWV3cG9ydC5wYW5CeShcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzKFxuICAgICAgICAgICAgICAgIGV2ZW50LmRlbHRhXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uQ2FudmFzUmVsZWFzZSggZXZlbnQgKSB7XG4gICAgaWYgKCBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCAmJiB0aGlzLnZpZXdlci52aWV3cG9ydCApIHtcbiAgICAgICAgdGhpcy52aWV3ZXIudmlld3BvcnQuYXBwbHlDb25zdHJhaW50cygpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvbkNhbnZhc1Njcm9sbCggZXZlbnQgKSB7XG4gICAgLyoqXG4gICAgICogUmFpc2VkIHdoZW4gYSBzY3JvbGwgZXZlbnQgb2NjdXJzIG9uIHRoZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXIjbmF2aWdhdG9yfSBlbGVtZW50IChtb3VzZSB3aGVlbCwgdG91Y2ggcGluY2gsIGV0Yy4pLlxuICAgICAqXG4gICAgICogQGV2ZW50IG5hdmlnYXRvci1zY3JvbGxcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uTW91c2VUcmFja2VyfSB0cmFja2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIE1vdXNlVHJhY2tlciB3aGljaCBvcmlnaW5hdGVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHRyYWNrZWQgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsIC0gVGhlIHNjcm9sbCBkZWx0YSBmb3IgdGhlIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hpZnQgLSBUcnVlIGlmIHRoZSBzaGlmdCBrZXkgd2FzIHByZXNzZWQgZHVyaW5nIHRoaXMgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdlci5yYWlzZUV2ZW50KCAnbmF2aWdhdG9yLXNjcm9sbCcsIHtcbiAgICAgICAgdHJhY2tlcjogZXZlbnQuZXZlbnRTb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uOiBldmVudC5wb3NpdGlvbixcbiAgICAgICAgc2Nyb2xsOiBldmVudC5zY3JvbGwsXG4gICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudFxuICAgIH0pO1xuXG4gICAgLy9kb250IHNjcm9sbCB0aGUgcGFnZSB1cCBhbmQgZG93biBpZiB0aGUgdXNlciBpcyBzY3JvbGxpbmdcbiAgICAvL2luIHRoZSBuYXZpZ2F0b3JcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWVzXG4gICAgKi9cbmZ1bmN0aW9uIF9zZXRUcmFuc2Zvcm1Sb3RhdGUgKGVsZW1lbnQsIGRlZ3JlZXMpIHtcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgZGVncmVlcyArIFwiZGVnKVwiO1xuICAgIGVsZW1lbnQuc3R5bGUubW96VHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyBkZWdyZWVzICsgXCJkZWcpXCI7XG4gICAgZWxlbWVudC5zdHlsZS5tc1RyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgZGVncmVlcyArIFwiZGVnKVwiO1xuICAgIGVsZW1lbnQuc3R5bGUub1RyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgZGVncmVlcyArIFwiZGVnKVwiO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyBkZWdyZWVzICsgXCJkZWcpXCI7XG59XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gZ2V0U3RyaW5nL3NldFN0cmluZ1xuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLy9UT0RPOiBJIGd1ZXNzIHRoaXMgaXMgd2hlcmUgdGhlIGkxOG4gbmVlZHMgdG8gYmUgcmVpbXBsZW1lbnRlZC4gIEknbGwgbG9va1xuLy8gICAgICBpbnRvIGV4aXN0aW5nIHBhdHRlcm5zIGZvciBpMThuIGluIGphdmFzY3JpcHQgYnV0IGkgdGhpbmsgdGhhdCBtaW1pY2tpbmdcbi8vICAgICAgcHl0aG9ucyBnZXR0ZXh0IG1pZ2h0IGJlIGEgcmVhc29uYWJsZSBhcHByb2FjaC5cbnZhciBJMThOID0ge1xuICAgIEVycm9yczoge1xuICAgICAgICBEemM6ICAgICAgICAgICAgXCJTb3JyeSwgd2UgZG9uJ3Qgc3VwcG9ydCBEZWVwIFpvb20gQ29sbGVjdGlvbnMhXCIsXG4gICAgICAgIER6aTogICAgICAgICAgICBcIkhtbSwgdGhpcyBkb2Vzbid0IGFwcGVhciB0byBiZSBhIHZhbGlkIERlZXAgWm9vbSBJbWFnZS5cIixcbiAgICAgICAgWG1sOiAgICAgICAgICAgIFwiSG1tLCB0aGlzIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgRGVlcCBab29tIEltYWdlLlwiLFxuICAgICAgICBJbWFnZUZvcm1hdDogICAgXCJTb3JyeSwgd2UgZG9uJ3Qgc3VwcG9ydCB7MH0tYmFzZWQgRGVlcCBab29tIEltYWdlcy5cIixcbiAgICAgICAgU2VjdXJpdHk6ICAgICAgIFwiSXQgbG9va3MgbGlrZSBhIHNlY3VyaXR5IHJlc3RyaWN0aW9uIHN0b3BwZWQgdXMgZnJvbSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxvYWRpbmcgdGhpcyBEZWVwIFpvb20gSW1hZ2UuXCIsXG4gICAgICAgIFN0YXR1czogICAgICAgICBcIlRoaXMgc3BhY2UgdW5pbnRlbnRpb25hbGx5IGxlZnQgYmxhbmsgKHswfSB7MX0pLlwiLFxuICAgICAgICBPcGVuRmFpbGVkOiAgICAgXCJVbmFibGUgdG8gb3BlbiB7MH06IHsxfVwiXG4gICAgfSxcblxuICAgIFRvb2x0aXBzOiB7XG4gICAgICAgIEZ1bGxQYWdlOiAgICAgICBcIlRvZ2dsZSBmdWxsIHBhZ2VcIixcbiAgICAgICAgSG9tZTogICAgICAgICAgIFwiR28gaG9tZVwiLFxuICAgICAgICBab29tSW46ICAgICAgICAgXCJab29tIGluXCIsXG4gICAgICAgIFpvb21PdXQ6ICAgICAgICBcIlpvb20gb3V0XCIsXG4gICAgICAgIE5leHRQYWdlOiAgICAgICBcIk5leHQgcGFnZVwiLFxuICAgICAgICBQcmV2aW91c1BhZ2U6ICAgXCJQcmV2aW91cyBwYWdlXCIsXG4gICAgICAgIFJvdGF0ZUxlZnQ6ICAgICBcIlJvdGF0ZSBsZWZ0XCIsXG4gICAgICAgIFJvdGF0ZVJpZ2h0OiAgICBcIlJvdGF0ZSByaWdodFwiXG4gICAgfVxufTtcblxuJC5leHRlbmQoICQsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbiAqL3tcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGdldFN0cmluZzogZnVuY3Rpb24oIHByb3AgKSB7XG5cbiAgICAgICAgdmFyIHByb3BzICAgPSBwcm9wLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBzdHJpbmcgID0gbnVsbCxcbiAgICAgICAgICAgIGFyZ3MgICAgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBjb250YWluZXIgPSBJMThOLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aC0xOyBpKysgKSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG5vdCBhIHN1YnByb3BlcnR5XG4gICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJbIHByb3BzWyBpIF0gXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgPSBjb250YWluZXJbIHByb3BzWyBpIF0gXTtcblxuICAgICAgICBpZiAoIHR5cGVvZiggc3RyaW5nICkgIT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICQuY29uc29sZS5kZWJ1ZyggXCJVbnRyYW5zbGF0ZWQgc291cmNlIHN0cmluZzpcIiwgcHJvcCApO1xuICAgICAgICAgICAgc3RyaW5nID0gXCJcIjsgLy8gRklYTUU6IHRoaXMgYnJlYWtzIGdldHRleHQoKS1zdHlsZSBjb252ZW50aW9uLCB3aGljaCB3b3VsZCByZXR1cm4gc291cmNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xce1xcZCtcXH0vZywgZnVuY3Rpb24oY2FwdHVyZSkge1xuICAgICAgICAgICAgdmFyIGkgPSBwYXJzZUludCggY2FwdHVyZS5tYXRjaCggL1xcZCsvICksIDEwICkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBhcmdzLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgYXJnc1sgaSBdIDpcbiAgICAgICAgICAgICAgICBcIlwiO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFN0cmluZzogZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXG4gICAgICAgIHZhciBwcm9wcyAgICAgPSBwcm9wLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBjb250YWluZXIgPSBJMThOLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aCAtIDE7IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggIWNvbnRhaW5lclsgcHJvcHNbIGkgXSBdICkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lclsgcHJvcHNbIGkgXSBdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJbIHByb3BzWyBpIF0gXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lclsgcHJvcHNbIGkgXSBdID0gdmFsdWU7XG4gICAgfVxuXG59KTtcblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgUG9pbnRcbiAqIEBjbGFzc2Rlc2MgQSBQb2ludCBpcyByZWFsbHkgdXNlZCBhcyBhIDItZGltZW5zaW9uYWwgdmVjdG9yLCBlcXVhbGx5IHVzZWZ1bCBmb3JcbiAqIHJlcHJlc2VudGluZyBhIHBvaW50IG9uIGEgcGxhbmUsIG9yIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIGEgcGxhbmVcbiAqIG5vdCByZXF1aXJpbmcgYW55IG90aGVyIGZyYW1lIG9mIHJlZmVyZW5jZS5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQHBhcmFtIHtOdW1iZXJ9IFt4XSBUaGUgdmVjdG9yIGNvbXBvbmVudCAneCcuIERlZmF1bHRzIHRvIHRoZSBvcmlnaW4gYXQgMC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbeV0gVGhlIHZlY3RvciBjb21wb25lbnQgJ3knLiBEZWZhdWx0cyB0byB0aGUgb3JpZ2luIGF0IDAuXG4gKi9cbiQuUG9pbnQgPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVjdG9yIGNvbXBvbmVudCAneCcuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB4XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uUG9pbnQjXG4gICAgICovXG4gICAgdGhpcy54ID0gdHlwZW9mICggeCApID09IFwibnVtYmVyXCIgPyB4IDogMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVjdG9yIGNvbXBvbmVudCAneScuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB5XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uUG9pbnQjXG4gICAgICovXG4gICAgdGhpcy55ID0gdHlwZW9mICggeSApID09IFwibnVtYmVyXCIgPyB5IDogMDtcbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5Qb2ludC5wcm90b3R5cGUgKi9cbiQuUG9pbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBhIGR1cGxpY2F0ZSBvZiB0aGlzIFBvaW50XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW5vdGhlciBQb2ludCB0byB0aGlzIHBvaW50IGFuZCByZXR1cm4gYSBuZXcgUG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gYWRkIHZlY3RvciBjb21wb25lbnRzLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBBIG5ldyBwb2ludCByZXByZXNlbnRpbmcgdGhlIHN1bSBvZiB0aGVcbiAgICAgKiAgdmVjdG9yIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBwbHVzOiBmdW5jdGlvbiggcG9pbnQgKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIHRoaXMueCArIHBvaW50LngsXG4gICAgICAgICAgICB0aGlzLnkgKyBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnN0cmFjdCBhbm90aGVyIFBvaW50IHRvIHRoaXMgcG9pbnQgYW5kIHJldHVybiBhIG5ldyBQb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byBzdWJzdHJhY3QgdmVjdG9yIGNvbXBvbmVudHMuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IEEgbmV3IHBvaW50IHJlcHJlc2VudGluZyB0aGUgc3Vic3RyYWN0aW9uIG9mIHRoZVxuICAgICAqICB2ZWN0b3IgY29tcG9uZW50c1xuICAgICAqL1xuICAgIG1pbnVzOiBmdW5jdGlvbiggcG9pbnQgKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIHRoaXMueCAtIHBvaW50LngsXG4gICAgICAgICAgICB0aGlzLnkgLSBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHRoaXMgcG9pbnQgYnkgYSBmYWN0b3IgYW5kIHJldHVybiBhIG5ldyBQb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmFjdG9yIFRoZSBmYWN0b3IgdG8gbXVsdGlwbHkgdmVjdG9yIGNvbXBvbmVudHMuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IEEgbmV3IHBvaW50IHJlcHJlc2VudGluZyB0aGUgbXVsdGlwbGljYXRpb25cbiAgICAgKiAgb2YgdGhlIHZlY3RvciBjb21wb25lbnRzIGJ5IHRoZSBmYWN0b3JcbiAgICAgKi9cbiAgICB0aW1lczogZnVuY3Rpb24oIGZhY3RvciApIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgdGhpcy54ICogZmFjdG9yLFxuICAgICAgICAgICAgdGhpcy55ICogZmFjdG9yXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0aGlzIHBvaW50IGJ5IGEgZmFjdG9yIGFuZCByZXR1cm4gYSBuZXcgUG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZhY3RvciBUaGUgZmFjdG9yIHRvIGRpdmlkZSB2ZWN0b3IgY29tcG9uZW50cy5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gQSBuZXcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBkaXZpc2lvbiBvZiB0aGVcbiAgICAgKiAgdmVjdG9yIGNvbXBvbmVudHMgYnkgdGhlIGZhY3RvclxuICAgICAqL1xuICAgIGRpdmlkZTogZnVuY3Rpb24oIGZhY3RvciApIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgdGhpcy54IC8gZmFjdG9yLFxuICAgICAgICAgICAgdGhpcy55IC8gZmFjdG9yXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG9wcG9zaXRlIG9mIHRoaXMgcG9pbnQgYW5kIHJldHVybiBhIG5ldyBQb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gQSBuZXcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBvcHBvc2l0ZSBvZiB0aGVcbiAgICAgKiAgdmVjdG9yIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBuZWdhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoIC10aGlzLngsIC10aGlzLnkgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIHBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHdpdGguXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIDIgcG9pbnRzXG4gICAgICovXG4gICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oIHBvaW50ICkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3coIHRoaXMueCAtIHBvaW50LngsIDIgKSArXG4gICAgICAgICAgICBNYXRoLnBvdyggdGhpcy55IC0gcG9pbnQueSwgMiApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCBjb29yZGluYXRlIG9mIHRoaXMgcG9pbnQgYW5kIHJldHVybiBhIG5ldyBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IEEgbmV3IHBvaW50IHdpdGggdGhlIGNvb3JkaW5hdGVzIGNvbXB1dGVkXG4gICAgICogYnkgdGhlIHNwZWNpZmllZCBmdW5jdGlvblxuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbiggZnVuYyApIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KCBmdW5jKCB0aGlzLnggKSwgZnVuYyggdGhpcy55ICkgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBwb2ludCBpcyBlcXVhbCB0byBhbm90aGVyIG9uZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byBjb21wYXJlIHRoaXMgcG9pbnQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVxdWFsczogZnVuY3Rpb24oIHBvaW50ICkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9pbnQgaW5zdGFuY2VvZiAkLlBvaW50XG4gICAgICAgICkgJiYgKFxuICAgICAgICAgICAgdGhpcy54ID09PSBwb2ludC54XG4gICAgICAgICkgJiYgKFxuICAgICAgICAgICAgdGhpcy55ID09PSBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIHBvaW50IGFyb3VuZCB0aGUgc3BlY2lmaWVkIHBpdm90XG4gICAgICogRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ0NjU5MzEvcm90YXRlLXJlY3RhbmdsZS1hcm91bmQtYS1wb2ludFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZXNzIHRvIHJvdGF0ZSBhcm91bmQgdGhlIHBpdm90LlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gW3Bpdm90PSgwLDApXSBQb2ludCBhcm91bmQgd2hpY2ggdG8gcm90YXRlLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBvcmlnaW4uXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9LiBBIG5ldyBwb2ludCByZXByZXNlbnRpbmcgdGhlIHBvaW50IHJvdGF0ZWQgYXJvdW5kIHRoZSBzcGVjaWZpZWQgcGl2b3RcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uIChkZWdyZWVzLCBwaXZvdCkge1xuICAgICAgICBwaXZvdCA9IHBpdm90IHx8IG5ldyAkLlBvaW50KDAsIDApO1xuICAgICAgICB2YXIgY29zO1xuICAgICAgICB2YXIgc2luO1xuICAgICAgICAvLyBBdm9pZCBmbG9hdCBjb21wdXRhdGlvbnMgd2hlbiBwb3NzaWJsZVxuICAgICAgICBpZiAoZGVncmVlcyAlIDkwID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGRlZ3JlZXMgJSAzNjA7XG4gICAgICAgICAgICBpZiAoZCA8IDApIHtcbiAgICAgICAgICAgICAgICBkICs9IDM2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY29zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgc2luID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgICAgICAgICAgY29zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2luID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBzaW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgICAgICAgICAgY29zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2luID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gZGVncmVlcyAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IGNvcyAqICh0aGlzLnggLSBwaXZvdC54KSAtIHNpbiAqICh0aGlzLnkgLSBwaXZvdC55KSArIHBpdm90Lng7XG4gICAgICAgIHZhciB5ID0gc2luICogKHRoaXMueCAtIHBpdm90LngpICsgY29zICogKHRoaXMueSAtIHBpdm90LnkpICsgcGl2b3QueTtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoaXMgcG9pbnQgdG8gYSBzdHJpbmcgaW4gdGhlIGZvcm1hdCAoeCx5KSB3aGVyZSB4IGFuZCB5IGFyZVxuICAgICAqIHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBvaW50LlxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgKE1hdGgucm91bmQodGhpcy54ICogMTAwKSAvIDEwMCkgKyBcIixcIiArIChNYXRoLnJvdW5kKHRoaXMueSAqIDEwMCkgLyAxMDApICsgXCIpXCI7XG4gICAgfVxufTtcblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBUaWxlU291cmNlXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG5cbi8qKlxuICogQGNsYXNzIFRpbGVTb3VyY2VcbiAqIEBjbGFzc2Rlc2MgVGhlIFRpbGVTb3VyY2UgY29udGFpbnMgdGhlIG1vc3QgYmFzaWMgaW1wbGVtZW50YXRpb24gcmVxdWlyZWQgdG8gY3JlYXRlIGFcbiAqIHNtb290aCB0cmFuc2l0aW9uIGJldHdlZW4gbGF5ZXJzIGluIGFuIGltYWdlIHB5cmFtaWQuIEl0IGhhcyBvbmx5IGEgc2luZ2xlIGtleVxuICogaW50ZXJmYWNlIHRoYXQgbXVzdCBiZSBpbXBsZW1lbnRlZCB0byBjb21wbGV0ZSBpdHMga2V5IGZ1bmN0aW9uYWxpdHk6XG4gKiAnZ2V0VGlsZVVybCcuICBJdCBhbHNvIGhhcyBzZXZlcmFsIG9wdGlvbmFsIGludGVyZmFjZXMgdGhhdCBjYW4gYmVcbiAqIGltcGxlbWVudGVkIGlmIGEgbmV3IFRpbGVTb3VyY2Ugd2lzaGVzIHRvIHN1cHBvcnQgY29uZmlndXJhdGlvbiB2aWEgYSBzaW1wbGVcbiAqIG9iamVjdCBvciBhcnJheSAoJ2NvbmZpZ3VyZScpIGFuZCBpZiB0aGUgdGlsZSBzb3VyY2Ugc3VwcG9ydHMgb3IgcmVxdWlyZXNcbiAqIGNvbmZpZ3VyYXRpb24gdmlhIHJldHJpZXZhbCBvZiBhIGRvY3VtZW50IG9uIHRoZSBuZXR3b3JrIGFsYSBBSkFYIG9yIEpTT05QLFxuICogKCdnZXRJbWFnZUluZm8nKS5cbiAqIDxici8+XG4gKiBCeSBkZWZhdWx0IHRoZSBpbWFnZSBweXJhbWlkIGlzIHNwbGl0IGludG8gTiBsYXllcnMgd2hlcmUgdGhlIGltYWdlJ3MgbG9uZ2VzdFxuICogc2lkZSBpbiBNIChpbiBwaXhlbHMpLCB3aGVyZSBOIGlzIHRoZSBzbWFsbGVzdCBpbnRlZ2VyIHdoaWNoIHNhdGlzZmllc1xuICogICAgICA8c3Ryb25nPjJeKE4rMSkgPj0gTTwvc3Ryb25nPi5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5FdmVudFNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgWW91IGNhbiBlaXRoZXIgc3BlY2lmeSBhIFVSTCwgb3IgbGl0ZXJhbGx5IGRlZmluZSB0aGUgVGlsZVNvdXJjZSAoYnkgc3BlY2lmeWluZ1xuICogICAgICB3aWR0aCwgaGVpZ2h0LCB0aWxlU2l6ZSwgdGlsZU92ZXJsYXAsIG1pbkxldmVsLCBhbmQgbWF4TGV2ZWwpLiBGb3IgdGhlIGZvcm1lcixcbiAqICAgICAgdGhlIGV4dGVuZGluZyBjbGFzcyBpcyBleHBlY3RlZCB0byBpbXBsZW1lbnQgJ2dldEltYWdlSW5mbycgYW5kICdjb25maWd1cmUnLlxuICogICAgICBGb3IgdGhlIGxhdHRlciwgdGhlIGNvbnN0cnVjdGlvbiBpcyBhc3N1bWVkIHRvIG9jY3VyIHRocm91Z2hcbiAqICAgICAgdGhlIGV4dGVuZGluZyBjbGFzc2VzIGltcGxlbWVudGF0aW9uIG9mICdjb25maWd1cmUnLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnVybF1cbiAqICAgICAgVGhlIFVSTCBmb3IgdGhlIGRhdGEgbmVjZXNzYXJ5IGZvciB0aGlzIFRpbGVTb3VyY2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5zdWNjZXNzXVxuICogICAgICBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgY3JlYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFqYXhXaXRoQ3JlZGVudGlhbHNdXG4gKiAgICAgIElmIHRoaXMgVGlsZVNvdXJjZSBuZWVkcyB0byBtYWtlIGFuIEFKQVggY2FsbCwgdGhpcyBzcGVjaWZpZXMgd2hldGhlciB0byBzZXRcbiAqICAgICAgdGhlIFhIUidzIHdpdGhDcmVkZW50aWFscyAoZm9yIGFjY2Vzc2luZyBzZWN1cmUgZGF0YSkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdXG4gKiAgICAgIFdpZHRoIG9mIHRoZSBzb3VyY2UgaW1hZ2UgYXQgbWF4IHJlc29sdXRpb24gaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF1cbiAqICAgICAgSGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW1hZ2UgYXQgbWF4IHJlc29sdXRpb24gaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbGVTaXplXVxuICogICAgICBUaGUgc2l6ZSBvZiB0aGUgdGlsZXMgdG8gYXNzdW1lZCB0byBtYWtlIHVwIGVhY2ggcHlyYW1pZCBsYXllciBpbiBwaXhlbHMuXG4gKiAgICAgIFRpbGUgc2l6ZSBkZXRlcm1pbmVzIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgaW1hZ2UgcHlyYW1pZCBtdXN0IGJlXG4gKiAgICAgIGRpdmlkZWQgaW50byBhIG1hdHJpeCBvZiBzbWFsbGVyIGltYWdlcy5cbiAqICAgICAgVXNlIG9wdGlvbnMudGlsZVdpZHRoIGFuZCBvcHRpb25zLnRpbGVIZWlnaHQgdG8gc3VwcG9ydCBub24tc3F1YXJlIHRpbGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbGVXaWR0aF1cbiAqICAgICAgVGhlIHdpZHRoIG9mIHRoZSB0aWxlcyB0byBhc3N1bWVkIHRvIG1ha2UgdXAgZWFjaCBweXJhbWlkIGxheWVyIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aWxlSGVpZ2h0XVxuICogICAgICBUaGUgaGVpZ2h0IG9mIHRoZSB0aWxlcyB0byBhc3N1bWVkIHRvIG1ha2UgdXAgZWFjaCBweXJhbWlkIGxheWVyIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aWxlT3ZlcmxhcF1cbiAqICAgICAgVGhlIG51bWJlciBvZiBwaXhlbHMgZWFjaCB0aWxlIGlzIGV4cGVjdGVkIHRvIG92ZXJsYXAgdG91Y2hpbmcgdGlsZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluTGV2ZWxdXG4gKiAgICAgIFRoZSBtaW5pbXVtIGxldmVsIHRvIGF0dGVtcHQgdG8gbG9hZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhMZXZlbF1cbiAqICAgICAgVGhlIG1heGltdW0gbGV2ZWwgdG8gYXR0ZW1wdCB0byBsb2FkLlxuICovXG4kLlRpbGVTb3VyY2UgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgdGlsZVNpemUsIHRpbGVPdmVybGFwLCBtaW5MZXZlbCwgbWF4TGV2ZWwgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpO1xuXG4gICAgaWYoICQuaXNQbGFpbk9iamVjdCggd2lkdGggKSApe1xuICAgICAgICBvcHRpb25zID0gd2lkdGg7XG4gICAgfWVsc2V7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB3aWR0aDogYXJnc1swXSxcbiAgICAgICAgICAgIGhlaWdodDogYXJnc1sxXSxcbiAgICAgICAgICAgIHRpbGVTaXplOiBhcmdzWzJdLFxuICAgICAgICAgICAgdGlsZU92ZXJsYXA6IGFyZ3NbM10sXG4gICAgICAgICAgICBtaW5MZXZlbDogYXJnc1s0XSxcbiAgICAgICAgICAgIG1heExldmVsOiBhcmdzWzVdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9UaWxlIHNvdXJjZXMgc3VwcGx5IHNvbWUgZXZlbnRzLCBuYW1lbHkgJ3JlYWR5JyB3aGVuIHRoZXkgbXVzdCBiZSBjb25maWd1cmVkXG4gICAgLy9ieSBhc3luY2hyb25vdXNseSBmZXRjaGluZyB0aGVpciBjb25maWd1cmF0aW9uIGRhdGEuXG4gICAgJC5FdmVudFNvdXJjZS5jYWxsKCB0aGlzICk7XG5cbiAgICAvL3dlIGFsbG93IG9wdGlvbnMgdG8gb3ZlcnJpZGUgYW55dGhpbmcgd2UgZG9udCB0cmVhdCBhc1xuICAgIC8vcmVxdWlyZWQgdmlhIGlkaW9tYXRpYyBvcHRpb25zIG9yIHdoaWNoIGlzIGZ1bmN0aW9uYWxseVxuICAgIC8vc2V0IGRlcGVuZGluZyBvbiB0aGUgc3RhdGUgb2YgdGhlIHJlYWRpbmVzcyBvZiB0aGlzIHRpbGVcbiAgICAvL3NvdXJjZVxuICAgICQuZXh0ZW5kKCB0cnVlLCB0aGlzLCBvcHRpb25zICk7XG5cbiAgICBpZiAoIXRoaXMuc3VjY2Vzcykge1xuICAgICAgICAvL0FueSBmdW5jdGlvbnMgdGhhdCBhcmUgcGFzc2VkIGFzIGFyZ3VtZW50cyBhcmUgYm91bmQgdG8gdGhlIHJlYWR5IGNhbGxiYWNrXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIGFyZ3VtZW50c1sgaSBdICkgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzID0gYXJndW1lbnRzWyBpIF07XG4gICAgICAgICAgICAgICAgLy9vbmx5IG9uZSBjYWxsYmFjayBwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhpcy5hZGRIYW5kbGVyKCAncmVhZHknLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgX3RoaXMuc3VjY2VzcyggZXZlbnQgKTtcbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJhdGlvIG9mIHdpZHRoIHRvIGhlaWdodFxuICAgICAqIEBtZW1iZXIge051bWJlcn0gYXNwZWN0UmF0aW9cbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlI1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFZlY3RvciBzdG9yaW5nIHggYW5kIHkgZGltZW5zaW9ucyAoIHdpZHRoIGFuZCBoZWlnaHQgcmVzcGVjdGl2ZWx5ICkuXG4gICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5Qb2ludH0gZGltZW5zaW9uc1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2UjXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhlIG92ZXJsYXAgaW4gcGl4ZWxzIGVhY2ggdGlsZSBzaGFyZXMgd2l0aCBpdHMgYWRqYWNlbnQgbmVpZ2hib3JzLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gdGlsZU92ZXJsYXBcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlI1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHB5cmFtaWQgbGV2ZWwgdGhpcyB0aWxlIHNvdXJjZSBzdXBwb3J0cyBvciBzaG91bGQgYXR0ZW1wdCB0byBsb2FkLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWluTGV2ZWxcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlI1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHB5cmFtaWQgbGV2ZWwgdGhpcyB0aWxlIHNvdXJjZSBzdXBwb3J0cyBvciBzaG91bGQgYXR0ZW1wdCB0byBsb2FkLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4TGV2ZWxcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlI1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVhZHlcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlI1xuICAgICAqL1xuXG4gICAgaWYoICdzdHJpbmcnID09ICQudHlwZSggYXJndW1lbnRzWyAwIF0gKSApe1xuICAgICAgICB0aGlzLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51cmwpIHtcbiAgICAgICAgLy9pbiBjYXNlIHRoZSBnZXRJbWFnZUluZm8gbWV0aG9kIGlzIG92ZXJyaWRlbiBhbmQvb3IgaW1wbGllcyBhblxuICAgICAgICAvL2FzeW5jIG1lY2hhbmlzbSBzZXQgc29tZSBzYWZlIGRlZmF1bHRzIGZpcnN0XG4gICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSAxO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMgID0gbmV3ICQuUG9pbnQoIDEwLCAxMCApO1xuICAgICAgICB0aGlzLl90aWxlV2lkdGggID0gMDtcbiAgICAgICAgdGhpcy5fdGlsZUhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMudGlsZU92ZXJsYXAgPSAwO1xuICAgICAgICB0aGlzLm1pbkxldmVsICAgID0gMDtcbiAgICAgICAgdGhpcy5tYXhMZXZlbCAgICA9IDA7XG4gICAgICAgIHRoaXMucmVhZHkgICAgICAgPSBmYWxzZTtcbiAgICAgICAgLy9jb25maWd1cmF0aW9uIHZpYSB1cmwgaW1wbGllcyB0aGUgZXh0ZW5kaW5nIGNsYXNzXG4gICAgICAgIC8vaW1wbGVtZW50cyBhbmQgJ2NvbmZpZ3VyZSdcbiAgICAgICAgdGhpcy5nZXRJbWFnZUluZm8oIHRoaXMudXJsICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vZXhwbGljaXQgY29uZmlndXJhdGlvbiB2aWEgcG9zaXRpb25hbCBhcmdzIGluIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vb3IgdGhlIG1vcmUgaWRpb21hdGljICdvcHRpb25zJyBvYmplY3RcbiAgICAgICAgdGhpcy5yZWFkeSAgICAgICA9IHRydWU7XG4gICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSAoIG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQgKSA/XG4gICAgICAgICAgICAoICBvcHRpb25zLndpZHRoIC8gb3B0aW9ucy5oZWlnaHQgKSA6IDE7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyAgPSBuZXcgJC5Qb2ludCggb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQgKTtcblxuICAgICAgICBpZiAoIHRoaXMudGlsZVNpemUgKXtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVXaWR0aCA9IHRoaXMuX3RpbGVIZWlnaHQgPSB0aGlzLnRpbGVTaXplO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudGlsZVNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiggdGhpcy50aWxlV2lkdGggKXtcbiAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHBhc3NlZCB0aWxlV2lkdGggaW4gb3B0aW9ucywgYnV0IHdlIHdhbnQgdG8gcmVuYW1lIGl0XG4gICAgICAgICAgICAgICAgLy8gd2l0aCBhIGxlYWRpbmcgdW5kZXJzY29yZSB0byBtYWtlIGNsZWFyIHRoYXQgaXQgaXMgbm90IHNhZmUgdG8gZGlyZWN0bHkgbW9kaWZ5IGl0XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlsZVdpZHRoID0gdGhpcy50aWxlV2lkdGg7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGlsZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlV2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdGhpcy50aWxlSGVpZ2h0ICl7XG4gICAgICAgICAgICAgICAgLy8gU2VlIG5vdGUgYWJvdmUgYWJvdXQgcmVuYW1pbmcgdGhpcy50aWxlV2lkdGhcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlSGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aWxlT3ZlcmxhcCA9IG9wdGlvbnMudGlsZU92ZXJsYXAgPyBvcHRpb25zLnRpbGVPdmVybGFwIDogMDtcbiAgICAgICAgdGhpcy5taW5MZXZlbCAgICA9IG9wdGlvbnMubWluTGV2ZWwgPyBvcHRpb25zLm1pbkxldmVsIDogMDtcbiAgICAgICAgdGhpcy5tYXhMZXZlbCAgICA9ICggdW5kZWZpbmVkICE9PSBvcHRpb25zLm1heExldmVsICYmIG51bGwgIT09IG9wdGlvbnMubWF4TGV2ZWwgKSA/XG4gICAgICAgICAgICBvcHRpb25zLm1heExldmVsIDogKFxuICAgICAgICAgICAgICAgICggb3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCApID8gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZyggTWF0aC5tYXgoIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0ICkgKSAvXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKCAyIClcbiAgICAgICAgICAgICAgICApIDogMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaWYoIHRoaXMuc3VjY2VzcyAmJiAkLmlzRnVuY3Rpb24oIHRoaXMuc3VjY2VzcyApICl7XG4gICAgICAgICAgICB0aGlzLnN1Y2Nlc3MoIHRoaXMgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZS5wcm90b3R5cGUgKi9cbiQuVGlsZVNvdXJjZS5wcm90b3R5cGUgPSB7XG5cbiAgICBnZXRUaWxlU2l6ZTogZnVuY3Rpb24oIGxldmVsICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIltUaWxlU291cmNlLmdldFRpbGVTaXplXSBpcyBkZXByZWNhdGVkLlwiICtcbiAgICAgICAgICAgIFwiVXNlIFRpbGVTb3VyY2UuZ2V0VGlsZVdpZHRoKCkgYW5kIFRpbGVTb3VyY2UuZ2V0VGlsZUhlaWdodCgpIGluc3RlYWRcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZVdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRpbGVXaWR0aCBmb3IgYSBnaXZlbiBsZXZlbC5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIGlmIHRpbGVXaWR0aCBjYW4gYmUgZGlmZmVyZW50IGF0IGRpZmZlcmVudCBsZXZlbHNcbiAgICAgKiAgIHN1Y2ggYXMgaW4gSUlJRlRpbGVTb3VyY2UuICBDb2RlIHNob3VsZCB1c2UgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZWFkaW5nXG4gICAgICogICBmcm9tIC5fdGlsZVdpZHRoIGRpcmVjdGx5LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqL1xuICAgIGdldFRpbGVXaWR0aDogZnVuY3Rpb24oIGxldmVsICkge1xuICAgICAgICBpZiAoIXRoaXMuX3RpbGVXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVNpemUobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlV2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGlsZUhlaWdodCBmb3IgYSBnaXZlbiBsZXZlbC5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIGlmIHRpbGVIZWlnaHQgY2FuIGJlIGRpZmZlcmVudCBhdCBkaWZmZXJlbnQgbGV2ZWxzXG4gICAgICogICBzdWNoIGFzIGluIElJSUZUaWxlU291cmNlLiAgQ29kZSBzaG91bGQgdXNlIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmVhZGluZ1xuICAgICAqICAgZnJvbSAuX3RpbGVIZWlnaHQgZGlyZWN0bHkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0VGlsZUhlaWdodDogZnVuY3Rpb24oIGxldmVsICkge1xuICAgICAgICBpZiAoIXRoaXMuX3RpbGVIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVTaXplKGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZUhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0TGV2ZWxTY2FsZTogZnVuY3Rpb24oIGxldmVsICkge1xuXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbnNlYWRyYWdvbi9vcGVuc2VhZHJhZ29uL2lzc3Vlcy8yMlxuICAgICAgICAvLyB3ZSB1c2UgdGhlIHRpbGVzb3VyY2VzIGltcGxlbWVudGF0aW9uIG9mIGdldExldmVsU2NhbGUgdG8gZ2VuZXJhdGVcbiAgICAgICAgLy8gYSBtZW1vaXplZCByZS1pbXBsZW1lbnRhdGlvblxuICAgICAgICB2YXIgbGV2ZWxTY2FsZUNhY2hlID0ge30sXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IoIGkgPSAwOyBpIDw9IHRoaXMubWF4TGV2ZWw7IGkrKyApe1xuICAgICAgICAgICAgbGV2ZWxTY2FsZUNhY2hlWyBpIF0gPSAxIC8gTWF0aC5wb3coMiwgdGhpcy5tYXhMZXZlbCAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0TGV2ZWxTY2FsZSA9IGZ1bmN0aW9uKCBfbGV2ZWwgKXtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbFNjYWxlQ2FjaGVbIF9sZXZlbCBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMZXZlbFNjYWxlKCBsZXZlbCApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXROdW1UaWxlczogZnVuY3Rpb24oIGxldmVsICkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldExldmVsU2NhbGUoIGxldmVsICksXG4gICAgICAgICAgICB4ID0gTWF0aC5jZWlsKCBzY2FsZSAqIHRoaXMuZGltZW5zaW9ucy54IC8gdGhpcy5nZXRUaWxlV2lkdGgobGV2ZWwpICksXG4gICAgICAgICAgICB5ID0gTWF0aC5jZWlsKCBzY2FsZSAqIHRoaXMuZGltZW5zaW9ucy55IC8gdGhpcy5nZXRUaWxlSGVpZ2h0KGxldmVsKSApO1xuXG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCggeCwgeSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbiggbGV2ZWwgKSB7XG4gICAgICAgIHZhciBpbWFnZVNpemVTY2FsZWQgPSB0aGlzLmRpbWVuc2lvbnMudGltZXMoIHRoaXMuZ2V0TGV2ZWxTY2FsZSggbGV2ZWwgKSApLFxuICAgICAgICAgICAgcnggPSAxLjAgLyBpbWFnZVNpemVTY2FsZWQueCxcbiAgICAgICAgICAgIHJ5ID0gMS4wIC8gaW1hZ2VTaXplU2NhbGVkLnk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHJ4LCByeSk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0Q2xvc2VzdExldmVsOiBmdW5jdGlvbiggcmVjdCApIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB0aWxlc1BlclNpZGUsXG4gICAgICAgICAgICB0aWxlcztcblxuICAgICAgICBmb3IoIGkgPSB0aGlzLm1pbkxldmVsOyBpIDwgdGhpcy5tYXhMZXZlbDsgaSsrICl7XG4gICAgICAgICAgICB0aWxlcyA9IHRoaXMuZ2V0TnVtVGlsZXMoIGkgKTtcbiAgICAgICAgICAgIHRpbGVzUGVyU2lkZSA9IG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKCByZWN0LnggLyB0aGlzLmdldFRpbGVXaWR0aChpKSApLFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKCByZWN0LnkgLyB0aGlzLmdldFRpbGVIZWlnaHQoaSkgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYoIHRpbGVzLnggKyAxID49IHRpbGVzUGVyU2lkZS54ICYmIHRpbGVzLnkgKyAxID49IHRpbGVzUGVyU2lkZS55ICl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KCAwLCBpIC0gMSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50XG4gICAgICovXG4gICAgZ2V0VGlsZUF0UG9pbnQ6IGZ1bmN0aW9uKCBsZXZlbCwgcG9pbnQgKSB7XG4gICAgICAgIHZhciBwaXhlbCA9IHBvaW50LnRpbWVzKCB0aGlzLmRpbWVuc2lvbnMueCApLnRpbWVzKCB0aGlzLmdldExldmVsU2NhbGUobGV2ZWwpICksXG4gICAgICAgICAgICB0eCA9IE1hdGguZmxvb3IoIHBpeGVsLnggLyB0aGlzLmdldFRpbGVXaWR0aChsZXZlbCkgKSxcbiAgICAgICAgICAgIHR5ID0gTWF0aC5mbG9vciggcGl4ZWwueSAvIHRoaXMuZ2V0VGlsZUhlaWdodChsZXZlbCkgKTtcblxuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoIHR4LCB0eSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgZ2V0VGlsZUJvdW5kczogZnVuY3Rpb24oIGxldmVsLCB4LCB5ICkge1xuICAgICAgICB2YXIgZGltZW5zaW9uc1NjYWxlZCA9IHRoaXMuZGltZW5zaW9ucy50aW1lcyggdGhpcy5nZXRMZXZlbFNjYWxlKCBsZXZlbCApICksXG4gICAgICAgICAgICB0aWxlV2lkdGggPSB0aGlzLmdldFRpbGVXaWR0aChsZXZlbCksXG4gICAgICAgICAgICB0aWxlSGVpZ2h0ID0gdGhpcy5nZXRUaWxlSGVpZ2h0KGxldmVsKSxcbiAgICAgICAgICAgIHB4ID0gKCB4ID09PSAwICkgPyAwIDogdGlsZVdpZHRoICogeCAtIHRoaXMudGlsZU92ZXJsYXAsXG4gICAgICAgICAgICBweSA9ICggeSA9PT0gMCApID8gMCA6IHRpbGVIZWlnaHQgKiB5IC0gdGhpcy50aWxlT3ZlcmxhcCxcbiAgICAgICAgICAgIHN4ID0gdGlsZVdpZHRoICsgKCB4ID09PSAwID8gMSA6IDIgKSAqIHRoaXMudGlsZU92ZXJsYXAsXG4gICAgICAgICAgICBzeSA9IHRpbGVIZWlnaHQgKyAoIHkgPT09IDAgPyAxIDogMiApICogdGhpcy50aWxlT3ZlcmxhcCxcbiAgICAgICAgICAgIHNjYWxlID0gMS4wIC8gZGltZW5zaW9uc1NjYWxlZC54O1xuXG4gICAgICAgIHN4ID0gTWF0aC5taW4oIHN4LCBkaW1lbnNpb25zU2NhbGVkLnggLSBweCApO1xuICAgICAgICBzeSA9IE1hdGgubWluKCBzeSwgZGltZW5zaW9uc1NjYWxlZC55IC0gcHkgKTtcblxuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdCggcHggKiBzY2FsZSwgcHkgKiBzY2FsZSwgc3ggKiBzY2FsZSwgc3kgKiBzY2FsZSApO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciByZXRyaWV2aW5nLCBhbmQgY2FjaGluZyB0aGVcbiAgICAgKiBpbWFnZSBtZXRhZGF0YSBwZXJ0aW5lbnQgdG8gdGhpcyBUaWxlU291cmNlcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgZ2V0SW1hZ2VJbmZvOiBmdW5jdGlvbiggdXJsICkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgY2FsbGJhY2tOYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICByZWFkeVNvdXJjZSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB1cmxQYXJ0cyxcbiAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgbGFzdERvdDtcblxuXG4gICAgICAgIGlmKCB1cmwgKSB7XG4gICAgICAgICAgICB1cmxQYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IHVybFBhcnRzWyB1cmxQYXJ0cy5sZW5ndGggLSAxIF07XG4gICAgICAgICAgICBsYXN0RG90ICA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKCAnLicgKTtcbiAgICAgICAgICAgIGlmICggbGFzdERvdCA+IC0xICkge1xuICAgICAgICAgICAgICAgIHVybFBhcnRzWyB1cmxQYXJ0cy5sZW5ndGggLSAxIF0gPSBmaWxlbmFtZS5zbGljZSggMCwgbGFzdERvdCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiggZGF0YSApe1xuICAgICAgICAgICAgaWYoIHR5cGVvZihkYXRhKSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gJC5wYXJzZVhtbCggZGF0YSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyICRUaWxlU291cmNlID0gJC5UaWxlU291cmNlLmRldGVybWluZVR5cGUoIF90aGlzLCBkYXRhLCB1cmwgKTtcbiAgICAgICAgICAgIGlmICggISRUaWxlU291cmNlICkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBsb2FkaW5nIGEgVGlsZVNvdXJjZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBvcGVuLWZhaWxlZFxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2VcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlU291cmNlfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBUaWxlU291cmNlIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc291cmNlXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoICdvcGVuLWZhaWxlZCcsIHsgbWVzc2FnZTogXCJVbmFibGUgdG8gbG9hZCBUaWxlU291cmNlXCIsIHNvdXJjZTogdXJsIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSAkVGlsZVNvdXJjZS5wcm90b3R5cGUuY29uZmlndXJlLmFwcGx5KCBfdGhpcywgWyBkYXRhLCB1cmwgXSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hamF4V2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFqYXhXaXRoQ3JlZGVudGlhbHMgPSBfdGhpcy5hamF4V2l0aENyZWRlbnRpYWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWFkeVNvdXJjZSA9IG5ldyAkVGlsZVNvdXJjZSggb3B0aW9ucyApO1xuICAgICAgICAgICAgX3RoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhIFRpbGVTb3VyY2UgaXMgb3BlbmVkIGFuZCBpbml0aWFsaXplZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgcmVhZHlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZVNvdXJjZX0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVGlsZVNvdXJjZSB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IHRpbGVTb3VyY2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggJ3JlYWR5JywgeyB0aWxlU291cmNlOiByZWFkeVNvdXJjZSB9ICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHVybC5tYXRjaCgvXFwuanMkLykgKXtcbiAgICAgICAgICAgIC8vVE9ETzogSXRzIG5vdCB2ZXJ5IGZsZXhpYmxlIHRvIHJlcXVpcmUgdGlsZSBzb3VyY2VzIHRvIGVuZCBqc29ucFxuICAgICAgICAgICAgLy8gICAgICByZXF1ZXN0IGZvciBpbmZvICB3aXRoIGEgdXJsIHRoYXQgZW5kcyB3aXRoICcuanMnIGJ1dCBmb3JcbiAgICAgICAgICAgIC8vICAgICAgbm93IGl0J3MgdGhlIG9ubHkgd2F5IEkgc2VlIHRvIGRpc3Rpbmd1aXNoIHVuaWZvcm1seS5cbiAgICAgICAgICAgIGNhbGxiYWNrTmFtZSA9IHVybC5zcGxpdCggJy8nICkucG9wKCkucmVwbGFjZSgnLmpzJywnJyk7XG4gICAgICAgICAgICAkLmpzb25wKHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tOYW1lOiBjYWxsYmFja05hbWUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgaW5mbyB2aWEgeGhyIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgJC5tYWtlQWpheFJlcXVlc3QoIHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRoaXMuYWpheFdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiggeGhyICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHByb2Nlc3NSZXNwb25zZSggeGhyICk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBkYXRhICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKCB4aHIsIGV4YyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZztcblxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgSUUgPCAxMCB3aWxsIGJsb2NrIFhIUiByZXF1ZXN0cyB0byBkaWZmZXJlbnQgb3JpZ2lucy4gQW55IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uIHdoaWNoIHdlJ2xsIGF0dGVtcHQgdG8gaGFuZGxlIGJ5IGZvcm1hdHRpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNlcHRpb24gcmF0aGVyIHRoYW4gdGhlIHNlY29uZCBvbmUgcmFpc2VkIHdoZW4gd2UgdHJ5IHRvIGFjY2VzcyB4aHIuc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gXCJIVFRQIFwiICsgeGhyLnN0YXR1cyArIFwiIGF0dGVtcHRpbmcgdG8gbG9hZCBUaWxlU291cmNlXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZEV4YztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mKCBleGMgKSA9PSBcInVuZGVmaW5lZFwiIHx8ICFleGMudG9TdHJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkRXhjID0gXCJVbmtub3duIGVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEV4YyA9IGV4Yy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBmb3JtYXR0ZWRFeGMgKyBcIiBhdHRlbXB0aW5nIHRvIGxvYWQgVGlsZVNvdXJjZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqKlxuICAgICAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgbG9hZGluZyBhIFRpbGVTb3VyY2UuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBldmVudCBvcGVuLWZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlU291cmNlfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBUaWxlU291cmNlIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmFpc2VFdmVudCggJ29wZW4tZmFpbGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBkZXRlcm1pbmluZyBpZiBhIHRoZSBwYXJ0aWN1bGFyIFRpbGVTb3VyY2Ugc3VwcG9ydHMgdGhlXG4gICAgICogZGF0YSBmb3JtYXQgKCBhbmQgYWxsb3dlZCB0byBhcHBseSBsb2dpYyBhZ2FpbnN0IHRoZSB1cmwgdGhlIGRhdGEgd2FzXG4gICAgICogbG9hZGVkIGZyb20sIGlmIGFueSApLiBPdmVycmlkaW5nIGltcGxlbWVudGF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gZG9cbiAgICAgKiBzb21ldGhpbmcgc21hcnQgd2l0aCBkYXRhIGFuZCAvIG9yIHVybCB0byBkZXRlcm1pbmUgc3VwcG9ydC4gIEFsc29cbiAgICAgKiB1bmRlcnN0YW5kIHRoYXQgaXRlcmF0aW9uIG9yZGVyIG9mIFRpbGVTb3VyY2VzIGlzIG5vdCBndWFydW50ZWVkIHNvXG4gICAgICogcGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGRhdGEgb3IgdXJsIGlzIGV4cHJlc3NpdmUgZW5vdWdoIHRvIGVuc3VyZSBhIHNpbXBsZVxuICAgICAqIGFuZCBzdWZmaWNpZW50IG1lY2hhbmlzaW0gZm9yIGNsZWFyIGRldGVybWluYXRpb24uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEFycmF5fERvY3VtZW50fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIHRoZSB1cmwgdGhlIGRhdGEgd2FzIGxvYWRlZFxuICAgICAqICAgICAgZnJvbSBpZiBhbnkuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdXBwb3J0czogZnVuY3Rpb24oIGRhdGEsIHVybCApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgcGFyc2luZyBhbmQgY29uZmlndXJpbmcgdGhlXG4gICAgICogaW1hZ2UgbWV0YWRhdGEgcGVydGluZW50IHRvIHRoaXMgVGlsZVNvdXJjZXMgaW1wbGVtZW50YXRpb24uXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGJ5IHRoaXMgY2xhc3Mgb3RoZXIgdGhhbiB0byB0aHJvdyBhbiBFcnJvclxuICAgICAqIGFubm91bmNpbmcgeW91IGhhdmUgdG8gaW1wbGVtZW50IGl0LiAgQmVjYXVzZSBvZiB0aGUgdmFyaWV0eSBvZiB0aWxlXG4gICAgICogc2VydmVyIHRlY2hub2xvZ2llcywgYW5kIHZhcmlvdXMgc3BlY2lmaWNhdGlvbnMgZm9yIGJ1aWxkaW5nIGltYWdlXG4gICAgICogcHlyYW1pZHMsIHRoaXMgbWV0aG9kIGlzIGhlcmUgdG8gYWxsb3cgZWFzeSBpbnRlZ3JhdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl8RG9jdW1lbnR9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gdGhlIHVybCB0aGUgZGF0YSB3YXMgbG9hZGVkXG4gICAgICogICAgICBmcm9tIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9wdGlvbnMgLSBBIGRpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMgc3VmZmljaWVudFxuICAgICAqICAgICAgdG8gY29uZmlndXJlIHRoaXMgdGlsZSBzb3VyY2VzIGNvbnN0cnVjdG9yLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24oIGRhdGEsIHVybCApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2libGUgZm9yIHJldHJpdmluZyB0aGUgdXJsIHdoaWNoIHdpbGwgcmV0dXJuIGFuIGltYWdlIGZvciB0aGVcbiAgICAgKiByZWdpb24gc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiB4LCB5LCBhbmQgbGV2ZWwgY29tcG9uZW50cy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgYnkgdGhpcyBjbGFzcyBvdGhlciB0aGFuIHRvIHRocm93IGFuIEVycm9yXG4gICAgICogYW5ub3VuY2luZyB5b3UgaGF2ZSB0byBpbXBsZW1lbnQgaXQuICBCZWNhdXNlIG9mIHRoZSB2YXJpZXR5IG9mIHRpbGVcbiAgICAgKiBzZXJ2ZXIgdGVjaG5vbG9naWVzLCBhbmQgdmFyaW91cyBzcGVjaWZpY2F0aW9ucyBmb3IgYnVpbGRpbmcgaW1hZ2VcbiAgICAgKiBweXJhbWlkcywgdGhpcyBtZXRob2QgaXMgaGVyZSB0byBhbGxvdyBlYXN5IGludGVncmF0aW9uLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRUaWxlVXJsOiBmdW5jdGlvbiggbGV2ZWwsIHgsIHkgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKi9cbiAgICB0aWxlRXhpc3RzOiBmdW5jdGlvbiggbGV2ZWwsIHgsIHkgKSB7XG4gICAgICAgIHZhciBudW1UaWxlcyA9IHRoaXMuZ2V0TnVtVGlsZXMoIGxldmVsICk7XG4gICAgICAgIHJldHVybiAgbGV2ZWwgPj0gdGhpcy5taW5MZXZlbCAmJlxuICAgICAgICAgICAgICAgIGxldmVsIDw9IHRoaXMubWF4TGV2ZWwgJiZcbiAgICAgICAgICAgICAgICB4ID49IDAgJiZcbiAgICAgICAgICAgICAgICB5ID49IDAgJiZcbiAgICAgICAgICAgICAgICB4IDwgbnVtVGlsZXMueCAmJlxuICAgICAgICAgICAgICAgIHkgPCBudW1UaWxlcy55O1xuICAgIH1cbn07XG5cblxuJC5leHRlbmQoIHRydWUsICQuVGlsZVNvdXJjZS5wcm90b3R5cGUsICQuRXZlbnRTb3VyY2UucHJvdG90eXBlICk7XG5cblxuLyoqXG4gKiBEZWNpZGVzIHdoZXRoZXIgdG8gdHJ5IHRvIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGFzIHhtbCwganNvbiwgb3IgaGFuZCBiYWNrXG4gKiB0aGUgdGV4dFxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHIgLSB0aGUgY29tcGxldGVkIG5ldHdvcmsgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2UoIHhociApe1xuICAgIHZhciByZXNwb25zZVRleHQgPSB4aHIucmVzcG9uc2VUZXh0LFxuICAgICAgICBzdGF0dXMgICAgICAgPSB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICBkYXRhO1xuXG4gICAgaWYgKCAheGhyICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5TZWN1cml0eVwiICkgKTtcbiAgICB9IGVsc2UgaWYgKCB4aHIuc3RhdHVzICE9PSAyMDAgJiYgeGhyLnN0YXR1cyAhPT0gMCApIHtcbiAgICAgICAgc3RhdHVzICAgICA9IHhoci5zdGF0dXM7XG4gICAgICAgIHN0YXR1c1RleHQgPSAoIHN0YXR1cyA9PSA0MDQgKSA/XG4gICAgICAgICAgICBcIk5vdCBGb3VuZFwiIDpcbiAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0O1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5TdGF0dXNcIiwgc3RhdHVzLCBzdGF0dXNUZXh0ICkgKTtcbiAgICB9XG5cbiAgICBpZiggcmVzcG9uc2VUZXh0Lm1hdGNoKC9cXHMqPC4qLykgKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICBkYXRhID0gKCB4aHIucmVzcG9uc2VYTUwgJiYgeGhyLnJlc3BvbnNlWE1MLmRvY3VtZW50RWxlbWVudCApID9cbiAgICAgICAgICAgIHhoci5yZXNwb25zZVhNTCA6XG4gICAgICAgICAgICAkLnBhcnNlWG1sKCByZXNwb25zZVRleHQgKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuICAgIH1lbHNlIGlmKCByZXNwb25zZVRleHQubWF0Y2goL1xccypbXFx7XFxbXS4qLykgKXtcbiAgICAgICAgZGF0YSA9ICQucGFyc2VKU09OKHJlc3BvbnNlVGV4dCk7XG4gICAgfWVsc2V7XG4gICAgICAgIGRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgVGlsZVNvdXJjZSBJbXBsZW1lbnRhdGlvbiBieSBpbnRyb3NwZWN0aW9uIG9mIE9wZW5TZWFkcmFnb25cbiAqIG5hbWVzcGFjZSwgY2FsbGluZyBlYWNoIFRpbGVTb3VyY2UgaW1wbGVtZW50YXRpb24gb2YgJ2lzVHlwZSdcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8RG9jdW1lbnR9IGRhdGEgLSB0aGUgdGlsZSBzb3VyY2UgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSB0aGUgdXJsIHdoZXJlIHRoZSB0aWxlIHNvdXJjZSBjb25maWd1cmF0aW9uIG9iamVjdCB3YXNcbiAqICAgICAgbG9hZGVkIGZyb20sIGlmIGFueS5cbiAqL1xuJC5UaWxlU291cmNlLmRldGVybWluZVR5cGUgPSBmdW5jdGlvbiggdGlsZVNvdXJjZSwgZGF0YSwgdXJsICl7XG4gICAgdmFyIHByb3BlcnR5O1xuICAgIGZvciggcHJvcGVydHkgaW4gT3BlblNlYWRyYWdvbiApe1xuICAgICAgICBpZiggcHJvcGVydHkubWF0Y2goLy4rVGlsZVNvdXJjZSQvKSAmJlxuICAgICAgICAgICAgJC5pc0Z1bmN0aW9uKCBPcGVuU2VhZHJhZ29uWyBwcm9wZXJ0eSBdICkgJiZcbiAgICAgICAgICAgICQuaXNGdW5jdGlvbiggT3BlblNlYWRyYWdvblsgcHJvcGVydHkgXS5wcm90b3R5cGUuc3VwcG9ydHMgKSAmJlxuICAgICAgICAgICAgT3BlblNlYWRyYWdvblsgcHJvcGVydHkgXS5wcm90b3R5cGUuc3VwcG9ydHMuY2FsbCggdGlsZVNvdXJjZSwgZGF0YSwgdXJsIClcbiAgICAgICAgKXtcbiAgICAgICAgICAgIHJldHVybiBPcGVuU2VhZHJhZ29uWyBwcm9wZXJ0eSBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJC5jb25zb2xlLmVycm9yKCBcIk5vIFRpbGVTb3VyY2Ugd2FzIGFibGUgdG8gb3BlbiAlcyAlc1wiLCB1cmwsIGRhdGEgKTtcbn07XG5cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBEemlUaWxlU291cmNlXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBEemlUaWxlU291cmNlXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHdpZHRoIC0gdGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBpbWFnZSBvciB0aGUgaWRpb21hdGljXG4gKiAgICAgIG9wdGlvbnMgb2JqZWN0IHdoaWNoIGlzIHVzZWQgaW5zdGVhZCBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aWxlU2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVPdmVybGFwXG4gKiBAcGFyYW0ge1N0cmluZ30gdGlsZXNVcmxcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlRm9ybWF0XG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRGlzcGxheVJlY3RbXX0gZGlzcGxheVJlY3RzXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdGlsZXNVcmxcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmaWxlRm9ybWF0XG4gKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uRGlzcGxheVJlY3RbXX0gZGlzcGxheVJlY3RzXG4gKi9cbiQuRHppVGlsZVNvdXJjZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0LCB0aWxlU2l6ZSwgdGlsZU92ZXJsYXAsIHRpbGVzVXJsLCBmaWxlRm9ybWF0LCBkaXNwbGF5UmVjdHMsIG1pbkxldmVsLCBtYXhMZXZlbCApIHtcbiAgICB2YXIgaSxcbiAgICAgICAgcmVjdCxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIG9wdGlvbnM7XG5cbiAgICBpZiggJC5pc1BsYWluT2JqZWN0KCB3aWR0aCApICl7XG4gICAgICAgIG9wdGlvbnMgPSB3aWR0aDtcbiAgICB9ZWxzZXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmd1bWVudHNbIDAgXSxcbiAgICAgICAgICAgIGhlaWdodDogYXJndW1lbnRzWyAxIF0sXG4gICAgICAgICAgICB0aWxlU2l6ZTogYXJndW1lbnRzWyAyIF0sXG4gICAgICAgICAgICB0aWxlT3ZlcmxhcDogYXJndW1lbnRzWyAzIF0sXG4gICAgICAgICAgICB0aWxlc1VybDogYXJndW1lbnRzWyA0IF0sXG4gICAgICAgICAgICBmaWxlRm9ybWF0OiBhcmd1bWVudHNbIDUgXSxcbiAgICAgICAgICAgIGRpc3BsYXlSZWN0czogYXJndW1lbnRzWyA2IF0sXG4gICAgICAgICAgICBtaW5MZXZlbDogYXJndW1lbnRzWyA3IF0sXG4gICAgICAgICAgICBtYXhMZXZlbDogYXJndW1lbnRzWyA4IF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl9sZXZlbFJlY3RzICA9IHt9O1xuICAgIHRoaXMudGlsZXNVcmwgICAgID0gb3B0aW9ucy50aWxlc1VybDtcbiAgICB0aGlzLmZpbGVGb3JtYXQgICA9IG9wdGlvbnMuZmlsZUZvcm1hdDtcbiAgICB0aGlzLmRpc3BsYXlSZWN0cyA9IG9wdGlvbnMuZGlzcGxheVJlY3RzO1xuXG4gICAgaWYgKCB0aGlzLmRpc3BsYXlSZWN0cyApIHtcbiAgICAgICAgZm9yICggaSA9IHRoaXMuZGlzcGxheVJlY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgICAgcmVjdCA9IHRoaXMuZGlzcGxheVJlY3RzWyBpIF07XG4gICAgICAgICAgICBmb3IgKCBsZXZlbCA9IHJlY3QubWluTGV2ZWw7IGxldmVsIDw9IHJlY3QubWF4TGV2ZWw7IGxldmVsKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhdGhpcy5fbGV2ZWxSZWN0c1sgbGV2ZWwgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxSZWN0c1sgbGV2ZWwgXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbFJlY3RzWyBsZXZlbCBdLnB1c2goIHJlY3QgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICQuVGlsZVNvdXJjZS5hcHBseSggdGhpcywgWyBvcHRpb25zIF0gKTtcblxufTtcblxuJC5leHRlbmQoICQuRHppVGlsZVNvdXJjZS5wcm90b3R5cGUsICQuVGlsZVNvdXJjZS5wcm90b3R5cGUsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5EemlUaWxlU291cmNlLnByb3RvdHlwZSAqL3tcblxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBkYXRhIGFuZC9vciB1cmwgaW1wbHkgdGhlIGltYWdlIHNlcnZpY2UgaXMgc3VwcG9ydGVkIGJ5XG4gICAgICogdGhpcyB0aWxlIHNvdXJjZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25hbCAtIHVybFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiggZGF0YSwgdXJsICl7XG4gICAgICAgIHZhciBucztcbiAgICAgICAgaWYgKCBkYXRhLkltYWdlICkge1xuICAgICAgICAgICAgbnMgPSBkYXRhLkltYWdlLnhtbG5zO1xuICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKFwiSW1hZ2VcIiA9PSBkYXRhLmRvY3VtZW50RWxlbWVudC5sb2NhbE5hbWUgfHwgXCJJbWFnZVwiID09IGRhdGEuZG9jdW1lbnRFbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBucyA9IGRhdGEuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoIFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9kZWVwem9vbS8yMDA4XCIgPT0gbnMgfHxcbiAgICAgICAgICAgIFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9kZWVwem9vbS8yMDA5XCIgPT0gbnMgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxYTUxEb2N1bWVudH0gZGF0YSAtIHRoZSByYXcgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSB0aGUgdXJsIHRoZSBkYXRhIHdhcyByZXRyZWl2ZWQgZnJvbSBpZiBhbnkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvcHRpb25zIC0gQSBkaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHN1ZmZpY2llbnRcbiAgICAgKiAgICAgIHRvIGNvbmZpZ3VyZSB0aGlzIHRpbGUgc291cmNlcyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKXtcblxuICAgICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgICBpZiggISQuaXNQbGFpbk9iamVjdChkYXRhKSApe1xuXG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlndXJlRnJvbVhNTCggdGhpcywgZGF0YSApO1xuXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlndXJlRnJvbU9iamVjdCggdGhpcywgZGF0YSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybCAmJiAhb3B0aW9ucy50aWxlc1VybCkge1xuICAgICAgICAgICAgb3B0aW9ucy50aWxlc1VybCA9IHVybC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvKFteXFwvXSs/KShcXC4oZHppfHhtbHxqcykpP1xcLz8oXFw/LiopPyQvLCAnJDFfZmlsZXMvJyk7XG5cbiAgICAgICAgICAgIGlmICh1cmwuc2VhcmNoKC9cXC4oZHppfHhtbHxqcylcXD8vKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnlQYXJhbXMgPSB1cmwubWF0Y2goL1xcPy4qLyk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5UGFyYW1zID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgZ2V0VGlsZVVybDogZnVuY3Rpb24oIGxldmVsLCB4LCB5ICkge1xuICAgICAgICByZXR1cm4gWyB0aGlzLnRpbGVzVXJsLCBsZXZlbCwgJy8nLCB4LCAnXycsIHksICcuJywgdGhpcy5maWxlRm9ybWF0LCB0aGlzLnF1ZXJ5UGFyYW1zIF0uam9pbiggJycgKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgdGlsZUV4aXN0czogZnVuY3Rpb24oIGxldmVsLCB4LCB5ICkge1xuICAgICAgICB2YXIgcmVjdHMgPSB0aGlzLl9sZXZlbFJlY3RzWyBsZXZlbCBdLFxuICAgICAgICAgICAgcmVjdCxcbiAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgeE1pbixcbiAgICAgICAgICAgIHlNaW4sXG4gICAgICAgICAgICB4TWF4LFxuICAgICAgICAgICAgeU1heCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgaWYgKCAhcmVjdHMgfHwgIXJlY3RzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaSA9IHJlY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgICAgcmVjdCA9IHJlY3RzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggbGV2ZWwgPCByZWN0Lm1pbkxldmVsIHx8IGxldmVsID4gcmVjdC5tYXhMZXZlbCApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NhbGUgPSB0aGlzLmdldExldmVsU2NhbGUoIGxldmVsICk7XG4gICAgICAgICAgICB4TWluID0gcmVjdC54ICogc2NhbGU7XG4gICAgICAgICAgICB5TWluID0gcmVjdC55ICogc2NhbGU7XG4gICAgICAgICAgICB4TWF4ID0geE1pbiArIHJlY3Qud2lkdGggKiBzY2FsZTtcbiAgICAgICAgICAgIHlNYXggPSB5TWluICsgcmVjdC5oZWlnaHQgKiBzY2FsZTtcblxuICAgICAgICAgICAgeE1pbiA9IE1hdGguZmxvb3IoIHhNaW4gLyB0aGlzLnRpbGVTaXplICk7XG4gICAgICAgICAgICB5TWluID0gTWF0aC5mbG9vciggeU1pbiAvIHRoaXMudGlsZVNpemUgKTtcbiAgICAgICAgICAgIHhNYXggPSBNYXRoLmNlaWwoIHhNYXggLyB0aGlzLnRpbGVTaXplICk7XG4gICAgICAgICAgICB5TWF4ID0gTWF0aC5jZWlsKCB5TWF4IC8gdGhpcy50aWxlU2l6ZSApO1xuXG4gICAgICAgICAgICBpZiAoIHhNaW4gPD0geCAmJiB4IDwgeE1heCAmJiB5TWluIDw9IHkgJiYgeSA8IHlNYXggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlRnJvbVhNTCggdGlsZVNvdXJjZSwgeG1sRG9jICl7XG5cbiAgICBpZiAoICF4bWxEb2MgfHwgIXhtbERvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggJC5nZXRTdHJpbmcoIFwiRXJyb3JzLlhtbFwiICkgKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCAgICAgICAgICAgPSB4bWxEb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICByb290TmFtZSAgICAgICA9IHJvb3QubG9jYWxOYW1lIHx8IHJvb3QudGFnTmFtZSxcbiAgICAgICAgbnMgICAgICAgICAgICAgPSB4bWxEb2MuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSxcbiAgICAgICAgY29uZmlndXJhdGlvbiAgPSBudWxsLFxuICAgICAgICBkaXNwbGF5UmVjdHMgICA9IFtdLFxuICAgICAgICBkaXNwUmVjdE5vZGVzLFxuICAgICAgICBkaXNwUmVjdE5vZGUsXG4gICAgICAgIHJlY3ROb2RlLFxuICAgICAgICBzaXplTm9kZSxcbiAgICAgICAgaTtcblxuICAgIGlmICggcm9vdE5hbWUgPT0gXCJJbWFnZVwiICkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaXplTm9kZSA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJTaXplXCIgKVsgMCBdO1xuICAgICAgICAgICAgaWYgKHNpemVOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzaXplTm9kZSA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyhucywgXCJTaXplXCIgKVsgMCBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIEltYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHhtbG5zOiAgICAgICBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vZGVlcHpvb20vMjAwOFwiLFxuICAgICAgICAgICAgICAgICAgICBVcmw6ICAgICAgICAgcm9vdC5nZXRBdHRyaWJ1dGUoIFwiVXJsXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgRm9ybWF0OiAgICAgIHJvb3QuZ2V0QXR0cmlidXRlKCBcIkZvcm1hdFwiICksXG4gICAgICAgICAgICAgICAgICAgIERpc3BsYXlSZWN0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBPdmVybGFwOiAgICAgcGFyc2VJbnQoIHJvb3QuZ2V0QXR0cmlidXRlKCBcIk92ZXJsYXBcIiApLCAxMCApLFxuICAgICAgICAgICAgICAgICAgICBUaWxlU2l6ZTogICAgcGFyc2VJbnQoIHJvb3QuZ2V0QXR0cmlidXRlKCBcIlRpbGVTaXplXCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgU2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgSGVpZ2h0OiBwYXJzZUludCggc2l6ZU5vZGUuZ2V0QXR0cmlidXRlKCBcIkhlaWdodFwiICksIDEwICksXG4gICAgICAgICAgICAgICAgICAgICAgICBXaWR0aDogIHBhcnNlSW50KCBzaXplTm9kZS5nZXRBdHRyaWJ1dGUoIFwiV2lkdGhcIiApLCAxMCApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoICEkLmltYWdlRm9ybWF0U3VwcG9ydGVkKCBjb25maWd1cmF0aW9uLkltYWdlLkZvcm1hdCApICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJC5nZXRTdHJpbmcoIFwiRXJyb3JzLkltYWdlRm9ybWF0XCIsIGNvbmZpZ3VyYXRpb24uSW1hZ2UuRm9ybWF0LnRvVXBwZXJDYXNlKCkgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpc3BSZWN0Tm9kZXMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRGlzcGxheVJlY3RcIiApO1xuICAgICAgICAgICAgaWYgKGRpc3BSZWN0Tm9kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRpc3BSZWN0Tm9kZXMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lTlMobnMsIFwiRGlzcGxheVJlY3RcIiApWyAwIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZGlzcFJlY3ROb2Rlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBkaXNwUmVjdE5vZGUgPSBkaXNwUmVjdE5vZGVzWyBpIF07XG4gICAgICAgICAgICAgICAgcmVjdE5vZGUgICAgID0gZGlzcFJlY3ROb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiUmVjdFwiIClbIDAgXTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0Tm9kZSA9IGRpc3BSZWN0Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKG5zLCBcIlJlY3RcIiApWyAwIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGlzcGxheVJlY3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBSZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBYOiBwYXJzZUludCggcmVjdE5vZGUuZ2V0QXR0cmlidXRlKCBcIlhcIiApLCAxMCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgWTogcGFyc2VJbnQoIHJlY3ROb2RlLmdldEF0dHJpYnV0ZSggXCJZXCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFdpZHRoOiBwYXJzZUludCggcmVjdE5vZGUuZ2V0QXR0cmlidXRlKCBcIldpZHRoXCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEhlaWdodDogcGFyc2VJbnQoIHJlY3ROb2RlLmdldEF0dHJpYnV0ZSggXCJIZWlnaHRcIiApLCAxMCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWluTGV2ZWw6IHBhcnNlSW50KCBkaXNwUmVjdE5vZGUuZ2V0QXR0cmlidXRlKCBcIk1pbkxldmVsXCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1heExldmVsOiBwYXJzZUludCggZGlzcFJlY3ROb2RlLmdldEF0dHJpYnV0ZSggXCJNYXhMZXZlbFwiICksIDEwIClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggZGlzcGxheVJlY3RzLmxlbmd0aCApe1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uSW1hZ2UuRGlzcGxheVJlY3QgPSBkaXNwbGF5UmVjdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb25maWd1cmVGcm9tT2JqZWN0KCB0aWxlU291cmNlLCBjb25maWd1cmF0aW9uICk7XG5cbiAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICB0aHJvdyAoZSBpbnN0YW5jZW9mIEVycm9yKSA/XG4gICAgICAgICAgICAgICAgZSA6XG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCAkLmdldFN0cmluZyhcIkVycm9ycy5EemlcIikgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIHJvb3ROYW1lID09IFwiQ29sbGVjdGlvblwiICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5EemNcIiApICk7XG4gICAgfSBlbHNlIGlmICggcm9vdE5hbWUgPT0gXCJFcnJvclwiICkge1xuICAgICAgICB2YXIgbWVzc2FnZU5vZGUgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiTWVzc2FnZVwiKVswXTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlTm9kZS5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvciggJC5nZXRTdHJpbmcoIFwiRXJyb3JzLkR6aVwiICkgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlRnJvbU9iamVjdCggdGlsZVNvdXJjZSwgY29uZmlndXJhdGlvbiApe1xuICAgIHZhciBpbWFnZURhdGEgICAgID0gY29uZmlndXJhdGlvbi5JbWFnZSxcbiAgICAgICAgdGlsZXNVcmwgICAgICA9IGltYWdlRGF0YS5VcmwsXG4gICAgICAgIGZpbGVGb3JtYXQgICAgPSBpbWFnZURhdGEuRm9ybWF0LFxuICAgICAgICBzaXplRGF0YSAgICAgID0gaW1hZ2VEYXRhLlNpemUsXG4gICAgICAgIGRpc3BSZWN0RGF0YSAgPSBpbWFnZURhdGEuRGlzcGxheVJlY3QgfHwgW10sXG4gICAgICAgIHdpZHRoICAgICAgICAgPSBwYXJzZUludCggc2l6ZURhdGEuV2lkdGgsIDEwICksXG4gICAgICAgIGhlaWdodCAgICAgICAgPSBwYXJzZUludCggc2l6ZURhdGEuSGVpZ2h0LCAxMCApLFxuICAgICAgICB0aWxlU2l6ZSAgICAgID0gcGFyc2VJbnQoIGltYWdlRGF0YS5UaWxlU2l6ZSwgMTAgKSxcbiAgICAgICAgdGlsZU92ZXJsYXAgICA9IHBhcnNlSW50KCBpbWFnZURhdGEuT3ZlcmxhcCwgMTAgKSxcbiAgICAgICAgZGlzcGxheVJlY3RzICA9IFtdLFxuICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgaTtcblxuICAgIC8vVE9ETzogbmVlZCB0byBmaWd1cmUgb3V0IG91dCB0byBiZXR0ZXIgaGFuZGxlIGltYWdlIGZvcm1hdCBjb21wYXRpYmlsaXR5XG4gICAgLy8gICAgICB3aGljaCBhY3R1YWxseSBpbmNsdWRlcyBhZGRpdGlvbmFsIGZpbGUgZm9ybWF0cyBsaWtlIHhtbCBhbmQgcGRmXG4gICAgLy8gICAgICBhbmQgcGxhaW4gdGV4dCBmb3IgdmFyaW91cyB0aWxlc291cmNlIGltcGxlbWVudGF0aW9ucyB0byBhdm9pZCBsb3dcbiAgICAvLyAgICAgIGxldmVsIGVycm9ycy5cbiAgICAvL1xuICAgIC8vICAgICAgRm9yIG5vdywganVzdCBkb24ndCBwZXJmb3JtIHRoZSBjaGVjay5cbiAgICAvL1xuICAgIC8qaWYgKCAhaW1hZ2VGb3JtYXRTdXBwb3J0ZWQoIGZpbGVGb3JtYXQgKSApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJC5nZXRTdHJpbmcoIFwiRXJyb3JzLkltYWdlRm9ybWF0XCIsIGZpbGVGb3JtYXQudG9VcHBlckNhc2UoKSApXG4gICAgICAgICk7XG4gICAgfSovXG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGRpc3BSZWN0RGF0YS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgcmVjdERhdGEgPSBkaXNwUmVjdERhdGFbIGkgXS5SZWN0O1xuXG4gICAgICAgIGRpc3BsYXlSZWN0cy5wdXNoKCBuZXcgJC5EaXNwbGF5UmVjdChcbiAgICAgICAgICAgIHBhcnNlSW50KCByZWN0RGF0YS5YLCAxMCApLFxuICAgICAgICAgICAgcGFyc2VJbnQoIHJlY3REYXRhLlksIDEwICksXG4gICAgICAgICAgICBwYXJzZUludCggcmVjdERhdGEuV2lkdGgsIDEwICksXG4gICAgICAgICAgICBwYXJzZUludCggcmVjdERhdGEuSGVpZ2h0LCAxMCApLFxuICAgICAgICAgICAgcGFyc2VJbnQoIHJlY3REYXRhLk1pbkxldmVsLCAxMCApLFxuICAgICAgICAgICAgcGFyc2VJbnQoIHJlY3REYXRhLk1heExldmVsLCAxMCApXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCwgLyogd2lkdGggKnJlcXVpcmVkICovXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LCAvKiBoZWlnaHQgKnJlcXVpcmVkICovXG4gICAgICAgIHRpbGVTaXplOiB0aWxlU2l6ZSwgLyogdGlsZVNpemUgKnJlcXVpcmVkICovXG4gICAgICAgIHRpbGVPdmVybGFwOiB0aWxlT3ZlcmxhcCwgLyogdGlsZU92ZXJsYXAgKnJlcXVpcmVkICovXG4gICAgICAgIG1pbkxldmVsOiBudWxsLCAvKiBtaW5MZXZlbCAqL1xuICAgICAgICBtYXhMZXZlbDogbnVsbCwgLyogbWF4TGV2ZWwgKi9cbiAgICAgICAgdGlsZXNVcmw6IHRpbGVzVXJsLCAvKiB0aWxlc1VybCAqL1xuICAgICAgICBmaWxlRm9ybWF0OiBmaWxlRm9ybWF0LCAvKiBmaWxlRm9ybWF0ICovXG4gICAgICAgIGRpc3BsYXlSZWN0czogZGlzcGxheVJlY3RzIC8qIGRpc3BsYXlSZWN0cyAqL1xuICAgIH0sIGNvbmZpZ3VyYXRpb24gKTtcblxufVxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIElJSUZUaWxlU291cmNlXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBJSUlGVGlsZVNvdXJjZVxuICogQGNsYXNzZGVzYyBBIGNsaWVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSW50ZXJuYXRpb25hbCBJbWFnZSBJbnRlcm9wZXJhYmlsaXR5IEZyYW1ld29ya1xuICogRm9ybWF0OiBJbWFnZSBBUEkgMS4wIC0gMi4xXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZVxuICogQHNlZSBodHRwOi8vaWlpZi5pby9hcGkvaW1hZ2UvXG4gKi9cbiQuSUlJRlRpbGVTb3VyY2UgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuXG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywgb3B0aW9ucyApO1xuXG4gICAgaWYgKCAhKCB0aGlzLmhlaWdodCAmJiB0aGlzLndpZHRoICYmIHRoaXNbJ0BpZCddICkgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggJ0lJSUYgcmVxdWlyZWQgcGFyYW1ldGVycyBub3QgcHJvdmlkZWQuJyApO1xuICAgIH1cblxuICAgIG9wdGlvbnMudGlsZVNpemVQZXJTY2FsZUZhY3RvciA9IHt9O1xuXG4gICAgLy8gTi5CLiAyLjAgcmVuYW1lZCBzY2FsZV9mYWN0b3JzIHRvIHNjYWxlRmFjdG9yc1xuICAgIGlmICggdGhpcy50aWxlX3dpZHRoICYmIHRoaXMudGlsZV9oZWlnaHQgKSB7XG4gICAgICAgIG9wdGlvbnMudGlsZVdpZHRoID0gdGhpcy50aWxlX3dpZHRoO1xuICAgICAgICBvcHRpb25zLnRpbGVIZWlnaHQgPSB0aGlzLnRpbGVfaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoIHRoaXMudGlsZV93aWR0aCApIHtcbiAgICAgICAgb3B0aW9ucy50aWxlU2l6ZSA9IHRoaXMudGlsZV93aWR0aDtcbiAgICB9IGVsc2UgaWYgKCB0aGlzLnRpbGVfaGVpZ2h0ICkge1xuICAgICAgICBvcHRpb25zLnRpbGVTaXplID0gdGhpcy50aWxlX2hlaWdodDtcbiAgICB9IGVsc2UgaWYgKCB0aGlzLnRpbGVzICkge1xuICAgICAgICAvLyBWZXJzaW9uIDIuMCBmb3J3YXJkc1xuICAgICAgICBpZiAoIHRoaXMudGlsZXMubGVuZ3RoID09IDEgKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRpbGVXaWR0aCAgPSB0aGlzLnRpbGVzWzBdLndpZHRoO1xuICAgICAgICAgICAgLy8gVXNlIGhlaWdodCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGFzc3VtZSBzcXVhcmUgdGlsZXMgYW5kIHVzZSB3aWR0aC5cbiAgICAgICAgICAgIG9wdGlvbnMudGlsZUhlaWdodCA9IHRoaXMudGlsZXNbMF0uaGVpZ2h0IHx8IHRoaXMudGlsZXNbMF0ud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnNjYWxlX2ZhY3RvcnMgPSB0aGlzLnRpbGVzWzBdLnNjYWxlRmFjdG9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE11bHRpcGxlIHRpbGUgc2l6ZXMgYXQgZGlmZmVyZW50IGxldmVsc1xuICAgICAgICAgICAgdGhpcy5zY2FsZV9mYWN0b3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMudGlsZXMubGVuZ3RoOyB0KysgKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2YgPSAwOyBzZiA8IHRoaXMudGlsZXNbdF0uc2NhbGVGYWN0b3JzLmxlbmd0aDsgc2YrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSB0aGlzLnRpbGVzW3RdLnNjYWxlRmFjdG9yc1tzZl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVfZmFjdG9ycy5wdXNoKHNjYWxlRmFjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50aWxlU2l6ZVBlclNjYWxlRmFjdG9yW3NjYWxlRmFjdG9yXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnRpbGVzW3RdLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnRpbGVzW3RdLmhlaWdodCB8fCB0aGlzLnRpbGVzW3RdLndpZHRoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICggY2FuQmVUaWxlZChvcHRpb25zLnByb2ZpbGUpICkge1xuICAgICAgICAvLyB1c2UgdGhlIGxhcmdlc3Qgb2YgdGlsZU9wdGlvbnMgdGhhdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHNob3J0IGRpbWVuc2lvblxuICAgICAgICB2YXIgc2hvcnREaW0gPSBNYXRoLm1pbiggdGhpcy5oZWlnaHQsIHRoaXMud2lkdGggKSxcbiAgICAgICAgICAgIHRpbGVPcHRpb25zID0gWzI1Niw1MTIsMTAyNF0sXG4gICAgICAgICAgICBzbWFsbGVyVGlsZXMgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgYyA9IDA7IGMgPCB0aWxlT3B0aW9ucy5sZW5ndGg7IGMrKyApIHtcbiAgICAgICAgICAgIGlmICggdGlsZU9wdGlvbnNbY10gPD0gc2hvcnREaW0gKSB7XG4gICAgICAgICAgICAgICAgc21hbGxlclRpbGVzLnB1c2goIHRpbGVPcHRpb25zW2NdICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHNtYWxsZXJUaWxlcy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgb3B0aW9ucy50aWxlU2l6ZSA9IE1hdGgubWF4LmFwcGx5KCBudWxsLCBzbWFsbGVyVGlsZXMgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHNtYWxsZXIgdGhhbiAyNTYsIGp1c3QgdXNlIHRoZSBzaG9ydCBzaWRlLlxuICAgICAgICAgICAgb3B0aW9ucy50aWxlU2l6ZSA9IHNob3J0RGltO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNpemVzICYmIHRoaXMuc2l6ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUaGlzIGluZm8uanNvbiBjYW4ndCBiZSB0aWxlZCwgYnV0IHdlIGNhbiBzdGlsbCBjb25zdHJ1Y3QgYSBsZWdhY3kgcHlyYW1pZCBmcm9tIHRoZSBzaXplcyBhcnJheS4gXG4gICAgICAgIC8vIEluIHRoaXMgbW9kZSwgSUlJRlRpbGVTb3VyY2Ugd2lsbCBjYWxsIGZ1bmN0aW9ucyBmcm9tIHRoZSBhYnN0cmFjdCBiYXNlVGlsZVNvdXJjZSBvciB0aGUgXG4gICAgICAgIC8vIExlZ2FjeVRpbGVTb3VyY2UgaW5zdGVhZCBvZiBwZXJmb3JtaW5nIElJSUYgdGlsaW5nLiAgICAgIFxuICAgICAgICB0aGlzLmVtdWxhdGVMZWdhY3lJbWFnZVB5cmFtaWQgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgb3B0aW9ucy5sZXZlbHMgPSBjb25zdHJ1Y3RMZXZlbHMoIHRoaXMgKTtcbiAgICAgICAgLy8gdXNlIHRoZSBsYXJnZXN0IGF2YWlsYWJsZSBzaXplIHRvIGRlZmluZSB0aWxlc1xuICAgICAgICAkLmV4dGVuZCggdHJ1ZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMubGV2ZWxzWyBvcHRpb25zLmxldmVscy5sZW5ndGggLSAxIF0ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubGV2ZWxzWyBvcHRpb25zLmxldmVscy5sZW5ndGggLSAxIF0uaGVpZ2h0LFxuICAgICAgICAgICAgdGlsZVNpemU6IE1hdGgubWF4KCBvcHRpb25zLmhlaWdodCwgb3B0aW9ucy53aWR0aCApLFxuICAgICAgICAgICAgdGlsZU92ZXJsYXA6IDAsXG4gICAgICAgICAgICBtaW5MZXZlbDogMCxcbiAgICAgICAgICAgIG1heExldmVsOiBvcHRpb25zLmxldmVscy5sZW5ndGggLSAxXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxldmVscyA9IG9wdGlvbnMubGV2ZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcIk5vdGhpbmcgaW4gdGhlIGluZm8uanNvbiB0byBjb25zdHJ1Y3QgaW1hZ2UgcHlyYW1pZHMgZnJvbVwiKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWF4TGV2ZWwgJiYgIXRoaXMuZW11bGF0ZUxlZ2FjeUltYWdlUHlyYW1pZCkge1xuICAgICAgICBpZiAoIXRoaXMuc2NhbGVfZmFjdG9ycykge1xuICAgICAgICAgICAgb3B0aW9ucy5tYXhMZXZlbCA9IE51bWJlcihNYXRoLmNlaWwoTWF0aC5sb2coTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCAyKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5tYXhMZXZlbCA9IE1hdGguZmxvb3IoTWF0aC5wb3coTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5zY2FsZV9mYWN0b3JzKSwgMC41KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkLlRpbGVTb3VyY2UuYXBwbHkoIHRoaXMsIFsgb3B0aW9ucyBdICk7XG59O1xuXG4kLmV4dGVuZCggJC5JSUlGVGlsZVNvdXJjZS5wcm90b3R5cGUsICQuVGlsZVNvdXJjZS5wcm90b3R5cGUsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5JSUlGVGlsZVNvdXJjZS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBkYXRhIGFuZC9vciB1cmwgaW1wbHkgdGhlIGltYWdlIHNlcnZpY2UgaXMgc3VwcG9ydGVkIGJ5XG4gICAgICogdGhpcyB0aWxlIHNvdXJjZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25hbCAtIHVybFxuICAgICAqL1xuICAgICBcbiAgICBzdXBwb3J0czogZnVuY3Rpb24oIGRhdGEsIHVybCApIHtcbiAgICAgICAgLy8gVmVyc2lvbiAyLjAgYW5kIGZvcndhcmRzXG4gICAgICAgIGlmIChkYXRhLnByb3RvY29sICYmIGRhdGEucHJvdG9jb2wgPT0gJ2h0dHA6Ly9paWlmLmlvL2FwaS9pbWFnZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBWZXJzaW9uIDEuMVxuICAgICAgICB9IGVsc2UgaWYgKCBkYXRhWydAY29udGV4dCddICYmIChcbiAgICAgICAgICAgIGRhdGFbJ0Bjb250ZXh0J10gPT0gXCJodHRwOi8vbGlicmFyeS5zdGFuZm9yZC5lZHUvaWlpZi9pbWFnZS1hcGkvMS4xL2NvbnRleHQuanNvblwiIHx8XG4gICAgICAgICAgICBkYXRhWydAY29udGV4dCddID09IFwiaHR0cDovL2lpaWYuaW8vYXBpL2ltYWdlLzEvY29udGV4dC5qc29uXCIpICkge1xuICAgICAgICAgICAgLy8gTi5CLiB0aGUgaWlpZi5pbyBjb250ZXh0IGlzIHdyb25nLCBidXQgd2hlcmUgdGhlIHJlcHJlc2VudGF0aW9uIGxpdmVzIHNvIGxpa2VseSB0byBiZSB1c2VkXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBWZXJzaW9uIDEuMFxuICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLnByb2ZpbGUgJiZcbiAgICAgICAgICAgIGRhdGEucHJvZmlsZS5pbmRleE9mKFwiaHR0cDovL2xpYnJhcnkuc3RhbmZvcmQuZWR1L2lpaWYvaW1hZ2UtYXBpL2NvbXBsaWFuY2UuaHRtbFwiKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIGRhdGEuaWRlbnRpZmllciAmJiBkYXRhLndpZHRoICYmIGRhdGEuaGVpZ2h0ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIGRhdGEuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgICAgICAgICBcImluZm9cIiA9PSBkYXRhLmRvY3VtZW50RWxlbWVudC50YWdOYW1lICYmXG4gICAgICAgICAgICBcImh0dHA6Ly9saWJyYXJ5LnN0YW5mb3JkLmVkdS9paWlmL2ltYWdlLWFwaS9ucy9cIiA9PVxuICAgICAgICAgICAgICAgIGRhdGEuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gTm90IElJSUZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdGhlIHJhdyBjb25maWd1cmF0aW9uXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+SUlJRiAxLjEgSW5mbyBMb29rcyBsaWtlIHRoaXM8L2NhcHRpb24+XG4gICAgICoge1xuICAgICAqICAgXCJAY29udGV4dFwiIDogXCJodHRwOi8vbGlicmFyeS5zdGFuZm9yZC5lZHUvaWlpZi9pbWFnZS1hcGkvMS4xL2NvbnRleHQuanNvblwiLFxuICAgICAqICAgXCJAaWRcIiA6IFwiaHR0cDovL2lpaWYuZXhhbXBsZS5jb20vcHJlZml4LzFFMzQ3NTBELTM4REItNDgyNS1BMzhBLUI2MEEzNDVFNTkxQ1wiLFxuICAgICAqICAgXCJ3aWR0aFwiIDogNjAwMCxcbiAgICAgKiAgIFwiaGVpZ2h0XCIgOiA0MDAwLFxuICAgICAqICAgXCJzY2FsZV9mYWN0b3JzXCIgOiBbIDEsIDIsIDQgXSxcbiAgICAgKiAgIFwidGlsZV93aWR0aFwiIDogMTAyNCxcbiAgICAgKiAgIFwidGlsZV9oZWlnaHRcIiA6IDEwMjQsXG4gICAgICogICBcImZvcm1hdHNcIiA6IFsgXCJqcGdcIiwgXCJwbmdcIiBdLFxuICAgICAqICAgXCJxdWFsaXRpZXNcIiA6IFsgXCJuYXRpdmVcIiwgXCJncmV5XCIgXSxcbiAgICAgKiAgIFwicHJvZmlsZVwiIDogXCJodHRwOi8vbGlicmFyeS5zdGFuZm9yZC5lZHUvaWlpZi9pbWFnZS1hcGkvMS4xL2NvbXBsaWFuY2UuaHRtbCNsZXZlbDBcIlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKXtcbiAgICAgICAgLy8gVHJ5IHRvIGRlZHVjZSBvdXIgdmVyc2lvbiBhbmQgZmFrZSBpdCB1cHdhcmRzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoICEkLmlzUGxhaW5PYmplY3QoZGF0YSkgKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbmZpZ3VyZUZyb21YbWwxMCggZGF0YSApO1xuICAgICAgICAgICAgb3B0aW9uc1snQGNvbnRleHQnXSA9IFwiaHR0cDovL2lpaWYuaW8vYXBpL2ltYWdlLzEuMC9jb250ZXh0Lmpzb25cIjtcbiAgICAgICAgICAgIG9wdGlvbnNbJ0BpZCddID0gdXJsLnJlcGxhY2UoJy9pbmZvLnhtbCcsICcnKTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKCAhZGF0YVsnQGNvbnRleHQnXSApIHtcbiAgICAgICAgICAgIGRhdGFbJ0Bjb250ZXh0J10gPSAnaHR0cDovL2lpaWYuaW8vYXBpL2ltYWdlLzEuMC9jb250ZXh0Lmpzb24nO1xuICAgICAgICAgICAgZGF0YVsnQGlkJ10gPSB1cmwucmVwbGFjZSgnL2luZm8uanNvbicsICcnKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0aWxlV2lkdGggZm9yIHRoZSBnaXZlbiBsZXZlbC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXRUaWxlV2lkdGg6IGZ1bmN0aW9uKCBsZXZlbCApIHtcblxuICAgICAgICBpZih0aGlzLmVtdWxhdGVMZWdhY3lJbWFnZVB5cmFtaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkLlRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVXaWR0aC5jYWxsKHRoaXMsIGxldmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IE1hdGgucG93KDIsIHRoaXMubWF4TGV2ZWwgLSBsZXZlbCk7XG5cbiAgICAgICAgaWYgKHRoaXMudGlsZVNpemVQZXJTY2FsZUZhY3RvciAmJiB0aGlzLnRpbGVTaXplUGVyU2NhbGVGYWN0b3Jbc2NhbGVGYWN0b3JdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZVBlclNjYWxlRmFjdG9yW3NjYWxlRmFjdG9yXS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZVdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRpbGVIZWlnaHQgZm9yIHRoZSBnaXZlbiBsZXZlbC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXRUaWxlSGVpZ2h0OiBmdW5jdGlvbiggbGV2ZWwgKSB7XG5cbiAgICAgICAgaWYodGhpcy5lbXVsYXRlTGVnYWN5SW1hZ2VQeXJhbWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlSGVpZ2h0LmNhbGwodGhpcywgbGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gTWF0aC5wb3coMiwgdGhpcy5tYXhMZXZlbCAtIGxldmVsKTtcblxuICAgICAgICBpZiAodGhpcy50aWxlU2l6ZVBlclNjYWxlRmFjdG9yICYmIHRoaXMudGlsZVNpemVQZXJTY2FsZUZhY3RvcltzY2FsZUZhY3Rvcl0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplUGVyU2NhbGVGYWN0b3Jbc2NhbGVGYWN0b3JdLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZUhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgZ2V0TGV2ZWxTY2FsZTogZnVuY3Rpb24gKCBsZXZlbCApIHtcblxuICAgICAgICBpZih0aGlzLmVtdWxhdGVMZWdhY3lJbWFnZVB5cmFtaWQpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbFNjYWxlID0gTmFOO1xuICAgICAgICAgICAgaWYgKHRoaXMubGV2ZWxzLmxlbmd0aCA+IDAgJiYgbGV2ZWwgPj0gdGhpcy5taW5MZXZlbCAmJiBsZXZlbCA8PSB0aGlzLm1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxTY2FsZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGV2ZWxzW2xldmVsXS53aWR0aCAvXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGV2ZWxzW3RoaXMubWF4TGV2ZWxdLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxldmVsU2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJC5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRMZXZlbFNjYWxlLmNhbGwodGhpcywgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXROdW1UaWxlczogZnVuY3Rpb24oIGxldmVsICkge1xuXG4gICAgICAgIGlmKHRoaXMuZW11bGF0ZUxlZ2FjeUltYWdlUHlyYW1pZCkge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRMZXZlbFNjYWxlKGxldmVsKTtcbiAgICAgICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCgxLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0TnVtVGlsZXMuY2FsbCh0aGlzLCBsZXZlbCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludFxuICAgICAqL1xuICAgIGdldFRpbGVBdFBvaW50OiBmdW5jdGlvbiggbGV2ZWwsIHBvaW50ICkge1xuXG4gICAgICAgIGlmKHRoaXMuZW11bGF0ZUxlZ2FjeUltYWdlUHlyYW1pZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUF0UG9pbnQuY2FsbCh0aGlzLCBsZXZlbCwgcG9pbnQpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciByZXRyaWV2aW5nIHRoZSB1cmwgd2hpY2ggd2lsbCByZXR1cm4gYW4gaW1hZ2UgZm9yIHRoZVxuICAgICAqIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHgsIHksIGFuZCBsZXZlbCBjb21wb25lbnRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCAtIHogaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgZ2V0VGlsZVVybDogZnVuY3Rpb24oIGxldmVsLCB4LCB5ICl7XG5cbiAgICAgICAgaWYodGhpcy5lbXVsYXRlTGVnYWN5SW1hZ2VQeXJhbWlkKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gbnVsbDtcbiAgICAgICAgICAgIGlmICggdGhpcy5sZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbCA+PSB0aGlzLm1pbkxldmVsICYmIGxldmVsIDw9IHRoaXMubWF4TGV2ZWwgKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5sZXZlbHNbIGxldmVsIF0udXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIyBjb25zdGFudHNcbiAgICAgICAgdmFyIElJSUZfUk9UQVRJT04gPSAnMCcsXG4gICAgICAgICAgICAvLyMjIGdldCB0aGUgc2NhbGUgKGxldmVsIGFzIGEgZGVjaW1hbClcbiAgICAgICAgICAgIHNjYWxlID0gTWF0aC5wb3coIDAuNSwgdGhpcy5tYXhMZXZlbCAtIGxldmVsICksXG5cbiAgICAgICAgICAgIC8vIyBpbWFnZSBkaW1lbnNpb25zIGF0IHRoaXMgbGV2ZWxcbiAgICAgICAgICAgIGxldmVsV2lkdGggPSBNYXRoLmNlaWwoIHRoaXMud2lkdGggKiBzY2FsZSApLFxuICAgICAgICAgICAgbGV2ZWxIZWlnaHQgPSBNYXRoLmNlaWwoIHRoaXMuaGVpZ2h0ICogc2NhbGUgKSxcblxuICAgICAgICAgICAgLy8jIyBpaWlmIHJlZ2lvblxuICAgICAgICAgICAgdGlsZVdpZHRoLFxuICAgICAgICAgICAgdGlsZUhlaWdodCxcbiAgICAgICAgICAgIGlpaWZUaWxlU2l6ZVdpZHRoLFxuICAgICAgICAgICAgaWlpZlRpbGVTaXplSGVpZ2h0LFxuICAgICAgICAgICAgaWlpZlJlZ2lvbixcbiAgICAgICAgICAgIGlpaWZUaWxlWCxcbiAgICAgICAgICAgIGlpaWZUaWxlWSxcbiAgICAgICAgICAgIGlpaWZUaWxlVyxcbiAgICAgICAgICAgIGlpaWZUaWxlSCxcbiAgICAgICAgICAgIGlpaWZTaXplLFxuICAgICAgICAgICAgaWlpZlF1YWxpdHksXG4gICAgICAgICAgICB1cmk7XG5cbiAgICAgICAgdGlsZVdpZHRoID0gdGhpcy5nZXRUaWxlV2lkdGgobGV2ZWwpO1xuICAgICAgICB0aWxlSGVpZ2h0ID0gdGhpcy5nZXRUaWxlSGVpZ2h0KGxldmVsKTtcbiAgICAgICAgaWlpZlRpbGVTaXplV2lkdGggPSBNYXRoLmNlaWwoIHRpbGVXaWR0aCAvIHNjYWxlICk7XG4gICAgICAgIGlpaWZUaWxlU2l6ZUhlaWdodCA9IE1hdGguY2VpbCggdGlsZUhlaWdodCAvIHNjYWxlICk7XG5cbiAgICAgICAgaWYgKCB0aGlzWydAY29udGV4dCddLmluZGV4T2YoJy8xLjAvY29udGV4dC5qc29uJykgPiAtMSB8fFxuICAgICAgICAgICAgIHRoaXNbJ0Bjb250ZXh0J10uaW5kZXhPZignLzEuMS9jb250ZXh0Lmpzb24nKSA+IC0xIHx8XG4gICAgICAgICAgICAgdGhpc1snQGNvbnRleHQnXS5pbmRleE9mKCcvMS9jb250ZXh0Lmpzb24nKSA+IC0xICkge1xuICAgICAgICAgICAgaWlpZlF1YWxpdHkgPSBcIm5hdGl2ZS5qcGdcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpaWZRdWFsaXR5ID0gXCJkZWZhdWx0LmpwZ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBsZXZlbFdpZHRoIDwgdGlsZVdpZHRoICYmIGxldmVsSGVpZ2h0IDwgdGlsZUhlaWdodCApe1xuICAgICAgICAgICAgaWlpZlNpemUgPSBsZXZlbFdpZHRoICsgXCIsXCI7XG4gICAgICAgICAgICBpaWlmUmVnaW9uID0gJ2Z1bGwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWlpZlRpbGVYID0geCAqIGlpaWZUaWxlU2l6ZVdpZHRoO1xuICAgICAgICAgICAgaWlpZlRpbGVZID0geSAqIGlpaWZUaWxlU2l6ZUhlaWdodDtcbiAgICAgICAgICAgIGlpaWZUaWxlVyA9IE1hdGgubWluKCBpaWlmVGlsZVNpemVXaWR0aCwgdGhpcy53aWR0aCAtIGlpaWZUaWxlWCApO1xuICAgICAgICAgICAgaWlpZlRpbGVIID0gTWF0aC5taW4oIGlpaWZUaWxlU2l6ZUhlaWdodCwgdGhpcy5oZWlnaHQgLSBpaWlmVGlsZVkgKTtcbiAgICAgICAgICAgIGlpaWZTaXplID0gTWF0aC5jZWlsKCBpaWlmVGlsZVcgKiBzY2FsZSApICsgXCIsXCI7XG4gICAgICAgICAgICBpaWlmUmVnaW9uID0gWyBpaWlmVGlsZVgsIGlpaWZUaWxlWSwgaWlpZlRpbGVXLCBpaWlmVGlsZUggXS5qb2luKCAnLCcgKTtcbiAgICAgICAgfVxuICAgICAgICB1cmkgPSBbIHRoaXNbJ0BpZCddLCBpaWlmUmVnaW9uLCBpaWlmU2l6ZSwgSUlJRl9ST1RBVElPTiwgaWlpZlF1YWxpdHkgXS5qb2luKCAnLycgKTtcblxuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cblxuICB9KTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIGFyYml0cmFyeSB0aWxlIHJlcXVlc3RzIGNhbiBiZSBtYWRlIGFnYWluc3QgYSBzZXJ2aWNlIHdpdGggdGhlIGdpdmVuIHByb2ZpbGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvZmlsZSAtIElJSUYgcHJvZmlsZSBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5CZVRpbGVkIChwcm9maWxlICkge1xuICAgICAgICB2YXIgbGV2ZWwwUHJvZmlsZXMgPSBbXG4gICAgICAgICAgICBcImh0dHA6Ly9saWJyYXJ5LnN0YW5mb3JkLmVkdS9paWlmL2ltYWdlLWFwaS9jb21wbGlhbmNlLmh0bWwjbGV2ZWwwXCIsXG4gICAgICAgICAgICBcImh0dHA6Ly9saWJyYXJ5LnN0YW5mb3JkLmVkdS9paWlmL2ltYWdlLWFwaS8xLjEvY29tcGxpYW5jZS5odG1sI2xldmVsMFwiLFxuICAgICAgICAgICAgXCJodHRwOi8vaWlpZi5pby9hcGkvaW1hZ2UvMi9sZXZlbDAuanNvblwiXG4gICAgICAgIF07XG4gICAgICAgIHZhciBpc0xldmVsMCA9IChsZXZlbDBQcm9maWxlcy5pbmRleE9mKHByb2ZpbGVbMF0pICE9IC0xKTtcbiAgICAgICAgcmV0dXJuICFpc0xldmVsMCB8fCAocHJvZmlsZS5pbmRleE9mKFwic2l6ZUJ5V1wiKSAhPSAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIGxlZ2FjeSBweXJhbWlkIFVSTHMgKG9uZSB0aWxlIHBlciBsZXZlbClcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGluZm9Kc29uXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RydWN0TGV2ZWxzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IFtdO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxvcHRpb25zLnNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXZlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsOiBvcHRpb25zWydAaWQnXSArICcvZnVsbC8nICsgb3B0aW9ucy5zaXplc1tpXS53aWR0aCArICcsLzAvZGVmYXVsdC5qcGcnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLnNpemVzW2ldLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9ucy5zaXplc1tpXS5oZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZXZlbHMuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLndpZHRoIC0gYi53aWR0aDt9KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZUZyb21YbWwxMCh4bWxEb2MpIHtcbiAgICAgICAgLy9wYXJzZSB0aGUgeG1sXG4gICAgICAgIGlmICggIXhtbERvYyB8fCAheG1sRG9jLmRvY3VtZW50RWxlbWVudCApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJC5nZXRTdHJpbmcoIFwiRXJyb3JzLlhtbFwiICkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290ICAgICAgICAgICAgPSB4bWxEb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgcm9vdE5hbWUgICAgICAgID0gcm9vdC50YWdOYW1lLFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbiAgID0gbnVsbDtcblxuICAgICAgICBpZiAoIHJvb3ROYW1lID09IFwiaW5mb1wiICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgICAgICAgICAgcGFyc2VYTUwxMCggcm9vdCwgY29uZmlndXJhdGlvbiApO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uO1xuXG4gICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSBpbnN0YW5jZW9mIEVycm9yKSA/XG4gICAgICAgICAgICAgICAgICAgIGUgOlxuICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKFwiRXJyb3JzLklJSUZcIikgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICQuZ2V0U3RyaW5nKCBcIkVycm9ycy5JSUlGXCIgKSApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlWE1MMTAoIG5vZGUsIGNvbmZpZ3VyYXRpb24sIHByb3BlcnR5ICkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICBpZiAoIG5vZGUubm9kZVR5cGUgPT0gMyAmJiBwcm9wZXJ0eSApIHsvL3RleHQgbm9kZVxuICAgICAgICAgICAgdmFsdWUgPSBub2RlLm5vZGVWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICBpZiggdmFsdWUubWF0Y2goL15cXGQqJC8pKXtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlciggdmFsdWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCAhY29uZmlndXJhdGlvblsgcHJvcGVydHkgXSApe1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25bIHByb3BlcnR5IF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGlmKCAhJC5pc0FycmF5KCBjb25maWd1cmF0aW9uWyBwcm9wZXJ0eSBdICkgKXtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvblsgcHJvcGVydHkgXSA9IFsgY29uZmlndXJhdGlvblsgcHJvcGVydHkgXSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uWyBwcm9wZXJ0eSBdLnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggbm9kZS5ub2RlVHlwZSA9PSAxICl7XG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgICAgcGFyc2VYTUwxMCggbm9kZS5jaGlsZE5vZGVzWyBpIF0sIGNvbmZpZ3VyYXRpb24sIG5vZGUubm9kZU5hbWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gT3NtVGlsZVNvdXJjZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKlxuICogRGVyaXZlZCBmcm9tIHRoZSBPU00gdGlsZSBzb3VyY2UgaW4gUmFpbmVyIFNpbW9uJ3Mgc2VhamF4LXV0aWxzIHByb2plY3RcbiAqIDxodHRwOi8vZ2l0aHViLmNvbS9yc2ltb24vc2VhamF4LXV0aWxzPi4gIFJhaW5lciBTaW1vbiBoYXMgY29udHJpYnV0ZWRcbiAqIHRoZSBpbmNsdWRlZCBjb2RlIHRvIHRoZSBPcGVuU2VhZHJhZ29uIHByb2plY3QgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZTtcbiAqIHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL29wZW5zZWFkcmFnb24vb3BlbnNlYWRyYWdvbi9pc3N1ZXMvNTg+LlxuICovXG5cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8qKlxuICogQGNsYXNzIE9zbVRpbGVTb3VyY2VcbiAqIEBjbGFzc2Rlc2MgQSB0aWxlc291cmNlIGltcGxlbWVudGF0aW9uIGZvciBPcGVuU3RyZWV0TWFwLjxicj48YnI+XG4gKlxuICogTm90ZSAxLiBab29tbGV2ZWxzLiBEZWVwIFpvb20gYW5kIE9TTSBkZWZpbmUgem9vbSBsZXZlbHMgZGlmZmVyZW50bHkuIEluICBEZWVwXG4gKiBab29tLCBsZXZlbCAwIGVxdWFscyBhbiBpbWFnZSBvZiAxeDEgcGl4ZWxzLiBJbiBPU00sIGxldmVsIDAgZXF1YWxzIGFuIGltYWdlIG9mXG4gKiAyNTZ4MjU2IGxldmVscyAoc2VlIGh0dHA6Ly9nYXNpLmNoL2Jsb2cvaW5zaWRlLWRlZXAtem9vbS0yKS4gSS5lLiB0aGVyZSBpcyBhXG4gKiBkaWZmZXJlbmNlIG9mIGxvZzIoMjU2KT04IGxldmVscy48YnI+PGJyPlxuICpcbiAqIE5vdGUgMi4gSW1hZ2UgZGltZW5zaW9uLiBBY2NvcmRpbmcgdG8gdGhlIE9TTSBXaWtpXG4gKiAoaHR0cDovL3dpa2kub3BlbnN0cmVldG1hcC5vcmcvd2lraS9TbGlwcHlfbWFwX3RpbGVuYW1lcyNab29tX2xldmVscylcbiAqIHRoZSBoaWdoZXN0IE1hcG5payB6b29tIGxldmVsIGhhcyAyNTYuMTQ0eDI1Ni4xNDQgdGlsZXMsIHdpdGggYSAyNTZ4MjU2XG4gKiBwaXhlbCBzaXplLiBJLmUuIHRoZSBEZWVwIFpvb20gaW1hZ2UgZGltZW5zaW9uIGlzIDY1LjU3Mi44NjR4NjUuNTcyLjg2NFxuICogcGl4ZWxzLlxuICpcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2VcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gd2lkdGggLSB0aGUgcGl4ZWwgd2lkdGggb2YgdGhlIGltYWdlIG9yIHRoZSBpZGlvbWF0aWNcbiAqICAgICAgb3B0aW9ucyBvYmplY3Qgd2hpY2ggaXMgdXNlZCBpbnN0ZWFkIG9mIHBvc2l0aW9uYWwgYXJndW1lbnRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVTaXplXG4gKiBAcGFyYW0ge051bWJlcn0gdGlsZU92ZXJsYXBcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aWxlc1VybFxuICovXG4kLk9zbVRpbGVTb3VyY2UgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCwgdGlsZVNpemUsIHRpbGVPdmVybGFwLCB0aWxlc1VybCApIHtcbiAgICB2YXIgb3B0aW9ucztcblxuICAgIGlmKCAkLmlzUGxhaW5PYmplY3QoIHdpZHRoICkgKXtcbiAgICAgICAgb3B0aW9ucyA9IHdpZHRoO1xuICAgIH1lbHNle1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgd2lkdGg6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGhlaWdodDogYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgdGlsZVNpemU6IGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgIHRpbGVPdmVybGFwOiBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICB0aWxlc1VybDogYXJndW1lbnRzWzRdXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vYXBwbHkgZGVmYXVsdCBzZXR0aW5nIGZvciBzdGFuZGFyZCBwdWJsaWMgT3BlblN0cmVhdE1hcHMgc2VydmljZVxuICAgIC8vYnV0IGFsbG93IHRoZW0gdG8gYmUgc3BlY2lmaWVkIHNvIGZsaWtzIGNhbiBob3N0IHRoZXJlIG93biBpbnN0YW5jZVxuICAgIC8vb3IgYXBwbHkgYWdhaW5zdCBvdGhlciBzZXJ2aWNlcyBzdXBwb3J0dGluZyB0aGUgc2FtZSBzdGFuZGFyZFxuICAgIGlmKCAhb3B0aW9ucy53aWR0aCB8fCAhb3B0aW9ucy5oZWlnaHQgKXtcbiAgICAgICAgb3B0aW9ucy53aWR0aCA9IDY1NTcyODY0O1xuICAgICAgICBvcHRpb25zLmhlaWdodCA9IDY1NTcyODY0O1xuICAgIH1cbiAgICBpZiggIW9wdGlvbnMudGlsZVNpemUgKXtcbiAgICAgICAgb3B0aW9ucy50aWxlU2l6ZSA9IDI1NjtcbiAgICAgICAgb3B0aW9ucy50aWxlT3ZlcmxhcCA9IDA7XG4gICAgfVxuICAgIGlmKCAhb3B0aW9ucy50aWxlc1VybCApe1xuICAgICAgICBvcHRpb25zLnRpbGVzVXJsID0gXCJodHRwOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy9cIjtcbiAgICB9XG4gICAgb3B0aW9ucy5taW5MZXZlbCA9IDg7XG5cbiAgICAkLlRpbGVTb3VyY2UuYXBwbHkoIHRoaXMsIFsgb3B0aW9ucyBdICk7XG5cbn07XG5cbiQuZXh0ZW5kKCAkLk9zbVRpbGVTb3VyY2UucHJvdG90eXBlLCAkLlRpbGVTb3VyY2UucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uT3NtVGlsZVNvdXJjZS5wcm90b3R5cGUgKi97XG5cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgZGF0YSBhbmQvb3IgdXJsIGltcGx5IHRoZSBpbWFnZSBzZXJ2aWNlIGlzIHN1cHBvcnRlZCBieVxuICAgICAqIHRoaXMgdGlsZSBzb3VyY2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uYWwgLSB1cmxcbiAgICAgKi9cbiAgICBzdXBwb3J0czogZnVuY3Rpb24oIGRhdGEsIHVybCApe1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGF0YS50eXBlICYmXG4gICAgICAgICAgICBcIm9wZW5zdHJlZXRtYXBzXCIgPT0gZGF0YS50eXBlXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0aGUgcmF3IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gdGhlIHVybCB0aGUgZGF0YSB3YXMgcmV0cmVpdmVkIGZyb20gaWYgYW55LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb3B0aW9ucyAtIEEgZGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cyBzdWZmaWNpZW50XG4gICAgICogICAgICB0byBjb25maWd1cmUgdGhpcyB0aWxlIHNvdXJjZXMgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbiggZGF0YSwgdXJsICl7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKi9cbiAgICBnZXRUaWxlVXJsOiBmdW5jdGlvbiggbGV2ZWwsIHgsIHkgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzVXJsICsgKGxldmVsIC0gOCkgKyBcIi9cIiArIHggKyBcIi9cIiArIHkgKyBcIi5wbmdcIjtcbiAgICB9XG59KTtcblxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFRtc1RpbGVTb3VyY2VcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLypcbiAqIERlcml2ZWQgZnJvbSB0aGUgVE1TIHRpbGUgc291cmNlIGluIFJhaW5lciBTaW1vbidzIHNlYWpheC11dGlscyBwcm9qZWN0XG4gKiA8aHR0cDovL2dpdGh1Yi5jb20vcnNpbW9uL3NlYWpheC11dGlscz4uICBSYWluZXIgU2ltb24gaGFzIGNvbnRyaWJ1dGVkXG4gKiB0aGUgaW5jbHVkZWQgY29kZSB0byB0aGUgT3BlblNlYWRyYWdvbiBwcm9qZWN0IHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2U7XG4gKiBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuc2VhZHJhZ29uL29wZW5zZWFkcmFnb24vaXNzdWVzLzU4Pi5cbiAqL1xuXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBUbXNUaWxlU291cmNlXG4gKiBAY2xhc3NkZXNjIEEgdGlsZXNvdXJjZSBpbXBsZW1lbnRhdGlvbiBmb3IgVGlsZWQgTWFwIFNlcnZpY2VzIChUTVMpLlxuICogVE1TIHRpbGUgc2NoZW1lICggWyBhcyBzdXBwb3J0ZWQgYnkgT3BlbkxheWVycyBdIGlzIGRlc2NyaWJlZCBoZXJlXG4gKiAoIGh0dHA6Ly9vcGVubGF5ZXJzLm9yZy9kZXYvZXhhbXBsZXMvdG1zLmh0bWwgKS5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5UaWxlU291cmNlXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHdpZHRoIC0gdGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBpbWFnZSBvciB0aGUgaWRpb21hdGljXG4gKiAgICAgIG9wdGlvbnMgb2JqZWN0IHdoaWNoIGlzIHVzZWQgaW5zdGVhZCBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aWxlU2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVPdmVybGFwXG4gKiBAcGFyYW0ge1N0cmluZ30gdGlsZXNVcmxcbiAqL1xuJC5UbXNUaWxlU291cmNlID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIHRpbGVTaXplLCB0aWxlT3ZlcmxhcCwgdGlsZXNVcmwgKSB7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiggJC5pc1BsYWluT2JqZWN0KCB3aWR0aCApICl7XG4gICAgICAgIG9wdGlvbnMgPSB3aWR0aDtcbiAgICB9ZWxzZXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIHRpbGVTaXplOiBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICB0aWxlT3ZlcmxhcDogYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgdGlsZXNVcmw6IGFyZ3VtZW50c1s0XVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBUTVMgaGFzIGludGVnZXIgbXVsdGlwbGVzIG9mIDI1NiBmb3Igd2lkdGgvaGVpZ2h0IGFuZCBhZGRzIGJ1ZmZlclxuICAgIC8vIGlmIG5lY2Vzc2FyeSAtPiBhY2NvdW50IGZvciB0aGlzIVxuICAgIHZhciBidWZmZXJlZFdpZHRoID0gTWF0aC5jZWlsKG9wdGlvbnMud2lkdGggLyAyNTYpICogMjU2LFxuICAgICAgICBidWZmZXJlZEhlaWdodCA9IE1hdGguY2VpbChvcHRpb25zLmhlaWdodCAvIDI1NikgKiAyNTYsXG4gICAgICAgIG1heDtcblxuICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgaW4gdGhpcyB0aWxlc2V0XG4gICAgaWYgKGJ1ZmZlcmVkV2lkdGggPiBidWZmZXJlZEhlaWdodCkge1xuICAgICAgICBtYXggPSBidWZmZXJlZFdpZHRoIC8gMjU2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9IGJ1ZmZlcmVkSGVpZ2h0IC8gMjU2O1xuICAgIH1cbiAgICBvcHRpb25zLm1heExldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heCkvTWF0aC5sb2coMikpIC0gMTtcbiAgICBvcHRpb25zLnRpbGVTaXplID0gMjU2O1xuICAgIG9wdGlvbnMud2lkdGggPSBidWZmZXJlZFdpZHRoO1xuICAgIG9wdGlvbnMuaGVpZ2h0ID0gYnVmZmVyZWRIZWlnaHQ7XG5cbiAgICAkLlRpbGVTb3VyY2UuYXBwbHkoIHRoaXMsIFsgb3B0aW9ucyBdICk7XG5cbn07XG5cbiQuZXh0ZW5kKCAkLlRtc1RpbGVTb3VyY2UucHJvdG90eXBlLCAkLlRpbGVTb3VyY2UucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uVG1zVGlsZVNvdXJjZS5wcm90b3R5cGUgKi97XG5cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgZGF0YSBhbmQvb3IgdXJsIGltcGx5IHRoZSBpbWFnZSBzZXJ2aWNlIGlzIHN1cHBvcnRlZCBieVxuICAgICAqIHRoaXMgdGlsZSBzb3VyY2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uYWwgLSB1cmxcbiAgICAgKi9cbiAgICBzdXBwb3J0czogZnVuY3Rpb24oIGRhdGEsIHVybCApe1xuICAgICAgICByZXR1cm4gKCBkYXRhLnR5cGUgJiYgXCJ0aWxlZG1hcHNlcnZpY2VcIiA9PSBkYXRhLnR5cGUgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHRoZSByYXcgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSB0aGUgdXJsIHRoZSBkYXRhIHdhcyByZXRyZWl2ZWQgZnJvbSBpZiBhbnkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvcHRpb25zIC0gQSBkaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHN1ZmZpY2llbnRcbiAgICAgKiAgICAgIHRvIGNvbmZpZ3VyZSB0aGlzIHRpbGUgc291cmNlcyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uKCBkYXRhLCB1cmwgKXtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGdldFRpbGVVcmw6IGZ1bmN0aW9uKCBsZXZlbCwgeCwgeSApIHtcbiAgICAgICAgLy8gQ29udmVydCBmcm9tIERlZXAgWm9vbSBkZWZpbml0aW9uIHRvIFRNUyB6b29tIGRlZmluaXRpb25cbiAgICAgICAgdmFyIHlUaWxlcyA9IHRoaXMuZ2V0TnVtVGlsZXMoIGxldmVsICkueSAtIDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZXNVcmwgKyBsZXZlbCArIFwiL1wiICsgeCArIFwiL1wiICsgICh5VGlsZXMgLSB5KSArIFwiLnBuZ1wiO1xuICAgIH1cbn0pO1xuXG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gTGVnYWN5VGlsZVNvdXJjZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgTGVnYWN5VGlsZVNvdXJjZVxuICogQGNsYXNzZGVzYyBUaGUgTGVnYWN5VGlsZVNvdXJjZSBhbGxvd3Mgc2ltcGxlLCB0cmFkaXRpb25hbCBpbWFnZSBweXJhbWlkcyB0byBiZSBsb2FkZWRcbiAqIGludG8gYW4gT3BlblNlYWRyYWdvbiBWaWV3ZXIuICBCYXNpY2FsbHksIHRoaXMgdHJhbnNsYXRlcyB0byB0aGUgaGlzdG9yaWNhbGx5XG4gKiBjb21tb24gcHJhY3RpY2Ugb2Ygc3RhcnRpbmcgd2l0aCBhICdtYXN0ZXInIGltYWdlLCBtYXliZSBhIHRpZmYgZm9yIGV4YW1wbGUsXG4gKiBhbmQgZ2VuZXJhdGluZyBhIHNldCBvZiAnc2VydmljZScgaW1hZ2VzIGxpa2Ugb25lIG9yIG1vcmUgdGh1bWJuYWlscywgYSBtZWRpdW1cbiAqIHJlc29sdXRpb24gaW1hZ2UgYW5kIGEgaGlnaCByZXNvbHV0aW9uIGltYWdlIGluIHN0YW5kYXJkIHdlYiBmb3JtYXRzIGxpa2VcbiAqIHBuZyBvciBqcGcuXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uVGlsZVNvdXJjZVxuICogQHBhcmFtIHtBcnJheX0gbGV2ZWxzIEFuIGFycmF5IG9mIGZpbGUgZGVzY3JpcHRpb25zLCBlYWNoIGlzIGFuIG9iamVjdCB3aXRoXG4gKiAgICAgIGEgJ3VybCcsIGEgJ3dpZHRoJywgYW5kIGEgJ2hlaWdodCcuICBPdmVycmlkaW5nIGNsYXNzZXMgY2FuIGV4cGVjdCBtb3JlXG4gKiAgICAgIHByb3BlcnRpZXMgYnV0IHRoZXNlIHByb3BlcnRpZXMgYXJlIHN1ZmZpY2llbnQgZm9yIHRoaXMgaW1wbGVtZW50YXRpb24uXG4gKiAgICAgIEFkZGl0aW9uYWxseSwgdGhlIGxldmVscyBhcmUgcmVxdWlyZWQgdG8gYmUgbGlzdGVkIGluIG9yZGVyIGZyb21cbiAqICAgICAgc21hbGxlc3QgdG8gbGFyZ2VzdC5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhc3BlY3RSYXRpb1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aWxlU2l6ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbGVPdmVybGFwXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluTGV2ZWxcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhMZXZlbFxuICogQHByb3BlcnR5IHtBcnJheX0gIGxldmVsc1xuICovXG4kLkxlZ2FjeVRpbGVTb3VyY2UgPSBmdW5jdGlvbiggbGV2ZWxzICkge1xuXG4gICAgdmFyIG9wdGlvbnMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQ7XG5cbiAgICBpZiggJC5pc0FycmF5KCBsZXZlbHMgKSApe1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgdHlwZTogJ2xlZ2FjeS1pbWFnZS1weXJhbWlkJyxcbiAgICAgICAgICAgIGxldmVsczogbGV2ZWxzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9jbGVhbiB1cCB0aGUgbGV2ZWxzIHRvIG1ha2Ugc3VyZSB3ZSBzdXBwb3J0IGFsbCBmb3JtYXRzXG4gICAgb3B0aW9ucy5sZXZlbHMgPSBmaWx0ZXJGaWxlcyggb3B0aW9ucy5sZXZlbHMgKTtcblxuICAgIGlmICggb3B0aW9ucy5sZXZlbHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgd2lkdGggPSBvcHRpb25zLmxldmVsc1sgb3B0aW9ucy5sZXZlbHMubGVuZ3RoIC0gMSBdLndpZHRoO1xuICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmxldmVsc1sgb3B0aW9ucy5sZXZlbHMubGVuZ3RoIC0gMSBdLmhlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKCBcIk5vIHN1cHBvcnRlZCBpbWFnZSBmb3JtYXRzIGZvdW5kXCIgKTtcbiAgICB9XG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgb3B0aW9ucywge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB0aWxlU2l6ZTogTWF0aC5tYXgoIGhlaWdodCwgd2lkdGggKSxcbiAgICAgICAgdGlsZU92ZXJsYXA6IDAsXG4gICAgICAgIG1pbkxldmVsOiAwLFxuICAgICAgICBtYXhMZXZlbDogb3B0aW9ucy5sZXZlbHMubGVuZ3RoID4gMCA/IG9wdGlvbnMubGV2ZWxzLmxlbmd0aCAtIDEgOiAwXG4gICAgfSApO1xuXG4gICAgJC5UaWxlU291cmNlLmFwcGx5KCB0aGlzLCBbIG9wdGlvbnMgXSApO1xuXG4gICAgdGhpcy5sZXZlbHMgPSBvcHRpb25zLmxldmVscztcbn07XG5cbiQuZXh0ZW5kKCAkLkxlZ2FjeVRpbGVTb3VyY2UucHJvdG90eXBlLCAkLlRpbGVTb3VyY2UucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uTGVnYWN5VGlsZVNvdXJjZS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBkYXRhIGFuZC9vciB1cmwgaW1wbHkgdGhlIGltYWdlIHNlcnZpY2UgaXMgc3VwcG9ydGVkIGJ5XG4gICAgICogdGhpcyB0aWxlIHNvdXJjZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25hbCAtIHVybFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiggZGF0YSwgdXJsICl7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkYXRhLnR5cGUgJiZcbiAgICAgICAgICAgIFwibGVnYWN5LWltYWdlLXB5cmFtaWRcIiA9PSBkYXRhLnR5cGVcbiAgICAgICAgKSB8fCAoXG4gICAgICAgICAgICBkYXRhLmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgICAgICAgXCJsZWdhY3ktaW1hZ2UtcHlyYW1pZFwiID09IGRhdGEuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpXG4gICAgICAgICk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxYTUxEb2N1bWVudH0gY29uZmlndXJhdGlvbiAtIHRoZSByYXcgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhVXJsIC0gdGhlIHVybCB0aGUgZGF0YSB3YXMgcmV0cmVpdmVkIGZyb20gaWYgYW55LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb3B0aW9ucyAtIEEgZGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cyBzdWZmaWNpZW50XG4gICAgICogICAgICB0byBjb25maWd1cmUgdGhpcyB0aWxlIHNvdXJjZXMgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbiggY29uZmlndXJhdGlvbiwgZGF0YVVybCApe1xuXG4gICAgICAgIHZhciBvcHRpb25zO1xuXG4gICAgICAgIGlmKCAhJC5pc1BsYWluT2JqZWN0KGNvbmZpZ3VyYXRpb24pICl7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb25maWd1cmVGcm9tWE1MKCB0aGlzLCBjb25maWd1cmF0aW9uICk7XG5cbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb25maWd1cmVGcm9tT2JqZWN0KCB0aGlzLCBjb25maWd1cmF0aW9uICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXRMZXZlbFNjYWxlOiBmdW5jdGlvbiAoIGxldmVsICkge1xuICAgICAgICB2YXIgbGV2ZWxTY2FsZSA9IE5hTjtcbiAgICAgICAgaWYgKCB0aGlzLmxldmVscy5sZW5ndGggPiAwICYmIGxldmVsID49IHRoaXMubWluTGV2ZWwgJiYgbGV2ZWwgPD0gdGhpcy5tYXhMZXZlbCApIHtcbiAgICAgICAgICAgIGxldmVsU2NhbGUgPVxuICAgICAgICAgICAgICAgIHRoaXMubGV2ZWxzWyBsZXZlbCBdLndpZHRoIC9cbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsc1sgdGhpcy5tYXhMZXZlbCBdLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZXZlbFNjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXROdW1UaWxlczogZnVuY3Rpb24oIGxldmVsICkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldExldmVsU2NhbGUoIGxldmVsICk7XG4gICAgICAgIGlmICggc2NhbGUgKXtcbiAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCggMSwgMSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KCAwLCAwICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludFxuICAgICAqL1xuICAgIGdldFRpbGVBdFBvaW50OiBmdW5jdGlvbiggbGV2ZWwsIHBvaW50ICkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoIDAsIDAgKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgYnkgdGhpcyBjbGFzcyBvdGhlciB0aGFuIHRvIHRocm93IGFuIEVycm9yXG4gICAgICogYW5ub3VuY2luZyB5b3UgaGF2ZSB0byBpbXBsZW1lbnQgaXQuICBCZWNhdXNlIG9mIHRoZSB2YXJpZXR5IG9mIHRpbGVcbiAgICAgKiBzZXJ2ZXIgdGVjaG5vbG9naWVzLCBhbmQgdmFyaW91cyBzcGVjaWZpY2F0aW9ucyBmb3IgYnVpbGRpbmcgaW1hZ2VcbiAgICAgKiBweXJhbWlkcywgdGhpcyBtZXRob2QgaXMgaGVyZSB0byBhbGxvdyBlYXN5IGludGVncmF0aW9uLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRUaWxlVXJsOiBmdW5jdGlvbiAoIGxldmVsLCB4LCB5ICkge1xuICAgICAgICB2YXIgdXJsID0gbnVsbDtcbiAgICAgICAgaWYgKCB0aGlzLmxldmVscy5sZW5ndGggPiAwICYmIGxldmVsID49IHRoaXMubWluTGV2ZWwgJiYgbGV2ZWwgPD0gdGhpcy5tYXhMZXZlbCApIHtcbiAgICAgICAgICAgIHVybCA9IHRoaXMubGV2ZWxzWyBsZXZlbCBdLnVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn0gKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZW1vdmVzIGFueSBmaWxlcyBmcm9tIHRoZSBBcnJheSB3aGljaCBkb250IGNvbmZvcm0gdG8gb3VyXG4gKiBiYXNpYyByZXF1aXJlbWVudHMgZm9yIGEgJ2xldmVsJyBpbiB0aGUgTGVnYWN5VGlsZVNvdXJjZS5cbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJGaWxlcyggZmlsZXMgKXtcbiAgICB2YXIgZmlsdGVyZWQgPSBbXSxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgaTtcbiAgICBmb3IoIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZmlsZSA9IGZpbGVzWyBpIF07XG4gICAgICAgIGlmKCBmaWxlLmhlaWdodCAmJlxuICAgICAgICAgICAgZmlsZS53aWR0aCAmJlxuICAgICAgICAgICAgZmlsZS51cmwgJiYgKFxuICAgICAgICAgICAgICAgIGZpbGUudXJsLnRvTG93ZXJDYXNlKCkubWF0Y2goL14uKlxcLihwbmd8anBnfGpwZWd8Z2lmKSg/OlxcPy4qKT8kLykgfHwgKFxuICAgICAgICAgICAgICAgICAgICBmaWxlLm1pbWV0eXBlICYmXG4gICAgICAgICAgICAgICAgICAgIGZpbGUubWltZXR5cGUudG9Mb3dlckNhc2UoKS5tYXRjaCgvXi4qXFwvKHBuZ3xqcGd8anBlZ3xnaWYpJC8pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSApe1xuICAgICAgICAgICAgLy9UaGlzIGlzIHN1ZmZpY2llbnQgdG8gc2VydmUgYXMgYSBsZXZlbFxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsOiBmaWxlLnVybCxcbiAgICAgICAgICAgICAgICB3aWR0aDogTnVtYmVyKCBmaWxlLndpZHRoICksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoIGZpbGUuaGVpZ2h0IClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJC5jb25zb2xlLmVycm9yKCAnVW5zdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0OiAlcycsIGZpbGUudXJsID8gZmlsZS51cmwgOiAnPG5vIFVSTD4nICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyZWQuc29ydChmdW5jdGlvbihhLGIpe1xuICAgICAgICByZXR1cm4gYS5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICB9KTtcblxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjb25maWd1cmVGcm9tWE1MKCB0aWxlU291cmNlLCB4bWxEb2MgKXtcblxuICAgIGlmICggIXhtbERvYyB8fCAheG1sRG9jLmRvY3VtZW50RWxlbWVudCApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAkLmdldFN0cmluZyggXCJFcnJvcnMuWG1sXCIgKSApO1xuICAgIH1cblxuICAgIHZhciByb290ICAgICAgICAgPSB4bWxEb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICByb290TmFtZSAgICAgPSByb290LnRhZ05hbWUsXG4gICAgICAgIGNvbmYgICAgICAgICA9IG51bGwsXG4gICAgICAgIGxldmVscyAgICAgICA9IFtdLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgaTtcblxuICAgIGlmICggcm9vdE5hbWUgPT0gXCJpbWFnZVwiICkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25mID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgICByb290LmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSxcbiAgICAgICAgICAgICAgICBsZXZlbHM6ICAgICAgW11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxldmVscyA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwibGV2ZWxcIiApO1xuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuICAgICAgICAgICAgICAgIGNvbmYubGV2ZWxzIC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAgICBsZXZlbC5nZXRBdHRyaWJ1dGUoIFwidXJsXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICBwYXJzZUludCggbGV2ZWwuZ2V0QXR0cmlidXRlKCBcIndpZHRoXCIgKSwgMTAgKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludCggbGV2ZWwuZ2V0QXR0cmlidXRlKCBcImhlaWdodFwiICksIDEwIClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ3VyZUZyb21PYmplY3QoIHRpbGVTb3VyY2UsIGNvbmYgKTtcblxuICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgIHRocm93IChlIGluc3RhbmNlb2YgRXJyb3IpID9cbiAgICAgICAgICAgICAgICBlIDpcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoICdVbmtub3duIGVycm9yIHBhcnNpbmcgTGVnYWN5IEltYWdlIFB5cmFtaWQgWE1MLicgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIHJvb3ROYW1lID09IFwiY29sbGVjdGlvblwiICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdMZWdhY3kgSW1hZ2UgUHlyYW1pZCBDb2xsZWN0aW9ucyBub3QgeWV0IHN1cHBvcnRlZC4nICk7XG4gICAgfSBlbHNlIGlmICggcm9vdE5hbWUgPT0gXCJlcnJvclwiICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdFcnJvcjogJyArIHhtbERvYyApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gZWxlbWVudCAnICsgcm9vdE5hbWUgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlRnJvbU9iamVjdCggdGlsZVNvdXJjZSwgY29uZmlndXJhdGlvbiApe1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb24ubGV2ZWxzO1xuXG59XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gSW1hZ2VUaWxlU291cmNlXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiAoJCkge1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEltYWdlVGlsZVNvdXJjZVxuICAgICAqIEBjbGFzc2Rlc2MgVGhlIEltYWdlVGlsZVNvdXJjZSBhbGxvd3MgYSBzaW1wbGUgaW1hZ2UgdG8gYmUgbG9hZGVkXG4gICAgICogaW50byBhbiBPcGVuU2VhZHJhZ29uIFZpZXdlci5cbiAgICAgKiBUaGVyZSBhcmUgMiB3YXlzIHRvIG9wZW4gYW4gSW1hZ2VUaWxlU291cmNlOlxuICAgICAqIDEuIHZpZXdlci5vcGVuKHt0eXBlOiAnaW1hZ2UnLCB1cmw6IGZvb1VybH0pO1xuICAgICAqIDIuIHZpZXdlci5vcGVuKG5ldyBPcGVuU2VhZHJhZ29uLkltYWdlVGlsZVNvdXJjZSh7dXJsOiBmb29Vcmx9KSk7XG4gICAgICpcbiAgICAgKiBXaXRoIHRoZSBmaXJzdCBzeW50YXgsIHRoZSBjcm9zc09yaWdpblBvbGljeSwgYWpheFdpdGhDcmVkZW50aWFscyBhbmRcbiAgICAgKiB1c2VDYW52YXMgb3B0aW9ucyBhcmUgaW5oZXJpdGVkIGZyb20gdGhlIHZpZXdlciBpZiB0aGV5IGFyZSBub3RcbiAgICAgKiBzcGVjaWZpZWQgZGlyZWN0bHkgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLlRpbGVTb3VyY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgVVJMIG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnVpbGRQeXJhbWlkPXRydWVdIElmIHNldCB0byB0cnVlIChkZWZhdWx0KSwgYVxuICAgICAqIHB5cmFtaWQgd2lsbCBiZSBidWlsdCBpbnRlcm5hbGx5IHRvIHByb3ZpZGUgYSBiZXR0ZXIgZG93bnNhbXBsaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtvcHRpb25zLmNyb3NzT3JpZ2luUG9saWN5PWZhbHNlXSBWYWxpZCB2YWx1ZXMgYXJlXG4gICAgICogJ0Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnLCBhbmQgZmFsc2UuIElmIGZhbHNlLCBpbWFnZSByZXF1ZXN0cyB3aWxsXG4gICAgICogbm90IHVzZSBDT1JTIHByZXZlbnRpbmcgaW50ZXJuYWwgcHlyYW1pZCBidWlsZGluZyBmb3IgaW1hZ2VzIGZyb20gb3RoZXJcbiAgICAgKiBkb21haW5zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtvcHRpb25zLmFqYXhXaXRoQ3JlZGVudGlhbHM9ZmFsc2VdIFdoZXRoZXIgdG8gc2V0XG4gICAgICogdGhlIHdpdGhDcmVkZW50aWFscyBYSFIgZmxhZyBmb3IgQUpBWCByZXF1ZXN0cyAod2hlbiBsb2FkaW5nIHRpbGUgc291cmNlcykuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VDYW52YXM9dHJ1ZV0gU2V0IHRvIGZhbHNlIHRvIHByZXZlbnQgYW55IHVzZVxuICAgICAqIG9mIHRoZSBjYW52YXMgQVBJLlxuICAgICAqL1xuICAgICQuSW1hZ2VUaWxlU291cmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgYnVpbGRQeXJhbWlkOiB0cnVlLFxuICAgICAgICAgICAgY3Jvc3NPcmlnaW5Qb2xpY3k6IGZhbHNlLFxuICAgICAgICAgICAgYWpheFdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICB1c2VDYW52YXM6IHRydWVcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICQuVGlsZVNvdXJjZS5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuXG4gICAgfTtcblxuICAgICQuZXh0ZW5kKCQuSW1hZ2VUaWxlU291cmNlLnByb3RvdHlwZSwgJC5UaWxlU291cmNlLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLkltYWdlVGlsZVNvdXJjZS5wcm90b3R5cGUgKi97XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGRhdGEgYW5kL29yIHVybCBpbXBseSB0aGUgaW1hZ2Ugc2VydmljZSBpcyBzdXBwb3J0ZWQgYnlcbiAgICAgICAgICogdGhpcyB0aWxlIHNvdXJjZS5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25hbCAtIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgc3VwcG9ydHM6IGZ1bmN0aW9uIChkYXRhLCB1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnR5cGUgJiYgZGF0YS50eXBlID09PSBcImltYWdlXCI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGUgb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVVybCAtIHRoZSB1cmwgdGhlIGltYWdlIHdhcyByZXRyZWl2ZWQgZnJvbSwgaWYgYW55LlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9wdGlvbnMgLSBBIGRpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMgc3VmZmljaWVudFxuICAgICAgICAgKiAgICAgIHRvIGNvbmZpZ3VyZSB0aGlzIHRpbGUgc291cmNlcyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24gKG9wdGlvbnMsIGRhdGFVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzcG9uc2libGUgZm9yIHJldHJpZXZpbmcsIGFuZCBjYWNoaW5nIHRoZVxuICAgICAgICAgKiBpbWFnZSBtZXRhZGF0YSBwZXJ0aW5lbnQgdG8gdGhpcyBUaWxlU291cmNlcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRJbWFnZUluZm86IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jcm9zc09yaWdpblBvbGljeSkge1xuICAgICAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpblBvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFqYXhXaXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS51c2VDcmVkZW50aWFscyA9IHRoaXMuYWpheFdpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJC5hZGRFdmVudChpbWFnZSwgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgICAgICBfdGhpcy5hc3BlY3RSYXRpbyA9IF90aGlzLndpZHRoIC8gX3RoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMgPSBuZXcgJC5Qb2ludChfdGhpcy53aWR0aCwgX3RoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGlsZVdpZHRoID0gX3RoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RpbGVIZWlnaHQgPSBfdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgX3RoaXMudGlsZU92ZXJsYXAgPSAwO1xuICAgICAgICAgICAgICAgIF90aGlzLm1pbkxldmVsID0gMDtcbiAgICAgICAgICAgICAgICBfdGhpcy5sZXZlbHMgPSBfdGhpcy5fYnVpbGRMZXZlbHMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYXhMZXZlbCA9IF90aGlzLmxldmVscy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMucmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBldmVudCBpcyBkb2N1bWVudGVkIGVsc2V3aGVyZSwgaW4gVGlsZVNvdXJjZVxuICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoJ3JlYWR5Jywge3RpbGVTb3VyY2U6IF90aGlzfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJC5hZGRFdmVudChpbWFnZSwgJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgZXZlbnQgaXMgZG9jdW1lbnRlZCBlbHNld2hlcmUsIGluIFRpbGVTb3VyY2VcbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCdvcGVuLWZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJFcnJvciBsb2FkaW5nIGltYWdlIGF0IFwiICsgdXJsLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHVybFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGdldExldmVsU2NhbGU6IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxldmVsU2NhbGUgPSBOYU47XG4gICAgICAgICAgICBpZiAobGV2ZWwgPj0gdGhpcy5taW5MZXZlbCAmJiBsZXZlbCA8PSB0aGlzLm1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxTY2FsZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxldmVsc1tsZXZlbF0ud2lkdGggL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXZlbHNbdGhpcy5tYXhMZXZlbF0ud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWxTY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGdldE51bVRpbGVzOiBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0TGV2ZWxTY2FsZShsZXZlbCk7XG4gICAgICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoMSwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxcbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlsZUF0UG9pbnQ6IGZ1bmN0aW9uIChsZXZlbCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCgwLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIHRpbGUgdXJsXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgTGV2ZWwgb2YgdGhlIHRpbGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlIG9mIHRoZSB0aWxlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlsZVVybDogZnVuY3Rpb24gKGxldmVsLCB4LCB5KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSB0aGlzLm1pbkxldmVsICYmIGxldmVsIDw9IHRoaXMubWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmxldmVsc1tsZXZlbF0udXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIHRpbGUgY29udGV4dCAyRFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIExldmVsIG9mIHRoZSB0aWxlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRpbGVcbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRleHQyRDogZnVuY3Rpb24gKGxldmVsLCB4LCB5KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPj0gdGhpcy5taW5MZXZlbCAmJiBsZXZlbCA8PSB0aGlzLm1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMubGV2ZWxzW2xldmVsXS5jb250ZXh0MkQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJ1aWxkcyB0aGUgZGlmZmVyZW50cyBsZXZlbHMgb2YgdGhlIHB5cmFtaWQgaWYgcG9zc2libGVcbiAgICAgICAgLy8gKGkuZS4gaWYgY2FudmFzIEFQSSBlbmFibGVkIGFuZCBubyBjYW52YXMgdGFpbnRpbmcgaXNzdWUpLlxuICAgICAgICBfYnVpbGRMZXZlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbHMgPSBbe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuX2ltYWdlLnNyYyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX2ltYWdlLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9pbWFnZS5uYXR1cmFsSGVpZ2h0XG4gICAgICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5idWlsZFB5cmFtaWQgfHwgISQuc3VwcG9ydHNDYW52YXMgfHwgIXRoaXMudXNlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgaW1hZ2UgYW55bW9yZS4gQWxsb3dzIGl0IHRvIGJlIEdDLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbWFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGV2ZWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudFdpZHRoID0gdGhpcy5faW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRIZWlnaHQgPSB0aGlzLl9pbWFnZS5uYXR1cmFsSGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgYmlnQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIHZhciBiaWdDb250ZXh0ID0gYmlnQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAgICAgYmlnQ2FudmFzLndpZHRoID0gY3VycmVudFdpZHRoO1xuICAgICAgICAgICAgYmlnQ2FudmFzLmhlaWdodCA9IGN1cnJlbnRIZWlnaHQ7XG4gICAgICAgICAgICBiaWdDb250ZXh0LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgMCwgMCwgY3VycmVudFdpZHRoLCBjdXJyZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIFdlIGNhY2hlIHRoZSBjb250ZXh0IG9mIHRoZSBoaWdoZXN0IGxldmVsIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIGlzIGEgbG90IGZhc3RlciBhdCBkb3duc2FtcGxpbmcgc29tZXRoaW5nIGl0IGFscmVhZHkgaGFzXG4gICAgICAgICAgICAvLyBkb3duc2FtcGxlZCBiZWZvcmUuXG4gICAgICAgICAgICBsZXZlbHNbMF0uY29udGV4dDJEID0gYmlnQ29udGV4dDtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdGhlIGltYWdlIGFueW1vcmUuIEFsbG93cyBpdCB0byBiZSBHQy5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbWFnZTtcblxuICAgICAgICAgICAgaWYgKCQuaXNDYW52YXNUYWludGVkKGJpZ0NhbnZhcykpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2FudmFzIGlzIHRhaW50ZWQsIHdlIGNhbid0IGNvbXB1dGUgdGhlIHB5cmFtaWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVscztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgYnVpbGQgc21hbGxlciBsZXZlbHMgdW50aWwgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBiZWNvbWVzXG4gICAgICAgICAgICAvLyAxIHBpeGVsIHdpZGUuXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudFdpZHRoID49IDIgJiYgY3VycmVudEhlaWdodCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpZHRoID0gTWF0aC5mbG9vcihjdXJyZW50V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gTWF0aC5mbG9vcihjdXJyZW50SGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxDb250ZXh0ID0gc21hbGxDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgIHNtYWxsQ2FudmFzLndpZHRoID0gY3VycmVudFdpZHRoO1xuICAgICAgICAgICAgICAgIHNtYWxsQ2FudmFzLmhlaWdodCA9IGN1cnJlbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgc21hbGxDb250ZXh0LmRyYXdJbWFnZShiaWdDYW52YXMsIDAsIDAsIGN1cnJlbnRXaWR0aCwgY3VycmVudEhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBsZXZlbHMuc3BsaWNlKDAsIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDJEOiBzbWFsbENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjdXJyZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY3VycmVudEhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYmlnQ2FudmFzID0gc21hbGxDYW52YXM7XG4gICAgICAgICAgICAgICAgYmlnQ29udGV4dCA9IHNtYWxsQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZXZlbHM7XG4gICAgICAgIH1cbiAgICB9KTtcblxufShPcGVuU2VhZHJhZ29uKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gVGlsZVNvdXJjZUNvbGxlY3Rpb25cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG5cbi8vIGRlcHJlY2F0ZWRcbiQuVGlsZVNvdXJjZUNvbGxlY3Rpb24gPSBmdW5jdGlvbiggdGlsZVNpemUsIHRpbGVTb3VyY2VzLCByb3dzLCBsYXlvdXQgICkge1xuICAgICQuY29uc29sZS5lcnJvcignVGlsZVNvdXJjZUNvbGxlY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIFdvcmxkIGluc3RlYWQnKTtcbn07XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gQnV0dG9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIGJ1dHRvbiBzdGF0ZXNcbiAqIEBtZW1iZXIgQnV0dG9uU3RhdGVcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFJFU1RcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBHUk9VUFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IEhPVkVSXG4gKiBAcHJvcGVydHkge051bWJlcn0gRE9XTlxuICovXG4kLkJ1dHRvblN0YXRlID0ge1xuICAgIFJFU1Q6ICAgMCxcbiAgICBHUk9VUDogIDEsXG4gICAgSE9WRVI6ICAyLFxuICAgIERPV046ICAgM1xufTtcblxuLyoqXG4gKiBAY2xhc3MgQnV0dG9uXG4gKiBAY2xhc3NkZXNjIE1hbmFnZXMgZXZlbnRzLCBob3ZlciBzdGF0ZXMgZm9yIGluZGl2aWR1YWwgYnV0dG9ucywgdG9vbC10aXBzLCBhcyB3ZWxsXG4gKiBhcyBmYWRpbmcgdGhlIGJ1dHRvbnMgb3V0IHdoZW4gdGhlIHVzZXIgaGFzIG5vdCBpbnRlcmFjdGVkIHdpdGggdGhlbVxuICogZm9yIGEgc3BlY2lmaWVkIHBlcmlvZC5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGV4dGVuZHMgT3BlblNlYWRyYWdvbi5FdmVudFNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RWxlbWVudH0gW29wdGlvbnMuZWxlbWVudD1udWxsXSBFbGVtZW50IHRvIHVzZSBhcyB0aGUgYnV0dG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBhbiBIVE1MICZsdDtidXR0b24mZ3Q7IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50b29sdGlwPW51bGxdIFByb3ZpZGVzIGNvbnRleHQgaGVscCBmb3IgdGhlIGJ1dHRvbiB3aGVuIHRoZVxuICogIHVzZXIgaG92ZXJzIG92ZXIgaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3JjUmVzdD1udWxsXSBVUkwgb2YgaW1hZ2UgdG8gdXNlIGluICdyZXN0JyBzdGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zcmNHcm91cD1udWxsXSBVUkwgb2YgaW1hZ2UgdG8gdXNlIGluICd1cCcgc3RhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3JjSG92ZXI9bnVsbF0gVVJMIG9mIGltYWdlIHRvIHVzZSBpbiAnaG92ZXInIHN0YXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNyY0Rvd249bnVsbF0gVVJMIG9mIGltYWdlIHRvIHVzZSBpbiAnZG93bicgc3RhdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFkZURlbGF5PTBdIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIGZhZGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYWRlTGVuZ3RoPTIwMDBdIEhvdyBsb25nIHNob3VsZCBpdCB0YWtlIHRvIGZhZGUgdGhlIGJ1dHRvbi5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLm9uUHJlc3M9bnVsbF0gRXZlbnQgaGFuZGxlciBjYWxsYmFjayBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uQnV0dG9uLmV2ZW50OnByZXNzfS5cbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5FdmVudEhhbmRsZXJ9IFtvcHRpb25zLm9uUmVsZWFzZT1udWxsXSBFdmVudCBoYW5kbGVyIGNhbGxiYWNrIGZvciB7QGxpbmsgT3BlblNlYWRyYWdvbi5CdXR0b24uZXZlbnQ6cmVsZWFzZX0uXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5vbkNsaWNrPW51bGxdIEV2ZW50IGhhbmRsZXIgY2FsbGJhY2sgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLkJ1dHRvbi5ldmVudDpjbGlja30uXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5vbkVudGVyPW51bGxdIEV2ZW50IGhhbmRsZXIgY2FsbGJhY2sgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLkJ1dHRvbi5ldmVudDplbnRlcn0uXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRXZlbnRIYW5kbGVyfSBbb3B0aW9ucy5vbkV4aXQ9bnVsbF0gRXZlbnQgaGFuZGxlciBjYWxsYmFjayBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uQnV0dG9uLmV2ZW50OmV4aXR9LlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMub25Gb2N1cz1udWxsXSBFdmVudCBoYW5kbGVyIGNhbGxiYWNrIGZvciB7QGxpbmsgT3BlblNlYWRyYWdvbi5CdXR0b24uZXZlbnQ6Zm9jdXN9LlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLkV2ZW50SGFuZGxlcn0gW29wdGlvbnMub25CbHVyPW51bGxdIEV2ZW50IGhhbmRsZXIgY2FsbGJhY2sgZm9yIHtAbGluayBPcGVuU2VhZHJhZ29uLkJ1dHRvbi5ldmVudDpibHVyfS5cbiAqL1xuJC5CdXR0b24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAkLkV2ZW50U291cmNlLmNhbGwoIHRoaXMgKTtcblxuICAgICQuZXh0ZW5kKCB0cnVlLCB0aGlzLCB7XG5cbiAgICAgICAgdG9vbHRpcDogICAgICAgICAgICBudWxsLFxuICAgICAgICBzcmNSZXN0OiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIHNyY0dyb3VwOiAgICAgICAgICAgbnVsbCxcbiAgICAgICAgc3JjSG92ZXI6ICAgICAgICAgICBudWxsLFxuICAgICAgICBzcmNEb3duOiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIGNsaWNrVGltZVRocmVzaG9sZDogJC5ERUZBVUxUX1NFVFRJTkdTLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiAkLkRFRkFVTFRfU0VUVElOR1MuY2xpY2tEaXN0VGhyZXNob2xkLFxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IGxvbmcgdG8gd2FpdCBiZWZvcmUgZmFkaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGZhZGVEZWxheVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b24jXG4gICAgICAgICAqL1xuICAgICAgICBmYWRlRGVsYXk6ICAgICAgICAgIDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb3cgbG9uZyBzaG91bGQgaXQgdGFrZSB0byBmYWRlIHRoZSBidXR0b24uXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZmFkZUxlbmd0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b24jXG4gICAgICAgICAqL1xuICAgICAgICBmYWRlTGVuZ3RoOiAgICAgICAgIDIwMDAsXG4gICAgICAgIG9uUHJlc3M6ICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgb25SZWxlYXNlOiAgICAgICAgICBudWxsLFxuICAgICAgICBvbkNsaWNrOiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIG9uRW50ZXI6ICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgb25FeGl0OiAgICAgICAgICAgICBudWxsLFxuICAgICAgICBvbkZvY3VzOiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIG9uQmx1cjogICAgICAgICAgICAgbnVsbFxuXG4gICAgfSwgb3B0aW9ucyApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJ1dHRvbiBlbGVtZW50LlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b24jXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ICAgICAgICA9IG9wdGlvbnMuZWxlbWVudCAgIHx8ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG5cbiAgICAvL2lmIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgdGhlIGVsZW1lbnQgdG8gYmluZCB0aGUgY29udHJvbCB0byBleHBsaWNpdGx5XG4gICAgLy90aGVuIGRvIG5vdCBhZGQgdGhlIGRlZmF1bHQgY29udHJvbCBpbWFnZXNcbiAgICBpZiAoICFvcHRpb25zLmVsZW1lbnQgKSB7XG4gICAgICAgIHRoaXMuaW1nUmVzdCAgICAgID0gJC5tYWtlVHJhbnNwYXJlbnRJbWFnZSggdGhpcy5zcmNSZXN0ICk7XG4gICAgICAgIHRoaXMuaW1nR3JvdXAgICAgID0gJC5tYWtlVHJhbnNwYXJlbnRJbWFnZSggdGhpcy5zcmNHcm91cCApO1xuICAgICAgICB0aGlzLmltZ0hvdmVyICAgICA9ICQubWFrZVRyYW5zcGFyZW50SW1hZ2UoIHRoaXMuc3JjSG92ZXIgKTtcbiAgICAgICAgdGhpcy5pbWdEb3duICAgICAgPSAkLm1ha2VUcmFuc3BhcmVudEltYWdlKCB0aGlzLnNyY0Rvd24gKTtcblxuICAgICAgICB0aGlzLmltZ1Jlc3QuYWx0ICA9XG4gICAgICAgIHRoaXMuaW1nR3JvdXAuYWx0ID1cbiAgICAgICAgdGhpcy5pbWdIb3Zlci5hbHQgPVxuICAgICAgICB0aGlzLmltZ0Rvd24uYWx0ICA9XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXA7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAkLnNldEVsZW1lbnRUb3VjaEFjdGlvbk5vbmUoIHRoaXMuZWxlbWVudCApO1xuXG4gICAgICAgIHRoaXMuaW1nR3JvdXAuc3R5bGUucG9zaXRpb24gPVxuICAgICAgICB0aGlzLmltZ0hvdmVyLnN0eWxlLnBvc2l0aW9uID1cbiAgICAgICAgdGhpcy5pbWdEb3duLnN0eWxlLnBvc2l0aW9uICA9XG4gICAgICAgICAgICBcImFic29sdXRlXCI7XG5cbiAgICAgICAgdGhpcy5pbWdHcm91cC5zdHlsZS50b3AgPVxuICAgICAgICB0aGlzLmltZ0hvdmVyLnN0eWxlLnRvcCA9XG4gICAgICAgIHRoaXMuaW1nRG93bi5zdHlsZS50b3AgID1cbiAgICAgICAgICAgIFwiMHB4XCI7XG5cbiAgICAgICAgdGhpcy5pbWdHcm91cC5zdHlsZS5sZWZ0ID1cbiAgICAgICAgdGhpcy5pbWdIb3Zlci5zdHlsZS5sZWZ0ID1cbiAgICAgICAgdGhpcy5pbWdEb3duLnN0eWxlLmxlZnQgID1cbiAgICAgICAgICAgIFwiMHB4XCI7XG5cbiAgICAgICAgdGhpcy5pbWdIb3Zlci5zdHlsZS52aXNpYmlsaXR5ID1cbiAgICAgICAgdGhpcy5pbWdEb3duLnN0eWxlLnZpc2liaWxpdHkgID1cbiAgICAgICAgICAgIFwiaGlkZGVuXCI7XG5cbiAgICAgICAgaWYgKCAkLkJyb3dzZXIudmVuZG9yID09ICQuQlJPV1NFUlMuRklSRUZPWCAgJiYgJC5Ccm93c2VyLnZlcnNpb24gPCAzICl7XG4gICAgICAgICAgICB0aGlzLmltZ0dyb3VwLnN0eWxlLnRvcCA9XG4gICAgICAgICAgICB0aGlzLmltZ0hvdmVyLnN0eWxlLnRvcCA9XG4gICAgICAgICAgICB0aGlzLmltZ0Rvd24uc3R5bGUudG9wICA9XG4gICAgICAgICAgICAgICAgXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy5pbWdSZXN0ICk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy5pbWdHcm91cCApO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuaW1nSG92ZXIgKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLmltZ0Rvd24gKTtcbiAgICB9XG5cblxuICAgIHRoaXMuYWRkSGFuZGxlciggXCJwcmVzc1wiLCAgICAgdGhpcy5vblByZXNzICk7XG4gICAgdGhpcy5hZGRIYW5kbGVyKCBcInJlbGVhc2VcIiwgICB0aGlzLm9uUmVsZWFzZSApO1xuICAgIHRoaXMuYWRkSGFuZGxlciggXCJjbGlja1wiLCAgICAgdGhpcy5vbkNsaWNrICk7XG4gICAgdGhpcy5hZGRIYW5kbGVyKCBcImVudGVyXCIsICAgICB0aGlzLm9uRW50ZXIgKTtcbiAgICB0aGlzLmFkZEhhbmRsZXIoIFwiZXhpdFwiLCAgICAgIHRoaXMub25FeGl0ICk7XG4gICAgdGhpcy5hZGRIYW5kbGVyKCBcImZvY3VzXCIsICAgICB0aGlzLm9uRm9jdXMgKTtcbiAgICB0aGlzLmFkZEhhbmRsZXIoIFwiYmx1clwiLCAgICAgIHRoaXMub25CbHVyICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnV0dG9uJ3MgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBAbWVtYmVyIHtPcGVuU2VhZHJhZ29uLkJ1dHRvblN0YXRlfSBjdXJyZW50U3RhdGVcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b24jXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50U3RhdGUgPSAkLkJ1dHRvblN0YXRlLkdST1VQO1xuXG4gICAgLy8gV2hlbiB0aGUgYnV0dG9uIGxhc3QgYmVnYW4gdG8gZmFkZS5cbiAgICB0aGlzLmZhZGVCZWdpblRpbWUgID0gbnVsbDtcbiAgICAvLyBXaGV0aGVyIHRoaXMgYnV0dG9uIHNob3VsZCBmYWRlIGFmdGVyIHVzZXIgc3RvcHMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlld3BvcnQuXG4gICAgdGhpcy5zaG91bGRGYWRlICAgICA9IGZhbHNlO1xuXG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgdGhpcy5lbGVtZW50LnRpdGxlICAgICAgICAgID0gdGhpcy50b29sdGlwO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2tzIG1vdXNlL3RvdWNoL2tleSBldmVudHMgb24gdGhlIGJ1dHRvbi5cbiAgICAgKiBAbWVtYmVyIHtPcGVuU2VhZHJhZ29uLk1vdXNlVHJhY2tlcn0gdHJhY2tlclxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvbiNcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrZXIgPSBuZXcgJC5Nb3VzZVRyYWNrZXIoe1xuXG4gICAgICAgIGVsZW1lbnQ6ICAgICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6IHRoaXMuY2xpY2tEaXN0VGhyZXNob2xkLFxuXG4gICAgICAgIGVudGVySGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgaWYgKCBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCApIHtcbiAgICAgICAgICAgICAgICBpblRvKCBfdGhpcywgJC5CdXR0b25TdGF0ZS5ET1dOICk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIGN1cnNvciBlbnRlcnMgdGhlIEJ1dHRvbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IGVudGVyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uXG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uQnV0dG9ufSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBCdXR0b24gd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoIFwiZW50ZXJcIiwgeyBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0gKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICFldmVudC5idXR0b25Eb3duQW55ICkge1xuICAgICAgICAgICAgICAgIGluVG8oIF90aGlzLCAkLkJ1dHRvblN0YXRlLkhPVkVSICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9jdXNIYW5kbGVyOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgdGhpcy5lbnRlckhhbmRsZXIoIGV2ZW50ICk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBCdXR0b24gZWxlbWVudCByZWNlaXZlcyBmb2N1cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgZm9jdXNcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5CdXR0b259IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEJ1dHRvbiB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcImZvY3VzXCIsIHsgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhpdEhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIG91dFRvKCBfdGhpcywgJC5CdXR0b25TdGF0ZS5HUk9VUCApO1xuICAgICAgICAgICAgaWYgKCBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgY3Vyc29yIGxlYXZlcyB0aGUgQnV0dG9uIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgZXhpdFxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcImV4aXRcIiwgeyBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBibHVySGFuZGxlcjogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgIHRoaXMuZXhpdEhhbmRsZXIoIGV2ZW50ICk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBCdXR0b24gZWxlbWVudCBsb3NlcyBmb2N1cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgYmx1clxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoIFwiYmx1clwiLCB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByZXNzSGFuZGxlcjogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgIGluVG8oIF90aGlzLCAkLkJ1dHRvblN0YXRlLkRPV04gKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gYSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCBvciB0b3VjaCBvY2N1cnMgaW4gdGhlIEJ1dHRvbiBlbGVtZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBwcmVzc1xuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoIFwicHJlc3NcIiwgeyBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWxlYXNlSGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgaWYgKCBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCAmJiBldmVudC5pbnNpZGVFbGVtZW50UmVsZWFzZWQgKSB7XG4gICAgICAgICAgICAgICAgb3V0VG8oIF90aGlzLCAkLkJ1dHRvblN0YXRlLkhPVkVSICk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIG1vdXNlIGJ1dHRvbiBpcyByZWxlYXNlZCBvciB0b3VjaCBlbmRzIGluIHRoZSBCdXR0b24gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCByZWxlYXNlXG4gICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uXG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uQnV0dG9ufSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBCdXR0b24gd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoIFwicmVsZWFzZVwiLCB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggZXZlbnQuaW5zaWRlRWxlbWVudFByZXNzZWQgKSB7XG4gICAgICAgICAgICAgICAgb3V0VG8oIF90aGlzLCAkLkJ1dHRvblN0YXRlLkdST1VQICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluVG8oIF90aGlzLCAkLkJ1dHRvblN0YXRlLkhPVkVSICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xpY2tIYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICBpZiAoIGV2ZW50LnF1aWNrICkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIGEgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHJlbGVhc2VkIG9yIHRvdWNoIGlzIGluaXRpYXRlZCBhbmQgZW5kZWQgaW4gdGhlIEJ1dHRvbiBlbGVtZW50IHdpdGhpbiB0aGUgdGltZSBhbmQgZGlzdGFuY2UgdGhyZXNob2xkLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IGNsaWNrXG4gICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uXG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uQnV0dG9ufSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBCdXR0b24gd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIF90aGlzLnJhaXNlRXZlbnQoXCJjbGlja1wiLCB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5SGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCBcIiVzIDogaGFuZGxpbmcga2V5ICVzIVwiLCBfdGhpcy50b29sdGlwLCBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgICAgIGlmKCAxMyA9PT0gZXZlbnQua2V5Q29kZSApe1xuICAgICAgICAgICAgICAgIC8qKipcbiAgICAgICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiBhIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCByZWxlYXNlZCBvciB0b3VjaCBpcyBpbml0aWF0ZWQgYW5kIGVuZGVkIGluIHRoZSBCdXR0b24gZWxlbWVudCB3aXRoaW4gdGhlIHRpbWUgYW5kIGRpc3RhbmNlIHRocmVzaG9sZC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBjbGlja1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcImNsaWNrXCIsIHsgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9ICk7XG4gICAgICAgICAgICAgICAgLyoqKlxuICAgICAgICAgICAgICAgICAqIFJhaXNlZCB3aGVuIHRoZSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQgb3IgdG91Y2ggZW5kcyBpbiB0aGUgQnV0dG9uIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgcmVsZWFzZVxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLkJ1dHRvbn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgQnV0dG9uIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5yYWlzZUV2ZW50KCBcInJlbGVhc2VcIiwgeyBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBvdXRUbyggdGhpcywgJC5CdXR0b25TdGF0ZS5SRVNUICk7XG59O1xuXG4kLmV4dGVuZCggJC5CdXR0b24ucHJvdG90eXBlLCAkLkV2ZW50U291cmNlLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLkJ1dHRvbi5wcm90b3R5cGUgKi97XG5cbiAgICAvKipcbiAgICAgKiBUT0RPOiBEZXRlcm1pbmUgd2hhdCB0aGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGRvIGFuZCBpZiBpdCdzIGFjdHVhbGx5XG4gICAgICogdXNlZnVsIGFzIGFuIEFQSSBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBub3RpZnlHcm91cEVudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaW5UbyggdGhpcywgJC5CdXR0b25TdGF0ZS5HUk9VUCApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUT0RPOiBEZXRlcm1pbmUgd2hhdCB0aGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGRvIGFuZCBpZiBpdCdzIGFjdHVhbGx5XG4gICAgICogdXNlZnVsIGFzIGFuIEFQSSBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBub3RpZnlHcm91cEV4aXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvdXRUbyggdGhpcywgJC5CdXR0b25TdGF0ZS5SRVNUICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMubm90aWZ5R3JvdXBFeGl0KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIHRoaXMuZWxlbWVudCwgMC4yLCB0cnVlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5lbGVtZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIHRoaXMuZWxlbWVudCwgMS4wLCB0cnVlICk7XG4gICAgICAgIHRoaXMubm90aWZ5R3JvdXBFbnRlcigpO1xuICAgIH1cblxufSk7XG5cblxuZnVuY3Rpb24gc2NoZWR1bGVGYWRlKCBidXR0b24gKSB7XG4gICAgJC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgdXBkYXRlRmFkZSggYnV0dG9uICk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZhZGUoIGJ1dHRvbiApIHtcbiAgICB2YXIgY3VycmVudFRpbWUsXG4gICAgICAgIGRlbHRhVGltZSxcbiAgICAgICAgb3BhY2l0eTtcblxuICAgIGlmICggYnV0dG9uLnNob3VsZEZhZGUgKSB7XG4gICAgICAgIGN1cnJlbnRUaW1lID0gJC5ub3coKTtcbiAgICAgICAgZGVsdGFUaW1lICAgPSBjdXJyZW50VGltZSAtIGJ1dHRvbi5mYWRlQmVnaW5UaW1lO1xuICAgICAgICBvcGFjaXR5ICAgICA9IDEuMCAtIGRlbHRhVGltZSAvIGJ1dHRvbi5mYWRlTGVuZ3RoO1xuICAgICAgICBvcGFjaXR5ICAgICA9IE1hdGgubWluKCAxLjAsIG9wYWNpdHkgKTtcbiAgICAgICAgb3BhY2l0eSAgICAgPSBNYXRoLm1heCggMC4wLCBvcGFjaXR5ICk7XG5cbiAgICAgICAgaWYoIGJ1dHRvbi5pbWdHcm91cCApe1xuICAgICAgICAgICAgJC5zZXRFbGVtZW50T3BhY2l0eSggYnV0dG9uLmltZ0dyb3VwLCBvcGFjaXR5LCB0cnVlICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBvcGFjaXR5ID4gMCApIHtcbiAgICAgICAgICAgIC8vIGZhZGUgYWdhaW5cbiAgICAgICAgICAgIHNjaGVkdWxlRmFkZSggYnV0dG9uICk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luRmFkaW5nKCBidXR0b24gKSB7XG4gICAgYnV0dG9uLnNob3VsZEZhZGUgPSB0cnVlO1xuICAgIGJ1dHRvbi5mYWRlQmVnaW5UaW1lID0gJC5ub3coKSArIGJ1dHRvbi5mYWRlRGVsYXk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNjaGVkdWxlRmFkZSggYnV0dG9uICk7XG4gICAgfSwgYnV0dG9uLmZhZGVEZWxheSApO1xufVxuXG5mdW5jdGlvbiBzdG9wRmFkaW5nKCBidXR0b24gKSB7XG4gICAgYnV0dG9uLnNob3VsZEZhZGUgPSBmYWxzZTtcbiAgICBpZiggYnV0dG9uLmltZ0dyb3VwICl7XG4gICAgICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIGJ1dHRvbi5pbWdHcm91cCwgMS4wLCB0cnVlICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpblRvKCBidXR0b24sIG5ld1N0YXRlICkge1xuXG4gICAgaWYoIGJ1dHRvbi5lbGVtZW50LmRpc2FibGVkICl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIG5ld1N0YXRlID49ICQuQnV0dG9uU3RhdGUuR1JPVVAgJiZcbiAgICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPT0gJC5CdXR0b25TdGF0ZS5SRVNUICkge1xuICAgICAgICBzdG9wRmFkaW5nKCBidXR0b24gKTtcbiAgICAgICAgYnV0dG9uLmN1cnJlbnRTdGF0ZSA9ICQuQnV0dG9uU3RhdGUuR1JPVVA7XG4gICAgfVxuXG4gICAgaWYgKCBuZXdTdGF0ZSA+PSAkLkJ1dHRvblN0YXRlLkhPVkVSICYmXG4gICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID09ICQuQnV0dG9uU3RhdGUuR1JPVVAgKSB7XG4gICAgICAgIGlmKCBidXR0b24uaW1nSG92ZXIgKXtcbiAgICAgICAgICAgIGJ1dHRvbi5pbWdIb3Zlci5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID0gJC5CdXR0b25TdGF0ZS5IT1ZFUjtcbiAgICB9XG5cbiAgICBpZiAoIG5ld1N0YXRlID49ICQuQnV0dG9uU3RhdGUuRE9XTiAmJlxuICAgICAgICAgYnV0dG9uLmN1cnJlbnRTdGF0ZSA9PSAkLkJ1dHRvblN0YXRlLkhPVkVSICkge1xuICAgICAgICBpZiggYnV0dG9uLmltZ0Rvd24gKXtcbiAgICAgICAgICAgIGJ1dHRvbi5pbWdEb3duLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPSAkLkJ1dHRvblN0YXRlLkRPV047XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIG91dFRvKCBidXR0b24sIG5ld1N0YXRlICkge1xuXG4gICAgaWYoIGJ1dHRvbi5lbGVtZW50LmRpc2FibGVkICl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIG5ld1N0YXRlIDw9ICQuQnV0dG9uU3RhdGUuSE9WRVIgJiZcbiAgICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPT0gJC5CdXR0b25TdGF0ZS5ET1dOICkge1xuICAgICAgICBpZiggYnV0dG9uLmltZ0Rvd24gKXtcbiAgICAgICAgICAgIGJ1dHRvbi5pbWdEb3duLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPSAkLkJ1dHRvblN0YXRlLkhPVkVSO1xuICAgIH1cblxuICAgIGlmICggbmV3U3RhdGUgPD0gJC5CdXR0b25TdGF0ZS5HUk9VUCAmJlxuICAgICAgICAgYnV0dG9uLmN1cnJlbnRTdGF0ZSA9PSAkLkJ1dHRvblN0YXRlLkhPVkVSICkge1xuICAgICAgICBpZiggYnV0dG9uLmltZ0hvdmVyICl7XG4gICAgICAgICAgICBidXR0b24uaW1nSG92ZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgICAgYnV0dG9uLmN1cnJlbnRTdGF0ZSA9ICQuQnV0dG9uU3RhdGUuR1JPVVA7XG4gICAgfVxuXG4gICAgaWYgKCBuZXdTdGF0ZSA8PSAkLkJ1dHRvblN0YXRlLlJFU1QgJiZcbiAgICAgICAgIGJ1dHRvbi5jdXJyZW50U3RhdGUgPT0gJC5CdXR0b25TdGF0ZS5HUk9VUCApIHtcbiAgICAgICAgYmVnaW5GYWRpbmcoIGJ1dHRvbiApO1xuICAgICAgICBidXR0b24uY3VycmVudFN0YXRlID0gJC5CdXR0b25TdGF0ZS5SRVNUO1xuICAgIH1cbn1cblxuXG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gQnV0dG9uR3JvdXBcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCAkICl7XG4vKipcbiAqIEBjbGFzcyBCdXR0b25Hcm91cFxuICogQGNsYXNzZGVzYyBNYW5hZ2VzIGV2ZW50cyBvbiBncm91cHMgb2YgYnV0dG9ucy5cbiAqXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBIGRpY3Rpb25hcnkgb2Ygc2V0dGluZ3MgYXBwbGllZCBhZ2FpbnN0IHRoZSBlbnRpcmUgZ3JvdXAgb2YgYnV0dG9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuYnV0dG9ucyBBcnJheSBvZiBidXR0b25zXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtvcHRpb25zLmVsZW1lbnRdIEVsZW1lbnQgdG8gdXNlIGFzIHRoZSBjb250YWluZXJcbiAqKi9cbiQuQnV0dG9uR3JvdXAgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICQuZXh0ZW5kKCB0cnVlLCB0aGlzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBidXR0b25zIHRoZW1zZWx2ZXMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBidXR0b25zXG4gICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkJ1dHRvbkdyb3VwI1xuICAgICAgICAgKi9cbiAgICAgICAgYnV0dG9uczogICAgICAgICAgICBbXSxcbiAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiAkLkRFRkFVTFRfU0VUVElOR1MuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICBjbGlja0Rpc3RUaHJlc2hvbGQ6ICQuREVGQVVMVF9TRVRUSU5HUy5jbGlja0Rpc3RUaHJlc2hvbGQsXG4gICAgICAgIGxhYmVsVGV4dDogICAgICAgICAgXCJcIlxuICAgIH0sIG9wdGlvbnMgKTtcblxuICAgIC8vIGNvcHkgdGhlIGJ1dHRvbiBlbGVtZW50cyAgVE9ETzogV2h5P1xuICAgIHZhciBidXR0b25zID0gdGhpcy5idXR0b25zLmNvbmNhdChbXSksXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgaTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFyZWQgY29udGFpbmVyIGZvciB0aGUgYnV0dG9ucy5cbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uQnV0dG9uR3JvdXAjXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50IHx8ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImRpdlwiICk7XG5cbiAgICAvLyBUT0RPIFdoYXQgaWYgdGhlcmUgSVMgYW4gb3B0aW9ucy5ncm91cCBzcGVjaWZpZWQ/XG4gICAgaWYoICFvcHRpb25zLmdyb3VwICl7XG4gICAgICAgIHRoaXMubGFiZWwgICA9ICQubWFrZU5ldXRyYWxFbGVtZW50KCBcImxhYmVsXCIgKTtcbiAgICAgICAgLy9UT0RPOiBzdXBwb3J0IGxhYmVscyBmb3IgQnV0dG9uR3JvdXBzXG4gICAgICAgIC8vdGhpcy5sYWJlbC5pbm5lckhUTUwgPSB0aGlzLmxhYmVsVGV4dDtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMubGFiZWwgKTtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCBidXR0b25zWyBpIF0uZWxlbWVudCApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJC5zZXRFbGVtZW50VG91Y2hBY3Rpb25Ob25lKCB0aGlzLmVsZW1lbnQgKTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrcyBtb3VzZS90b3VjaC9rZXkgZXZlbnRzIGFjY3Jvc3MgdGhlIGdyb3VwIG9mIGJ1dHRvbnMuXG4gICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5Nb3VzZVRyYWNrZXJ9IHRyYWNrZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5CdXR0b25Hcm91cCNcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrZXIgPSBuZXcgJC5Nb3VzZVRyYWNrZXIoe1xuICAgICAgICBlbGVtZW50OiAgICAgICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgY2xpY2tUaW1lVGhyZXNob2xkOiB0aGlzLmNsaWNrVGltZVRocmVzaG9sZCxcbiAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgZW50ZXJIYW5kbGVyOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IF90aGlzLmJ1dHRvbnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnV0dG9uc1sgaSBdLm5vdGlmeUdyb3VwRW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXhpdEhhbmRsZXI6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGlmICggIWV2ZW50Lmluc2lkZUVsZW1lbnRQcmVzc2VkICkge1xuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgX3RoaXMuYnV0dG9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnV0dG9uc1sgaSBdLm5vdGlmeUdyb3VwRXhpdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5CdXR0b25Hcm91cC5wcm90b3R5cGUgKi9cbiQuQnV0dG9uR3JvdXAucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVE9ETzogRmlndXJlIG91dCB3aHkgdGhpcyBpcyB1c2VkIG9uIHRoZSBwdWJsaWMgQVBJIGFuZCBpZiBhIG1vcmUgdXNlZnVsXG4gICAgICogYXBpIGNhbiBiZSBjcmVhdGVkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZW11bGF0ZUVudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmFja2VyLmVudGVySGFuZGxlciggeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyIH0gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETzogRmlndXJlIG91dCB3aHkgdGhpcyBpcyB1c2VkIG9uIHRoZSBwdWJsaWMgQVBJIGFuZCBpZiBhIG1vcmUgdXNlZnVsXG4gICAgICogYXBpIGNhbiBiZSBjcmVhdGVkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZW11bGF0ZUV4aXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIuZXhpdEhhbmRsZXIoIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciB9ICk7XG4gICAgfVxufTtcblxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFJlY3RcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAtIE5laXRoZXIgdGhlIG5hbWUgb2YgQ29kZVBsZXggRm91bmRhdGlvbiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBAY2xhc3MgUmVjdFxuICogQGNsYXNzZGVzYyBBIFJlY3RhbmdsZSBpcyBkZXNjcmliZWQgYnkgaXQgdG9wIGxlZnQgY29vcmRpbmF0ZXMgKHgsIHkpLCB3aWR0aCxcbiAqIGhlaWdodCBhbmQgZGVncmVlcyBvZiByb3RhdGlvbiBhcm91bmQgKHgsIHkpLlxuICogTm90ZSB0aGF0IHRoZSBjb29yZGluYXRlIHN5c3RlbSB1c2VkIGlzIHRoZSBvbmUgY29tbW9ubHkgdXNlZCB3aXRoIGltYWdlczpcbiAqIHggaW5jcmVhc2VzIHdoZW4gZ29pbmcgdG8gdGhlIHJpZ2h0XG4gKiB5IGluY3JlYXNlcyB3aGVuIGdvaW5nIHRvIHRoZSBib3R0b21cbiAqIGRlZ3JlZXMgaW5jcmVhc2VzIGNsb2Nrd2lzZSB3aXRoIDAgYmVpbmcgdGhlIGhvcml6b250YWxcbiAqXG4gKiBUaGUgY29uc3RydWN0b3Igbm9ybWFsaXplcyB0aGUgcmVjdGFuZ2xlIHRvIGFsd2F5cyBoYXZlIDAgPD0gZGVncmVlcyA8IDkwXG4gKlxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBUaGUgdmVjdG9yIGNvbXBvbmVudCAneCcuXG4gKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gVGhlIHZlY3RvciBjb21wb25lbnQgJ3knLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgdmVjdG9yIGNvbXBvbmVudCAnd2lkdGgnLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIHZlY3RvciBjb21wb25lbnQgJ2hlaWdodCcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2RlZ3JlZXM9MF0gUm90YXRpb24gb2YgdGhlIHJlY3RhbmdsZSBhcm91bmQgKHgseSkgaW4gZGVncmVlcy5cbiAqL1xuJC5SZWN0ID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgZGVncmVlcykge1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZWN0b3IgY29tcG9uZW50ICd4Jy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHhcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5SZWN0I1xuICAgICAqL1xuICAgIHRoaXMueCA9IHR5cGVvZih4KSA9PT0gXCJudW1iZXJcIiA/IHggOiAwO1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZWN0b3IgY29tcG9uZW50ICd5Jy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHlcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5SZWN0I1xuICAgICAqL1xuICAgIHRoaXMueSA9IHR5cGVvZih5KSA9PT0gXCJudW1iZXJcIiA/IHkgOiAwO1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZWN0b3IgY29tcG9uZW50ICd3aWR0aCcuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlJlY3QjXG4gICAgICovXG4gICAgdGhpcy53aWR0aCAgPSB0eXBlb2Yod2lkdGgpID09PSBcIm51bWJlclwiID8gd2lkdGggOiAwO1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZWN0b3IgY29tcG9uZW50ICdoZWlnaHQnLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gaGVpZ2h0XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uUmVjdCNcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IHR5cGVvZihoZWlnaHQpID09PSBcIm51bWJlclwiID8gaGVpZ2h0IDogMDtcblxuICAgIHRoaXMuZGVncmVlcyA9IHR5cGVvZihkZWdyZWVzKSA9PT0gXCJudW1iZXJcIiA/IGRlZ3JlZXMgOiAwO1xuXG4gICAgLy8gTm9ybWFsaXplcyB0aGUgcmVjdGFuZ2xlLlxuICAgIHRoaXMuZGVncmVlcyA9IHRoaXMuZGVncmVlcyAlIDM2MDtcbiAgICBpZiAodGhpcy5kZWdyZWVzIDwgMCkge1xuICAgICAgICB0aGlzLmRlZ3JlZXMgKz0gMzYwO1xuICAgIH1cbiAgICB2YXIgbmV3VG9wTGVmdCwgbmV3V2lkdGg7XG4gICAgaWYgKHRoaXMuZGVncmVlcyA+PSAyNzApIHtcbiAgICAgICAgbmV3VG9wTGVmdCA9IHRoaXMuZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgdGhpcy54ID0gbmV3VG9wTGVmdC54O1xuICAgICAgICB0aGlzLnkgPSBuZXdUb3BMZWZ0Lnk7XG4gICAgICAgIG5ld1dpZHRoID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICB0aGlzLmRlZ3JlZXMgLT0gMjcwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kZWdyZWVzID49IDE4MCkge1xuICAgICAgICBuZXdUb3BMZWZ0ID0gdGhpcy5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICB0aGlzLnggPSBuZXdUb3BMZWZ0Lng7XG4gICAgICAgIHRoaXMueSA9IG5ld1RvcExlZnQueTtcbiAgICAgICAgdGhpcy5kZWdyZWVzIC09IDE4MDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVncmVlcyA+PSA5MCkge1xuICAgICAgICBuZXdUb3BMZWZ0ID0gdGhpcy5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgIHRoaXMueCA9IG5ld1RvcExlZnQueDtcbiAgICAgICAgdGhpcy55ID0gbmV3VG9wTGVmdC55O1xuICAgICAgICBuZXdXaWR0aCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgdGhpcy5kZWdyZWVzIC09IDkwO1xuICAgIH1cbn07XG5cbi8qKlxuICogQnVpbGRzIGEgcmVjdGFuZ2xlIGhhdmluZyB0aGUgMyBzcGVjaWZpZWQgcG9pbnRzIGFzIHN1bW1pdHMuXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5SZWN0XG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHRvcExlZnRcbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gdG9wUmlnaHRcbiAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gYm90dG9tTGVmdFxuICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH1cbiAqL1xuJC5SZWN0LmZyb21TdW1taXRzID0gZnVuY3Rpb24odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQpIHtcbiAgICB2YXIgd2lkdGggPSB0b3BMZWZ0LmRpc3RhbmNlVG8odG9wUmlnaHQpO1xuICAgIHZhciBoZWlnaHQgPSB0b3BMZWZ0LmRpc3RhbmNlVG8oYm90dG9tTGVmdCk7XG4gICAgdmFyIGRpZmYgPSB0b3BSaWdodC5taW51cyh0b3BMZWZ0KTtcbiAgICB2YXIgcmFkaWFucyA9IE1hdGguYXRhbihkaWZmLnkgLyBkaWZmLngpO1xuICAgIGlmIChkaWZmLnggPCAwKSB7XG4gICAgICAgIHJhZGlhbnMgKz0gTWF0aC5QSTtcbiAgICB9IGVsc2UgaWYgKGRpZmYueSA8IDApIHtcbiAgICAgICAgcmFkaWFucyArPSAyICogTWF0aC5QSTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgIHRvcExlZnQueCxcbiAgICAgICAgdG9wTGVmdC55LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByYWRpYW5zIC8gTWF0aC5QSSAqIDE4MCk7XG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uUmVjdC5wcm90b3R5cGUgKi9cbiQuUmVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gYSBkdXBsaWNhdGUgb2YgdGhpcyBSZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIHRoaXMueCxcbiAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHRoaXMuZGVncmVlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhc3BlY3QgcmF0aW8gaXMgc2ltcGx5IHRoZSByYXRpbyBvZiB3aWR0aCB0byBoZWlnaHQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIHJhdGlvIG9mIHdpZHRoIHRvIGhlaWdodC5cbiAgICAgKi9cbiAgICBnZXRBc3BlY3RSYXRpbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZSBhcyBhXG4gICAgICogcG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9IFRoZSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZlxuICAgICAqICB0aGUgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGdldFRvcExlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICB0aGlzLngsXG4gICAgICAgICAgICB0aGlzLnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUgYXMgYVxuICAgICAqIHBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lciBvZlxuICAgICAqICB0aGUgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSArIHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgLnJvdGF0ZSh0aGlzLmRlZ3JlZXMsIHRoaXMuZ2V0VG9wTGVmdCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AtcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUgYXMgYVxuICAgICAqIHBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdG9wLXJpZ2h0IGNvcm5lciBvZlxuICAgICAqICB0aGUgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGdldFRvcFJpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSlcbiAgICAgICAgICAgIC5yb3RhdGUodGhpcy5kZWdyZWVzLCB0aGlzLmdldFRvcExlZnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUgYXMgYVxuICAgICAqIHBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mXG4gICAgICogIHRoZSByZWN0YW5nbGUuXG4gICAgICovXG4gICAgZ2V0Qm90dG9tTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludCh0aGlzLngsIHRoaXMueSArIHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgLnJvdGF0ZSh0aGlzLmRlZ3JlZXMsIHRoaXMuZ2V0VG9wTGVmdCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGNlbnRlciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgY2VudGVyIG9mIHRoZSByZWN0YW5nbGUgYXMgcmVwcmVzZW50ZWRcbiAgICAgKiAgYXMgcmVwcmVzZW50ZWQgYnkgYSAyLWRpbWVuc2lvbmFsIHZlY3RvciAoeCx5KVxuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGggLyAyLjAsXG4gICAgICAgICAgICB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIuMFxuICAgICAgICApLnJvdGF0ZSh0aGlzLmRlZ3JlZXMsIHRoaXMuZ2V0VG9wTGVmdCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggYW5kIGhlaWdodCBjb21wb25lbnQgYXMgYSB2ZWN0b3IgT3BlblNlYWRyYWdvbi5Qb2ludFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgMiBkaW1lbnNpb25hbCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZVxuICAgICAqICB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHR3byBSZWN0YW5nbGVzIGhhdmUgZXF1aXZhbGVudCBjb21wb25lbnRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSByZWN0YW5nbGUgVGhlIFJlY3RhbmdsZSB0byBjb21wYXJlIHRvLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICd0cnVlJyBpZiBhbGwgY29tcG9uZW50cyBhcmUgZXF1YWwsIG90aGVyd2lzZSAnZmFsc2UnLlxuICAgICAqL1xuICAgIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mICQuUmVjdCkgJiZcbiAgICAgICAgICAgIHRoaXMueCA9PT0gb3RoZXIueCAmJlxuICAgICAgICAgICAgdGhpcy55ID09PSBvdGhlci55ICYmXG4gICAgICAgICAgICB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJlxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPT09IG90aGVyLmhlaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5kZWdyZWVzID09PSBvdGhlci5kZWdyZWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIE11bHRpcGx5IGFsbCBkaW1lbnNpb25zIChleGNlcHQgZGVncmVlcykgaW4gdGhpcyBSZWN0IGJ5IGEgZmFjdG9yIGFuZFxuICAgICogcmV0dXJuIGEgbmV3IFJlY3QuXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3IgVGhlIGZhY3RvciB0byBtdWx0aXBseSB2ZWN0b3IgY29tcG9uZW50cy5cbiAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IEEgbmV3IHJlY3QgcmVwcmVzZW50aW5nIHRoZSBtdWx0aXBsaWNhdGlvblxuICAgICogIG9mIHRoZSB2ZWN0b3IgY29tcG9uZW50cyBieSB0aGUgZmFjdG9yXG4gICAgKi9cbiAgICB0aW1lczogZnVuY3Rpb24oZmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgdGhpcy54ICogZmFjdG9yLFxuICAgICAgICAgICAgdGhpcy55ICogZmFjdG9yLFxuICAgICAgICAgICAgdGhpcy53aWR0aCAqIGZhY3RvcixcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ICogZmFjdG9yLFxuICAgICAgICAgICAgdGhpcy5kZWdyZWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBUcmFuc2xhdGUvbW92ZSB0aGlzIFJlY3QgYnkgYSB2ZWN0b3IgYW5kIHJldHVybiBuZXcgUmVjdC5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBkZWx0YSBUaGUgdHJhbnNsYXRpb24gdmVjdG9yLlxuICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gQSBuZXcgcmVjdCB3aXRoIGFsdGVyZWQgcG9zaXRpb25cbiAgICAqL1xuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oZGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICB0aGlzLnggKyBkZWx0YS54LFxuICAgICAgICAgICAgdGhpcy55ICsgZGVsdGEueSxcbiAgICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHRoaXMuZGVncmVlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNtYWxsZXN0IHJlY3RhbmdsZSB0aGF0IHdpbGwgY29udGFpbiB0aGlzIGFuZCB0aGUgZ2l2ZW5cbiAgICAgKiByZWN0YW5nbGUgYm91bmRpbmcgYm94ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IHJlY3RcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFRoZSBuZXcgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIHVuaW9uOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHZhciB0aGlzQm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHZhciBvdGhlckJvdW5kaW5nQm94ID0gcmVjdC5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4odGhpc0JvdW5kaW5nQm94LngsIG90aGVyQm91bmRpbmdCb3gueCk7XG4gICAgICAgIHZhciB0b3AgPSBNYXRoLm1pbih0aGlzQm91bmRpbmdCb3gueSwgb3RoZXJCb3VuZGluZ0JveC55KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICB0aGlzQm91bmRpbmdCb3gueCArIHRoaXNCb3VuZGluZ0JveC53aWR0aCxcbiAgICAgICAgICAgIG90aGVyQm91bmRpbmdCb3gueCArIG90aGVyQm91bmRpbmdCb3gud2lkdGgpO1xuICAgICAgICB2YXIgYm90dG9tID0gTWF0aC5tYXgoXG4gICAgICAgICAgICB0aGlzQm91bmRpbmdCb3gueSArIHRoaXNCb3VuZGluZ0JveC5oZWlnaHQsXG4gICAgICAgICAgICBvdGhlckJvdW5kaW5nQm94LnkgKyBvdGhlckJvdW5kaW5nQm94LmhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQgLSBsZWZ0LFxuICAgICAgICAgICAgYm90dG9tIC0gdG9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyByZWN0YW5nbGUgd2l0aCB0aGVcbiAgICAgKiBnaXZlbiByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IHJlY3RcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlJlY3R9IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGludGVyc2VjdGlvblxuICAgICAqIG9yIG51bGwgaWYgdGhlIHJlY3RhbmdsZXMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgICAqL1xuICAgIGludGVyc2VjdGlvbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICAvLyBTaW1wbGlmaWVkIHZlcnNpb24gb2YgV2VpbGVyIEF0aGVydG9uIGNsaXBwaW5nIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWlsZXIlRTIlODAlOTNBdGhlcnRvbl9jbGlwcGluZ19hbGdvcml0aG1cbiAgICAgICAgLy8gQmVjYXVzZSB3ZSBqdXN0IHdhbnQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgaW50ZXJzZWN0aW9uLFxuICAgICAgICAvLyB3ZSBjYW4ganVzdCBjb21wdXRlIHRoZSBib3VuZGluZyBib3ggb2Y6XG4gICAgICAgIC8vIDEuIGFsbCB0aGUgc3VtbWl0cyBvZiB0aGlzIHdoaWNoIGFyZSBpbnNpZGUgcmVjdFxuICAgICAgICAvLyAyLiBhbGwgdGhlIHN1bW1pdHMgb2YgcmVjdCB3aGljaCBhcmUgaW5zaWRlIHRoaXNcbiAgICAgICAgLy8gMy4gYWxsIHRoZSBpbnRlcnNlY3Rpb25zIG9mIHJlY3QgYW5kIHRoaXNcbiAgICAgICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuXG4gICAgICAgIHZhciB0aGlzVG9wTGVmdCA9IHRoaXMuZ2V0VG9wTGVmdCgpO1xuICAgICAgICBpZiAocmVjdC5jb250YWluc1BvaW50KHRoaXNUb3BMZWZ0LCBFUFNJTE9OKSkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godGhpc1RvcExlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzVG9wUmlnaHQgPSB0aGlzLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIGlmIChyZWN0LmNvbnRhaW5zUG9pbnQodGhpc1RvcFJpZ2h0LCBFUFNJTE9OKSkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2godGhpc1RvcFJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JvdHRvbUxlZnQgPSB0aGlzLmdldEJvdHRvbUxlZnQoKTtcbiAgICAgICAgaWYgKHJlY3QuY29udGFpbnNQb2ludCh0aGlzQm90dG9tTGVmdCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHRoaXNCb3R0b21MZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JvdHRvbVJpZ2h0ID0gdGhpcy5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICBpZiAocmVjdC5jb250YWluc1BvaW50KHRoaXNCb3R0b21SaWdodCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHRoaXNCb3R0b21SaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdFRvcExlZnQgPSByZWN0LmdldFRvcExlZnQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludChyZWN0VG9wTGVmdCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHJlY3RUb3BMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjdFRvcFJpZ2h0ID0gcmVjdC5nZXRUb3BSaWdodCgpO1xuICAgICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KHJlY3RUb3BSaWdodCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHJlY3RUb3BSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY3RCb3R0b21MZWZ0ID0gcmVjdC5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQocmVjdEJvdHRvbUxlZnQsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChyZWN0Qm90dG9tTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY3RCb3R0b21SaWdodCA9IHJlY3QuZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludChyZWN0Qm90dG9tUmlnaHQsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChyZWN0Qm90dG9tUmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoaXNTZWdtZW50cyA9IHRoaXMuX2dldFNlZ21lbnRzKCk7XG4gICAgICAgIHZhciByZWN0U2VnbWVudHMgPSByZWN0Ll9nZXRTZWdtZW50cygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRoaXNTZWdtZW50ID0gdGhpc1NlZ21lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWN0U2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFNlZ21lbnQgPSByZWN0U2VnbWVudHNbal07XG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGdldEludGVyc2VjdGlvbih0aGlzU2VnbWVudFswXSwgdGhpc1NlZ21lbnRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJlY3RTZWdtZW50WzBdLCByZWN0U2VnbWVudFsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChpbnRlcnNlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBpbnRlcnNlY3Rpb24gcG9pbnQgb2Ygc2VnbWVudHMgW2EsYl0gYW5kIFtjLGRdXG4gICAgICAgIGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTY4MzQ1LzE0NDA0MDNcbiAgICAgICAgICAgIHZhciBhYlZlY3RvciA9IGIubWludXMoYSk7XG4gICAgICAgICAgICB2YXIgY2RWZWN0b3IgPSBkLm1pbnVzKGMpO1xuXG4gICAgICAgICAgICB2YXIgZGVub20gPSAtY2RWZWN0b3IueCAqIGFiVmVjdG9yLnkgKyBhYlZlY3Rvci54ICogY2RWZWN0b3IueTtcbiAgICAgICAgICAgIGlmIChkZW5vbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcyA9IChhYlZlY3Rvci54ICogKGEueSAtIGMueSkgLSBhYlZlY3Rvci55ICogKGEueCAtIGMueCkpIC8gZGVub207XG4gICAgICAgICAgICB2YXIgdCA9IChjZFZlY3Rvci54ICogKGEueSAtIGMueSkgLSBjZFZlY3Rvci55ICogKGEueCAtIGMueCkpIC8gZGVub207XG5cbiAgICAgICAgICAgIGlmICgtRVBTSUxPTiA8PSBzICYmIHMgPD0gMSAtIEVQU0lMT04gJiZcbiAgICAgICAgICAgICAgICAtRVBTSUxPTiA8PSB0ICYmIHQgPD0gMSAtIEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoYS54ICsgdCAqIGFiVmVjdG9yLngsIGEueSArIHQgKiBhYlZlY3Rvci55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblggPSBpbnRlcnNlY3Rpb25Qb2ludHNbMF0ueDtcbiAgICAgICAgdmFyIG1heFggPSBpbnRlcnNlY3Rpb25Qb2ludHNbMF0ueDtcbiAgICAgICAgdmFyIG1pblkgPSBpbnRlcnNlY3Rpb25Qb2ludHNbMF0ueTtcbiAgICAgICAgdmFyIG1heFkgPSBpbnRlcnNlY3Rpb25Qb2ludHNbMF0ueTtcbiAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGludGVyc2VjdGlvblBvaW50c1trXTtcbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgbWluWCkge1xuICAgICAgICAgICAgICAgIG1pblggPSBwb2ludC54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvaW50LnggPiBtYXhYKSB7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHBvaW50Lng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9pbnQueSA8IG1pblkpIHtcbiAgICAgICAgICAgICAgICBtaW5ZID0gcG9pbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludC55ID4gbWF4WSkge1xuICAgICAgICAgICAgICAgIG1heFkgPSBwb2ludC55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfZ2V0U2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9wTGVmdCA9IHRoaXMuZ2V0VG9wTGVmdCgpO1xuICAgICAgICB2YXIgdG9wUmlnaHQgPSB0aGlzLmdldFRvcFJpZ2h0KCk7XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gdGhpcy5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgIHZhciBib3R0b21SaWdodCA9IHRoaXMuZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgcmV0dXJuIFtbdG9wTGVmdCwgdG9wUmlnaHRdLFxuICAgICAgICAgICAgW3RvcFJpZ2h0LCBib3R0b21SaWdodF0sXG4gICAgICAgICAgICBbYm90dG9tUmlnaHQsIGJvdHRvbUxlZnRdLFxuICAgICAgICAgICAgW2JvdHRvbUxlZnQsIHRvcExlZnRdXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBhIHJlY3RhbmdsZSBhcm91bmQgYSBwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlcyB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBbcGl2b3RdIFRoZSBwb2ludCBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIGNlbnRlciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUmVjdH1cbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGRlZ3JlZXMsIHBpdm90KSB7XG4gICAgICAgIGRlZ3JlZXMgPSBkZWdyZWVzICUgMzYwO1xuICAgICAgICBpZiAoZGVncmVlcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVncmVlcyA8IDApIHtcbiAgICAgICAgICAgIGRlZ3JlZXMgKz0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgcGl2b3QgPSBwaXZvdCB8fCB0aGlzLmdldENlbnRlcigpO1xuICAgICAgICB2YXIgbmV3VG9wTGVmdCA9IHRoaXMuZ2V0VG9wTGVmdCgpLnJvdGF0ZShkZWdyZWVzLCBwaXZvdCk7XG4gICAgICAgIHZhciBuZXdUb3BSaWdodCA9IHRoaXMuZ2V0VG9wUmlnaHQoKS5yb3RhdGUoZGVncmVlcywgcGl2b3QpO1xuXG4gICAgICAgIHZhciBkaWZmID0gbmV3VG9wUmlnaHQubWludXMobmV3VG9wTGVmdCk7XG4gICAgICAgIHZhciByYWRpYW5zID0gTWF0aC5hdGFuKGRpZmYueSAvIGRpZmYueCk7XG4gICAgICAgIGlmIChkaWZmLnggPCAwKSB7XG4gICAgICAgICAgICByYWRpYW5zICs9IE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZi55IDwgMCkge1xuICAgICAgICAgICAgcmFkaWFucyArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIG5ld1RvcExlZnQueCxcbiAgICAgICAgICAgIG5ld1RvcExlZnQueSxcbiAgICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgICB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHJhZGlhbnMgLyBNYXRoLlBJICogMTgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzbWFsbGVzdCBob3Jpem9udGFsIChkZWdyZWVzPTApIHJlY3RhbmdsZSB3aGljaCBjb250YWluc1xuICAgICAqIHRoaXMgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9XG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWdyZWVzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5nZXRUb3BMZWZ0KCk7XG4gICAgICAgIHZhciB0b3BSaWdodCA9IHRoaXMuZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSB0aGlzLmdldEJvdHRvbUxlZnQoKTtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluKHRvcExlZnQueCwgdG9wUmlnaHQueCwgYm90dG9tTGVmdC54LCBib3R0b21SaWdodC54KTtcbiAgICAgICAgdmFyIG1heFggPSBNYXRoLm1heCh0b3BMZWZ0LngsIHRvcFJpZ2h0LngsIGJvdHRvbUxlZnQueCwgYm90dG9tUmlnaHQueCk7XG4gICAgICAgIHZhciBtaW5ZID0gTWF0aC5taW4odG9wTGVmdC55LCB0b3BSaWdodC55LCBib3R0b21MZWZ0LnksIGJvdHRvbVJpZ2h0LnkpO1xuICAgICAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHRvcExlZnQueSwgdG9wUmlnaHQueSwgYm90dG9tTGVmdC55LCBib3R0b21SaWdodC55KTtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBtaW5YLFxuICAgICAgICAgICAgbWluWSxcbiAgICAgICAgICAgIG1heFggLSBtaW5YLFxuICAgICAgICAgICAgbWF4WSAtIG1pblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNtYWxsZXN0IGhvcml6b250YWwgKGRlZ3JlZXM9MCkgcmVjdGFuZ2xlIHdoaWNoIGNvbnRhaW5zXG4gICAgICogdGhpcyByZWN0YW5nbGUgYW5kIGhhcyBpbnRlZ2VycyB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH1cbiAgICAgKi9cbiAgICBnZXRJbnRlZ2VyQm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54KTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LnkpO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoYm91bmRpbmdCb3gud2lkdGggKyBib3VuZGluZ0JveC54IC0geCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmNlaWwoYm91bmRpbmdCb3guaGVpZ2h0ICsgYm91bmRpbmdCb3gueSAtIHkpO1xuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgcmVjdGFuZ2xlIChlZGdlIGluY2x1ZGVkKS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlcHNpbG9uPTBdIHRoZSBtYXJnaW4gb2YgZXJyb3IgYWxsb3dlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhpcyByZWN0YW5nbGUsIGZhbHNlXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBlcHNpbG9uKSB7XG4gICAgICAgIGVwc2lsb24gPSBlcHNpbG9uIHx8IDA7XG5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3NTI3NTQvMTQ0MDQwMyBmb3IgZXhwbGFuYXRpb25cbiAgICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLmdldFRvcExlZnQoKTtcbiAgICAgICAgdmFyIHRvcFJpZ2h0ID0gdGhpcy5nZXRUb3BSaWdodCgpO1xuICAgICAgICB2YXIgYm90dG9tTGVmdCA9IHRoaXMuZ2V0Qm90dG9tTGVmdCgpO1xuICAgICAgICB2YXIgdG9wRGlmZiA9IHRvcFJpZ2h0Lm1pbnVzKHRvcExlZnQpO1xuICAgICAgICB2YXIgbGVmdERpZmYgPSBib3R0b21MZWZ0Lm1pbnVzKHRvcExlZnQpO1xuXG4gICAgICAgIHJldHVybiAoKHBvaW50LnggLSB0b3BMZWZ0LngpICogdG9wRGlmZi54ICtcbiAgICAgICAgICAgIChwb2ludC55IC0gdG9wTGVmdC55KSAqIHRvcERpZmYueSA+PSAtZXBzaWxvbikgJiZcblxuICAgICAgICAgICAgKChwb2ludC54IC0gdG9wUmlnaHQueCkgKiB0b3BEaWZmLnggK1xuICAgICAgICAgICAgKHBvaW50LnkgLSB0b3BSaWdodC55KSAqIHRvcERpZmYueSA8PSBlcHNpbG9uKSAmJlxuXG4gICAgICAgICAgICAoKHBvaW50LnggLSB0b3BMZWZ0LngpICogbGVmdERpZmYueCArXG4gICAgICAgICAgICAocG9pbnQueSAtIHRvcExlZnQueSkgKiBsZWZ0RGlmZi55ID49IC1lcHNpbG9uKSAmJlxuXG4gICAgICAgICAgICAoKHBvaW50LnggLSBib3R0b21MZWZ0LngpICogbGVmdERpZmYueCArXG4gICAgICAgICAgICAocG9pbnQueSAtIGJvdHRvbUxlZnQueSkgKiBsZWZ0RGlmZi55IDw9IGVwc2lsb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIHdoaWNoIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiBkZWJ1Z2dpbmcuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArXG4gICAgICAgICAgICAoTWF0aC5yb3VuZCh0aGlzLnggKiAxMDApIC8gMTAwKSArIFwiLCBcIiArXG4gICAgICAgICAgICAoTWF0aC5yb3VuZCh0aGlzLnkgKiAxMDApIC8gMTAwKSArIFwiLCBcIiArXG4gICAgICAgICAgICAoTWF0aC5yb3VuZCh0aGlzLndpZHRoICogMTAwKSAvIDEwMCkgKyBcInhcIiArXG4gICAgICAgICAgICAoTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIDEwMCkgLyAxMDApICsgXCIsIFwiICtcbiAgICAgICAgICAgIChNYXRoLnJvdW5kKHRoaXMuZGVncmVlcyAqIDEwMCkgLyAxMDApICsgXCJkZWdcIiArXG4gICAgICAgICAgICBcIl1cIjtcbiAgICB9XG59O1xuXG5cbn0oT3BlblNlYWRyYWdvbikpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFJlZmVyZW5jZVN0cmlwXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiAoICQgKSB7XG5cbi8vIGRpY3Rpb25hcnkgZnJvbSBpZCB0byBwcml2YXRlIHByb3BlcnRpZXNcbnZhciBUSElTID0ge307XG5cbi8qKlxuICogIFRoZSBDb2xsZWN0aW9uRHJhd2VyIGlzIGEgcmVpbXBsZW1lbnRhdGlvbiBpZiB0aGUgRHJhd2VyIEFQSSB0aGF0XG4gKiAgZm9jdXNlcyBvbiBhbGxvd2luZyBhIHZpZXdwb3J0IHRvIGJlIHJlZGVmaW5lZCBhcyBhIGNvbGxlY3Rpb25cbiAqICBvZiBzbWFsbGVyIHZpZXdwb3J0cywgZGVmaW5lZCBieSBhIGNsZWFyIG51bWJlciBvZiByb3dzIGFuZCAvIG9yXG4gKiAgY29sdW1ucyBvZiB3aGljaCBlYWNoIGl0ZW0gaW4gdGhlIG1hdHJpeCBvZiB2aWV3cG9ydHMgaGFzIGl0cyBvd25cbiAqICBzb3VyY2UuXG4gKlxuICogIFRoaXMgaWRlYSBpcyBhIHJlZXhwcmVzc2lvbiBvZiB0aGUgaWRlYSBvZiBkemkgY29sbGVjdGlvbnNcbiAqICB3aGljaCBhbGxvd3MgYSBjbGVhcmVyIGFsZ29yaXRobSB0byByZXVzZSB0aGUgdGlsZSBzb3VyY2VzIGFscmVhZHlcbiAqICBzdXBwb3J0ZWQgYnkgT3BlblNlYWRyYWdvbiwgaW4gaGV0ZXJvZ2VuaW91cyBvciBob21vZ2VuaW91c1xuICogIHNlcXVlbmNlcyBqdXN0IGxpa2UgbWl4ZWQgZ3JvdXBzIGFscmVhZHkgc3VwcG9ydGVkIGJ5IHRoZSB2aWV3ZXJcbiAqICBmb3IgdGhlIHB1cnBvc2Ugb2YgaW1hZ2Ugc2VxdW5jZXMuXG4gKlxuICogIFRPRE86ICAgVGhlIGRpZmZpY3VsdCBwYXJ0IG9mIHRoaXMgZmVhdHVyZSBpcyBmaWd1cmluZyBvdXQgaG93IHRvIGV4cHJlc3NcbiAqICAgICAgICAgIHRoaXMgZnVuY3Rpb25hbGl0eSBhcyBhIGNvbWJpbmF0aW9uIG9mIHRoZSBmdW5jdGlvbmFsaXR5IGFscmVhZHlcbiAqICAgICAgICAgIHByb3ZpZGVkIGJ5IERyYXdlciwgVmlld3BvcnQsIFRpbGVTb3VyY2UsIGFuZCBOYXZpZ2F0b3IuICBJdCBtYXlcbiAqICAgICAgICAgIHJlcXVpcmUgYmV0dGVyIGFic3RyYWN0aW9uIGF0IHRob3NlIHBvaW50cyBpbiBvcmRlciB0byBlZmZlY2llbnRseVxuICogICAgICAgICAgcmV1c2UgdGhvc2UgcGFyYWRpZ21zLlxuICovXG4vKipcbiAqIEBjbGFzcyBSZWZlcmVuY2VTdHJpcFxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbiQuUmVmZXJlbmNlU3RyaXAgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cbiAgICB2YXIgX3RoaXMgICAgICAgPSB0aGlzLFxuICAgICAgICB2aWV3ZXIgICAgICA9IG9wdGlvbnMudmlld2VyLFxuICAgICAgICB2aWV3ZXJTaXplICA9ICQuZ2V0RWxlbWVudFNpemUoIHZpZXdlci5lbGVtZW50ICksXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBpO1xuXG4gICAgLy9XZSBtYXkgbmVlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudCBhbmQgaWQgaWYgdGhleSBkaWQgbm90XG4gICAgLy9wcm92aWRlIHRoZSBpZCBmb3IgdGhlIGV4aXN0aW5nIGVsZW1lbnRcbiAgICBpZiAoICFvcHRpb25zLmlkICkge1xuICAgICAgICBvcHRpb25zLmlkICAgICAgICAgICAgICA9ICdyZWZlcmVuY2VzdHJpcC0nICsgJC5ub3coKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ICAgICAgICAgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuICAgICAgICB0aGlzLmVsZW1lbnQuaWQgICAgICAgICA9IG9wdGlvbnMuaWQ7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgID0gJ3JlZmVyZW5jZXN0cmlwJztcbiAgICB9XG5cbiAgICBvcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHtcbiAgICAgICAgc2l6ZVJhdGlvOiAgJC5ERUZBVUxUX1NFVFRJTkdTLnJlZmVyZW5jZVN0cmlwU2l6ZVJhdGlvLFxuICAgICAgICBwb3NpdGlvbjogICAkLkRFRkFVTFRfU0VUVElOR1MucmVmZXJlbmNlU3RyaXBQb3NpdGlvbixcbiAgICAgICAgc2Nyb2xsOiAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLnJlZmVyZW5jZVN0cmlwU2Nyb2xsLFxuICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6ICAkLkRFRkFVTFRfU0VUVElOR1MuY2xpY2tUaW1lVGhyZXNob2xkXG4gICAgfSwgb3B0aW9ucywge1xuICAgICAgICAvL3JlcXVpcmVkIG92ZXJyaWRlc1xuICAgICAgICBlbGVtZW50OiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgIC8vVGhlc2UgbmVlZCB0byBiZSBvdmVycmlkZGVuIHRvIHByZXZlbnQgcmVjdXJzaW9uIHNpbmNlXG4gICAgICAgIC8vdGhlIG5hdmlnYXRvciBpcyBhIHZpZXdlciBhbmQgYSB2aWV3ZXIgaGFzIGEgbmF2aWdhdG9yXG4gICAgICAgIHNob3dOYXZpZ2F0b3I6ICAgICAgICAgIGZhbHNlLFxuICAgICAgICBtb3VzZU5hdkVuYWJsZWQ6ICAgICAgICBmYWxzZSxcbiAgICAgICAgc2hvd05hdmlnYXRpb25Db250cm9sOiAgZmFsc2UsXG4gICAgICAgIHNob3dTZXF1ZW5jZUNvbnRyb2w6ICAgIGZhbHNlXG4gICAgfSApO1xuXG4gICAgJC5leHRlbmQoIHRoaXMsIG9wdGlvbnMgKTtcbiAgICAvL1ByaXZhdGUgc3RhdGUgcHJvcGVydGllc1xuICAgIFRISVNbdGhpcy5pZF0gPSB7XG4gICAgICAgIFwiYW5pbWF0aW5nXCI6ICAgICAgICAgICBmYWxzZVxuICAgIH07XG5cbiAgICB0aGlzLm1pblBpeGVsUmF0aW8gPSB0aGlzLnZpZXdlci5taW5QaXhlbFJhdGlvO1xuXG4gICAgc3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGU7XG4gICAgc3R5bGUubWFyZ2luVG9wICAgICA9ICcwcHgnO1xuICAgIHN0eWxlLm1hcmdpblJpZ2h0ICAgPSAnMHB4JztcbiAgICBzdHlsZS5tYXJnaW5Cb3R0b20gID0gJzBweCc7XG4gICAgc3R5bGUubWFyZ2luTGVmdCAgICA9ICcwcHgnO1xuICAgIHN0eWxlLmxlZnQgICAgICAgICAgPSAnMHB4JztcbiAgICBzdHlsZS5ib3R0b20gICAgICAgID0gJzBweCc7XG4gICAgc3R5bGUuYm9yZGVyICAgICAgICA9ICcwcHgnO1xuICAgIHN0eWxlLmJhY2tncm91bmQgICAgPSAnIzAwMCc7XG4gICAgc3R5bGUucG9zaXRpb24gICAgICA9ICdyZWxhdGl2ZSc7XG5cbiAgICAkLnNldEVsZW1lbnRUb3VjaEFjdGlvbk5vbmUoIHRoaXMuZWxlbWVudCApO1xuXG4gICAgJC5zZXRFbGVtZW50T3BhY2l0eSggdGhpcy5lbGVtZW50LCAwLjggKTtcblxuICAgIHRoaXMudmlld2VyID0gdmlld2VyO1xuICAgIHRoaXMuaW5uZXJUcmFja2VyID0gbmV3ICQuTW91c2VUcmFja2VyKCB7XG4gICAgICAgIGVsZW1lbnQ6ICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGRyYWdIYW5kbGVyOiAgICAkLmRlbGVnYXRlKCB0aGlzLCBvblN0cmlwRHJhZyApLFxuICAgICAgICBzY3JvbGxIYW5kbGVyOiAgJC5kZWxlZ2F0ZSggdGhpcywgb25TdHJpcFNjcm9sbCApLFxuICAgICAgICBlbnRlckhhbmRsZXI6ICAgJC5kZWxlZ2F0ZSggdGhpcywgb25TdHJpcEVudGVyICksXG4gICAgICAgIGV4aXRIYW5kbGVyOiAgICAkLmRlbGVnYXRlKCB0aGlzLCBvblN0cmlwRXhpdCApLFxuICAgICAgICBrZXlEb3duSGFuZGxlcjogJC5kZWxlZ2F0ZSggdGhpcywgb25LZXlEb3duICksXG4gICAgICAgIGtleUhhbmRsZXI6ICAgICAkLmRlbGVnYXRlKCB0aGlzLCBvbktleVByZXNzIClcbiAgICB9ICk7XG5cbiAgICAvL0NvbnRyb2xzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIHJlZmVyZW5jZSBzdHJpcCBhbmQgc2V0cyB0aGVcbiAgICAvL2FwcHJvcHJpYXRlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBpZiAoIG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQgKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCAgPSBvcHRpb25zLndpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdmlld2VyLmFkZENvbnRyb2woXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICB7IGFuY2hvcjogJC5Db250cm9sQW5jaG9yLkJPVFRPTV9MRUZUIH1cbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIFwiaG9yaXpvbnRhbFwiID09IG9wdGlvbnMuc2Nyb2xsICkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKFxuICAgICAgICAgICAgICAgIHZpZXdlclNpemUueCAqXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaXplUmF0aW8gKlxuICAgICAgICAgICAgICAgIHZpZXdlci50aWxlU291cmNlcy5sZW5ndGhcbiAgICAgICAgICAgICkgKyAoIDEyICogdmlld2VyLnRpbGVTb3VyY2VzLmxlbmd0aCApICsgJ3B4JztcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChcbiAgICAgICAgICAgICAgICB2aWV3ZXJTaXplLnkgKlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2l6ZVJhdGlvXG4gICAgICAgICAgICApICsgJ3B4JztcblxuICAgICAgICAgICAgdmlld2VyLmFkZENvbnRyb2woXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIHsgYW5jaG9yOiAkLkNvbnRyb2xBbmNob3IuQk9UVE9NX0xFRlQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoXG4gICAgICAgICAgICAgICAgdmlld2VyU2l6ZS55ICpcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpemVSYXRpbyAqXG4gICAgICAgICAgICAgICAgdmlld2VyLnRpbGVTb3VyY2VzLmxlbmd0aFxuICAgICAgICAgICAgKSArICggMTIgKiB2aWV3ZXIudGlsZVNvdXJjZXMubGVuZ3RoICkgKyAncHgnO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAoXG4gICAgICAgICAgICAgICAgdmlld2VyU2l6ZS54ICpcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpemVSYXRpb1xuICAgICAgICAgICAgKSArICdweCc7XG5cbiAgICAgICAgICAgIHZpZXdlci5hZGRDb250cm9sKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB7IGFuY2hvcjogJC5Db250cm9sQW5jaG9yLlRPUF9MRUZUIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGFuZWxXaWR0aCA9ICggdmlld2VyU2l6ZS54ICogdGhpcy5zaXplUmF0aW8gKSArIDg7XG4gICAgdGhpcy5wYW5lbEhlaWdodCA9ICggdmlld2VyU2l6ZS55ICogdGhpcy5zaXplUmF0aW8gKSArIDg7XG4gICAgdGhpcy5wYW5lbHMgPSBbXTtcblxuICAgIC8qanNoaW50IGxvb3BmdW5jOnRydWUqL1xuICAgIGZvciAoIGkgPSAwOyBpIDwgdmlld2VyLnRpbGVTb3VyY2VzLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgIGVsZW1lbnQgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgZWxlbWVudC5pZCA9IHRoaXMuZWxlbWVudC5pZCArIFwiLVwiICsgaTtcblxuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoICAgICAgICAgPSBfdGhpcy5wYW5lbFdpZHRoICsgJ3B4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgICAgICAgID0gX3RoaXMucGFuZWxIZWlnaHQgKyAncHgnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgICAgICAgPSAnaW5saW5lJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5mbG9hdCAgICAgICAgID0gJ2xlZnQnOyAvL1dlYmtpdFxuICAgICAgICBlbGVtZW50LnN0eWxlLmNzc0Zsb2F0ICAgICAgPSAnbGVmdCc7IC8vRmlyZWZveFxuICAgICAgICBlbGVtZW50LnN0eWxlLnN0eWxlRmxvYXQgICAgPSAnbGVmdCc7IC8vSUVcbiAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nICAgICAgID0gJzJweCc7XG4gICAgICAgICQuc2V0RWxlbWVudFRvdWNoQWN0aW9uTm9uZSggZWxlbWVudCApO1xuXG4gICAgICAgIGVsZW1lbnQuaW5uZXJUcmFja2VyID0gbmV3ICQuTW91c2VUcmFja2VyKCB7XG4gICAgICAgICAgICBlbGVtZW50OiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBjbGlja1RpbWVUaHJlc2hvbGQ6IHRoaXMuY2xpY2tUaW1lVGhyZXNob2xkLFxuICAgICAgICAgICAgY2xpY2tEaXN0VGhyZXNob2xkOiB0aGlzLmNsaWNrRGlzdFRocmVzaG9sZCxcbiAgICAgICAgICAgIHByZXNzSGFuZGxlcjogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICBldmVudC5ldmVudFNvdXJjZS5kcmFnZ2luZyA9ICQubm93KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsZWFzZUhhbmRsZXI6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrZXIgPSBldmVudC5ldmVudFNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA9IHRyYWNrZXIuZWxlbWVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZSAgICA9IE51bWJlciggaWQuc3BsaXQoICctJyApWzJdICksXG4gICAgICAgICAgICAgICAgICAgIG5vdyAgICAgPSAkLm5vdygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC5pbnNpZGVFbGVtZW50UHJlc3NlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaW5zaWRlRWxlbWVudFJlbGVhc2VkICYmXG4gICAgICAgICAgICAgICAgICAgICB0cmFja2VyLmRyYWdnaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICAoIG5vdyAtIHRyYWNrZXIuZHJhZ2dpbmcgKSA8IHRyYWNrZXIuY2xpY2tUaW1lVGhyZXNob2xkICkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLmdvVG9QYWdlKCBwYWdlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCBlbGVtZW50ICk7XG5cbiAgICAgICAgZWxlbWVudC5hY3RpdmVQYW5lbCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucGFuZWxzLnB1c2goIGVsZW1lbnQgKTtcblxuICAgIH1cbiAgICBsb2FkUGFuZWxzKCB0aGlzLCB0aGlzLnNjcm9sbCA9PSAndmVydGljYWwnID8gdmlld2VyU2l6ZS55IDogdmlld2VyU2l6ZS54LCAwICk7XG4gICAgdGhpcy5zZXRGb2N1cyggMCApO1xuXG59O1xuXG4kLmV4dGVuZCggJC5SZWZlcmVuY2VTdHJpcC5wcm90b3R5cGUsICQuRXZlbnRTb3VyY2UucHJvdG90eXBlLCAkLlZpZXdlci5wcm90b3R5cGUsIC8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5SZWZlcmVuY2VTdHJpcC5wcm90b3R5cGUgKi97XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZXRGb2N1czogZnVuY3Rpb24gKCBwYWdlICkge1xuICAgICAgICB2YXIgZWxlbWVudCAgICAgID0gJC5nZXRFbGVtZW50KCB0aGlzLmVsZW1lbnQuaWQgKyAnLScgKyBwYWdlICksXG4gICAgICAgICAgICB2aWV3ZXJTaXplICAgPSAkLmdldEVsZW1lbnRTaXplKCB0aGlzLnZpZXdlci5jYW52YXMgKSxcbiAgICAgICAgICAgIHNjcm9sbFdpZHRoICA9IE51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoLnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IE51bWJlciggdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgICAgICBvZmZzZXRMZWZ0ICAgPSAtTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdC5yZXBsYWNlKCAncHgnLCAnJyApICksXG4gICAgICAgICAgICBvZmZzZXRUb3AgICAgPSAtTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wLnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgICAgIG9mZnNldDtcblxuICAgICAgICBpZiAoIHRoaXMuY3VycmVudFNlbGVjdGVkICE9PSBlbGVtZW50ICkge1xuICAgICAgICAgICAgaWYgKCB0aGlzLmN1cnJlbnRTZWxlY3RlZCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3RlZC5zdHlsZS5iYWNrZ3JvdW5kID0gJyMwMDAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0ZWQgPSBlbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0ZWQuc3R5bGUuYmFja2dyb3VuZCA9ICcjOTk5JztcblxuICAgICAgICAgICAgaWYgKCAnaG9yaXpvbnRhbCcgPT0gdGhpcy5zY3JvbGwgKSB7XG4gICAgICAgICAgICAgICAgLy9yaWdodCBsZWZ0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKCBOdW1iZXIoIHBhZ2UgKSApICogKCB0aGlzLnBhbmVsV2lkdGggKyAzICk7XG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXQgPiBvZmZzZXRMZWZ0ICsgdmlld2VyU2l6ZS54IC0gdGhpcy5wYW5lbFdpZHRoICkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbiggb2Zmc2V0LCAoIHNjcm9sbFdpZHRoIC0gdmlld2VyU2l6ZS54ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAtb2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgbG9hZFBhbmVscyggdGhpcywgdmlld2VyU2l6ZS54LCAtb2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggb2Zmc2V0IDwgb2Zmc2V0TGVmdCApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoIDAsIG9mZnNldCAtIHZpZXdlclNpemUueCAvIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAtb2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgbG9hZFBhbmVscyggdGhpcywgdmlld2VyU2l6ZS54LCAtb2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAoIE51bWJlciggcGFnZSApICkgKiAoIHRoaXMucGFuZWxIZWlnaHQgKyAzICk7XG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXQgPiBvZmZzZXRUb3AgKyB2aWV3ZXJTaXplLnkgLSB0aGlzLnBhbmVsSGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbiggb2Zmc2V0LCAoIHNjcm9sbEhlaWdodCAtIHZpZXdlclNpemUueSApICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAtb2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgbG9hZFBhbmVscyggdGhpcywgdmlld2VyU2l6ZS55LCAtb2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggb2Zmc2V0IDwgb2Zmc2V0VG9wICkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCggMCwgb2Zmc2V0IC0gdmlld2VyU2l6ZS55IC8gMiApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gLW9mZnNldCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueSwgLW9mZnNldCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICBvblN0cmlwRW50ZXIuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy5pbm5lclRyYWNrZXIgfSApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIFRISVNbdGhpcy5pZF0uYW5pbWF0aW5nICkge1xuICAgICAgICAgICAgJC5jb25zb2xlLmxvZyggJ2ltYWdlIHJlZmVyZW5jZSBzdHJpcCB1cGRhdGUnICk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlcyBWaWV3ZXIuZGVzdHJveVxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59ICk7XG5cblxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uU3RyaXBEcmFnKCBldmVudCApIHtcblxuICAgIHZhciBvZmZzZXRMZWZ0ICAgPSBOdW1iZXIoIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0LnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgb2Zmc2V0VG9wICAgID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wLnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgc2Nyb2xsV2lkdGggID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGgucmVwbGFjZSggJ3B4JywgJycgKSApLFxuICAgICAgICBzY3JvbGxIZWlnaHQgPSBOdW1iZXIoIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQucmVwbGFjZSggJ3B4JywgJycgKSApLFxuICAgICAgICB2aWV3ZXJTaXplICAgPSAkLmdldEVsZW1lbnRTaXplKCB0aGlzLnZpZXdlci5jYW52YXMgKTtcbiAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICBpZiAoIHRoaXMuZWxlbWVudCApIHtcbiAgICAgICAgaWYgKCAnaG9yaXpvbnRhbCcgPT0gdGhpcy5zY3JvbGwgKSB7XG4gICAgICAgICAgICBpZiAoIC1ldmVudC5kZWx0YS54ID4gMCApIHtcbiAgICAgICAgICAgICAgICAvL2ZvcndhcmRcbiAgICAgICAgICAgICAgICBpZiAoIG9mZnNldExlZnQgPiAtKCBzY3JvbGxXaWR0aCAtIHZpZXdlclNpemUueCApICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9ICggb2Zmc2V0TGVmdCArICggZXZlbnQuZGVsdGEueCAqIDIgKSApICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgbG9hZFBhbmVscyggdGhpcywgdmlld2VyU2l6ZS54LCBvZmZzZXRMZWZ0ICsgKCBldmVudC5kZWx0YS54ICogMiApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggLWV2ZW50LmRlbHRhLnggPCAwICkge1xuICAgICAgICAgICAgICAgIC8vcmV2ZXJzZVxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0TGVmdCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gKCBvZmZzZXRMZWZ0ICsgKCBldmVudC5kZWx0YS54ICogMiApICkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLngsIG9mZnNldExlZnQgKyAoIGV2ZW50LmRlbHRhLnggKiAyICkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIC1ldmVudC5kZWx0YS55ID4gMCApIHtcbiAgICAgICAgICAgICAgICAvL2ZvcndhcmRcbiAgICAgICAgICAgICAgICBpZiAoIG9mZnNldFRvcCA+IC0oIHNjcm9sbEhlaWdodCAtIHZpZXdlclNpemUueSApICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gKCBvZmZzZXRUb3AgKyAoIGV2ZW50LmRlbHRhLnkgKiAyICkgKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueSwgb2Zmc2V0VG9wICsgKCBldmVudC5kZWx0YS55ICogMiApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggLWV2ZW50LmRlbHRhLnkgPCAwICkge1xuICAgICAgICAgICAgICAgIC8vcmV2ZXJzZVxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0VG9wIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICggb2Zmc2V0VG9wICsgKCBldmVudC5kZWx0YS55ICogMiApICkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICBsb2FkUGFuZWxzKCB0aGlzLCB2aWV3ZXJTaXplLnksIG9mZnNldFRvcCArICggZXZlbnQuZGVsdGEueSAqIDIgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG5cbn1cblxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uU3RyaXBTY3JvbGwoIGV2ZW50ICkge1xuICAgIHZhciBvZmZzZXRMZWZ0ICAgPSBOdW1iZXIoIHRoaXMuZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0LnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgb2Zmc2V0VG9wICAgID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wLnJlcGxhY2UoICdweCcsICcnICkgKSxcbiAgICAgICAgc2Nyb2xsV2lkdGggID0gTnVtYmVyKCB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGgucmVwbGFjZSggJ3B4JywgJycgKSApLFxuICAgICAgICBzY3JvbGxIZWlnaHQgPSBOdW1iZXIoIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQucmVwbGFjZSggJ3B4JywgJycgKSApLFxuICAgICAgICB2aWV3ZXJTaXplICAgPSAkLmdldEVsZW1lbnRTaXplKCB0aGlzLnZpZXdlci5jYW52YXMgKTtcbiAgICBpZiAoIHRoaXMuZWxlbWVudCApIHtcbiAgICAgICAgaWYgKCAnaG9yaXpvbnRhbCcgPT0gdGhpcy5zY3JvbGwgKSB7XG4gICAgICAgICAgICBpZiAoIGV2ZW50LnNjcm9sbCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgLy9mb3J3YXJkXG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXRMZWZ0ID4gLSggc2Nyb2xsV2lkdGggLSB2aWV3ZXJTaXplLnggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAoIG9mZnNldExlZnQgLSAoIGV2ZW50LnNjcm9sbCAqIDYwICkgKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueCwgb2Zmc2V0TGVmdCAtICggZXZlbnQuc2Nyb2xsICogNjAgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50LnNjcm9sbCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgLy9yZXZlcnNlXG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXRMZWZ0IDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAoIG9mZnNldExlZnQgLSAoIGV2ZW50LnNjcm9sbCAqIDYwICkgKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueCwgb2Zmc2V0TGVmdCAtICggZXZlbnQuc2Nyb2xsICogNjAgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggZXZlbnQuc2Nyb2xsIDwgMCApIHtcbiAgICAgICAgICAgICAgICAvL3Njcm9sbCB1cFxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0VG9wID4gdmlld2VyU2l6ZS55IC0gc2Nyb2xsSGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gKCBvZmZzZXRUb3AgKyAoIGV2ZW50LnNjcm9sbCAqIDYwICkgKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueSwgb2Zmc2V0VG9wICsgKCBldmVudC5zY3JvbGwgKiA2MCApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggZXZlbnQuc2Nyb2xsID4gMCApIHtcbiAgICAgICAgICAgICAgICAvL3Njcm9sbCBkb3dtXG4gICAgICAgICAgICAgICAgaWYgKCBvZmZzZXRUb3AgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gKCBvZmZzZXRUb3AgKyAoIGV2ZW50LnNjcm9sbCAqIDYwICkgKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYW5lbHMoIHRoaXMsIHZpZXdlclNpemUueSwgb2Zmc2V0VG9wICsgKCBldmVudC5zY3JvbGwgKiA2MCApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vY2FuY2VscyBldmVudFxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuXG5mdW5jdGlvbiBsb2FkUGFuZWxzKCBzdHJpcCwgdmlld2VyU2l6ZSwgc2Nyb2xsICkge1xuICAgIHZhciBwYW5lbFNpemUsXG4gICAgICAgIGFjdGl2ZVBhbmVsc1N0YXJ0LFxuICAgICAgICBhY3RpdmVQYW5lbHNFbmQsXG4gICAgICAgIG1pbmlWaWV3ZXIsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBpLFxuICAgICAgICBlbGVtZW50O1xuICAgIGlmICggJ2hvcml6b250YWwnID09IHN0cmlwLnNjcm9sbCApIHtcbiAgICAgICAgcGFuZWxTaXplID0gc3RyaXAucGFuZWxXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYW5lbFNpemUgPSBzdHJpcC5wYW5lbEhlaWdodDtcbiAgICB9XG4gICAgYWN0aXZlUGFuZWxzU3RhcnQgPSBNYXRoLmNlaWwoIHZpZXdlclNpemUgLyBwYW5lbFNpemUgKSArIDU7XG4gICAgYWN0aXZlUGFuZWxzRW5kID0gTWF0aC5jZWlsKCAoIE1hdGguYWJzKCBzY3JvbGwgKSArIHZpZXdlclNpemUgKSAvIHBhbmVsU2l6ZSApICsgMTtcbiAgICBhY3RpdmVQYW5lbHNTdGFydCA9IGFjdGl2ZVBhbmVsc0VuZCAtIGFjdGl2ZVBhbmVsc1N0YXJ0O1xuICAgIGFjdGl2ZVBhbmVsc1N0YXJ0ID0gYWN0aXZlUGFuZWxzU3RhcnQgPCAwID8gMCA6IGFjdGl2ZVBhbmVsc1N0YXJ0O1xuXG4gICAgZm9yICggaSA9IGFjdGl2ZVBhbmVsc1N0YXJ0OyBpIDwgYWN0aXZlUGFuZWxzRW5kICYmIGkgPCBzdHJpcC5wYW5lbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGVsZW1lbnQgPSBzdHJpcC5wYW5lbHNbaV07XG4gICAgICAgIGlmICggIWVsZW1lbnQuYWN0aXZlUGFuZWwgKSB7XG4gICAgICAgICAgICBtaW5pVmlld2VyID0gbmV3ICQuVmlld2VyKCB7XG4gICAgICAgICAgICAgICAgaWQ6ICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pZCxcbiAgICAgICAgICAgICAgICB0aWxlU291cmNlczogICAgICAgICAgICBbc3RyaXAudmlld2VyLnRpbGVTb3VyY2VzW2ldXSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvclNpemVSYXRpbzogICAgIHN0cmlwLnNpemVSYXRpbyxcbiAgICAgICAgICAgICAgICBzaG93TmF2aWdhdG9yOiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBtb3VzZU5hdkVuYWJsZWQ6ICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93TmF2aWdhdGlvbkNvbnRyb2w6ICBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93U2VxdWVuY2VDb250cm9sOiAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbW1lZGlhdGVSZW5kZXI6ICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIGJsZW5kVGltZTogICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uVGltZTogICAgICAgICAgMFxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICBtaW5pVmlld2VyLmRpc3BsYXlSZWdpb24gICAgICAgICAgID0gJC5tYWtlTmV1dHJhbEVsZW1lbnQoIFwiZGl2XCIgKTtcbiAgICAgICAgICAgIG1pbmlWaWV3ZXIuZGlzcGxheVJlZ2lvbi5pZCAgICAgICAgPSBlbGVtZW50LmlkICsgJy1kaXNwbGF5cmVnaW9uJztcbiAgICAgICAgICAgIG1pbmlWaWV3ZXIuZGlzcGxheVJlZ2lvbi5jbGFzc05hbWUgPSAnZGlzcGxheXJlZ2lvbic7XG5cbiAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgICAgPSBtaW5pVmlld2VyLmRpc3BsYXlSZWdpb24uc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS5wb3NpdGlvbiAgICAgID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIHN0eWxlLnRvcCAgICAgICAgICAgPSAnMHB4JztcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgICAgICAgICAgPSAnMHB4JztcbiAgICAgICAgICAgIHN0eWxlLmZvbnRTaXplICAgICAgPSAnMHB4JztcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ICAgICAgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIHN0eWxlLmZsb2F0ICAgICAgICAgPSAnbGVmdCc7IC8vV2Via2l0XG4gICAgICAgICAgICBzdHlsZS5jc3NGbG9hdCAgICAgID0gJ2xlZnQnOyAvL0ZpcmVmb3hcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlRmxvYXQgICAgPSAnbGVmdCc7IC8vSUVcbiAgICAgICAgICAgIHN0eWxlLnpJbmRleCAgICAgICAgPSA5OTk5OTk5OTk7XG4gICAgICAgICAgICBzdHlsZS5jdXJzb3IgICAgICAgID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgc3R5bGUud2lkdGggICAgICAgICA9ICggc3RyaXAucGFuZWxXaWR0aCAtIDQgKSArICdweCc7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgICAgICAgID0gKCBzdHJpcC5wYW5lbEhlaWdodCAtIDQgKSArICdweCc7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgaXMgdGhpcyBmb3I/IEZ1dHVyZSBrZXlib2FyZCBuYXZpZ2F0aW9uIHN1cHBvcnQ/XG4gICAgICAgICAgICBtaW5pVmlld2VyLmRpc3BsYXlSZWdpb24uaW5uZXJUcmFja2VyID0gbmV3ICQuTW91c2VUcmFja2VyKCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogbWluaVZpZXdlci5kaXNwbGF5UmVnaW9uLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGlzYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2RpdicgKVswXS5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICBtaW5pVmlld2VyLmRpc3BsYXlSZWdpb25cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuYWN0aXZlUGFuZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uU3RyaXBFbnRlciggZXZlbnQgKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5ldmVudFNvdXJjZS5lbGVtZW50O1xuXG4gICAgLy8kLnNldEVsZW1lbnRPcGFjaXR5KGVsZW1lbnQsIDAuOCk7XG5cbiAgICAvL2VsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjNTU1JztcbiAgICAvL2VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9ICcjMDAwJztcblxuICAgIGlmICggJ2hvcml6b250YWwnID09IHRoaXMuc2Nyb2xsICkge1xuXG4gICAgICAgIC8vZWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wID0gXCIwcHhcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIjBweFwiO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcblxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gb25TdHJpcEV4aXQoIGV2ZW50ICkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZXZlbnRTb3VyY2UuZWxlbWVudDtcblxuICAgIGlmICggJ2hvcml6b250YWwnID09IHRoaXMuc2Nyb2xsICkge1xuXG4gICAgICAgIC8vZWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wID0gXCIxMHB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubWFyZ2luQm90dG9tID0gXCItXCIgKyAoICQuZ2V0RWxlbWVudFNpemUoIGVsZW1lbnQgKS55IC8gMiApICsgXCJweFwiO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIxMHB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiLVwiICsgKCAkLmdldEVsZW1lbnRTaXplKCBlbGVtZW50ICkueCAvIDIgKSArIFwicHhcIjtcblxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcbiAgICAvL2NvbnNvbGUubG9nKCBldmVudC5rZXlDb2RlICk7XG5cbiAgICBpZiAoICFldmVudC5wcmV2ZW50RGVmYXVsdEFjdGlvbiAmJiAhZXZlbnQuY3RybCAmJiAhZXZlbnQuYWx0ICYmICFldmVudC5tZXRhICkge1xuICAgICAgICBzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuICAgICAgICAgICAgY2FzZSAzODogLy91cCBhcnJvd1xuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAxLCBzaGlmdDogbnVsbCB9ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSA0MDogLy9kb3duIGFycm93XG4gICAgICAgICAgICAgICAgb25TdHJpcFNjcm9sbC5jYWxsKCB0aGlzLCB7IGV2ZW50U291cmNlOiB0aGlzLnRyYWNrZXIsIHBvc2l0aW9uOiBudWxsLCBzY3JvbGw6IC0xLCBzaGlmdDogbnVsbCB9ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAzNzogLy9sZWZ0IGFycm93XG4gICAgICAgICAgICAgICAgb25TdHJpcFNjcm9sbC5jYWxsKCB0aGlzLCB7IGV2ZW50U291cmNlOiB0aGlzLnRyYWNrZXIsIHBvc2l0aW9uOiBudWxsLCBzY3JvbGw6IC0xLCBzaGlmdDogbnVsbCB9ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAzOTogLy9yaWdodCBhcnJvd1xuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAxLCBzaGlmdDogbnVsbCB9ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAnbmF2aWdhdG9yIGtleWNvZGUgJXMnLCBldmVudC5rZXlDb2RlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gb25LZXlQcmVzcyggZXZlbnQgKSB7XG4gICAgLy9jb25zb2xlLmxvZyggZXZlbnQua2V5Q29kZSApO1xuXG4gICAgaWYgKCAhZXZlbnQucHJldmVudERlZmF1bHRBY3Rpb24gJiYgIWV2ZW50LmN0cmwgJiYgIWV2ZW50LmFsdCAmJiAhZXZlbnQubWV0YSApIHtcbiAgICAgICAgc3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcbiAgICAgICAgICAgIGNhc2UgNjE6IC8vPXwrXG4gICAgICAgICAgICAgICAgb25TdHJpcFNjcm9sbC5jYWxsKCB0aGlzLCB7IGV2ZW50U291cmNlOiB0aGlzLnRyYWNrZXIsIHBvc2l0aW9uOiBudWxsLCBzY3JvbGw6IDEsIHNoaWZ0OiBudWxsIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDQ1OiAvLy18X1xuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAtMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgNDg6IC8vMHwpXG4gICAgICAgICAgICBjYXNlIDExOTogLy93XG4gICAgICAgICAgICBjYXNlIDg3OiAvL1dcbiAgICAgICAgICAgICAgICBvblN0cmlwU2Nyb2xsLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciwgcG9zaXRpb246IG51bGwsIHNjcm9sbDogMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMTE1OiAvL3NcbiAgICAgICAgICAgIGNhc2UgODM6IC8vU1xuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAtMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgOTc6IC8vYVxuICAgICAgICAgICAgICAgIG9uU3RyaXBTY3JvbGwuY2FsbCggdGhpcywgeyBldmVudFNvdXJjZTogdGhpcy50cmFja2VyLCBwb3NpdGlvbjogbnVsbCwgc2Nyb2xsOiAtMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMTAwOiAvL2RcbiAgICAgICAgICAgICAgICBvblN0cmlwU2Nyb2xsLmNhbGwoIHRoaXMsIHsgZXZlbnRTb3VyY2U6IHRoaXMudHJhY2tlciwgcG9zaXRpb246IG51bGwsIHNjcm9sbDogMSwgc2hpZnQ6IG51bGwgfSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ25hdmlnYXRvciBrZXljb2RlICVzJywgZXZlbnQua2V5Q29kZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5cblxufSAoIE9wZW5TZWFkcmFnb24gKSApO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIERpc3BsYXlSZWN0XG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBEaXNwbGF5UmVjdFxuICogQGNsYXNzZGVzYyBBIGRpc3BsYXkgcmVjdGFuZ2xlIGlzIHZlcnkgc2ltaWxhciB0byB7QGxpbmsgT3BlblNlYWRyYWdvbi5SZWN0fSBidXQgYWRkcyB0d29cbiAqIGZpZWxkcywgJ21pbkxldmVsJyBhbmQgJ21heExldmVsJyB3aGljaCBkZW5vdGUgdGhlIHN1cHBvcnRlZCB6b29tIGxldmVsc1xuICogZm9yIHRoaXMgcmVjdGFuZ2xlLlxuICpcbiAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uXG4gKiBAZXh0ZW5kcyBPcGVuU2VhZHJhZ29uLlJlY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB2ZWN0b3IgY29tcG9uZW50ICd4Jy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB2ZWN0b3IgY29tcG9uZW50ICd5Jy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgdmVjdG9yIGNvbXBvbmVudCAnaGVpZ2h0Jy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIHZlY3RvciBjb21wb25lbnQgJ3dpZHRoJy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5MZXZlbCBUaGUgbG93ZXN0IHpvb20gbGV2ZWwgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heExldmVsIFRoZSBoaWdoZXN0IHpvb20gbGV2ZWwgc3VwcG9ydGVkLlxuICovXG4kLkRpc3BsYXlSZWN0ID0gZnVuY3Rpb24oIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbkxldmVsLCBtYXhMZXZlbCApIHtcbiAgICAkLlJlY3QuYXBwbHkoIHRoaXMsIFsgeCwgeSwgd2lkdGgsIGhlaWdodCBdICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXN0IHpvb20gbGV2ZWwgc3VwcG9ydGVkLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWluTGV2ZWxcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5EaXNwbGF5UmVjdCNcbiAgICAgKi9cbiAgICB0aGlzLm1pbkxldmVsID0gbWluTGV2ZWw7XG4gICAgLyoqXG4gICAgICogVGhlIGhpZ2hlc3Qgem9vbSBsZXZlbCBzdXBwb3J0ZWQuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhMZXZlbFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkRpc3BsYXlSZWN0I1xuICAgICAqL1xuICAgIHRoaXMubWF4TGV2ZWwgPSBtYXhMZXZlbDtcbn07XG5cbiQuZXh0ZW5kKCAkLkRpc3BsYXlSZWN0LnByb3RvdHlwZSwgJC5SZWN0LnByb3RvdHlwZSApO1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFNwcmluZ1xuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgU3ByaW5nXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTcHJpbmcgY29uZmlndXJhdGlvbiBzZXR0aW5ncy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNwcmluZ1N0aWZmbmVzcyAtIFNwcmluZyBzdGlmZm5lc3MuIE11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uXG4gKiBUaGUgY2xvc2VyIHRvIHplcm8sIHRoZSBjbG9zZXIgdG8gbGluZWFyIGFuaW1hdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFuaW1hdGlvblRpbWUgLSBBbmltYXRpb24gZHVyYXRpb24gcGVyIHNwcmluZywgaW4gc2Vjb25kcy5cbiAqIE11c3QgYmUgemVybyBvciBncmVhdGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmluaXRpYWw9MF0gLSBJbml0aWFsIHZhbHVlIG9mIHNwcmluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZXhwb25lbnRpYWw9ZmFsc2VdIC0gV2hldGhlciB0aGlzIHNwcmluZyByZXByZXNlbnRzXG4gKiBhbiBleHBvbmVudGlhbCBzY2FsZSAoc3VjaCBhcyB6b29tKSBhbmQgc2hvdWxkIGJlIGFuaW1hdGVkIGFjY29yZGluZ2x5LiBOb3RlIHRoYXRcbiAqIGV4cG9uZW50aWFsIHNwcmluZ3MgbXVzdCBoYXZlIG5vbi16ZXJvIHZhbHVlcy5cbiAqL1xuJC5TcHJpbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIGlmKCB0eXBlb2YoIG9wdGlvbnMgKSAhPSAnb2JqZWN0JyApe1xuICAgICAgICAvL2FsbG93cyBiYWNrd2FyZCBjb21wYXRpYmxlIHVzZSBvZiAoIGluaXRpYWxWYWx1ZSwgY29uZmlnICkgYXNcbiAgICAgICAgLy9jb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsOiBhcmdzLmxlbmd0aCAmJiB0eXBlb2YgKCBhcmdzWyAwIF0gKSA9PSBcIm51bWJlclwiID9cbiAgICAgICAgICAgICAgICBhcmdzWyAwIF0gOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3ByaW5nIHN0aWZmbmVzcy5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc3ByaW5nU3RpZmZuZXNzXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5TcHJpbmcjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNwcmluZ1N0aWZmbmVzczogYXJncy5sZW5ndGggPiAxID9cbiAgICAgICAgICAgICAgICBhcmdzWyAxIF0uc3ByaW5nU3RpZmZuZXNzIDpcbiAgICAgICAgICAgICAgICA1LjAsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuaW1hdGlvbiBkdXJhdGlvbiBwZXIgc3ByaW5nLlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhbmltYXRpb25UaW1lXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5TcHJpbmcjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFuaW1hdGlvblRpbWU6IGFyZ3MubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgYXJnc1sgMSBdLmFuaW1hdGlvblRpbWUgOlxuICAgICAgICAgICAgICAgIDEuNVxuICAgICAgICB9O1xuICAgIH1cblxuICAgICQuY29uc29sZS5hc3NlcnQodHlwZW9mIG9wdGlvbnMuc3ByaW5nU3RpZmZuZXNzID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMuc3ByaW5nU3RpZmZuZXNzICE9PSAwLFxuICAgICAgICBcIltPcGVuU2VhZHJhZ29uLlNwcmluZ10gb3B0aW9ucy5zcHJpbmdTdGlmZm5lc3MgbXVzdCBiZSBhIG5vbi16ZXJvIG51bWJlclwiKTtcblxuICAgICQuY29uc29sZS5hc3NlcnQodHlwZW9mIG9wdGlvbnMuYW5pbWF0aW9uVGltZSA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLmFuaW1hdGlvblRpbWUgPj0gMCxcbiAgICAgICAgXCJbT3BlblNlYWRyYWdvbi5TcHJpbmddIG9wdGlvbnMuYW5pbWF0aW9uVGltZSBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMuZXhwb25lbnRpYWwpIHtcbiAgICAgICAgdGhpcy5fZXhwb25lbnRpYWwgPSB0cnVlO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5leHBvbmVudGlhbDtcbiAgICB9XG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGN1cnJlbnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5TcHJpbmcjXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnQgPSB7XG4gICAgICAgIHZhbHVlOiB0eXBlb2YgKCB0aGlzLmluaXRpYWwgKSA9PSBcIm51bWJlclwiID9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbCA6XG4gICAgICAgICAgICAodGhpcy5fZXhwb25lbnRpYWwgPyAwIDogMSksXG4gICAgICAgIHRpbWU6ICAkLm5vdygpIC8vIGFsd2F5cyB3b3JrIGluIG1pbGxpc2Vjb25kc1xuICAgIH07XG5cbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCF0aGlzLl9leHBvbmVudGlhbCB8fCB0aGlzLmN1cnJlbnQudmFsdWUgIT09IDAsXG4gICAgICAgIFwiW09wZW5TZWFkcmFnb24uU3ByaW5nXSB2YWx1ZSBtdXN0IGJlIG5vbi16ZXJvIGZvciBleHBvbmVudGlhbCBzcHJpbmdzXCIpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBzdGFydFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlNwcmluZyNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdGltZVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnQudmFsdWUsXG4gICAgICAgIHRpbWU6ICB0aGlzLmN1cnJlbnQudGltZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlNwcmluZyNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdGltZVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0ge1xuICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50LnZhbHVlLFxuICAgICAgICB0aW1lOiAgdGhpcy5jdXJyZW50LnRpbWVcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2V4cG9uZW50aWFsKSB7XG4gICAgICAgIHRoaXMuc3RhcnQuX2xvZ1ZhbHVlID0gTWF0aC5sb2codGhpcy5zdGFydC52YWx1ZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuY3VycmVudC52YWx1ZSk7XG4gICAgfVxufTtcblxuLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLlNwcmluZy5wcm90b3R5cGUgKi9cbiQuU3ByaW5nLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRcbiAgICAgKi9cbiAgICByZXNldFRvOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KCF0aGlzLl9leHBvbmVudGlhbCB8fCB0YXJnZXQgIT09IDAsXG4gICAgICAgICAgICBcIltPcGVuU2VhZHJhZ29uLlNwcmluZy5yZXNldFRvXSB0YXJnZXQgbXVzdCBiZSBub24temVybyBmb3IgZXhwb25lbnRpYWwgc3ByaW5nc1wiKTtcblxuICAgICAgICB0aGlzLnN0YXJ0LnZhbHVlID0gdGhpcy50YXJnZXQudmFsdWUgPSB0aGlzLmN1cnJlbnQudmFsdWUgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuc3RhcnQudGltZSA9IHRoaXMudGFyZ2V0LnRpbWUgPSB0aGlzLmN1cnJlbnQudGltZSA9ICQubm93KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4cG9uZW50aWFsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuc3RhcnQudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuX2xvZ1ZhbHVlID0gTWF0aC5sb2codGhpcy50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuY3VycmVudC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldFxuICAgICAqL1xuICAgIHNwcmluZ1RvOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KCF0aGlzLl9leHBvbmVudGlhbCB8fCB0YXJnZXQgIT09IDAsXG4gICAgICAgICAgICBcIltPcGVuU2VhZHJhZ29uLlNwcmluZy5zcHJpbmdUb10gdGFyZ2V0IG11c3QgYmUgbm9uLXplcm8gZm9yIGV4cG9uZW50aWFsIHNwcmluZ3NcIik7XG5cbiAgICAgICAgdGhpcy5zdGFydC52YWx1ZSAgPSB0aGlzLmN1cnJlbnQudmFsdWU7XG4gICAgICAgIHRoaXMuc3RhcnQudGltZSAgID0gdGhpcy5jdXJyZW50LnRpbWU7XG4gICAgICAgIHRoaXMudGFyZ2V0LnZhbHVlID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnRhcmdldC50aW1lICA9IHRoaXMuc3RhcnQudGltZSArIDEwMDAgKiB0aGlzLmFuaW1hdGlvblRpbWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4cG9uZW50aWFsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuc3RhcnQudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuX2xvZ1ZhbHVlID0gTWF0aC5sb2codGhpcy50YXJnZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgICAqL1xuICAgIHNoaWZ0Qnk6IGZ1bmN0aW9uKCBkZWx0YSApIHtcbiAgICAgICAgdGhpcy5zdGFydC52YWx1ZSAgKz0gZGVsdGE7XG4gICAgICAgIHRoaXMudGFyZ2V0LnZhbHVlICs9IGRlbHRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9leHBvbmVudGlhbCkge1xuICAgICAgICAgICAgJC5jb25zb2xlLmFzc2VydCh0aGlzLnRhcmdldC52YWx1ZSAhPT0gMCAmJiB0aGlzLnN0YXJ0LnZhbHVlICE9PSAwLFxuICAgICAgICAgICAgICAgIFwiW09wZW5TZWFkcmFnb24uU3ByaW5nLnNoaWZ0QnldIHNwcmluZyB2YWx1ZSBtdXN0IGJlIG5vbi16ZXJvIGZvciBleHBvbmVudGlhbCBzcHJpbmdzXCIpO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Ll9sb2dWYWx1ZSA9IE1hdGgubG9nKHRoaXMuc3RhcnQudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuX2xvZ1ZhbHVlID0gTWF0aC5sb2codGhpcy50YXJnZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldEV4cG9uZW50aWFsOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9leHBvbmVudGlhbCA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLl9leHBvbmVudGlhbCkge1xuICAgICAgICAgICAgJC5jb25zb2xlLmFzc2VydCh0aGlzLmN1cnJlbnQudmFsdWUgIT09IDAgJiYgdGhpcy50YXJnZXQudmFsdWUgIT09IDAgJiYgdGhpcy5zdGFydC52YWx1ZSAhPT0gMCxcbiAgICAgICAgICAgICAgICBcIltPcGVuU2VhZHJhZ29uLlNwcmluZy5zZXRFeHBvbmVudGlhbF0gc3ByaW5nIHZhbHVlIG11c3QgYmUgbm9uLXplcm8gZm9yIGV4cG9uZW50aWFsIHNwcmluZ3NcIik7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnQuX2xvZ1ZhbHVlID0gTWF0aC5sb2codGhpcy5zdGFydC52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5fbG9nVmFsdWUgPSBNYXRoLmxvZyh0aGlzLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuX2xvZ1ZhbHVlID0gTWF0aC5sb2codGhpcy5jdXJyZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQudGltZSAgPSAkLm5vdygpO1xuXG4gICAgICAgIHZhciBzdGFydFZhbHVlLCB0YXJnZXRWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2V4cG9uZW50aWFsKSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlID0gdGhpcy5zdGFydC5fbG9nVmFsdWU7XG4gICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IHRoaXMudGFyZ2V0Ll9sb2dWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0aGlzLnN0YXJ0LnZhbHVlO1xuICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSB0aGlzLnRhcmdldC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSAodGhpcy5jdXJyZW50LnRpbWUgPj0gdGhpcy50YXJnZXQudGltZSkgP1xuICAgICAgICAgICAgdGFyZ2V0VmFsdWUgOlxuICAgICAgICAgICAgc3RhcnRWYWx1ZSArXG4gICAgICAgICAgICAgICAgKCB0YXJnZXRWYWx1ZSAtIHN0YXJ0VmFsdWUgKSAqXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgKCB0aGlzLmN1cnJlbnQudGltZSAtIHRoaXMuc3RhcnQudGltZSApIC9cbiAgICAgICAgICAgICAgICAgICAgKCB0aGlzLnRhcmdldC50aW1lICAtIHRoaXMuc3RhcnQudGltZSApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5fZXhwb25lbnRpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC52YWx1ZSA9IE1hdGguZXhwKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQudmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzcHJpbmcgaXMgYXQgdGhlIHRhcmdldCB2YWx1ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIGF0IHRhcmdldCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNBdFRhcmdldFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudC52YWx1ZSA9PT0gdGhpcy50YXJnZXQudmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0oIHN0aWZmbmVzcywgeCApIHtcbiAgICByZXR1cm4gKCAxLjAgLSBNYXRoLmV4cCggc3RpZmZuZXNzICogLXggKSApIC9cbiAgICAgICAgKCAxLjAgLSBNYXRoLmV4cCggLXN0aWZmbmVzcyApICk7XG59XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gSW1hZ2VMb2FkZXJcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDkgQ29kZVBsZXggRm91bmRhdGlvblxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTMgT3BlblNlYWRyYWdvbiBjb250cmlidXRvcnNcblxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vLyBwcml2YXRlIGNsYXNzXG5mdW5jdGlvbiBJbWFnZUpvYiAoIG9wdGlvbnMgKSB7XG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywge1xuICAgICAgICB0aW1lb3V0OiAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLnRpbWVvdXQsXG4gICAgICAgIGpvYklkOiAgICAgICAgICBudWxsXG4gICAgfSwgb3B0aW9ucyApO1xuXG4gICAgLyoqXG4gICAgICogSW1hZ2Ugb2JqZWN0IHdoaWNoIHdpbGwgY29udGFpbiBkb3dubG9hZGVkIGltYWdlLlxuICAgICAqIEBtZW1iZXIge0ltYWdlfSBpbWFnZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkltYWdlSm9iI1xuICAgICAqL1xuICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xufVxuXG5JbWFnZUpvYi5wcm90b3R5cGUgPSB7XG4gICAgZXJyb3JNc2c6IG51bGwsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgIGlmICggdGhpcy5jcm9zc09yaWdpblBvbGljeSAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpblBvbGljeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIF90aGlzLmZpbmlzaCggdHJ1ZSApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmltYWdlLm9uYWJvcnQgPSB0aGlzLmltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgX3RoaXMuZXJyb3JNc2cgPSBcIkltYWdlIGxvYWQgYWJvcnRlZFwiO1xuICAgICAgICAgICAgX3RoaXMuZmluaXNoKCBmYWxzZSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuam9iSWQgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIF90aGlzLmVycm9yTXNnID0gXCJJbWFnZSBsb2FkIGV4Y2VlZGVkIHRpbWVvdXRcIjtcbiAgICAgICAgICAgIF90aGlzLmZpbmlzaCggZmFsc2UgKTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcblxuICAgICAgICB0aGlzLmltYWdlLnNyYyA9IHRoaXMuc3JjO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKCBzdWNjZXNzZnVsICkge1xuICAgICAgICB0aGlzLmltYWdlLm9ubG9hZCA9IHRoaXMuaW1hZ2Uub25lcnJvciA9IHRoaXMuaW1hZ2Uub25hYm9ydCA9IG51bGw7XG4gICAgICAgIGlmICghc3VjY2Vzc2Z1bCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuam9iSWQgKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aGlzLmpvYklkICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKCB0aGlzICk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEBjbGFzcyBJbWFnZUxvYWRlclxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBjbGFzc2Rlc2MgSGFuZGxlcyBkb3dubG9hZGluZyBvZiBhIHNldCBvZiBpbWFnZXMgdXNpbmcgYXN5bmNocm9ub3VzIHF1ZXVlIHBhdHRlcm4uXG4gKiBZb3UgZ2VuZXJhbGx5IHdvbid0IGhhdmUgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgSW1hZ2VMb2FkZXIgZGlyZWN0bHkuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoaXMgSW1hZ2VMb2FkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuam9iTGltaXRdIC0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50IGltYWdlIHJlcXVlc3RzLiBTZWUgaW1hZ2VMb2FkZXJMaW1pdCBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfSBmb3IgZGV0YWlscy5cbiAqL1xuJC5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgJC5leHRlbmQoIHRydWUsIHRoaXMsIHtcbiAgICAgICAgam9iTGltaXQ6ICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5pbWFnZUxvYWRlckxpbWl0LFxuICAgICAgICBqb2JRdWV1ZTogICAgICAgW10sXG4gICAgICAgIGpvYnNJblByb2dyZXNzOiAwXG4gICAgfSwgb3B0aW9ucyApO1xuXG59O1xuXG4vKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uSW1hZ2VMb2FkZXIucHJvdG90eXBlICovXG4kLkltYWdlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiB1bmxvYWRlZCBpbWFnZSB0byB0aGUgbG9hZGVyIHF1ZXVlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIC0gVVJMIG9mIGltYWdlIHRvIGRvd25sb2FkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjcm9zc09yaWdpblBvbGljeSAtIENPUlMgcG9saWN5IHRvIHVzZSBmb3IgZG93bmxvYWRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsZWQgb25jZSBpbWFnZSBoYXMgYmVlbiBkb3dubG9hZGVkLlxuICAgICAqL1xuICAgIGFkZEpvYjogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICBjb21wbGV0ZSA9IGZ1bmN0aW9uKCBqb2IgKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVKb2IoIF90aGlzLCBqb2IsIG9wdGlvbnMuY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBqb2JPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHNyYzogb3B0aW9ucy5zcmMsXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW5Qb2xpY3k6IG9wdGlvbnMuY3Jvc3NPcmlnaW5Qb2xpY3ksXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgICAgICAgICAgIGFib3J0OiBvcHRpb25zLmFib3J0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV3Sm9iID0gbmV3IEltYWdlSm9iKCBqb2JPcHRpb25zICk7XG5cbiAgICAgICAgaWYgKCAhdGhpcy5qb2JMaW1pdCB8fCB0aGlzLmpvYnNJblByb2dyZXNzIDwgdGhpcy5qb2JMaW1pdCApIHtcbiAgICAgICAgICAgIG5ld0pvYi5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5qb2JzSW5Qcm9ncmVzcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5qb2JRdWV1ZS5wdXNoKCBuZXdKb2IgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbnkgdW5zdGFydGVkIGltYWdlIGxvYWRpbmcgam9icyBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuam9iUXVldWUubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgam9iID0gdGhpcy5qb2JRdWV1ZVtpXTtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGpvYi5hYm9ydCA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgIGpvYi5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5qb2JRdWV1ZSA9IFtdO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIEltYWdlSm9iIG9uY2UgY29tcGxldGVkLlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBsb2FkZXIgLSBJbWFnZUxvYWRlciB1c2VkIHRvIHN0YXJ0IGpvYi5cbiAqIEBwYXJhbSBqb2IgLSBUaGUgSW1hZ2VKb2IgdGhhdCBoYXMgY29tcGxldGVkLlxuICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGVkIG9uY2UgY2xlYW51cCBpcyBmaW5pc2hlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGxldGVKb2IoIGxvYWRlciwgam9iLCBjYWxsYmFjayApIHtcbiAgICB2YXIgbmV4dEpvYjtcblxuICAgIGxvYWRlci5qb2JzSW5Qcm9ncmVzcy0tO1xuXG4gICAgaWYgKCAoIWxvYWRlci5qb2JMaW1pdCB8fCBsb2FkZXIuam9ic0luUHJvZ3Jlc3MgPCBsb2FkZXIuam9iTGltaXQpICYmIGxvYWRlci5qb2JRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRKb2IgPSBsb2FkZXIuam9iUXVldWUuc2hpZnQoKTtcbiAgICAgICAgbmV4dEpvYi5zdGFydCgpO1xuICAgICAgICBsb2FkZXIuam9ic0luUHJvZ3Jlc3MrKztcbiAgICB9XG5cbiAgICBjYWxsYmFjayggam9iLmltYWdlLCBqb2IuZXJyb3JNc2cgKTtcbn1cblxufSggT3BlblNlYWRyYWdvbiApKTtcblxuLypcbiAqIE9wZW5TZWFkcmFnb24gLSBUaWxlXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBUaWxlXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB6b29tIGxldmVsIHRoaXMgdGlsZSBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHZlY3RvciBjb21wb25lbnQgJ3gnLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHZlY3RvciBjb21wb25lbnQgJ3knLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBib3VuZHMgV2hlcmUgdGhpcyB0aWxlIGZpdHMsIGluIG5vcm1hbGl6ZWRcbiAqICAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4aXN0cyBJcyB0aGlzIHRpbGUgYSBwYXJ0IG9mIGEgc3BhcnNlIGltYWdlPyAoIEFsc28gaGFzXG4gKiAgICAgIHRoaXMgdGlsZSBmYWlsZWQgdG8gbG9hZD8gKVxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoaXMgdGlsZSdzIGltYWdlLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyRCBUaGUgY29udGV4dDJEIG9mIHRoaXMgdGlsZSBpZiBpdFxuICogaXMgcHJvdmlkZWQgZGlyZWN0bHkgYnkgdGhlIHRpbGUgc291cmNlLlxuICovXG4kLlRpbGUgPSBmdW5jdGlvbihsZXZlbCwgeCwgeSwgYm91bmRzLCBleGlzdHMsIHVybCwgY29udGV4dDJEKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHpvb20gbGV2ZWwgdGhpcyB0aWxlIGJlbG9uZ3MgdG8uXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBsZXZlbFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5sZXZlbCAgID0gbGV2ZWw7XG4gICAgLyoqXG4gICAgICogVGhlIHZlY3RvciBjb21wb25lbnQgJ3gnLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0geFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy54ICAgICAgID0geDtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVjdG9yIGNvbXBvbmVudCAneScuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB5XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLnkgICAgICAgPSB5O1xuICAgIC8qKlxuICAgICAqIFdoZXJlIHRoaXMgdGlsZSBmaXRzLCBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzXG4gICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5SZWN0fSBib3VuZHNcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMuYm91bmRzICA9IGJvdW5kcztcbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIHRpbGUgYSBwYXJ0IG9mIGEgc3BhcnNlIGltYWdlPyBBbHNvIGhhcyB0aGlzIHRpbGUgZmFpbGVkIHRvIGxvYWQ/XG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZXhpc3RzXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmV4aXN0cyAgPSBleGlzdHM7XG4gICAgLyoqXG4gICAgICogVGhlIFVSTCBvZiB0aGlzIHRpbGUncyBpbWFnZS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHVybFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy51cmwgICAgID0gdXJsO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZXh0MkQgb2YgdGhpcyB0aWxlIGlmIGl0IGlzIHByb3ZpZGVkIGRpcmVjdGx5IGJ5IHRoZSB0aWxlIHNvdXJjZS5cbiAgICAgKiBAbWVtYmVyIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyRFxuICAgICAqIEBtZW1iZXJPZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0MkQgPSBjb250ZXh0MkQ7XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyB0aWxlIGxvYWRlZD9cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBsb2FkZWRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMubG9hZGVkICA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIElzIHRoaXMgdGlsZSBsb2FkaW5nP1xuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGxvYWRpbmdcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEhUTUwgZGl2IGVsZW1lbnQgZm9yIHRoaXMgdGlsZVxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCAgICA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIEhUTUwgaW1nIGVsZW1lbnQgZm9yIHRoaXMgdGlsZS5cbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBpbWdFbGVtZW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmltZ0VsZW1lbnQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBJbWFnZSBvYmplY3QgZm9yIHRoaXMgdGlsZS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGltYWdlXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLmltYWdlICAgICAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFsaWFzIG9mIHRoaXMuZWxlbWVudC5zdHlsZS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHN0eWxlXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlICAgICAgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoaXMgdGlsZSdzIHBvc2l0aW9uIG9uIHNjcmVlbiwgaW4gcGl4ZWxzLlxuICAgICAqIEBtZW1iZXIge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvc2l0aW9uXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uICAgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoaXMgdGlsZSdzIHNpemUgb24gc2NyZWVuLCBpbiBwaXhlbHMuXG4gICAgICogQG1lbWJlciB7T3BlblNlYWRyYWdvbi5Qb2ludH0gc2l6ZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5zaXplICAgICAgID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgdGltZSBvZiB0aGlzIHRpbGUncyBibGVuZGluZy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGJsZW5kU3RhcnRcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRTdGFydCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgb3BhY2l0eSB0aGlzIHRpbGUgc2hvdWxkIGJlLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gb3BhY2l0eVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5ICAgID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2Ugb2YgdGhpcyB0aWxlIHRvIHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlRpbGUjXG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSAgID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgdmlzaWJpbGl0eSBzY29yZSBvZiB0aGlzIHRpbGUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB2aXNpYmlsaXR5XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVGlsZSNcbiAgICAgKi9cbiAgICB0aGlzLnZpc2liaWxpdHkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHRpbGUgaXMgY3VycmVudGx5IGJlaW5nIGRyYXduLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGJlaW5nRHJhd25cbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMuYmVpbmdEcmF3biAgICAgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaW1lc3RhbXAgdGhlIHRpbGUgd2FzIGxhc3QgdG91Y2hlZC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGxhc3RUb3VjaFRpbWVcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5UaWxlI1xuICAgICAqL1xuICAgIHRoaXMubGFzdFRvdWNoVGltZSAgPSAwO1xufTtcblxuLyoqIEBsZW5kcyBPcGVuU2VhZHJhZ29uLlRpbGUucHJvdG90eXBlICovXG4kLlRpbGUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0aWxlcyBsZXZlbCBhbmQgKHgseSlcbiAgICAgKiBjb21wb25lbnRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbCArIFwiL1wiICsgdGhpcy54ICsgXCJfXCIgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfaGFzVHJhbnNwYXJlbmN5Q2hhbm5lbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY29udGV4dDJEIHx8IHRoaXMudXJsLm1hdGNoKCcucG5nJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHRpbGUgaW4gYW4gaHRtbCBjb250YWluZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAgICAgKi9cbiAgICBkcmF3SFRNTDogZnVuY3Rpb24oIGNvbnRhaW5lciApIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlSW1hZ2VSZWNvcmQpIHtcbiAgICAgICAgICAgICQuY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdbVGlsZS5kcmF3SFRNTF0gYXR0ZW1wdGluZyB0byBkcmF3IHRpbGUgJXMgd2hlbiBpdFxcJ3Mgbm90IGNhY2hlZCcsXG4gICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIXRoaXMubG9hZGVkICkge1xuICAgICAgICAgICAgJC5jb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIGRyYXcgdGlsZSAlcyB3aGVuIGl0J3Mgbm90IHlldCBsb2FkZWQuXCIsXG4gICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9FWFBFUklNRU5UQUwgLSB0cnlpbmcgdG8gZmlndXJlIG91dCBob3cgdG8gc2NhbGUgdGhlIGNvbnRhaW5lclxuICAgICAgICAvLyAgICAgICAgICAgICAgIGNvbnRlbnQgZHVyaW5nIGFuaW1hdGlvbiBvZiB0aGUgY29udGFpbmVyIHNpemUuXG5cbiAgICAgICAgaWYgKCAhdGhpcy5lbGVtZW50ICkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggXCJkaXZcIiApO1xuICAgICAgICAgICAgdGhpcy5pbWdFbGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLmNhY2hlSW1hZ2VSZWNvcmQuZ2V0SW1hZ2UoKS5jbG9uZU5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuaW1nRWxlbWVudC5zdHlsZS5tc0ludGVycG9sYXRpb25Nb2RlID0gXCJuZWFyZXN0LW5laWdoYm9yXCI7XG4gICAgICAgICAgICB0aGlzLmltZ0VsZW1lbnQuc3R5bGUud2lkdGggICAgICAgICAgICAgICA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgdGhpcy5pbWdFbGVtZW50LnN0eWxlLmhlaWdodCAgICAgICAgICAgICAgPSBcIjEwMCVcIjtcblxuICAgICAgICAgICAgdGhpcy5zdHlsZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcy5lbGVtZW50LnN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5wb3NpdGlvbiAgICAgICAgICAgID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICggdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgIT0gY29udGFpbmVyICkge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMuaW1nRWxlbWVudC5wYXJlbnROb2RlICE9IHRoaXMuZWxlbWVudCApIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy5pbWdFbGVtZW50ICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlLnRvcCAgICAgPSB0aGlzLnBvc2l0aW9uLnkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuc3R5bGUubGVmdCAgICA9IHRoaXMucG9zaXRpb24ueCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5zdHlsZS5oZWlnaHQgID0gdGhpcy5zaXplLnkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuc3R5bGUud2lkdGggICA9IHRoaXMuc2l6ZS54ICsgXCJweFwiO1xuXG4gICAgICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIHRoaXMuZWxlbWVudCwgdGhpcy5vcGFjaXR5ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHRpbGUgaW4gYSBjYW52YXMtYmFzZWQgY29udGV4dC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdpbmdIYW5kbGVyIC0gTWV0aG9kIGZvciBmaXJpbmcgdGhlIGRyYXdpbmcgZXZlbnQuXG4gICAgICogZHJhd2luZ0hhbmRsZXIoe2NvbnRleHQsIHRpbGUsIHJlbmRlcmVkfSlcbiAgICAgKiB3aGVyZSA8Y29kZT5yZW5kZXJlZDwvY29kZT4gaXMgdGhlIGNvbnRleHQgd2l0aCB0aGUgcHJlLWRyYXduIGltYWdlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gLSBBcHBseSBhIHNjYWxlIHRvIHBvc2l0aW9uIGFuZCBzaXplXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBbdHJhbnNsYXRlXSAtIEEgdHJhbnNsYXRpb24gdmVjdG9yXG4gICAgICovXG4gICAgZHJhd0NhbnZhczogZnVuY3Rpb24oIGNvbnRleHQsIGRyYXdpbmdIYW5kbGVyLCBzY2FsZSwgdHJhbnNsYXRlICkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24udGltZXMoJC5waXhlbERlbnNpdHlSYXRpbyksXG4gICAgICAgICAgICBzaXplICAgICA9IHRoaXMuc2l6ZS50aW1lcygkLnBpeGVsRGVuc2l0eVJhdGlvKSxcbiAgICAgICAgICAgIHJlbmRlcmVkO1xuXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0MkQgJiYgIXRoaXMuY2FjaGVJbWFnZVJlY29yZCkge1xuICAgICAgICAgICAgJC5jb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ1tUaWxlLmRyYXdDYW52YXNdIGF0dGVtcHRpbmcgdG8gZHJhdyB0aWxlICVzIHdoZW4gaXRcXCdzIG5vdCBjYWNoZWQnLFxuICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlZCA9IHRoaXMuY29udGV4dDJEIHx8IHRoaXMuY2FjaGVJbWFnZVJlY29yZC5nZXRSZW5kZXJlZENvbnRleHQoKTtcblxuICAgICAgICBpZiAoICF0aGlzLmxvYWRlZCB8fCAhcmVuZGVyZWQgKXtcbiAgICAgICAgICAgICQuY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiQXR0ZW1wdGluZyB0byBkcmF3IHRpbGUgJXMgd2hlbiBpdCdzIG5vdCB5ZXQgbG9hZGVkLlwiLFxuICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcblxuICAgICAgICBpZiAodHlwZW9mIHNjYWxlID09PSAnbnVtYmVyJyAmJiBzY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgLy8gZHJhdyB0aWxlIGF0IGEgZGlmZmVyZW50IHNjYWxlXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uLnRpbWVzKHNjYWxlKTtcbiAgICAgICAgICAgIHNpemUgPSBzaXplLnRpbWVzKHNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2xhdGUgaW5zdGFuY2VvZiAkLlBvaW50KSB7XG4gICAgICAgICAgICAvLyBzaGlmdCB0aWxlIHBvc2l0aW9uIHNsaWdodGx5XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uLnBsdXModHJhbnNsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgd2UgYXJlIHN1cHBvc2VkIHRvIGJlIHJlbmRlcmluZyBmdWxseSBvcGFxdWUgcmVjdGFuZ2xlLFxuICAgICAgICAvL2llIGl0cyBkb25lIGZhZGluZyBvciBmYWRpbmcgaXMgdHVybmVkIG9mZiwgYW5kIGlmIHdlIGFyZSBkcmF3aW5nXG4gICAgICAgIC8vYW4gaW1hZ2Ugd2l0aCBhbiBhbHBoYSBjaGFubmVsLCB0aGVuIHRoZSBvbmx5IHdheVxuICAgICAgICAvL3RvIGF2b2lkIHNlZWluZyB0aGUgdGlsZSB1bmRlcm5lYXRoIGlzIHRvIGNsZWFyIHRoZSByZWN0YW5nbGVcbiAgICAgICAgaWYgKGNvbnRleHQuZ2xvYmFsQWxwaGEgPT09IDEgJiYgdGhpcy5faGFzVHJhbnNwYXJlbmN5Q2hhbm5lbCgpKSB7XG4gICAgICAgICAgICAvL2NsZWFyaW5nIG9ubHkgdGhlIGluc2lkZSBvZiB0aGUgcmVjdGFuZ2xlIG9jY3VwaWVkXG4gICAgICAgICAgICAvL2J5IHRoZSBwbmcgcHJldmVudHMgZWRnZSBmbGlrZXJpbmdcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnggKyAxLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgKyAxLFxuICAgICAgICAgICAgICAgIHNpemUueCAtIDIsXG4gICAgICAgICAgICAgICAgc2l6ZS55IC0gMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgZ2l2ZXMgdGhlIGFwcGxpY2F0aW9uIGEgY2hhbmNlIHRvIG1ha2UgaW1hZ2UgbWFuaXB1bGF0aW9uXG4gICAgICAgIC8vIGNoYW5nZXMgYXMgd2UgYXJlIHJlbmRlcmluZyB0aGUgaW1hZ2VcbiAgICAgICAgZHJhd2luZ0hhbmRsZXIoe2NvbnRleHQ6IGNvbnRleHQsIHRpbGU6IHRoaXMsIHJlbmRlcmVkOiByZW5kZXJlZH0pO1xuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgcmVuZGVyZWQuY2FudmFzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICByZW5kZXJlZC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICByZW5kZXJlZC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgcG9zaXRpb24ueCxcbiAgICAgICAgICAgIHBvc2l0aW9uLnksXG4gICAgICAgICAgICBzaXplLngsXG4gICAgICAgICAgICBzaXplLnlcbiAgICAgICAgKTtcblxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByYXRpbyBiZXR3ZWVuIGN1cnJlbnQgYW5kIG9yaWdpbmFsIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7RmxvYXR9XG4gICAgICovXG4gICAgZ2V0U2NhbGVGb3JFZGdlU21vb3RoaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRleHQ7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlSW1hZ2VSZWNvcmQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNhY2hlSW1hZ2VSZWNvcmQuZ2V0UmVuZGVyZWRDb250ZXh0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZXh0MkQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQyRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdbVGlsZS5kcmF3Q2FudmFzXSBhdHRlbXB0aW5nIHRvIGdldCB0aWxlIHNjYWxlICVzIHdoZW4gdGlsZVxcJ3Mgbm90IGNhY2hlZCcsXG4gICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNhbnZhcy53aWR0aCAvICh0aGlzLnNpemUueCAqICQucGl4ZWxEZW5zaXR5UmF0aW8pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0cmFuc2xhdGlvbiB2ZWN0b3IgdGhhdCB3aGVuIGFwcGxpZWQgdG8gdGhlIHRpbGUgcG9zaXRpb24gcHJvZHVjZXMgaW50ZWdlciBjb29yZGluYXRlcy5cbiAgICAgKiBOZWVkZWQgdG8gYXZvaWQgc3dpbW1pbmcgYW5kIHR3aXRjaGluZy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIC0gU2NhbGUgdG8gYmUgYXBwbGllZCB0byBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIGdldFRyYW5zbGF0aW9uRm9yRWRnZVNtb290aGluZzogZnVuY3Rpb24oc2NhbGUsIGNhbnZhc1NpemUsIHNrZXRjaENhbnZhc1NpemUpIHtcbiAgICAgICAgLy8gVGhlIHRyYW5zbGF0aW9uIHZlY3RvciBtdXN0IGhhdmUgcG9zaXRpdmUgdmFsdWVzLCBvdGhlcndpc2UgdGhlIGltYWdlIGdvZXMgYSBiaXQgb2ZmXG4gICAgICAgIC8vIHRoZSBza2V0Y2ggY2FudmFzIHRvIHRoZSB0b3AgYW5kIGxlZnQgYW5kIHdlIG11c3QgdXNlIG5lZ2F0aXZlIGNvb3JkaW5hdGVzIHRvIHJlcGFpbnQgaXRcbiAgICAgICAgLy8gdG8gdGhlIG1haW4gY2FudmFzLiBJbiB0aGF0IGNhc2UsIHNvbWUgYnJvd3NlcnMgdGhyb3c6XG4gICAgICAgIC8vIElOREVYX1NJWkVfRVJSOiBET00gRXhjZXB0aW9uIDE6IEluZGV4IG9yIHNpemUgd2FzIG5lZ2F0aXZlLCBvciBncmVhdGVyIHRoYW4gdGhlIGFsbG93ZWQgdmFsdWUuXG4gICAgICAgIHZhciB4ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKChza2V0Y2hDYW52YXNTaXplLnggLSBjYW52YXNTaXplLngpIC8gMikpO1xuICAgICAgICB2YXIgeSA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCgoc2tldGNoQ2FudmFzU2l6ZS55IC0gY2FudmFzU2l6ZS55KSAvIDIpKTtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHgsIHkpLm1pbnVzKFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblxuICAgICAgICAgICAgICAgIC50aW1lcygkLnBpeGVsRGVuc2l0eVJhdGlvKVxuICAgICAgICAgICAgICAgIC50aW1lcyhzY2FsZSB8fCAxKVxuICAgICAgICAgICAgICAgIC5hcHBseShmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICUgMTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRpbGUgZnJvbSBpdHMgY29udGFpbmVyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICggdGhpcy5pbWdFbGVtZW50ICYmIHRoaXMuaW1nRWxlbWVudC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgdGhpcy5pbWdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMuaW1nRWxlbWVudCApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggdGhpcy5lbGVtZW50ICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtZW50ICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbWdFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkZWQgICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZyAgICA9IGZhbHNlO1xuICAgIH1cbn07XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gT3ZlcmxheVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oJCkge1xuXG4gICAgLyoqXG4gICAgICogQW4gZW51bWVyYXRpb24gb2YgcG9zaXRpb25zIHRoYXQgYW4gb3ZlcmxheSBtYXkgYmUgYXNzaWduZWQgcmVsYXRpdmUgdG9cbiAgICAgKiB0aGUgdmlld3BvcnQuXG4gICAgICogSXQgaXMgaWRlbnRpY2FsIHRvIE9wZW5TZWFkcmFnb24uUGxhY2VtZW50IGJ1dCBpcyBrZXB0IGZvciBiYWNrd2FyZFxuICAgICAqIGNvbXBhdGliaWxpdHkuXG4gICAgICogQG1lbWJlciBPdmVybGF5UGxhY2VtZW50XG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQ0VOVEVSXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFRPUF9MRUZUXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFRPUFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBUT1BfUklHSFRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gUklHSFRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQk9UVE9NX1JJR0hUXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPVFRPTVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1RUT01fTEVGVFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMRUZUXG4gICAgICovXG4gICAgJC5PdmVybGF5UGxhY2VtZW50ID0gJC5QbGFjZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBBbiBlbnVtZXJhdGlvbiBvZiBwb3NzaWJsZSB3YXlzIHRvIGhhbmRsZSBvdmVybGF5cyByb3RhdGlvblxuICAgICAqIEBtZW1iZXIgT3ZlcmxheVJvdGF0aW9uTW9kZVxuICAgICAqIEBtZW1iZXJPZiBPcGVuU2VhZHJhZ29uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZWFkb25seVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBOT19ST1RBVElPTiBUaGUgb3ZlcmxheSBpZ25vcmUgdGhlIHZpZXdwb3J0IHJvdGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBFWEFDVCBUaGUgb3ZlcmxheSB1c2UgQ1NTIDMgdHJhbnNmb3JtcyB0byByb3RhdGUgd2l0aFxuICAgICAqIHRoZSB2aWV3cG9ydC4gSWYgdGhlIG92ZXJsYXkgY29udGFpbnMgdGV4dCwgaXQgd2lsbCBnZXQgcm90YXRlZCBhcyB3ZWxsLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1VORElOR19CT1ggVGhlIG92ZXJsYXkgYWRqdXN0cyBmb3Igcm90YXRpb24gYnlcbiAgICAgKiB0YWtpbmcgdGhlIHNpemUgb2YgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcm90YXRlZCBib3VuZHMuXG4gICAgICogT25seSB2YWxpZCBmb3Igb3ZlcmxheXMgd2l0aCBSZWN0IGxvY2F0aW9uIGFuZCBzY2FsYWJsZSBpbiBib3RoIGRpcmVjdGlvbnMuXG4gICAgICovXG4gICAgJC5PdmVybGF5Um90YXRpb25Nb2RlID0gJC5mcmVlemVPYmplY3Qoe1xuICAgICAgICBOT19ST1RBVElPTjogMSxcbiAgICAgICAgRVhBQ1Q6IDIsXG4gICAgICAgIEJPVU5ESU5HX0JPWDogM1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIE92ZXJsYXlcbiAgICAgKiBAY2xhc3NkZXNjIFByb3ZpZGVzIGEgd2F5IHRvIGZsb2F0IGFuIEhUTUwgZWxlbWVudCBvbiB0b3Agb2YgdGhlIHZpZXdlciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9ucy5lbGVtZW50XG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fE9wZW5TZWFkcmFnb24uUmVjdH0gb3B0aW9ucy5sb2NhdGlvbiAtIFRoZVxuICAgICAqIGxvY2F0aW9uIG9mIHRoZSBvdmVybGF5IG9uIHRoZSBpbWFnZS4gSWYgYSB7QGxpbmsgT3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKiBpcyBzcGVjaWZpZWQsIHRoZSBvdmVybGF5IHdpbGwgYmUgbG9jYXRlZCBhdCB0aGlzIGxvY2F0aW9uIHdpdGggcmVzcGVjdFxuICAgICAqIHRvIHRoZSBwbGFjZW1lbnQgb3B0aW9uLiBJZiBhIHtAbGluayBPcGVuU2VhZHJhZ29uLlJlY3R9IGlzIHNwZWNpZmllZCxcbiAgICAgKiB0aGUgb3ZlcmxheSB3aWxsIGJlIHBsYWNlZCBhdCB0aGlzIGxvY2F0aW9uIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgd2lkdGhcbiAgICAgKiBhbmQgaGVpZ2h0IGFuZCBwbGFjZW1lbnQgVE9QX0xFRlQuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gW29wdGlvbnMucGxhY2VtZW50PU9wZW5TZWFkcmFnb24uUGxhY2VtZW50LlRPUF9MRUZUXVxuICAgICAqIERlZmluZXMgd2hhdCBwYXJ0IG9mIHRoZSBvdmVybGF5IHNob3VsZCBiZSBhdCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMubG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uT3ZlcmxheS5PbkRyYXdDYWxsYmFja30gW29wdGlvbnMub25EcmF3XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2hlY2tSZXNpemU9dHJ1ZV0gU2V0IHRvIGZhbHNlIHRvIGF2b2lkIHRvXG4gICAgICogY2hlY2sgdGhlIHNpemUgb2YgdGhlIG92ZXJsYXkgZXZlcnl0aW1lIGl0IGlzIGRyYXduIGluIHRoZSBkaXJlY3Rpb25zXG4gICAgICogd2hpY2ggYXJlIG5vdCBzY2FsZWQuIEl0IHdpbGwgaW1wcm92ZSBwZXJmb3JtYW5jZXMgYnV0IHdpbGwgY2F1c2UgYVxuICAgICAqIG1pc2FsaWdubWVudCBpZiB0aGUgb3ZlcmxheSBzaXplIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBUaGUgd2lkdGggb2YgdGhlIG92ZXJsYXkgaW4gdmlld3BvcnRcbiAgICAgKiBjb29yZGluYXRlcy4gSWYgc3BlY2lmaWVkLCB0aGUgd2lkdGggb2YgdGhlIG92ZXJsYXkgd2lsbCBiZSBhZGp1c3RlZCB3aGVuXG4gICAgICogdGhlIHpvb20gY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBUaGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IGluIHZpZXdwb3J0XG4gICAgICogY29vcmRpbmF0ZXMuIElmIHNwZWNpZmllZCwgdGhlIGhlaWdodCBvZiB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkanVzdGVkIHdoZW5cbiAgICAgKiB0aGUgem9vbSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucm90YXRpb25Nb2RlPU9wZW5TZWFkcmFnb24uT3ZlcmxheVJvdGF0aW9uTW9kZS5FWEFDVF1cbiAgICAgKiBIb3cgdG8gaGFuZGxlIHRoZSByb3RhdGlvbiBvZiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgJC5PdmVybGF5ID0gZnVuY3Rpb24oZWxlbWVudCwgbG9jYXRpb24sIHBsYWNlbWVudCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbkRyYXcgY2FsbGJhY2sgc2lnbmF0dXJlIHVzZWQgYnkge0BsaW5rIE9wZW5TZWFkcmFnb24uT3ZlcmxheX0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjYWxsYmFjayBPbkRyYXdDYWxsYmFja1xuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5PdmVybGF5XG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb25cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBzaXplXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChlbGVtZW50KSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuICAgICAgICB0aGlzLnN0eWxlID0gb3B0aW9ucy5lbGVtZW50LnN0eWxlO1xuICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uT3ZlcmxheS5wcm90b3R5cGUgKi9cbiAgICAkLk92ZXJsYXkucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8vIHByaXZhdGVcbiAgICAgICAgX2luaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBvcHRpb25zLmxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSBvcHRpb25zLnBsYWNlbWVudCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAkLlBsYWNlbWVudC5UT1BfTEVGVCA6IG9wdGlvbnMucGxhY2VtZW50O1xuICAgICAgICAgICAgdGhpcy5vbkRyYXcgPSBvcHRpb25zLm9uRHJhdztcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXNpemUgPSBvcHRpb25zLmNoZWNrUmVzaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRydWUgOiBvcHRpb25zLmNoZWNrUmVzaXplO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMud2lkdGggaXMgbm90IG51bGwsIHRoZSBvdmVybGF5IGdldCBzY2FsZWQgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMud2lkdGg7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcy5oZWlnaHQgaXMgbm90IG51bGwsIHRoZSBvdmVybGF5IGdldCBzY2FsZWQgdmVydGljYWxseVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uTW9kZSA9IG9wdGlvbnMucm90YXRpb25Nb2RlIHx8ICQuT3ZlcmxheVJvdGF0aW9uTW9kZS5FWEFDVDtcblxuICAgICAgICAgICAgLy8gSGF2aW5nIGEgcmVjdCBhcyBsb2NhdGlvbiBpcyBhIHN5bnRhY3RpYyBzdWdhclxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYXRpb24gaW5zdGFuY2VvZiAkLlJlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5sb2NhdGlvbi53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubG9jYXRpb24uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uLmdldFRvcExlZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlbWVudCA9ICQuUGxhY2VtZW50LlRPUF9MRUZUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXByZWNhdGVkIHByb3BlcnRpZXMga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgIHRoaXMuc2NhbGVzID0gdGhpcy53aWR0aCAhPT0gbnVsbCAmJiB0aGlzLmhlaWdodCAhPT0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gbmV3ICQuUmVjdChcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uLngsIHRoaXMubG9jYXRpb24ueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgcG9zaXRpb24gb2YgYW4gb3ZlcmxheVxuICAgICAgICAgKiBkZXBlbmRpbmcgb24gaXQgc2l6ZSBhbmQgcGxhY2VtZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb3NpdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHNpemVcbiAgICAgICAgICovXG4gICAgICAgIGFkanVzdDogZnVuY3Rpb24ocG9zaXRpb24sIHNpemUpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gJC5QbGFjZW1lbnQucHJvcGVydGllc1t0aGlzLnBsYWNlbWVudF07XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5pc0hvcml6b250YWxseUNlbnRlcmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueCAtPSBzaXplLnggLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLmlzUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi54IC09IHNpemUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzVmVydGljYWxseUNlbnRlcmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueSAtPSBzaXplLnkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLmlzQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueSAtPSBzaXplLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy90aGlzIHNob3VsZCBhbGxvdyB1cyB0byBwcmVzZXJ2ZSBvdmVybGF5cyB3aGVuIHJlcXVpcmVkIGJldHdlZW5cbiAgICAgICAgICAgICAgICAvL3BhZ2VzXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucHJldkVsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgLy9lbGVtZW50LnByZXZFbGVtZW50UGFyZW50Lmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgZWxlbWVudC5wcmV2TmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8pO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIG9uRHJhdyBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5vbkRyYXcgPSBudWxsO1xuXG4gICAgICAgICAgICBzdHlsZS50b3AgPSBcIlwiO1xuICAgICAgICAgICAgc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICAgICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW5Qcm9wID0gJC5nZXRDc3NQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXgoXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybU9yaWdpbicpO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVByb3AgPSAkLmdldENzc1Byb3BlcnR5V2l0aFZlbmRvclByZWZpeChcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtT3JpZ2luUHJvcCAmJiB0cmFuc2Zvcm1Qcm9wKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVbdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlW3RyYW5zZm9ybVByb3BdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3SFRNTDogZnVuY3Rpb24oY29udGFpbmVyLCB2aWV3cG9ydCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAvL3NhdmUgdGhlIHNvdXJjZSBwYXJlbnQgZm9yIGxhdGVyIGlmIHdlIG5lZWQgaXRcbiAgICAgICAgICAgICAgICBlbGVtZW50LnByZXZFbGVtZW50UGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucHJldk5leHRTaWJsaW5nID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLnNpemUgaXMgdXNlZCBieSBvdmVybGF5cyB3aGljaCBkb24ndCBnZXQgc2NhbGVkIGluIGF0XG4gICAgICAgICAgICAgICAgLy8gbGVhc3Qgb25lIGRpcmVjdGlvbiB3aGVuIHRoaXMuY2hlY2tSZXNpemUgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9ICQuZ2V0RWxlbWVudFNpemUoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFuZFNpemUgPSB0aGlzLl9nZXRPdmVybGF5UG9zaXRpb25BbmRTaXplKHZpZXdwb3J0KTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25BbmRTaXplLnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUgPSBwb3NpdGlvbkFuZFNpemUuc2l6ZTtcbiAgICAgICAgICAgIHZhciByb3RhdGUgPSBwb3NpdGlvbkFuZFNpemUucm90YXRlO1xuXG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBvbkRyYXcgY2FsbGJhY2sgaWYgaXQgZXhpc3RzIHRvIGFsbG93IG9uZSB0byBvdmVyd3JpdGVcbiAgICAgICAgICAgIC8vIHRoZSBkcmF3aW5nL3Bvc2l0aW9uaW5nL3NpemluZyBvZiB0aGUgb3ZlcmxheVxuICAgICAgICAgICAgaWYgKHRoaXMub25EcmF3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRyYXcocG9zaXRpb24sIHNpemUsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IHBvc2l0aW9uLnggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gcG9zaXRpb24ueSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHNpemUueCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHNpemUueSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybU9yaWdpblByb3AgPSAkLmdldENzc1Byb3BlcnR5V2l0aFZlbmRvclByZWZpeChcbiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybU9yaWdpbicpO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1Qcm9wID0gJC5nZXRDc3NQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXgoXG4gICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtT3JpZ2luUHJvcCAmJiB0cmFuc2Zvcm1Qcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3RyYW5zZm9ybU9yaWdpblByb3BdID0gdGhpcy5fZ2V0VHJhbnNmb3JtT3JpZ2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVt0cmFuc2Zvcm1Qcm9wXSA9IFwicm90YXRlKFwiICsgcm90YXRlICsgXCJkZWcpXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVt0cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVt0cmFuc2Zvcm1Qcm9wXSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIF9nZXRPdmVybGF5UG9zaXRpb25BbmRTaXplOiBmdW5jdGlvbih2aWV3cG9ydCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdmlld3BvcnQucGl4ZWxGcm9tUG9pbnQodGhpcy5sb2NhdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2dldFNpemVJblBpeGVscyh2aWV3cG9ydCk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdChwb3NpdGlvbiwgc2l6ZSk7XG5cbiAgICAgICAgICAgIHZhciByb3RhdGUgPSAwO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0LmRlZ3JlZXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uTW9kZSAhPT0gJC5PdmVybGF5Um90YXRpb25Nb2RlLk5PX1JPVEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgLy8gQk9VTkRJTkdfQk9YIGlzIG9ubHkgdmFsaWQgaWYgYm90aCBkaXJlY3Rpb25zIGdldCBzY2FsZWQuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHJlcGxhY2VkIGJ5IEVYQUNUIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3RhdGlvbk1vZGUgPT09ICQuT3ZlcmxheVJvdGF0aW9uTW9kZS5CT1VORElOR19CT1ggJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCAhPT0gbnVsbCAmJiB0aGlzLmhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyAkLlJlY3QocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc2l6ZS54LCBzaXplLnkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLl9nZXRCb3VuZGluZ0JveChyZWN0LCB2aWV3cG9ydC5kZWdyZWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBib3VuZGluZ0JveC5nZXRUb3BMZWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBib3VuZGluZ0JveC5nZXRTaXplKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlID0gdmlld3BvcnQuZGVncmVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICAgICAgcm90YXRlOiByb3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcHJpdmF0ZVxuICAgICAgICBfZ2V0U2l6ZUluUGl4ZWxzOiBmdW5jdGlvbih2aWV3cG9ydCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5zaXplLng7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gbnVsbCB8fCB0aGlzLmhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZWRTaXplID0gdmlld3BvcnQuZGVsdGFQaXhlbHNGcm9tUG9pbnRzTm9Sb3RhdGUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyAkLlBvaW50KHRoaXMud2lkdGggfHwgMCwgdGhpcy5oZWlnaHQgfHwgMCksIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc2NhbGVkU2l6ZS54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2NhbGVkU2l6ZS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUmVzaXplICYmXG4gICAgICAgICAgICAgICAgKHRoaXMud2lkdGggPT09IG51bGwgfHwgdGhpcy5oZWlnaHQgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsdFNpemUgPSB0aGlzLnNpemUgPSAkLmdldEVsZW1lbnRTaXplKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBlbHRTaXplLng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBlbHRTaXplLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHByaXZhdGVcbiAgICAgICAgX2dldEJvdW5kaW5nQm94OiBmdW5jdGlvbihyZWN0LCBkZWdyZWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVmUG9pbnQgPSB0aGlzLl9nZXRQbGFjZW1lbnRQb2ludChyZWN0KTtcbiAgICAgICAgICAgIHJldHVybiByZWN0LnJvdGF0ZShkZWdyZWVzLCByZWZQb2ludCkuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIF9nZXRQbGFjZW1lbnRQb2ludDogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyAkLlBvaW50KHJlY3QueCwgcmVjdC55KTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gJC5QbGFjZW1lbnQucHJvcGVydGllc1t0aGlzLnBsYWNlbWVudF07XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzSG9yaXpvbnRhbGx5Q2VudGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnggKz0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLmlzUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnggKz0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaXNWZXJ0aWNhbGx5Q2VudGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnkgKz0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5pc0JvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQueSArPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHByaXZhdGVcbiAgICAgICAgX2dldFRyYW5zZm9ybU9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gJC5QbGFjZW1lbnQucHJvcGVydGllc1t0aGlzLnBsYWNlbWVudF07XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMuaXNSaWdodCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzVG9wKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIHRvcFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLmlzQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGJvdHRvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgb3ZlcmxheSBzZXR0aW5ncy5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludHxPcGVuU2VhZHJhZ29uLlJlY3R8T2JqZWN0fSBsb2NhdGlvblxuICAgICAgICAgKiBJZiBhbiBvYmplY3QgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW9ucyBhcmUgdGhlIHNhbWUgdGhhbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICogZXhjZXB0IGZvciB0aGUgZWxlbWVudCB3aGljaCBjYW4gbm90IGJlIGNoYW5nZWQuXG4gICAgICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5QbGFjZW1lbnR9IHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGxvY2F0aW9uLCBwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gJC5pc1BsYWluT2JqZWN0KGxvY2F0aW9uKSA/IGxvY2F0aW9uIDoge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2luaXQoe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBvcHRpb25zLmxvY2F0aW9uIHx8IHRoaXMubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBvcHRpb25zLnBsYWNlbWVudCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wbGFjZW1lbnQgOiB0aGlzLnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICBvbkRyYXc6IG9wdGlvbnMub25EcmF3IHx8IHRoaXMub25EcmF3LFxuICAgICAgICAgICAgICAgIGNoZWNrUmVzaXplOiBvcHRpb25zLmNoZWNrUmVzaXplIHx8IHRoaXMuY2hlY2tSZXNpemUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud2lkdGggOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaGVpZ2h0IDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcm90YXRpb25Nb2RlOiBvcHRpb25zLnJvdGF0aW9uTW9kZSB8fCB0aGlzLnJvdGF0aW9uTW9kZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYm91bmRzIG9mIHRoZSBvdmVybGF5IGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IHZpZXdwb3J0IHRoZSB2aWV3cG9ydFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fSBvdmVybGF5IGJvdW5kc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qm91bmRzOiBmdW5jdGlvbih2aWV3cG9ydCkge1xuICAgICAgICAgICAgJC5jb25zb2xlLmFzc2VydCh2aWV3cG9ydCxcbiAgICAgICAgICAgICAgICAnQSB2aWV3cG9ydCBtdXN0IG5vdyBiZSBwYXNzZWQgdG8gT3ZlcmxheS5nZXRCb3VuZHMuJyk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSBudWxsIHx8IGhlaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdmlld3BvcnQuZGVsdGFQb2ludHNGcm9tUGl4ZWxzTm9Sb3RhdGUodGhpcy5zaXplLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzaXplLng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMubG9jYXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0KGxvY2F0aW9uLCBuZXcgJC5Qb2ludCh3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRqdXN0Qm91bmRzRm9yUm90YXRpb24oXG4gICAgICAgICAgICAgICAgdmlld3BvcnQsIG5ldyAkLlJlY3QobG9jYXRpb24ueCwgbG9jYXRpb24ueSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHByaXZhdGVcbiAgICAgICAgX2FkanVzdEJvdW5kc0ZvclJvdGF0aW9uOiBmdW5jdGlvbih2aWV3cG9ydCwgYm91bmRzKSB7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0IHx8XG4gICAgICAgICAgICAgICAgdmlld3BvcnQuZGVncmVlcyA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb25Nb2RlID09PSAkLk92ZXJsYXlSb3RhdGlvbk1vZGUuRVhBQ1QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpb25Nb2RlID09PSAkLk92ZXJsYXlSb3RhdGlvbk1vZGUuQk9VTkRJTkdfQk9YKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgb3ZlcmxheSBub3QgZnVsbHkgc2NhbGFibGUsIEJPVU5ESU5HX0JPWCBmYWxscyBiYWNrIHRvIEVYQUNUXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IG51bGwgfHwgdGhpcy5oZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgZWFzaWVyIHRvIGp1c3QgY29tcHV0ZSB0aGUgcG9zaXRpb24gYW5kIHNpemUgYW5kXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB0byB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25BbmRTaXplID0gdGhpcy5fZ2V0T3ZlcmxheVBvc2l0aW9uQW5kU2l6ZSh2aWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdwb3J0LnZpZXdlckVsZW1lbnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKG5ldyAkLlJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQW5kU2l6ZS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFuZFNpemUucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BbmRTaXplLnNpemUueCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BbmRTaXplLnNpemUueSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOT19ST1RBVElPTiBjYXNlXG4gICAgICAgICAgICByZXR1cm4gYm91bmRzLnJvdGF0ZSgtdmlld3BvcnQuZGVncmVlcyxcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRQb2ludChib3VuZHMpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0oT3BlblNlYWRyYWdvbikpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIERyYXdlclxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBAY2xhc3MgRHJhd2VyXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGNsYXNzZGVzYyBIYW5kbGVzIHJlbmRlcmluZyBvZiB0aWxlcyBmb3IgYW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhpcyBEcmF3ZXIuXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVmlld2VyfSBvcHRpb25zLnZpZXdlciAtIFRoZSBWaWV3ZXIgdGhhdCBvd25zIHRoaXMgRHJhd2VyLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBvcHRpb25zLnZpZXdwb3J0IC0gUmVmZXJlbmNlIHRvIFZpZXdlciB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9ucy5lbGVtZW50IC0gUGFyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVidWdHcmlkQ29sb3JdIC0gU2VlIGRlYnVnR3JpZENvbG9yIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICovXG4kLkRyYXdlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy52aWV3ZXIsIFwiW0RyYXdlcl0gb3B0aW9ucy52aWV3ZXIgaXMgcmVxdWlyZWRcIiApO1xuXG4gICAgLy9iYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBwb3NpdGlvbmFsIGFyZ3Mgd2hpbGUgcHJlZmVyaW5nIG1vcmVcbiAgICAvL2lkaW9tYXRpYyBqYXZhc2NyaXB0IG9wdGlvbnMgb2JqZWN0IGFzIHRoZSBvbmx5IGFyZ3VtZW50XG4gICAgdmFyIGFyZ3MgID0gYXJndW1lbnRzO1xuXG4gICAgaWYoICEkLmlzUGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgc291cmNlOiAgICAgYXJnc1sgMCBdLCAvLyBSZWZlcmVuY2UgdG8gVmlld2VyIHRpbGUgc291cmNlLlxuICAgICAgICAgICAgdmlld3BvcnQ6ICAgYXJnc1sgMSBdLCAvLyBSZWZlcmVuY2UgdG8gVmlld2VyIHZpZXdwb3J0LlxuICAgICAgICAgICAgZWxlbWVudDogICAgYXJnc1sgMiBdICAvLyBQYXJlbnQgZWxlbWVudC5cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLnZpZXdwb3J0LCBcIltEcmF3ZXJdIG9wdGlvbnMudmlld3BvcnQgaXMgcmVxdWlyZWRcIiApO1xuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMuZWxlbWVudCwgXCJbRHJhd2VyXSBvcHRpb25zLmVsZW1lbnQgaXMgcmVxdWlyZWRcIiApO1xuXG4gICAgaWYgKCBvcHRpb25zLnNvdXJjZSApIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKCBcIltEcmF3ZXJdIG9wdGlvbnMuc291cmNlIGlzIG5vIGxvbmdlciBhY2NlcHRlZDsgdXNlIFRpbGVkSW1hZ2UgaW5zdGVhZFwiICk7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3ZXIgPSBvcHRpb25zLnZpZXdlcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gb3B0aW9ucy52aWV3cG9ydDtcbiAgICB0aGlzLmRlYnVnR3JpZENvbG9yID0gb3B0aW9ucy5kZWJ1Z0dyaWRDb2xvciB8fCAkLkRFRkFVTFRfU0VUVElOR1MuZGVidWdHcmlkQ29sb3I7XG4gICAgaWYgKG9wdGlvbnMub3BhY2l0eSkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoIFwiW0RyYXdlcl0gb3B0aW9ucy5vcGFjaXR5IGlzIG5vIGxvbmdlciBhY2NlcHRlZDsgc2V0IHRoZSBvcGFjaXR5IG9uIHRoZSBUaWxlZEltYWdlIGluc3RlYWRcIiApO1xuICAgIH1cblxuICAgIHRoaXMudXNlQ2FudmFzICA9ICQuc3VwcG9ydHNDYW52YXMgJiYgKCB0aGlzLnZpZXdlciA/IHRoaXMudmlld2VyLnVzZUNhbnZhcyA6IHRydWUgKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGVsZW1lbnQgb2YgdGhpcyBEcmF3ZXIgaW5zdGFuY2UsIHBhc3NlZCBpbiB3aGVuIHRoZSBEcmF3ZXIgd2FzIGNyZWF0ZWQuXG4gICAgICogVGhlIHBhcmVudCBvZiB7QGxpbmsgT3BlblNlYWRyYWdvbi5EcmF3ZXIjY2FudmFzfS5cbiAgICAgKiBAbWVtYmVyIHtFbGVtZW50fSBjb250YWluZXJcbiAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5EcmF3ZXIjXG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgID0gJC5nZXRFbGVtZW50KCBvcHRpb25zLmVsZW1lbnQgKTtcbiAgICAvKipcbiAgICAgKiBBICZsdDtjYW52YXMmZ3Q7IGVsZW1lbnQgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlbSwgb3RoZXJ3aXNlIGEgJmx0O2RpdiZndDsgZWxlbWVudC5cbiAgICAgKiBDaGlsZCBlbGVtZW50IG9mIHtAbGluayBPcGVuU2VhZHJhZ29uLkRyYXdlciNjb250YWluZXJ9LlxuICAgICAqIEBtZW1iZXIge0VsZW1lbnR9IGNhbnZhc1xuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkRyYXdlciNcbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhcyAgICAgPSAkLm1ha2VOZXV0cmFsRWxlbWVudCggdGhpcy51c2VDYW52YXMgPyBcImNhbnZhc1wiIDogXCJkaXZcIiApO1xuICAgIC8qKlxuICAgICAqIDJkIGRyYXdpbmcgY29udGV4dCBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uRHJhd2VyI2NhbnZhc30gaWYgaXQncyBhICZsdDtjYW52YXMmZ3Q7IGVsZW1lbnQsIG90aGVyd2lzZSBudWxsLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gY29udGV4dFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkRyYXdlciNcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgICAgPSB0aGlzLnVzZUNhbnZhcyA/IHRoaXMuY2FudmFzLmdldENvbnRleHQoIFwiMmRcIiApIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBjYW52YXMgdXNlZCB0byB0ZW1wb3JhcmlseSBkcmF3IHRpbGVzIHdoaWNoIGNhbm5vdCBiZSBkcmF3biBkaXJlY3RseVxuICAgICAqIHRvIHRoZSBtYWluIGNhbnZhcyBkdWUgdG8gb3BhY2l0eS4gTGF6aWx5IGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoQ2FudmFzID0gbnVsbDtcbiAgICB0aGlzLnNrZXRjaENvbnRleHQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLkRyYXdlciNcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGlhcyBmb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uRHJhd2VyI2NvbnRhaW5lcn0uXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ICAgID0gdGhpcy5jb250YWluZXI7XG5cbiAgICAvLyBXZSBmb3JjZSBvdXIgY29udGFpbmVyIHRvIGx0ciBiZWNhdXNlIG91ciBkcmF3aW5nIG1hdGggZG9lc24ndCB3b3JrIGluIHJ0bC5cbiAgICAvLyBUaGlzIGlzc3VlIG9ubHkgYWZmZWN0cyBvdXIgY2FudmFzIHJlbmRlcmVyLCBidXQgd2UgZG8gaXQgYWx3YXlzIGZvciBjb25zaXN0ZW5jeS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBtZWFucyBvdmVybGF5cyB5b3Ugd2FudCB0byBiZSBydGwgbmVlZCB0byBiZSBleHBsaWNpdGx5IHNldCB0byBydGwuXG4gICAgdGhpcy5jb250YWluZXIuZGlyID0gJ2x0cic7XG5cbiAgICAvLyBjaGVjayBjYW52YXMgYXZhaWxhYmxlIHdpZHRoIGFuZCBoZWlnaHQsIHNldCBjYW52YXMgd2lkdGggYW5kIGhlaWdodCBzdWNoIHRoYXQgdGhlIGNhbnZhcyBiYWNraW5nIHN0b3JlIGlzIHNldCB0byB0aGUgcHJvcGVyIHBpeGVsIGRlbnNpdHlcbiAgICBpZiAodGhpcy51c2VDYW52YXMpIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0U2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUNhbnZhc1NpemUoKTtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB2aWV3cG9ydFNpemUueDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdmlld3BvcnRTaXplLnk7XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggICAgID0gXCIxMDAlXCI7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ICAgID0gXCIxMDAlXCI7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gID0gXCJhYnNvbHV0ZVwiO1xuICAgICQuc2V0RWxlbWVudE9wYWNpdHkoIHRoaXMuY2FudmFzLCB0aGlzLm9wYWNpdHksIHRydWUgKTtcblxuICAgIC8vIGV4cGxpY2l0IGxlZnQtYWxpZ25cbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5jYW52YXMgKTtcbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5EcmF3ZXIucHJvdG90eXBlICovXG4kLkRyYXdlci5wcm90b3R5cGUgPSB7XG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGFkZE92ZXJsYXk6IGZ1bmN0aW9uKCBlbGVtZW50LCBsb2NhdGlvbiwgcGxhY2VtZW50LCBvbkRyYXcgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcImRyYXdlci5hZGRPdmVybGF5IGlzIGRlcHJlY2F0ZWQuIFVzZSB2aWV3ZXIuYWRkT3ZlcmxheSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuYWRkT3ZlcmxheSggZWxlbWVudCwgbG9jYXRpb24sIHBsYWNlbWVudCwgb25EcmF3ICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgdXBkYXRlT3ZlcmxheTogZnVuY3Rpb24oIGVsZW1lbnQsIGxvY2F0aW9uLCBwbGFjZW1lbnQgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcImRyYXdlci51cGRhdGVPdmVybGF5IGlzIGRlcHJlY2F0ZWQuIFVzZSB2aWV3ZXIudXBkYXRlT3ZlcmxheSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy52aWV3ZXIudXBkYXRlT3ZlcmxheSggZWxlbWVudCwgbG9jYXRpb24sIHBsYWNlbWVudCApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIHJlbW92ZU92ZXJsYXk6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAkLmNvbnNvbGUuZXJyb3IoXCJkcmF3ZXIucmVtb3ZlT3ZlcmxheSBpcyBkZXByZWNhdGVkLiBVc2Ugdmlld2VyLnJlbW92ZU92ZXJsYXkgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMudmlld2VyLnJlbW92ZU92ZXJsYXkoIGVsZW1lbnQgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBjbGVhck92ZXJsYXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKFwiZHJhd2VyLmNsZWFyT3ZlcmxheXMgaXMgZGVwcmVjYXRlZC4gVXNlIHZpZXdlci5jbGVhck92ZXJsYXlzIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLnZpZXdlci5jbGVhck92ZXJsYXlzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGRyYXdlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uRHJhd2VyfSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgc2V0T3BhY2l0eTogZnVuY3Rpb24oIG9wYWNpdHkgKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcImRyYXdlci5zZXRPcGFjaXR5IGlzIGRlcHJlY2F0ZWQuIFVzZSB0aWxlZEltYWdlLnNldE9wYWNpdHkgaW5zdGVhZC5cIik7XG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMudmlld2VyLndvcmxkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmxkLmdldEl0ZW1Db3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgIHdvcmxkLmdldEl0ZW1BdCggaSApLnNldE9wYWNpdHkoIG9wYWNpdHkgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBkcmF3ZXIuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKFwiZHJhd2VyLmdldE9wYWNpdHkgaXMgZGVwcmVjYXRlZC4gVXNlIHRpbGVkSW1hZ2UuZ2V0T3BhY2l0eSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy52aWV3ZXIud29ybGQ7XG4gICAgICAgIHZhciBtYXhPcGFjaXR5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JsZC5nZXRJdGVtQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHdvcmxkLmdldEl0ZW1BdCggaSApLmdldE9wYWNpdHkoKTtcbiAgICAgICAgICAgIGlmICggb3BhY2l0eSA+IG1heE9wYWNpdHkgKSB7XG4gICAgICAgICAgICAgICAgbWF4T3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heE9wYWNpdHk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBuZWVkc1VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbRHJhd2VyLm5lZWRzVXBkYXRlXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBXb3JsZC5uZWVkc0RyYXcgaW5zdGVhZC5cIiApO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3ZXIud29ybGQubmVlZHNEcmF3KCk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBudW1UaWxlc0xvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbRHJhd2VyLm51bVRpbGVzTG9hZGVkXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBUaWxlQ2FjaGUubnVtVGlsZXNMb2FkZWQgaW5zdGVhZC5cIiApO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3ZXIudGlsZUNhY2hlLm51bVRpbGVzTG9hZGVkKCk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbRHJhd2VyLnJlc2V0XSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBXb3JsZC5yZXNldEl0ZW1zIGluc3RlYWQuXCIgKTtcbiAgICAgICAgdGhpcy52aWV3ZXIud29ybGQucmVzZXRJdGVtcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvciggXCJbRHJhd2VyLnVwZGF0ZV0gdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgRHJhd2VyLmNsZWFyIGFuZCBXb3JsZC5kcmF3IGluc3RlYWQuXCIgKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnZpZXdlci53b3JsZC5kcmF3KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHJvdGF0aW9uIGlzIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBjYW5Sb3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2VDYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGRyYXdlciAodW5sb2FkIGN1cnJlbnQgbG9hZGVkIHRpbGVzKVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2ZvcmNlIHVubG9hZGluZyBvZiBjdXJyZW50IGNhbnZhcyAoMXgxIHdpbGwgYmUgZ2MgbGF0ZXIsIHRyaWNrIG5vdCBuZWNlc3NhcmlseSBuZWVkZWQpXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoICA9IDE7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgIHRoaXMuc2tldGNoQ2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5za2V0Y2hDb250ZXh0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBEcmF3ZXIgc28gaXQncyByZWFkeSB0byBkcmF3IGFub3RoZXIgZnJhbWUuXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBpZiAoIHRoaXMudXNlQ2FudmFzICkge1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0U2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUNhbnZhc1NpemUoKTtcbiAgICAgICAgICAgIGlmKCB0aGlzLmNhbnZhcy53aWR0aCAhPSB2aWV3cG9ydFNpemUueCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCAhPSB2aWV3cG9ydFNpemUueSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHZpZXdwb3J0U2l6ZS54O1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZpZXdwb3J0U2l6ZS55O1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5za2V0Y2hDYW52YXMgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBza2V0Y2hDYW52YXNTaXplID0gdGhpcy5fY2FsY3VsYXRlU2tldGNoQ2FudmFzU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaENhbnZhcy53aWR0aCA9IHNrZXRjaENhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2V0Y2hDYW52YXMuaGVpZ2h0ID0gc2tldGNoQ2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyOiBmdW5jdGlvbiAodXNlU2tldGNoLCBib3VuZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZUNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dCh1c2VTa2V0Y2gpO1xuICAgICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdChib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZyb20gT3BlblNlYWRyYWdvbiB2aWV3ZXIgcmVjdGFuZ2xlIHRvIGRyYXdlciByZWN0YW5nbGVcbiAgICAgKiAoaWdub3Jpbmcgcm90YXRpb24pXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5SZWN0fSBSZWN0YW5nbGUgaW4gZHJhd2VyIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqL1xuICAgIHZpZXdwb3J0VG9EcmF3ZXJSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICAgICAgICB2YXIgdG9wTGVmdCA9IHRoaXMudmlld3BvcnQucGl4ZWxGcm9tUG9pbnROb1JvdGF0ZShyZWN0YW5nbGUuZ2V0VG9wTGVmdCgpLCB0cnVlKTtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnZpZXdwb3J0LmRlbHRhUGl4ZWxzRnJvbVBvaW50c05vUm90YXRlKHJlY3RhbmdsZS5nZXRTaXplKCksIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgdG9wTGVmdC54ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgIHRvcExlZnQueSAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICBzaXplLnggICAgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgc2l6ZS55ICAgICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gdGlsZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVGlsZX0gdGlsZSAtIFRoZSB0aWxlIHRvIGRyYXcuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhd2luZ0hhbmRsZXIgLSBNZXRob2QgZm9yIGZpcmluZyB0aGUgZHJhd2luZyBldmVudCBpZiB1c2luZyBjYW52YXMuXG4gICAgICogZHJhd2luZ0hhbmRsZXIoe2NvbnRleHQsIHRpbGUsIHJlbmRlcmVkfSlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVNrZXRjaCAtIFdoZXRoZXIgdG8gdXNlIHRoZSBza2V0Y2ggY2FudmFzIG9yIG5vdC5cbiAgICAgKiB3aGVyZSA8Y29kZT5yZW5kZXJlZDwvY29kZT4gaXMgdGhlIGNvbnRleHQgd2l0aCB0aGUgcHJlLWRyYXduIGltYWdlLlxuICAgICAqIEBwYXJhbSB7RmxvYXR9IFtzY2FsZT0xXSAtIEFwcGx5IGEgc2NhbGUgdG8gdGlsZSBwb3NpdGlvbiBhbmQgc2l6ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IFt0cmFuc2xhdGVdIEEgdHJhbnNsYXRpb24gdmVjdG9yIHRvIG9mZnNldCB0aWxlIHBvc2l0aW9uXG4gICAgICovXG4gICAgZHJhd1RpbGU6IGZ1bmN0aW9uKHRpbGUsIGRyYXdpbmdIYW5kbGVyLCB1c2VTa2V0Y2gsIHNjYWxlLCB0cmFuc2xhdGUpIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCh0aWxlLCAnW0RyYXdlci5kcmF3VGlsZV0gdGlsZSBpcyByZXF1aXJlZCcpO1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGRyYXdpbmdIYW5kbGVyLCAnW0RyYXdlci5kcmF3VGlsZV0gZHJhd2luZ0hhbmRsZXIgaXMgcmVxdWlyZWQnKTtcblxuICAgICAgICBpZiAodGhpcy51c2VDYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dCh1c2VTa2V0Y2gpO1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuICAgICAgICAgICAgdGlsZS5kcmF3Q2FudmFzKGNvbnRleHQsIGRyYXdpbmdIYW5kbGVyLCBzY2FsZSwgdHJhbnNsYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbGUuZHJhd0hUTUwoIHRoaXMuY2FudmFzICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldENvbnRleHQ6IGZ1bmN0aW9uKCB1c2VTa2V0Y2ggKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBpZiAoIHVzZVNrZXRjaCApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNrZXRjaENhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tldGNoQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJjYW52YXNcIiApO1xuICAgICAgICAgICAgICAgIHZhciBza2V0Y2hDYW52YXNTaXplID0gdGhpcy5fY2FsY3VsYXRlU2tldGNoQ2FudmFzU2l6ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tldGNoQ2FudmFzLndpZHRoID0gc2tldGNoQ2FudmFzU2l6ZS54O1xuICAgICAgICAgICAgICAgIHRoaXMuc2tldGNoQ2FudmFzLmhlaWdodCA9IHNrZXRjaENhbnZhc1NpemUueTtcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaENvbnRleHQgPSB0aGlzLnNrZXRjaENhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2aWV3cG9ydCBpcyBub3QgY3VycmVudGx5IHJvdGF0ZWQsIHRoZSBza2V0Y2hDYW52YXNcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgbWFpbiBjYW52YXMuIEhvd2V2ZXIsIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhlIHZpZXdwb3J0IGdldCByb3RhdGVkIGxhdGVyIG9uLCB3ZSB3aWxsIG5lZWQgdG8gcmVzaXplIGl0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmdldFJvdGF0aW9uKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdlci5hZGRIYW5kbGVyKCdyb3RhdGUnLCBmdW5jdGlvbiByZXNpemVTa2V0Y2hDYW52YXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnZpZXdlci5yZW1vdmVIYW5kbGVyKCdyb3RhdGUnLCByZXNpemVTa2V0Y2hDYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNrZXRjaENhbnZhc1NpemUgPSBzZWxmLl9jYWxjdWxhdGVTa2V0Y2hDYW52YXNTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNrZXRjaENhbnZhcy53aWR0aCA9IHNrZXRjaENhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2tldGNoQ2FudmFzLmhlaWdodCA9IHNrZXRjaENhbnZhc1NpemUueTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuc2tldGNoQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIHNhdmVDb250ZXh0OiBmdW5jdGlvbiggdXNlU2tldGNoICkge1xuICAgICAgICBpZiAoIXRoaXMudXNlQ2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9nZXRDb250ZXh0KCB1c2VTa2V0Y2ggKS5zYXZlKCk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICByZXN0b3JlQ29udGV4dDogZnVuY3Rpb24oIHVzZVNrZXRjaCApIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZUNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ2V0Q29udGV4dCggdXNlU2tldGNoICkucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgc2V0Q2xpcDogZnVuY3Rpb24ocmVjdCwgdXNlU2tldGNoKSB7XG4gICAgICAgIGlmICghdGhpcy51c2VDYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dCggdXNlU2tldGNoICk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIGRyYXdSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3QsIGZpbGxTdHlsZSwgdXNlU2tldGNoKSB7XG4gICAgICAgIGlmICghdGhpcy51c2VDYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dCggdXNlU2tldGNoICk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmxlbmRzIHRoZSBza2V0Y2ggY2FudmFzIGluIHRoZSBtYWluIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMub3BhY2l0eSBUaGUgb3BhY2l0eSBvZiB0aGUgYmxlbmRpbmcuXG4gICAgICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuc2NhbGU9MV0gVGhlIHNjYWxlIGF0IHdoaWNoIHRpbGVzIHdlcmUgZHJhd24gb25cbiAgICAgKiB0aGUgc2tldGNoLiBEZWZhdWx0IGlzIDEuXG4gICAgICogVXNlIHNjYWxlIHRvIGRyYXcgYXQgYSBsb3dlciBzY2FsZSBhbmQgdGhlbiBlbmxhcmdlIG9udG8gdGhlIG1haW4gY2FudmFzLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gW29wdGlvbnMudHJhbnNsYXRlXSBBIHRyYW5zbGF0aW9uIHZlY3RvclxuICAgICAqIHRoYXQgd2FzIHVzZWQgdG8gZHJhdyB0aGUgdGlsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29tcG9zaXRlT3BlcmF0aW9uXSAtIEhvdyB0aGUgaW1hZ2UgaXNcbiAgICAgKiBjb21wb3NpdGVkIG9udG8gb3RoZXIgaW1hZ2VzOyBzZWUgY29tcG9zaXRlT3BlcmF0aW9uIGluXG4gICAgICoge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30gZm9yIHBvc3NpYmxlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gW29wdGlvbnMuYm91bmRzXSBUaGUgcGFydCBvZiB0aGUgc2tldGNoXG4gICAgICogY2FudmFzIHRvIGJsZW5kIGluIHRoZSBtYWluIGNhbnZhcy4gSWYgc3BlY2lmaWVkLCBvcHRpb25zLnNjYWxlIGFuZFxuICAgICAqIG9wdGlvbnMudHJhbnNsYXRlIGdldCBpZ25vcmVkLlxuICAgICAqL1xuICAgIGJsZW5kU2tldGNoOiBmdW5jdGlvbihvcGFjaXR5LCBzY2FsZSwgdHJhbnNsYXRlLCBjb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBvcGFjaXR5O1xuICAgICAgICBpZiAoISQuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVPcGVyYXRpb246IGNvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudXNlQ2FudmFzIHx8ICF0aGlzLnNrZXRjaENhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IG9wdGlvbnMuY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICB2YXIgYm91bmRzID0gb3B0aW9ucy5ib3VuZHM7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIHRoaXMuc2tldGNoQ2FudmFzLFxuICAgICAgICAgICAgICAgIGJvdW5kcy54LFxuICAgICAgICAgICAgICAgIGJvdW5kcy55LFxuICAgICAgICAgICAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgICAgICBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdW5kcy54LFxuICAgICAgICAgICAgICAgIGJvdW5kcy55LFxuICAgICAgICAgICAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgICAgICBib3VuZHMuaGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IDE7XG4gICAgICAgICAgICB0cmFuc2xhdGUgPSBvcHRpb25zLnRyYW5zbGF0ZTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRyYW5zbGF0ZSBpbnN0YW5jZW9mICQuUG9pbnQgP1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSA6IG5ldyAkLlBvaW50KDAsIDApO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGhFeHQgPSAwO1xuICAgICAgICAgICAgdmFyIGhlaWdodEV4dCA9IDA7XG4gICAgICAgICAgICBpZiAodHJhbnNsYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoRGlmZiA9IHRoaXMuc2tldGNoQ2FudmFzLndpZHRoIC0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodERpZmYgPSB0aGlzLnNrZXRjaENhbnZhcy5oZWlnaHQgLSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGhFeHQgPSBNYXRoLnJvdW5kKHdpZHRoRGlmZiAvIDIpO1xuICAgICAgICAgICAgICAgIGhlaWdodEV4dCA9IE1hdGgucm91bmQoaGVpZ2h0RGlmZiAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaENhbnZhcyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi54IC0gd2lkdGhFeHQgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi55IC0gaGVpZ2h0RXh0ICogc2NhbGUsXG4gICAgICAgICAgICAgICAgKHRoaXMuY2FudmFzLndpZHRoICsgMiAqIHdpZHRoRXh0KSAqIHNjYWxlLFxuICAgICAgICAgICAgICAgICh0aGlzLmNhbnZhcy5oZWlnaHQgICsgMiAqIGhlaWdodEV4dCkgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICAtd2lkdGhFeHQsXG4gICAgICAgICAgICAgICAgLWhlaWdodEV4dCxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCArIDIgKiB3aWR0aEV4dCxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgKyAyICogaGVpZ2h0RXh0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBkcmF3RGVidWdJbmZvOiBmdW5jdGlvbiggdGlsZSwgY291bnQsIGkgKXtcbiAgICAgICAgaWYgKCAhdGhpcy51c2VDYW52YXMgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMiAqICQucGl4ZWxEZW5zaXR5UmF0aW87XG4gICAgICAgIGNvbnRleHQuZm9udCA9ICdzbWFsbC1jYXBzIGJvbGQgJyArICgxMyAqICQucGl4ZWxEZW5zaXR5UmF0aW8pICsgJ3B4IGFyaWFsJztcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuZGVidWdHcmlkQ29sb3I7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5kZWJ1Z0dyaWRDb2xvcjtcblxuICAgICAgICBpZiAoIHRoaXMudmlld3BvcnQuZGVncmVlcyAhPT0gMCApIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldEZvclJvdGF0aW9uKHRoaXMudmlld3BvcnQuZGVncmVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoXG4gICAgICAgICAgICB0aWxlLnBvc2l0aW9uLnggKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgdGlsZS5wb3NpdGlvbi55ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgIHRpbGUuc2l6ZS54ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgIHRpbGUuc2l6ZS55ICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICApO1xuXG4gICAgICAgIHZhciB0aWxlQ2VudGVyWCA9ICh0aWxlLnBvc2l0aW9uLnggKyAodGlsZS5zaXplLnggLyAyKSkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvO1xuICAgICAgICB2YXIgdGlsZUNlbnRlclkgPSAodGlsZS5wb3NpdGlvbi55ICsgKHRpbGUuc2l6ZS55IC8gMikpICogJC5waXhlbERlbnNpdHlSYXRpbztcblxuICAgICAgICAvLyBSb3RhdGUgdGhlIHRleHQgdGhlIHJpZ2h0IHdheSBhcm91bmQuXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCB0aWxlQ2VudGVyWCwgdGlsZUNlbnRlclkgKTtcbiAgICAgICAgY29udGV4dC5yb3RhdGUoIE1hdGguUEkgLyAxODAgKiAtdGhpcy52aWV3cG9ydC5kZWdyZWVzICk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCAtdGlsZUNlbnRlclgsIC10aWxlQ2VudGVyWSApO1xuXG4gICAgICAgIGlmKCB0aWxlLnggPT09IDAgJiYgdGlsZS55ID09PSAwICl7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgIFwiWm9vbTogXCIgKyB0aGlzLnZpZXdwb3J0LmdldFpvb20oKSxcbiAgICAgICAgICAgICAgICB0aWxlLnBvc2l0aW9uLnggKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnkgLSAzMCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICBcIlBhbjogXCIgKyB0aGlzLnZpZXdwb3J0LmdldEJvdW5kcygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdGlsZS5wb3NpdGlvbi54ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgICAgICAodGlsZS5wb3NpdGlvbi55IC0gMjApICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICAgICAgXCJMZXZlbDogXCIgKyB0aWxlLmxldmVsLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueCArIDEwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICAodGlsZS5wb3NpdGlvbi55ICsgMjApICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICAgICAgXCJDb2x1bW46IFwiICsgdGlsZS54LFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueCArIDEwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICAodGlsZS5wb3NpdGlvbi55ICsgMzApICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICAgICAgXCJSb3c6IFwiICsgdGlsZS55LFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueCArIDEwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICAodGlsZS5wb3NpdGlvbi55ICsgNDApICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICAgICAgXCJPcmRlcjogXCIgKyBpICsgXCIgb2YgXCIgKyBjb3VudCxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnggKyAxMCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueSArIDUwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgIFwiU2l6ZTogXCIgKyB0aWxlLnNpemUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICh0aWxlLnBvc2l0aW9uLnggKyAxMCkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueSArIDYwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICAgIFwiUG9zaXRpb246IFwiICsgdGlsZS5wb3NpdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgKHRpbGUucG9zaXRpb24ueCArIDEwKSAqICQucGl4ZWxEZW5zaXR5UmF0aW8sXG4gICAgICAgICAgICAodGlsZS5wb3NpdGlvbi55ICsgNzApICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICggdGhpcy52aWV3cG9ydC5kZWdyZWVzICE9PSAwICkge1xuICAgICAgICAgICAgdGhpcy5fcmVzdG9yZVJvdGF0aW9uQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgZGVidWdSZWN0OiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIGlmICggdGhpcy51c2VDYW52YXMgKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAyICogJC5waXhlbERlbnNpdHlSYXRpbztcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmRlYnVnR3JpZENvbG9yO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmRlYnVnR3JpZENvbG9yO1xuXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoXG4gICAgICAgICAgICAgICAgcmVjdC54ICogJC5waXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgICAgICByZWN0LnkgKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggKiAkLnBpeGVsRGVuc2l0eVJhdGlvLFxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICogJC5waXhlbERlbnNpdHlSYXRpb1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjYW52YXMgc2l6ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tldGNoIElmIHNldCB0byB0cnVlIHJldHVybiB0aGUgc2l6ZSBvZiB0aGUgc2tldGNoIGNhbnZhc1xuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgc2l6ZSBvZiB0aGUgY2FudmFzXG4gICAgICovXG4gICAgZ2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24oc2tldGNoKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9nZXRDb250ZXh0KHNrZXRjaCkuY2FudmFzO1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9vZmZzZXRGb3JSb3RhdGlvbjogZnVuY3Rpb24oZGVncmVlcywgdXNlU2tldGNoKSB7XG4gICAgICAgIHZhciBjeCA9IHRoaXMuY2FudmFzLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQodXNlU2tldGNoKTtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgY29udGV4dC5yb3RhdGUoTWF0aC5QSSAvIDE4MCAqIGRlZ3JlZXMpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfcmVzdG9yZVJvdGF0aW9uQ2hhbmdlczogZnVuY3Rpb24odXNlU2tldGNoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dCh1c2VTa2V0Y2gpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9jYWxjdWxhdGVDYW52YXNTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBpeGVsRGVuc2l0eVJhdGlvID0gJC5waXhlbERlbnNpdHlSYXRpbztcbiAgICAgICAgdmFyIHZpZXdwb3J0U2l6ZSA9IHRoaXMudmlld3BvcnQuZ2V0Q29udGFpbmVyU2l6ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdmlld3BvcnRTaXplLnggKiBwaXhlbERlbnNpdHlSYXRpbyxcbiAgICAgICAgICAgIHk6IHZpZXdwb3J0U2l6ZS55ICogcGl4ZWxEZW5zaXR5UmF0aW9cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9jYWxjdWxhdGVTa2V0Y2hDYW52YXNTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl9jYWxjdWxhdGVDYW52YXNTaXplKCk7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmdldFJvdGF0aW9uKCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXNTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB2aWV3cG9ydCBpcyByb3RhdGVkLCB3ZSBuZWVkIGEgbGFyZ2VyIHNrZXRjaCBjYW52YXMgaW4gb3JkZXJcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBlZGdlIHNtb290aGluZy5cbiAgICAgICAgdmFyIHNrZXRjaENhbnZhc1NpemUgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KFxuICAgICAgICAgICAgY2FudmFzU2l6ZS54ICogY2FudmFzU2l6ZS54ICtcbiAgICAgICAgICAgIGNhbnZhc1NpemUueSAqIGNhbnZhc1NpemUueSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogc2tldGNoQ2FudmFzU2l6ZSxcbiAgICAgICAgICAgIHk6IHNrZXRjaENhbnZhc1NpemVcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFZpZXdwb3J0XG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG5cbi8qKlxuICogQGNsYXNzIFZpZXdwb3J0XG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGNsYXNzZGVzYyBIYW5kbGVzIGNvb3JkaW5hdGUtcmVsYXRlZCBmdW5jdGlvbmFsaXR5ICh6b29tLCBwYW4sIHJvdGF0aW9uLCBldGMuKVxuICogZm9yIGFuIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlcn0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoaXMgVmlld3BvcnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWFyZ2luc10gLSBTZWUgdmlld3BvcnRNYXJnaW5zIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNwcmluZ1N0aWZmbmVzc10gLSBTZWUgc3ByaW5nU3RpZmZuZXNzIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuaW1hdGlvblRpbWVdIC0gU2VlIGFuaW1hdGlvblRpbWUgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluWm9vbUltYWdlUmF0aW9dIC0gU2VlIG1pblpvb21JbWFnZVJhdGlvIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFpvb21QaXhlbFJhdGlvXSAtIFNlZSBtYXhab29tUGl4ZWxSYXRpbyBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aXNpYmlsaXR5UmF0aW9dIC0gU2VlIHZpc2liaWxpdHlSYXRpbyBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud3JhcEhvcml6b250YWxdIC0gU2VlIHdyYXBIb3Jpem9udGFsIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53cmFwVmVydGljYWxdIC0gU2VlIHdyYXBWZXJ0aWNhbCBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZWZhdWx0Wm9vbUxldmVsXSAtIFNlZSBkZWZhdWx0Wm9vbUxldmVsIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblpvb21MZXZlbF0gLSBTZWUgbWluWm9vbUxldmVsIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFpvb21MZXZlbF0gLSBTZWUgbWF4Wm9vbUxldmVsIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlZ3JlZXNdIC0gU2VlIGRlZ3JlZXMgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmhvbWVGaWxsc1ZpZXdlcl0gLSBTZWUgaG9tZUZpbGxzVmlld2VyIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICovXG4kLlZpZXdwb3J0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICAvL2JhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHBvc2l0aW9uYWwgYXJncyB3aGlsZSBwcmVmZXJpbmcgbW9yZVxuICAgIC8vaWRpb21hdGljIGphdmFzY3JpcHQgb3B0aW9ucyBvYmplY3QgYXMgdGhlIG9ubHkgYXJndW1lbnRcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiggIGFyZ3MubGVuZ3RoICYmIGFyZ3NbIDAgXSBpbnN0YW5jZW9mICQuUG9pbnQgKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbnRhaW5lclNpemU6ICBhcmdzWyAwIF0sXG4gICAgICAgICAgICBjb250ZW50U2l6ZTogICAgYXJnc1sgMSBdLFxuICAgICAgICAgICAgY29uZmlnOiAgICAgICAgIGFyZ3NbIDIgXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vb3B0aW9ucy5jb25maWcgYW5kIHRoZSBnZW5lcmFsIGNvbmZpZyBhcmd1bWVudCBhcmUgZGVwcmVjYXRlZFxuICAgIC8vaW4gZmF2b3Igb2YgdGhlIG1vcmUgZGlyZWN0IHNwZWNpZmljYXRpb24gb2Ygb3B0aW9uYWwgc2V0dGluZ3NcbiAgICAvL2JlaW5nIHBhc3NlZCBkaXJlY3RseSBvbiB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICBpZiAoIG9wdGlvbnMuY29uZmlnICl7XG4gICAgICAgICQuZXh0ZW5kKCB0cnVlLCBvcHRpb25zLCBvcHRpb25zLmNvbmZpZyApO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jb25maWc7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFyZ2lucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwXG4gICAgfSwgb3B0aW9ucy5tYXJnaW5zIHx8IHt9KTtcblxuICAgIGRlbGV0ZSBvcHRpb25zLm1hcmdpbnM7XG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywge1xuXG4gICAgICAgIC8vcmVxdWlyZWQgc2V0dGluZ3NcbiAgICAgICAgY29udGFpbmVyU2l6ZTogICAgICBudWxsLFxuICAgICAgICBjb250ZW50U2l6ZTogICAgICAgIG51bGwsXG5cbiAgICAgICAgLy9pbnRlcm5hbCBzdGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHpvb21Qb2ludDogICAgICAgICAgbnVsbCxcbiAgICAgICAgdmlld2VyOiAgICAgICAgICAgbnVsbCxcblxuICAgICAgICAvL2NvbmZpZ3VyYWJsZSBvcHRpb25zXG4gICAgICAgIHNwcmluZ1N0aWZmbmVzczogICAgJC5ERUZBVUxUX1NFVFRJTkdTLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogICAgICAkLkRFRkFVTFRfU0VUVElOR1MuYW5pbWF0aW9uVGltZSxcbiAgICAgICAgbWluWm9vbUltYWdlUmF0aW86ICAkLkRFRkFVTFRfU0VUVElOR1MubWluWm9vbUltYWdlUmF0aW8sXG4gICAgICAgIG1heFpvb21QaXhlbFJhdGlvOiAgJC5ERUZBVUxUX1NFVFRJTkdTLm1heFpvb21QaXhlbFJhdGlvLFxuICAgICAgICB2aXNpYmlsaXR5UmF0aW86ICAgICQuREVGQVVMVF9TRVRUSU5HUy52aXNpYmlsaXR5UmF0aW8sXG4gICAgICAgIHdyYXBIb3Jpem9udGFsOiAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLndyYXBIb3Jpem9udGFsLFxuICAgICAgICB3cmFwVmVydGljYWw6ICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy53cmFwVmVydGljYWwsXG4gICAgICAgIGRlZmF1bHRab29tTGV2ZWw6ICAgJC5ERUZBVUxUX1NFVFRJTkdTLmRlZmF1bHRab29tTGV2ZWwsXG4gICAgICAgIG1pblpvb21MZXZlbDogICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLm1pblpvb21MZXZlbCxcbiAgICAgICAgbWF4Wm9vbUxldmVsOiAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MubWF4Wm9vbUxldmVsLFxuICAgICAgICBkZWdyZWVzOiAgICAgICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5kZWdyZWVzLFxuICAgICAgICBob21lRmlsbHNWaWV3ZXI6ICAgICQuREVGQVVMVF9TRVRUSU5HUy5ob21lRmlsbHNWaWV3ZXJcblxuICAgIH0sIG9wdGlvbnMgKTtcblxuICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lcklubmVyU2l6ZSgpO1xuXG4gICAgdGhpcy5jZW50ZXJTcHJpbmdYID0gbmV3ICQuU3ByaW5nKHtcbiAgICAgICAgaW5pdGlhbDogMCxcbiAgICAgICAgc3ByaW5nU3RpZmZuZXNzOiB0aGlzLnNwcmluZ1N0aWZmbmVzcyxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogICB0aGlzLmFuaW1hdGlvblRpbWVcbiAgICB9KTtcbiAgICB0aGlzLmNlbnRlclNwcmluZ1kgPSBuZXcgJC5TcHJpbmcoe1xuICAgICAgICBpbml0aWFsOiAwLFxuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6IHRoaXMuc3ByaW5nU3RpZmZuZXNzLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAgIHRoaXMuYW5pbWF0aW9uVGltZVxuICAgIH0pO1xuICAgIHRoaXMuem9vbVNwcmluZyAgICA9IG5ldyAkLlNwcmluZyh7XG4gICAgICAgIGV4cG9uZW50aWFsOiB0cnVlLFxuICAgICAgICBpbml0aWFsOiAxLFxuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6IHRoaXMuc3ByaW5nU3RpZmZuZXNzLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAgIHRoaXMuYW5pbWF0aW9uVGltZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fb2xkQ2VudGVyWCA9IHRoaXMuY2VudGVyU3ByaW5nWC5jdXJyZW50LnZhbHVlO1xuICAgIHRoaXMuX29sZENlbnRlclkgPSB0aGlzLmNlbnRlclNwcmluZ1kuY3VycmVudC52YWx1ZTtcbiAgICB0aGlzLl9vbGRab29tICAgID0gdGhpcy56b29tU3ByaW5nLmN1cnJlbnQudmFsdWU7XG5cbiAgICB0aGlzLl9zZXRDb250ZW50Qm91bmRzKG5ldyAkLlJlY3QoMCwgMCwgMSwgMSksIDEpO1xuXG4gICAgdGhpcy5nb0hvbWUodHJ1ZSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5WaWV3cG9ydC5wcm90b3R5cGUgKi9cbiQuVmlld3BvcnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZpZXdwb3J0J3MgaG9tZSBib3VuZHMgYW5kIGNvbnN0cmFpbnRzIGZvciB0aGUgZ2l2ZW4gY29udGVudCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gY29udGVudFNpemUgLSBzaXplIG9mIHRoZSBjb250ZW50IGluIGNvbnRlbnQgdW5pdHNcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnJlc2V0LXNpemVcbiAgICAgKi9cbiAgICByZXNldENvbnRlbnRTaXplOiBmdW5jdGlvbihjb250ZW50U2l6ZSkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGNvbnRlbnRTaXplLCBcIltWaWV3cG9ydC5yZXNldENvbnRlbnRTaXplXSBjb250ZW50U2l6ZSBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChjb250ZW50U2l6ZSBpbnN0YW5jZW9mICQuUG9pbnQsIFwiW1ZpZXdwb3J0LnJlc2V0Q29udGVudFNpemVdIGNvbnRlbnRTaXplIG11c3QgYmUgYW4gT3BlblNlYWRyYWdvbi5Qb2ludFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChjb250ZW50U2l6ZS54ID4gMCwgXCJbVmlld3BvcnQucmVzZXRDb250ZW50U2l6ZV0gY29udGVudFNpemUueCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGNvbnRlbnRTaXplLnkgPiAwLCBcIltWaWV3cG9ydC5yZXNldENvbnRlbnRTaXplXSBjb250ZW50U2l6ZS55IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG5cbiAgICAgICAgdGhpcy5fc2V0Q29udGVudEJvdW5kcyhuZXcgJC5SZWN0KDAsIDAsIDEsIGNvbnRlbnRTaXplLnkgLyBjb250ZW50U2l6ZS54KSwgY29udGVudFNpemUueCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgc2V0SG9tZUJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBjb250ZW50RmFjdG9yKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcihcIltWaWV3cG9ydC5zZXRIb21lQm91bmRzXSB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ7IFRoZSBjb250ZW50IGJvdW5kcyBzaG91bGQgbm90IGJlIHNldCBtYW51YWxseS5cIik7XG4gICAgICAgIHRoaXMuX3NldENvbnRlbnRCb3VuZHMoYm91bmRzLCBjb250ZW50RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHRoZSB2aWV3cG9ydCdzIGNvbnRlbnQgYm91bmRzXG4gICAgLy8gQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IGJvdW5kcyAtIHRoZSBuZXcgYm91bmRzIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgLy8gd2l0aG91dCByb3RhdGlvblxuICAgIC8vIEBwYXJhbSB7TnVtYmVyfSBjb250ZW50RmFjdG9yIC0gaG93IG1hbnkgY29udGVudCB1bml0cyBwZXIgdmlld3BvcnQgdW5pdFxuICAgIC8vIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpyZXNldC1zaXplXG4gICAgLy8gQHByaXZhdGVcbiAgICBfc2V0Q29udGVudEJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBjb250ZW50RmFjdG9yKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoYm91bmRzLCBcIltWaWV3cG9ydC5fc2V0Q29udGVudEJvdW5kc10gYm91bmRzIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGJvdW5kcyBpbnN0YW5jZW9mICQuUmVjdCwgXCJbVmlld3BvcnQuX3NldENvbnRlbnRCb3VuZHNdIGJvdW5kcyBtdXN0IGJlIGFuIE9wZW5TZWFkcmFnb24uUmVjdFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChib3VuZHMud2lkdGggPiAwLCBcIltWaWV3cG9ydC5fc2V0Q29udGVudEJvdW5kc10gYm91bmRzLndpZHRoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoYm91bmRzLmhlaWdodCA+IDAsIFwiW1ZpZXdwb3J0Ll9zZXRDb250ZW50Qm91bmRzXSBib3VuZHMuaGVpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG5cbiAgICAgICAgdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlID0gYm91bmRzLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRTaXplTm9Sb3RhdGUgPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUuZ2V0U2l6ZSgpLnRpbWVzKFxuICAgICAgICAgICAgY29udGVudEZhY3Rvcik7XG5cbiAgICAgICAgdGhpcy5fY29udGVudEJvdW5kcyA9IGJvdW5kcy5yb3RhdGUodGhpcy5kZWdyZWVzKS5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IHRoaXMuX2NvbnRlbnRCb3VuZHMuZ2V0U2l6ZSgpLnRpbWVzKGNvbnRlbnRGYWN0b3IpO1xuICAgICAgICB0aGlzLl9jb250ZW50QXNwZWN0UmF0aW8gPSB0aGlzLl9jb250ZW50U2l6ZS54IC8gdGhpcy5fY29udGVudFNpemUueTtcblxuICAgICAgICBpZiAodGhpcy52aWV3ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdlcidzIGNvbnRlbnQgc2l6ZSBvciBob21lIGJvdW5kcyBhcmUgcmVzZXRcbiAgICAgICAgICAgICAqIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld3BvcnQjcmVzZXRDb250ZW50U2l6ZX0pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCByZXNldC1zaXplXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IGNvbnRlbnRTaXplXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUmVjdH0gY29udGVudEJvdW5kcyAtIENvbnRlbnQgYm91bmRzLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlJlY3R9IGhvbWVCb3VuZHMgLSBDb250ZW50IGJvdW5kcy5cbiAgICAgICAgICAgICAqIERlcHJlY2F0ZWQgdXNlIGNvbnRlbnRCb3VuZHMgaW5zdGVhZC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250ZW50RmFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudmlld2VyLnJhaXNlRXZlbnQoJ3Jlc2V0LXNpemUnLCB7XG4gICAgICAgICAgICAgICAgY29udGVudFNpemU6IHRoaXMuX2NvbnRlbnRTaXplTm9Sb3RhdGUuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBjb250ZW50RmFjdG9yOiBjb250ZW50RmFjdG9yLFxuICAgICAgICAgICAgICAgIGhvbWVCb3VuZHM6IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRCb3VuZHM6IHRoaXMuX2NvbnRlbnRCb3VuZHMuY2xvbmUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaG9tZSB6b29tIGluIFwidmlld3BvcnQgem9vbVwiIHZhbHVlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBob21lIHpvb20gaW4gXCJ2aWV3cG9ydCB6b29tXCIuXG4gICAgICovXG4gICAgZ2V0SG9tZVpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0Wm9vbUxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0Wm9vbUxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFzcGVjdEZhY3RvciA9IHRoaXMuX2NvbnRlbnRBc3BlY3RSYXRpbyAvIHRoaXMuZ2V0QXNwZWN0UmF0aW8oKTtcbiAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgaWYgKHRoaXMuaG9tZUZpbGxzVmlld2VyKSB7IC8vIGZpbGwgdGhlIHZpZXdlciBhbmQgY2xpcCB0aGUgaW1hZ2VcbiAgICAgICAgICAgIG91dHB1dCA9IGFzcGVjdEZhY3RvciA+PSAxID8gYXNwZWN0RmFjdG9yIDogMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGFzcGVjdEZhY3RvciA+PSAxID8gMSA6IGFzcGVjdEZhY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQgLyB0aGlzLl9jb250ZW50Qm91bmRzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBob21lIGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fSBUaGUgaG9tZSBib3VuZHMgaW4gdmV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRIb21lQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SG9tZUJvdW5kc05vUm90YXRlKCkucm90YXRlKC10aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBob21lIGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpZ25vcmVzIHRoZSB2aWV3cG9ydCByb3RhdGlvbi4gVXNlXG4gICAgICoge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld3BvcnQjZ2V0SG9tZUJvdW5kc30gdG8gdGFrZSBpdCBpbnRvIGFjY291bnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gVGhlIGhvbWUgYm91bmRzIGluIHZld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0SG9tZUJvdW5kc05vUm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2NvbnRlbnRCb3VuZHMuZ2V0Q2VudGVyKCk7XG4gICAgICAgIHZhciB3aWR0aCAgPSAxLjAgLyB0aGlzLmdldEhvbWVab29tKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB3aWR0aCAvIHRoaXMuZ2V0QXNwZWN0UmF0aW8oKTtcblxuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIGNlbnRlci54IC0gKHdpZHRoIC8gMi4wKSxcbiAgICAgICAgICAgIGNlbnRlci55IC0gKGhlaWdodCAvIDIuMCksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGltbWVkaWF0ZWx5XG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OmhvbWVcbiAgICAgKi9cbiAgICBnb0hvbWU6IGZ1bmN0aW9uKGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgXCJob21lXCIgb3BlcmF0aW9uIG9jY3VycyAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I2dvSG9tZX0pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBob21lXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudmlld2VyLnJhaXNlRXZlbnQoJ2hvbWUnLCB7XG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlbHk6IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maXRCb3VuZHModGhpcy5nZXRIb21lQm91bmRzKCksIGltbWVkaWF0ZWx5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0TWluWm9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBob21lWm9vbSA9IHRoaXMuZ2V0SG9tZVpvb20oKSxcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLm1pblpvb21MZXZlbCA/XG4gICAgICAgICAgICB0aGlzLm1pblpvb21MZXZlbCA6XG4gICAgICAgICAgICAgICAgdGhpcy5taW5ab29tSW1hZ2VSYXRpbyAqIGhvbWVab29tO1xuXG4gICAgICAgIHJldHVybiB6b29tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXRNYXhab29tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLm1heFpvb21MZXZlbDtcbiAgICAgICAgaWYgKCF6b29tKSB7XG4gICAgICAgICAgICB6b29tID0gdGhpcy5fY29udGVudFNpemUueCAqIHRoaXMubWF4Wm9vbVBpeGVsUmF0aW8gLyB0aGlzLl9jb250YWluZXJJbm5lclNpemUueDtcbiAgICAgICAgICAgIHpvb20gLz0gdGhpcy5fY29udGVudEJvdW5kcy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCggem9vbSwgdGhpcy5nZXRIb21lWm9vbSgpICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldEFzcGVjdFJhdGlvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZS54IC8gdGhpcy5fY29udGFpbmVySW5uZXJTaXplLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBUaGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyLCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Q29udGFpbmVyU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZS54LFxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplLnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcmdpbnMgcHVzaCB0aGUgXCJob21lXCIgcmVnaW9uIGluIGZyb20gdGhlIHNpZGVzIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBQcm9wZXJ0aWVzIChOdW1iZXJzLCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMpOiBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20uXG4gICAgICovXG4gICAgZ2V0TWFyZ2luczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgdGhpcy5fbWFyZ2lucyk7IC8vIE1ha2UgYSBjb3B5IHNvIHdlIGFyZSBub3QgcmV0dXJuaW5nIG91ciBvcmlnaW5hbFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFyZ2lucyBwdXNoIHRoZSBcImhvbWVcIiByZWdpb24gaW4gZnJvbSB0aGUgc2lkZXMgYnkgdGhlIHNwZWNpZmllZCBhbW91bnRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXJnaW5zIC0gUHJvcGVydGllcyAoTnVtYmVycywgaW4gc2NyZWVuIGNvb3JkaW5hdGVzKTogbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLlxuICAgICAqL1xuICAgIHNldE1hcmdpbnM6IGZ1bmN0aW9uKG1hcmdpbnMpIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCgkLnR5cGUobWFyZ2lucykgPT09ICdvYmplY3QnLCAnW1ZpZXdwb3J0LnNldE1hcmdpbnNdIG1hcmdpbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgICAgICB0aGlzLl9tYXJnaW5zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH0sIG1hcmdpbnMpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lcklubmVyU2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy52aWV3ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudmlld2VyLmZvcmNlUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSB2aXNpYmxlIGFyZWEgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjdXJyZW50IC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjsgZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gVGhlIGxvY2F0aW9uIHlvdSBhcmUgem9vbWVkL3Bhbm5lZCB0bywgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbihjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kc05vUm90YXRlKGN1cnJlbnQpLnJvdGF0ZSgtdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSB2aXNpYmxlIGFyZWEgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgaWdub3JlcyB0aGUgdmlld3BvcnQgcm90YXRpb24uIFVzZVxuICAgICAqIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I2dldEJvdW5kc30gdG8gdGFrZSBpdCBpbnRvIGFjY291bnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjdXJyZW50IC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjsgZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gVGhlIGxvY2F0aW9uIHlvdSBhcmUgem9vbWVkL3Bhbm5lZCB0bywgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzTm9Sb3RhdGU6IGZ1bmN0aW9uKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKGN1cnJlbnQpO1xuICAgICAgICB2YXIgd2lkdGggID0gMS4wIC8gdGhpcy5nZXRab29tKGN1cnJlbnQpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkdGggLyB0aGlzLmdldEFzcGVjdFJhdGlvKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBjZW50ZXIueCAtICh3aWR0aCAvIDIuMCksXG4gICAgICAgICAgICBjZW50ZXIueSAtIChoZWlnaHQgLyAyLjApLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjdXJyZW50IC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjsgZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gVGhlIGxvY2F0aW9uIHlvdSBhcmUgem9vbWVkL3Bhbm5lZCB0byxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIHNwYWNlIHRha2VuIGJ5IG1hcmdpbnMsIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldEJvdW5kc1dpdGhNYXJnaW5zOiBmdW5jdGlvbihjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kc05vUm90YXRlV2l0aE1hcmdpbnMoY3VycmVudCkucm90YXRlKFxuICAgICAgICAgICAgLXRoaXMuZ2V0Um90YXRpb24oKSwgdGhpcy5nZXRDZW50ZXIoY3VycmVudCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGN1cnJlbnQgLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uOyBkZWZhdWx0cyB0byBmYWxzZSAodGFyZ2V0IGxvY2F0aW9uKS5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fSBUaGUgbG9jYXRpb24geW91IGFyZSB6b29tZWQvcGFubmVkIHRvLFxuICAgICAqIGluY2x1ZGluZyB0aGUgc3BhY2UgdGFrZW4gYnkgbWFyZ2lucywgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzTm9Sb3RhdGVXaXRoTWFyZ2luczogZnVuY3Rpb24oY3VycmVudCkge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHNOb1JvdGF0ZShjdXJyZW50KTtcbiAgICAgICAgdmFyIGZhY3RvciA9IHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZS54ICogdGhpcy5nZXRab29tKGN1cnJlbnQpO1xuICAgICAgICBib3VuZHMueCAtPSB0aGlzLl9tYXJnaW5zLmxlZnQgLyBmYWN0b3I7XG4gICAgICAgIGJvdW5kcy55IC09IHRoaXMuX21hcmdpbnMudG9wIC8gZmFjdG9yO1xuICAgICAgICBib3VuZHMud2lkdGggKz0gKHRoaXMuX21hcmdpbnMubGVmdCArIHRoaXMuX21hcmdpbnMucmlnaHQpIC8gZmFjdG9yO1xuICAgICAgICBib3VuZHMuaGVpZ2h0ICs9ICh0aGlzLl9tYXJnaW5zLnRvcCArIHRoaXMuX21hcmdpbnMuYm90dG9tKSAvIGZhY3RvcjtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjdXJyZW50IC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjsgZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiggY3VycmVudCApIHtcbiAgICAgICAgdmFyIGNlbnRlckN1cnJlbnQgPSBuZXcgJC5Qb2ludChcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1guY3VycmVudC52YWx1ZSxcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1kuY3VycmVudC52YWx1ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNlbnRlclRhcmdldCA9IG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyU3ByaW5nWC50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdZLnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG9sZFpvb21QaXhlbCxcbiAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGJvdW5kcyxcbiAgICAgICAgICAgIG5ld1pvb21QaXhlbCxcbiAgICAgICAgICAgIGRlbHRhWm9vbVBpeGVscyxcbiAgICAgICAgICAgIGRlbHRhWm9vbVBvaW50cztcblxuICAgICAgICBpZiAoIGN1cnJlbnQgKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VudGVyQ3VycmVudDtcbiAgICAgICAgfSBlbHNlIGlmICggIXRoaXMuem9vbVBvaW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbnRlclRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZFpvb21QaXhlbCA9IHRoaXMucGl4ZWxGcm9tUG9pbnQodGhpcy56b29tUG9pbnQsIHRydWUpO1xuXG4gICAgICAgIHpvb20gICAgPSB0aGlzLmdldFpvb20oKTtcbiAgICAgICAgd2lkdGggICA9IDEuMCAvIHpvb207XG4gICAgICAgIGhlaWdodCAgPSB3aWR0aCAvIHRoaXMuZ2V0QXNwZWN0UmF0aW8oKTtcbiAgICAgICAgYm91bmRzICA9IG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBjZW50ZXJDdXJyZW50LnggLSB3aWR0aCAvIDIuMCxcbiAgICAgICAgICAgIGNlbnRlckN1cnJlbnQueSAtIGhlaWdodCAvIDIuMCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgbmV3Wm9vbVBpeGVsID0gdGhpcy5fcGl4ZWxGcm9tUG9pbnQodGhpcy56b29tUG9pbnQsIGJvdW5kcyk7XG4gICAgICAgIGRlbHRhWm9vbVBpeGVscyA9IG5ld1pvb21QaXhlbC5taW51cyggb2xkWm9vbVBpeGVsICk7XG4gICAgICAgIGRlbHRhWm9vbVBvaW50cyA9IGRlbHRhWm9vbVBpeGVscy5kaXZpZGUoIHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZS54ICogem9vbSApO1xuXG4gICAgICAgIHJldHVybiBjZW50ZXJUYXJnZXQucGx1cyggZGVsdGFab29tUG9pbnRzICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY3VycmVudCAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247IGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uKCBjdXJyZW50ICkge1xuICAgICAgICBpZiAoIGN1cnJlbnQgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56b29tU3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56b29tU3ByaW5nLnRhcmdldC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX2FwcGx5Wm9vbUNvbnN0cmFpbnRzOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAgIE1hdGgubWluKHpvb20sIHRoaXMuZ2V0TWF4Wm9vbSgpKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0TWluWm9vbSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gYm91bmRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUmVjdH0gY29uc3RyYWluZWQgYm91bmRzLlxuICAgICAqL1xuICAgIF9hcHBseUJvdW5kYXJ5Q29uc3RyYWludHM6IGZ1bmN0aW9uKGJvdW5kcywgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIG5ld0JvdW5kcyA9IG5ldyAkLlJlY3QoXG4gICAgICAgICAgICAgICAgYm91bmRzLngsXG4gICAgICAgICAgICAgICAgYm91bmRzLnksXG4gICAgICAgICAgICAgICAgYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgICAgIGJvdW5kcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzLndyYXBIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAvL2RvIG5vdGhpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsVGhyZXNob2xkID0gdGhpcy52aXNpYmlsaXR5UmF0aW8gKiBuZXdCb3VuZHMud2lkdGg7XG4gICAgICAgICAgICB2YXIgYm91bmRzUmlnaHQgPSBuZXdCb3VuZHMueCArIG5ld0JvdW5kcy53aWR0aDtcbiAgICAgICAgICAgIHZhciBjb250ZW50UmlnaHQgPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUueCArIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBsZWZ0RHggPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUueCAtIGJvdW5kc1JpZ2h0ICsgaG9yaXpvbnRhbFRocmVzaG9sZDtcbiAgICAgICAgICAgIHZhciByaWdodER4ID0gY29udGVudFJpZ2h0IC0gbmV3Qm91bmRzLnggLSBob3Jpem9udGFsVGhyZXNob2xkO1xuXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbFRocmVzaG9sZCA+IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcy54ICs9IChsZWZ0RHggKyByaWdodER4KSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RHggPCAwKSB7XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRzLnggKz0gcmlnaHREeDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdER4ID4gMCkge1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcy54ICs9IGxlZnREeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLndyYXBWZXJ0aWNhbCkge1xuICAgICAgICAgICAgLy9kbyBub3RoaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmVydGljYWxUaHJlc2hvbGQgICA9IHRoaXMudmlzaWJpbGl0eVJhdGlvICogbmV3Qm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBib3VuZHNCb3R0b20gPSBuZXdCb3VuZHMueSArIG5ld0JvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY29udGVudEJvdHRvbSA9IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS55ICsgdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciB0b3BEeSA9IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS55IC0gYm91bmRzQm90dG9tICsgdmVydGljYWxUaHJlc2hvbGQ7XG4gICAgICAgICAgICB2YXIgYm90dG9tRHkgPSBjb250ZW50Qm90dG9tIC0gbmV3Qm91bmRzLnkgLSB2ZXJ0aWNhbFRocmVzaG9sZDtcblxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsVGhyZXNob2xkID4gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcy55ICs9ICh0b3BEeSArIGJvdHRvbUR5KSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbUR5IDwgMCkge1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kcy55ICs9IGJvdHRvbUR5O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3BEeSA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMueSArPSB0b3BEeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZpZXdlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgdmlld3BvcnQgY29uc3RyYWludHMgYXJlIGFwcGxpZWQgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNhcHBseUNvbnN0cmFpbnRzfSkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IGNvbnN0cmFpblxuICAgICAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlci5yYWlzZUV2ZW50KCAnY29uc3RyYWluJywge1xuICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5OiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3Qm91bmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmZvcmNlcyB0aGUgbWluWm9vbSwgbWF4Wm9vbSBhbmQgdmlzaWJpbGl0eVJhdGlvIGNvbnN0cmFpbnRzIGJ5XG4gICAgICogem9vbWluZyBhbmQgcGFubmluZyB0byB0aGUgY2xvc2VzdCBhY2NlcHRhYmxlIHpvb20gYW5kIGxvY2F0aW9uLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6Y29uc3RyYWluXG4gICAgICovXG4gICAgYXBwbHlDb25zdHJhaW50czogZnVuY3Rpb24oaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIGFjdHVhbFpvb20gPSB0aGlzLmdldFpvb20oKTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbmVkWm9vbSA9IHRoaXMuX2FwcGx5Wm9vbUNvbnN0cmFpbnRzKGFjdHVhbFpvb20pO1xuXG4gICAgICAgIGlmIChhY3R1YWxab29tICE9PSBjb25zdHJhaW5lZFpvb20pIHtcbiAgICAgICAgICAgIHRoaXMuem9vbVRvKGNvbnN0cmFpbmVkWm9vbSwgdGhpcy56b29tUG9pbnQsIGltbWVkaWF0ZWx5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kc05vUm90YXRlKCk7XG4gICAgICAgIHZhciBjb25zdHJhaW5lZEJvdW5kcyA9IHRoaXMuX2FwcGx5Qm91bmRhcnlDb25zdHJhaW50cyhcbiAgICAgICAgICAgIGJvdW5kcywgaW1tZWRpYXRlbHkpO1xuXG4gICAgICAgIGlmIChib3VuZHMueCAhPT0gY29uc3RyYWluZWRCb3VuZHMueCB8fFxuICAgICAgICAgICAgYm91bmRzLnkgIT09IGNvbnN0cmFpbmVkQm91bmRzLnkgfHxcbiAgICAgICAgICAgIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICB0aGlzLmZpdEJvdW5kcyhcbiAgICAgICAgICAgICAgICBjb25zdHJhaW5lZEJvdW5kcy5yb3RhdGUoLXRoaXMuZ2V0Um90YXRpb24oKSksXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlbHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I2FwcGx5Q29uc3RyYWludHN9XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpjb25zdHJhaW5cbiAgICAgKi9cbiAgICBlbnN1cmVWaXNpYmxlOiBmdW5jdGlvbihpbW1lZGlhdGVseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNvbnN0cmFpbnRzKGltbWVkaWF0ZWx5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gYm91bmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgKGltbWVkaWF0ZWx5PWZhbHNlLCBjb25zdHJhaW50cz1mYWxzZSlcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgX2ZpdEJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgaW1tZWRpYXRlbHkgPSBvcHRpb25zLmltbWVkaWF0ZWx5IHx8IGZhbHNlO1xuICAgICAgICB2YXIgY29uc3RyYWludHMgPSBvcHRpb25zLmNvbnN0cmFpbnRzIHx8IGZhbHNlO1xuXG4gICAgICAgIHZhciBhc3BlY3QgPSB0aGlzLmdldEFzcGVjdFJhdGlvKCk7XG4gICAgICAgIHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIGJvdW5kaW5nIGJveC5cbiAgICAgICAgdmFyIG5ld0JvdW5kcyA9IG5ldyAkLlJlY3QoXG4gICAgICAgICAgICBib3VuZHMueCxcbiAgICAgICAgICAgIGJvdW5kcy55LFxuICAgICAgICAgICAgYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgIGJvdW5kcy5kZWdyZWVzICsgdGhpcy5nZXRSb3RhdGlvbigpKVxuICAgICAgICAgICAgLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgaWYgKG5ld0JvdW5kcy5nZXRBc3BlY3RSYXRpbygpID49IGFzcGVjdCkge1xuICAgICAgICAgICAgbmV3Qm91bmRzLmhlaWdodCA9IG5ld0JvdW5kcy53aWR0aCAvIGFzcGVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0JvdW5kcy53aWR0aCA9IG5ld0JvdW5kcy5oZWlnaHQgKiBhc3BlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIHggYW5kIHkgZnJvbSB3aWR0aCwgaGVpZ2h0IGFuZCBjZW50ZXIgcG9zaXRpb25cbiAgICAgICAgbmV3Qm91bmRzLnggPSBjZW50ZXIueCAtIG5ld0JvdW5kcy53aWR0aCAvIDI7XG4gICAgICAgIG5ld0JvdW5kcy55ID0gY2VudGVyLnkgLSBuZXdCb3VuZHMuaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIG5ld1pvb20gPSAxLjAgLyBuZXdCb3VuZHMud2lkdGg7XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICB2YXIgbmV3Qm91bmRzQXNwZWN0UmF0aW8gPSBuZXdCb3VuZHMuZ2V0QXNwZWN0UmF0aW8oKTtcbiAgICAgICAgICAgIHZhciBuZXdDb25zdHJhaW5lZFpvb20gPSB0aGlzLl9hcHBseVpvb21Db25zdHJhaW50cyhuZXdab29tKTtcblxuICAgICAgICAgICAgaWYgKG5ld1pvb20gIT09IG5ld0NvbnN0cmFpbmVkWm9vbSkge1xuICAgICAgICAgICAgICAgIG5ld1pvb20gPSBuZXdDb25zdHJhaW5lZFpvb207XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRzLndpZHRoID0gMS4wIC8gbmV3Wm9vbTtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMueCA9IGNlbnRlci54IC0gbmV3Qm91bmRzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZHMuaGVpZ2h0ID0gbmV3Qm91bmRzLndpZHRoIC8gbmV3Qm91bmRzQXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRzLnkgPSBjZW50ZXIueSAtIG5ld0JvdW5kcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdCb3VuZHMgPSB0aGlzLl9hcHBseUJvdW5kYXJ5Q29uc3RyYWludHMobmV3Qm91bmRzLCBpbW1lZGlhdGVseSk7XG4gICAgICAgICAgICBjZW50ZXIgPSBuZXdCb3VuZHMuZ2V0Q2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIHRoaXMucGFuVG8oY2VudGVyLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnpvb21UbyhuZXdab29tLCBudWxsLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFuVG8odGhpcy5nZXRDZW50ZXIodHJ1ZSksIHRydWUpO1xuICAgICAgICB0aGlzLnpvb21Ubyh0aGlzLmdldFpvb20odHJ1ZSksIG51bGwsIHRydWUpO1xuXG4gICAgICAgIHZhciBvbGRCb3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICB2YXIgb2xkWm9vbSAgID0gdGhpcy5nZXRab29tKCk7XG5cbiAgICAgICAgaWYgKG9sZFpvb20gPT09IDAgfHwgTWF0aC5hYnMobmV3Wm9vbSAvIG9sZFpvb20gLSAxKSA8IDAuMDAwMDAwMDEpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbVRvKG5ld1pvb20sIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuVG8oY2VudGVyLCBpbW1lZGlhdGVseSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdCb3VuZHMgPSBuZXdCb3VuZHMucm90YXRlKC10aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgICAgICB2YXIgcmVmZXJlbmNlUG9pbnQgPSBuZXdCb3VuZHMuZ2V0VG9wTGVmdCgpLnRpbWVzKG5ld1pvb20pXG4gICAgICAgICAgICAubWludXMob2xkQm91bmRzLmdldFRvcExlZnQoKS50aW1lcyhvbGRab29tKSlcbiAgICAgICAgICAgIC5kaXZpZGUobmV3Wm9vbSAtIG9sZFpvb20pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnpvb21UbyhuZXdab29tLCByZWZlcmVuY2VQb2ludCwgaW1tZWRpYXRlbHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgdmlld3BvcnQgem9vbSBhbmQgcGFuIHNvIHRoYXQgdGhlIHNwZWNpZmllZCBib3VuZHMgdGFrZVxuICAgICAqIGFzIG11Y2ggc3BhY2UgYXMgcG9zc2libGUgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlnbm9yZXMgdGhlIGNvbnN0cmFpbnRzIChtaW5ab29tLCBtYXhab29tIGFuZFxuICAgICAqIHZpc2liaWxpdHlSYXRpbykuXG4gICAgICogVXNlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I2ZpdEJvdW5kc1dpdGhDb25zdHJhaW50c30gdG8gZW5mb3JjZVxuICAgICAqIHRoZW0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKi9cbiAgICBmaXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpdEJvdW5kcyhib3VuZHMsIHtcbiAgICAgICAgICAgIGltbWVkaWF0ZWx5OiBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIHZpZXdwb3J0IHpvb20gYW5kIHBhbiBzbyB0aGF0IHRoZSBzcGVjaWZpZWQgYm91bmRzIHRha2VcbiAgICAgKiBhcyBtdWNoIHNwYWNlIGFzIHBvc3NpYmxlIGluIHRoZSB2aWV3cG9ydCB3aGlsZSBlbmZvcmNpbmcgdGhlIGNvbnN0cmFpbnRzXG4gICAgICogKG1pblpvb20sIG1heFpvb20gYW5kIHZpc2liaWxpdHlSYXRpbykuXG4gICAgICogTm90ZTogYmVjYXVzZSB0aGlzIG1ldGhvZCBlbmZvcmNlcyB0aGUgY29uc3RyYWludHMsIHBhcnQgb2YgdGhlXG4gICAgICogcHJvdmlkZWQgYm91bmRzIG1heSBlbmQgdXAgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQuXG4gICAgICogVXNlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I2ZpdEJvdW5kc30gdG8gaWdub3JlIHRoZW0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKi9cbiAgICBmaXRCb3VuZHNXaXRoQ29uc3RyYWludHM6IGZ1bmN0aW9uKGJvdW5kcywgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpdEJvdW5kcyhib3VuZHMsIHtcbiAgICAgICAgICAgIGltbWVkaWF0ZWx5OiBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tcyBzbyB0aGUgaW1hZ2UganVzdCBmaWxscyB0aGUgdmlld2VyIHZlcnRpY2FsbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKi9cbiAgICBmaXRWZXJ0aWNhbGx5OiBmdW5jdGlvbihpbW1lZGlhdGVseSkge1xuICAgICAgICB2YXIgYm94ID0gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRCb3VuZHMueCArICh0aGlzLl9jb250ZW50Qm91bmRzLndpZHRoIC8gMiksXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50Qm91bmRzLnksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5fY29udGVudEJvdW5kcy5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5maXRCb3VuZHMoYm94LCBpbW1lZGlhdGVseSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb21zIHNvIHRoZSBpbWFnZSBqdXN0IGZpbGxzIHRoZSB2aWV3ZXIgaG9yaXpvbnRhbGx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW1tZWRpYXRlbHlcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICovXG4gICAgZml0SG9yaXpvbnRhbGx5OiBmdW5jdGlvbihpbW1lZGlhdGVseSkge1xuICAgICAgICB2YXIgYm94ID0gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRCb3VuZHMueCxcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRCb3VuZHMueSArICh0aGlzLl9jb250ZW50Qm91bmRzLmhlaWdodCAvIDIpLFxuICAgICAgICAgICAgdGhpcy5fY29udGVudEJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIDApO1xuICAgICAgICByZXR1cm4gdGhpcy5maXRCb3VuZHMoYm94LCBpbW1lZGlhdGVseSk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBkZWx0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW1tZWRpYXRlbHlcbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50OnBhblxuICAgICAqL1xuICAgIHBhbkJ5OiBmdW5jdGlvbiggZGVsdGEsIGltbWVkaWF0ZWx5ICkge1xuICAgICAgICB2YXIgY2VudGVyID0gbmV3ICQuUG9pbnQoXG4gICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1gudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdZLnRhcmdldC52YWx1ZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5wYW5UbyggY2VudGVyLnBsdXMoIGRlbHRhICksIGltbWVkaWF0ZWx5ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gY2VudGVyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5WaWV3ZXIuZXZlbnQ6cGFuXG4gICAgICovXG4gICAgcGFuVG86IGZ1bmN0aW9uKCBjZW50ZXIsIGltbWVkaWF0ZWx5ICkge1xuICAgICAgICBpZiAoIGltbWVkaWF0ZWx5ICkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJTcHJpbmdYLnJlc2V0VG8oIGNlbnRlci54ICk7XG4gICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1kucmVzZXRUbyggY2VudGVyLnkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyU3ByaW5nWC5zcHJpbmdUbyggY2VudGVyLnggKTtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyU3ByaW5nWS5zcHJpbmdUbyggY2VudGVyLnkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0aGlzLnZpZXdlciApe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgdmlld3BvcnQgaXMgcGFubmVkIChzZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld3BvcnQjcGFuQnl9IGFuZCB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNwYW5Ub30pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBwYW5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhpcyBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gY2VudGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudmlld2VyLnJhaXNlRXZlbnQoICdwYW4nLCB7XG4gICAgICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlbHk6IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlZpZXdwb3J0fSBDaGFpbmFibGUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVmlld2VyLmV2ZW50Onpvb21cbiAgICAgKi9cbiAgICB6b29tQnk6IGZ1bmN0aW9uKGZhY3RvciwgcmVmUG9pbnQsIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21UbyhcbiAgICAgICAgICAgIHRoaXMuem9vbVNwcmluZy50YXJnZXQudmFsdWUgKiBmYWN0b3IsIHJlZlBvaW50LCBpbW1lZGlhdGVseSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb21zIHRvIHRoZSBzcGVjaWZpZWQgem9vbSBsZXZlbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6b29tIFRoZSB6b29tIGxldmVsIHRvIHpvb20gdG8uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBbcmVmUG9pbnRdIFRoZSBwb2ludCB3aGljaCB3aWxsIHN0YXkgYXRcbiAgICAgKiB0aGUgc2FtZSBzY3JlZW4gbG9jYXRpb24uIERlZmF1bHRzIHRvIHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDp6b29tXG4gICAgICovXG4gICAgem9vbVRvOiBmdW5jdGlvbiggem9vbSwgcmVmUG9pbnQsIGltbWVkaWF0ZWx5ICkge1xuXG4gICAgICAgIHRoaXMuem9vbVBvaW50ID0gcmVmUG9pbnQgaW5zdGFuY2VvZiAkLlBvaW50ICYmXG4gICAgICAgICAgICAhaXNOYU4ocmVmUG9pbnQueCkgJiZcbiAgICAgICAgICAgICFpc05hTihyZWZQb2ludC55KSA/XG4gICAgICAgICAgICByZWZQb2ludCA6XG4gICAgICAgICAgICBudWxsO1xuXG4gICAgICAgIGlmICggaW1tZWRpYXRlbHkgKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21TcHJpbmcucmVzZXRUbyggem9vbSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy56b29tU3ByaW5nLnNwcmluZ1RvKCB6b29tICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGhpcy52aWV3ZXIgKXtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIHZpZXdwb3J0IHpvb20gbGV2ZWwgY2hhbmdlcyAoc2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I3pvb21CeX0gYW5kIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdwb3J0I3pvb21Ub30pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCB6b29tXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gem9vbVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlBvaW50fSByZWZQb2ludFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlci5yYWlzZUV2ZW50KCAnem9vbScsIHtcbiAgICAgICAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgICAgICAgIHJlZlBvaW50OiByZWZQb2ludCxcbiAgICAgICAgICAgICAgICBpbW1lZGlhdGVseTogaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhpcyB2aWV3cG9ydCB0byB0aGUgYW5nbGUgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uVmlld3BvcnR9IENoYWluYWJsZS5cbiAgICAgKi9cbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24oZGVncmVlcykge1xuICAgICAgICBpZiAoIXRoaXMudmlld2VyIHx8ICF0aGlzLnZpZXdlci5kcmF3ZXIuY2FuUm90YXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVncmVlcyA9IGRlZ3JlZXMgJSAzNjA7XG4gICAgICAgIGlmIChkZWdyZWVzIDwgMCkge1xuICAgICAgICAgICAgZGVncmVlcyArPSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWdyZWVzID0gZGVncmVlcztcbiAgICAgICAgdGhpcy5fc2V0Q29udGVudEJvdW5kcyhcbiAgICAgICAgICAgIHRoaXMudmlld2VyLndvcmxkLmdldEhvbWVCb3VuZHMoKSxcbiAgICAgICAgICAgIHRoaXMudmlld2VyLndvcmxkLmdldENvbnRlbnRGYWN0b3IoKSk7XG4gICAgICAgIHRoaXMudmlld2VyLmZvcmNlUmVkcmF3KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIHJvdGF0aW9uIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCByb3RhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZGVncmVlcyAtIFRoZSBudW1iZXIgb2YgZGVncmVlcyB0aGUgcm90YXRpb24gd2FzIHNldCB0by5cbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ZXIucmFpc2VFdmVudCgncm90YXRlJywge1wiZGVncmVlc1wiOiBkZWdyZWVzfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHJvdGF0aW9uIGluIGRlZ3JlZXMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCByb3RhdGlvbiBpbiBkZWdyZWVzLlxuICAgICAqL1xuICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVncmVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5WaWV3cG9ydH0gQ2hhaW5hYmxlLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlZpZXdlci5ldmVudDpyZXNpemVcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKCBuZXdDb250YWluZXJTaXplLCBtYWludGFpbiApIHtcbiAgICAgICAgdmFyIG9sZEJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzTm9Sb3RhdGUoKSxcbiAgICAgICAgICAgIG5ld0JvdW5kcyA9IG9sZEJvdW5kcyxcbiAgICAgICAgICAgIHdpZHRoRGVsdGFGYWN0b3I7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJTaXplLnggPSBuZXdDb250YWluZXJTaXplLng7XG4gICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZS55ID0gbmV3Q29udGFpbmVyU2l6ZS55O1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lcklubmVyU2l6ZSgpO1xuXG4gICAgICAgIGlmICggbWFpbnRhaW4gKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aWR0aERlbHRhRmFjdG9yIHdpbGwgYWx3YXlzIGJlIDE7IHByb2JhYmx5IG5vdCB3aGF0J3MgaW50ZW5kZWRcbiAgICAgICAgICAgIHdpZHRoRGVsdGFGYWN0b3IgPSBuZXdDb250YWluZXJTaXplLnggLyB0aGlzLmNvbnRhaW5lclNpemUueDtcbiAgICAgICAgICAgIG5ld0JvdW5kcy53aWR0aCAgPSBvbGRCb3VuZHMud2lkdGggKiB3aWR0aERlbHRhRmFjdG9yO1xuICAgICAgICAgICAgbmV3Qm91bmRzLmhlaWdodCA9IG5ld0JvdW5kcy53aWR0aCAvIHRoaXMuZ2V0QXNwZWN0UmF0aW8oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0aGlzLnZpZXdlciApe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgdmlld2VyIGlzIHJlc2l6ZWQgKHNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3cG9ydCNyZXNpemV9KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgcmVzaXplXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVmlld2VyfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBWaWV3ZXIgd2hpY2ggcmFpc2VkIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uUG9pbnR9IG5ld0NvbnRhaW5lclNpemVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbWFpbnRhaW5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy52aWV3ZXIucmFpc2VFdmVudCggJ3Jlc2l6ZScsIHtcbiAgICAgICAgICAgICAgICBuZXdDb250YWluZXJTaXplOiBuZXdDb250YWluZXJTaXplLFxuICAgICAgICAgICAgICAgIG1haW50YWluOiBtYWludGFpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5maXRCb3VuZHMoIG5ld0JvdW5kcywgdHJ1ZSApO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3VwZGF0ZUNvbnRhaW5lcklubmVyU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZSA9IG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgTWF0aC5tYXgoMSwgdGhpcy5jb250YWluZXJTaXplLnggLSAodGhpcy5fbWFyZ2lucy5sZWZ0ICsgdGhpcy5fbWFyZ2lucy5yaWdodCkpLFxuICAgICAgICAgICAgTWF0aC5tYXgoMSwgdGhpcy5jb250YWluZXJTaXplLnkgLSAodGhpcy5fbWFyZ2lucy50b3AgKyB0aGlzLl9tYXJnaW5zLmJvdHRvbSkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgem9vbSBhbmQgY2VudGVyIChYIGFuZCBZKSBzcHJpbmdzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIGFueSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuem9vbVBvaW50KSB7XG4gICAgICAgICAgICB2YXIgb2xkWm9vbVBpeGVsID0gdGhpcy5waXhlbEZyb21Qb2ludCh0aGlzLnpvb21Qb2ludCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnpvb21TcHJpbmcudXBkYXRlKCk7XG4gICAgICAgICAgICB2YXIgbmV3Wm9vbVBpeGVsID0gdGhpcy5waXhlbEZyb21Qb2ludCh0aGlzLnpvb21Qb2ludCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBkZWx0YVpvb21QaXhlbHMgPSBuZXdab29tUGl4ZWwubWludXMob2xkWm9vbVBpeGVsKTtcbiAgICAgICAgICAgIHZhciBkZWx0YVpvb21Qb2ludHMgPSB0aGlzLmRlbHRhUG9pbnRzRnJvbVBpeGVscyhcbiAgICAgICAgICAgICAgICBkZWx0YVpvb21QaXhlbHMsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1guc2hpZnRCeShkZWx0YVpvb21Qb2ludHMueCk7XG4gICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1kuc2hpZnRCeShkZWx0YVpvb21Qb2ludHMueSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnpvb21TcHJpbmcuaXNBdFRhcmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21Qb2ludCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnpvb21TcHJpbmcudXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1gudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuY2VudGVyU3ByaW5nWS51cGRhdGUoKTtcblxuICAgICAgICB2YXIgY2hhbmdlZCA9IHRoaXMuY2VudGVyU3ByaW5nWC5jdXJyZW50LnZhbHVlICE9PSB0aGlzLl9vbGRDZW50ZXJYIHx8XG4gICAgICAgICAgICB0aGlzLmNlbnRlclNwcmluZ1kuY3VycmVudC52YWx1ZSAhPT0gdGhpcy5fb2xkQ2VudGVyWSB8fFxuICAgICAgICAgICAgdGhpcy56b29tU3ByaW5nLmN1cnJlbnQudmFsdWUgIT09IHRoaXMuX29sZFpvb207XG5cbiAgICAgICAgdGhpcy5fb2xkQ2VudGVyWCA9IHRoaXMuY2VudGVyU3ByaW5nWC5jdXJyZW50LnZhbHVlO1xuICAgICAgICB0aGlzLl9vbGRDZW50ZXJZID0gdGhpcy5jZW50ZXJTcHJpbmdZLmN1cnJlbnQudmFsdWU7XG4gICAgICAgIHRoaXMuX29sZFpvb20gICAgPSB0aGlzLnpvb21TcHJpbmcuY3VycmVudC52YWx1ZTtcblxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGRlbHRhICh0cmFuc2xhdGlvbiB2ZWN0b3IpIGZyb20gdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gcGl4ZWxzXG4gICAgICogY29vcmRpbmF0ZXMuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHRha2Ugcm90YXRpb24gaW50byBhY2NvdW50LlxuICAgICAqIENvbnNpZGVyIHVzaW5nIGRlbHRhUGl4ZWxzRnJvbVBvaW50cyBpZiB5b3UgbmVlZCB0byBhY2NvdW50IGZvciByb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGRlbHRhUG9pbnRzIC0gVGhlIHRyYW5zbGF0aW9uIHZlY3RvciB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnJlbnQ9ZmFsc2VdIC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjtcbiAgICAgKiBkZWZhdWx0cyB0byBmYWxzZSAodGFyZ2V0IGxvY2F0aW9uKS5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBkZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZTogZnVuY3Rpb24oZGVsdGFQb2ludHMsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhUG9pbnRzLnRpbWVzKFxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVySW5uZXJTaXplLnggKiB0aGlzLmdldFpvb20oY3VycmVudClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGRlbHRhICh0cmFuc2xhdGlvbiB2ZWN0b3IpIGZyb20gdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gcGl4ZWxzXG4gICAgICogY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBkZWx0YVBvaW50cyAtIFRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247XG4gICAgICogZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgZGVsdGFQaXhlbHNGcm9tUG9pbnRzOiBmdW5jdGlvbihkZWx0YVBvaW50cywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZShcbiAgICAgICAgICAgIGRlbHRhUG9pbnRzLnJvdGF0ZSh0aGlzLmdldFJvdGF0aW9uKCkpLFxuICAgICAgICAgICAgY3VycmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBkZWx0YSAodHJhbnNsYXRpb24gdmVjdG9yKSBmcm9tIHBpeGVscyBjb29yZGluYXRlcyB0byB2aWV3cG9ydFxuICAgICAqIGNvb3JkaW5hdGVzLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB0YWtlIHJvdGF0aW9uIGludG8gYWNjb3VudC5cbiAgICAgKiBDb25zaWRlciB1c2luZyBkZWx0YVBvaW50c0Zyb21QaXhlbHMgaWYgeW91IG5lZWQgdG8gYWNjb3VudCBmb3Igcm90YXRpb24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBkZWx0YVBpeGVscyAtIFRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247XG4gICAgICogZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgZGVsdGFQb2ludHNGcm9tUGl4ZWxzTm9Sb3RhdGU6IGZ1bmN0aW9uKGRlbHRhUGl4ZWxzLCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBkZWx0YVBpeGVscy5kaXZpZGUoXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJJbm5lclNpemUueCAqIHRoaXMuZ2V0Wm9vbShjdXJyZW50KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgZGVsdGEgKHRyYW5zbGF0aW9uIHZlY3RvcikgZnJvbSBwaXhlbHMgY29vcmRpbmF0ZXMgdG8gdmlld3BvcnRcbiAgICAgKiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IGRlbHRhUGl4ZWxzIC0gVGhlIHRyYW5zbGF0aW9uIHZlY3RvciB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnJlbnQ9ZmFsc2VdIC0gUGFzcyB0cnVlIGZvciB0aGUgY3VycmVudCBsb2NhdGlvbjtcbiAgICAgKiBkZWZhdWx0cyB0byBmYWxzZSAodGFyZ2V0IGxvY2F0aW9uKS5cbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICBkZWx0YVBvaW50c0Zyb21QaXhlbHM6IGZ1bmN0aW9uKGRlbHRhUGl4ZWxzLCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbHRhUG9pbnRzRnJvbVBpeGVsc05vUm90YXRlKGRlbHRhUGl4ZWxzLCBjdXJyZW50KVxuICAgICAgICAgICAgLnJvdGF0ZSgtdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB2aWV3cG9ydCBjb29yZGluYXRlcyB0byBwaXhlbHMgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgdGFrZSByb3RhdGlvbiBpbnRvIGFjY291bnQuXG4gICAgICogQ29uc2lkZXIgdXNpbmcgcGl4ZWxGcm9tUG9pbnQgaWYgeW91IG5lZWQgdG8gYWNjb3VudCBmb3Igcm90YXRpb24uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludCB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247XG4gICAgICogZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgcGl4ZWxGcm9tUG9pbnROb1JvdGF0ZTogZnVuY3Rpb24ocG9pbnQsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsRnJvbVBvaW50Tm9Sb3RhdGUoXG4gICAgICAgICAgICBwb2ludCwgdGhpcy5nZXRCb3VuZHNOb1JvdGF0ZShjdXJyZW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gcGl4ZWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwb2ludCB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247XG4gICAgICogZGVmYXVsdHMgdG8gZmFsc2UgKHRhcmdldCBsb2NhdGlvbikuXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgcGl4ZWxGcm9tUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbEZyb21Qb2ludChwb2ludCwgdGhpcy5nZXRCb3VuZHNOb1JvdGF0ZShjdXJyZW50KSk7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfcGl4ZWxGcm9tUG9pbnROb1JvdGF0ZTogZnVuY3Rpb24ocG9pbnQsIGJvdW5kcykge1xuICAgICAgICByZXR1cm4gcG9pbnQubWludXMoXG4gICAgICAgICAgICBib3VuZHMuZ2V0VG9wTGVmdCgpXG4gICAgICAgICkudGltZXMoXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJJbm5lclNpemUueCAvIGJvdW5kcy53aWR0aFxuICAgICAgICApLnBsdXMoXG4gICAgICAgICAgICBuZXcgJC5Qb2ludCh0aGlzLl9tYXJnaW5zLmxlZnQsIHRoaXMuX21hcmdpbnMudG9wKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3BpeGVsRnJvbVBvaW50OiBmdW5jdGlvbihwb2ludCwgYm91bmRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbEZyb21Qb2ludE5vUm90YXRlKFxuICAgICAgICAgICAgcG9pbnQucm90YXRlKHRoaXMuZ2V0Um90YXRpb24oKSwgdGhpcy5nZXRDZW50ZXIodHJ1ZSkpLFxuICAgICAgICAgICAgYm91bmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBwaXhlbCBjb29yZGluYXRlcyB0byB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB0YWtlIHJvdGF0aW9uIGludG8gYWNjb3VudC5cbiAgICAgKiBDb25zaWRlciB1c2luZyBwb2ludEZyb21QaXhlbCBpZiB5b3UgbmVlZCB0byBhY2NvdW50IGZvciByb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsIFBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uO1xuICAgICAqIGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHBvaW50RnJvbVBpeGVsTm9Sb3RhdGU6IGZ1bmN0aW9uKHBpeGVsLCBjdXJyZW50KSB7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kc05vUm90YXRlKGN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gcGl4ZWwubWludXMoXG4gICAgICAgICAgICBuZXcgJC5Qb2ludCh0aGlzLl9tYXJnaW5zLmxlZnQsIHRoaXMuX21hcmdpbnMudG9wKVxuICAgICAgICApLmRpdmlkZShcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZS54IC8gYm91bmRzLndpZHRoXG4gICAgICAgICkucGx1cyhcbiAgICAgICAgICAgIGJvdW5kcy5nZXRUb3BMZWZ0KClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBwaXhlbCBjb29yZGluYXRlcyB0byB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsIFBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudD1mYWxzZV0gLSBQYXNzIHRydWUgZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uO1xuICAgICAqIGRlZmF1bHRzIHRvIGZhbHNlICh0YXJnZXQgbG9jYXRpb24pLlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHBvaW50RnJvbVBpeGVsOiBmdW5jdGlvbihwaXhlbCwgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEZyb21QaXhlbE5vUm90YXRlKHBpeGVsLCBjdXJyZW50KS5yb3RhdGUoXG4gICAgICAgICAgICAtdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgICAgICAgdGhpcy5nZXRDZW50ZXIodHJ1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF92aWV3cG9ydFRvSW1hZ2VEZWx0YTogZnVuY3Rpb24oIHZpZXdlclgsIHZpZXdlclkgKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS53aWR0aDtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgdmlld2VyWCAqIHRoaXMuX2NvbnRlbnRTaXplTm9Sb3RhdGUueCAvIHNjYWxlLFxuICAgICAgICAgICAgdmlld2VyWSAqIHRoaXMuX2NvbnRlbnRTaXplTm9Sb3RhdGUueCAvIHNjYWxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBmcm9tIE9wZW5TZWFkcmFnb24gdmlld2VyIGNvb3JkaW5hdGUgc3lzdGVtIHRvIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGJ5IHBhc3NpbmcgWCxZIGNvb3JkaW5hdGVzIG9yIGFuXG4gICAgICogT3BlblNlYWRyYWdvbi5Qb2ludFxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlOyB1c2UgVGlsZWRJbWFnZS52aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlcyBpbnN0ZWFkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KE9wZW5TZWFkcmFnb24uUG9pbnR8TnVtYmVyKX0gdmlld2VyWCBlaXRoZXIgYSBwb2ludCBvciB0aGUgWFxuICAgICAqIGNvb3JkaW5hdGUgaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt2aWV3ZXJZXSBZIGNvb3JkaW5hdGUgaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5Qb2ludH0gYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvb3JkaW5hdGVzIGluIHRoZSBpbWFnZS5cbiAgICAgKi9cbiAgICB2aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlczogZnVuY3Rpb24odmlld2VyWCwgdmlld2VyWSkge1xuICAgICAgICBpZiAodmlld2VyWCBpbnN0YW5jZW9mICQuUG9pbnQpIHtcbiAgICAgICAgICAgIC8vdGhleSBwYXNzZWQgYSBwb2ludCBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgY29tcG9uZW50c1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXModmlld2VyWC54LCB2aWV3ZXJYLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmlld2VyKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAkLmNvbnNvbGUuZXJyb3IoJ1tWaWV3cG9ydC52aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlc10gaXMgbm90IGFjY3VyYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2l0aCBtdWx0aS1pbWFnZTsgdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXMgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBiZXR0ZXIgdG8gdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZSBjYW4gbm90IGJlIHJlbGllZCBvblxuICAgICAgICAgICAgICAgIC8vIHdpdGggY2xpcHBpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXModmlld2VyWCwgdmlld2VyWSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRUb0ltYWdlRGVsdGEoXG4gICAgICAgICAgICB2aWV3ZXJYIC0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLngsXG4gICAgICAgICAgICB2aWV3ZXJZIC0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLnkpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX2ltYWdlVG9WaWV3cG9ydERlbHRhOiBmdW5jdGlvbiggaW1hZ2VYLCBpbWFnZVkgKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZS53aWR0aDtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgaW1hZ2VYIC8gdGhpcy5fY29udGVudFNpemVOb1JvdGF0ZS54ICogc2NhbGUsXG4gICAgICAgICAgICBpbWFnZVkgLyB0aGlzLl9jb250ZW50U2l6ZU5vUm90YXRlLnggKiBzY2FsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZnJvbSBpbWFnZSBjb29yZGluYXRlIHN5c3RlbSB0byBPcGVuU2VhZHJhZ29uIHZpZXdlciBjb29yZGluYXRlIHN5c3RlbVxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGJ5IHBhc3NpbmcgWCxZIGNvb3JkaW5hdGVzIG9yIGFuXG4gICAgICogT3BlblNlYWRyYWdvbi5Qb2ludFxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlOyB1c2UgVGlsZWRJbWFnZS5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlcyBpbnN0ZWFkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KE9wZW5TZWFkcmFnb24uUG9pbnQgfCBOdW1iZXIpfSBpbWFnZVggdGhlIHBvaW50IG9yIHRoZVxuICAgICAqIFggY29vcmRpbmF0ZSBpbiBpbWFnZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2ltYWdlWV0gWSBjb29yZGluYXRlIGluIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEByZXR1cm4ge09wZW5TZWFkcmFnb24uUG9pbnR9IGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb29yZGluYXRlcyBpbiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgaW1hZ2VUb1ZpZXdwb3J0Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKGltYWdlWCwgaW1hZ2VZKSB7XG4gICAgICAgIGlmIChpbWFnZVggaW5zdGFuY2VvZiAkLlBvaW50KSB7XG4gICAgICAgICAgICAvL3RoZXkgcGFzc2VkIGEgcG9pbnQgaW5zdGVhZCBvZiBpbmRpdmlkdWFsIGNvbXBvbmVudHNcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlVG9WaWV3cG9ydENvb3JkaW5hdGVzKGltYWdlWC54LCBpbWFnZVgueSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy52aWV3ZXIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMudmlld2VyLndvcmxkLmdldEl0ZW1Db3VudCgpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICQuY29uc29sZS5lcnJvcignW1ZpZXdwb3J0LmltYWdlVG9WaWV3cG9ydENvb3JkaW5hdGVzXSBpcyBub3QgYWNjdXJhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRoIG11bHRpLWltYWdlOyB1c2UgVGlsZWRJbWFnZS5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlcyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGJldHRlciB0byB1c2UgVGlsZWRJbWFnZS52aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlIGNhbiBub3QgYmUgcmVsaWVkIG9uXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBjbGlwcGluZy5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMudmlld2VyLndvcmxkLmdldEl0ZW1BdCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlcyhpbWFnZVgsIGltYWdlWSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLl9pbWFnZVRvVmlld3BvcnREZWx0YShpbWFnZVgsIGltYWdlWSk7XG4gICAgICAgIHBvaW50LnggKz0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLng7XG4gICAgICAgIHBvaW50LnkgKz0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLnk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBmcm9tIGEgcmVjdGFuZ2xlIHdoaWNoIGRlc2NyaWJlcyBhIHBvcnRpb24gb2YgdGhlIGltYWdlIGluXG4gICAgICogcGl4ZWwgY29vcmRpbmF0ZXMgdG8gT3BlblNlYWRyYWdvbiB2aWV3cG9ydCByZWN0YW5nbGUgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBlaXRoZXIgYnkgcGFzc2luZyBYLFksd2lkdGgsaGVpZ2h0IG9yIGFuXG4gICAgICogT3BlblNlYWRyYWdvbi5SZWN0XG4gICAgICogTm90ZTogbm90IGFjY3VyYXRlIHdpdGggbXVsdGktaW1hZ2U7IHVzZSBUaWxlZEltYWdlLmltYWdlVG9WaWV3cG9ydFJlY3RhbmdsZSBpbnN0ZWFkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KE9wZW5TZWFkcmFnb24uUmVjdCB8IE51bWJlcil9IGltYWdlWCB0aGUgcmVjdGFuZ2xlIG9yIHRoZSBYXG4gICAgICogY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUgaW4gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbWFnZVldIHRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogaW4gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwaXhlbFdpZHRoXSB0aGUgd2lkdGggaW4gcGl4ZWwgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BpeGVsSGVpZ2h0XSB0aGUgaGVpZ2h0IGluIHBpeGVsIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICovXG4gICAgaW1hZ2VUb1ZpZXdwb3J0UmVjdGFuZ2xlOiBmdW5jdGlvbihpbWFnZVgsIGltYWdlWSwgcGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBpbWFnZVg7XG4gICAgICAgIGlmICghKHJlY3QgaW5zdGFuY2VvZiAkLlJlY3QpKSB7XG4gICAgICAgICAgICAvL3RoZXkgcGFzc2VkIGluZGl2aWR1YWwgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGEgcmVjdGFuZ2xlXG4gICAgICAgICAgICByZWN0ID0gbmV3ICQuUmVjdChpbWFnZVgsIGltYWdlWSwgcGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmlld2VyKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAkLmNvbnNvbGUuZXJyb3IoJ1tWaWV3cG9ydC5pbWFnZVRvVmlld3BvcnRSZWN0YW5nbGVdIGlzIG5vdCBhY2N1cmF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGggbXVsdGktaW1hZ2U7IHVzZSBUaWxlZEltYWdlLmltYWdlVG9WaWV3cG9ydFJlY3RhbmdsZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGJldHRlciB0byB1c2UgVGlsZWRJbWFnZS5pbWFnZVRvVmlld3BvcnRSZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZSBjYW4gbm90IGJlIHJlbGllZCBvblxuICAgICAgICAgICAgICAgIC8vIHdpdGggY2xpcHBpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW1hZ2VUb1ZpZXdwb3J0UmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVgsIGltYWdlWSwgcGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkQSA9IHRoaXMuaW1hZ2VUb1ZpZXdwb3J0Q29vcmRpbmF0ZXMocmVjdC54LCByZWN0LnkpO1xuICAgICAgICB2YXIgY29vcmRCID0gdGhpcy5faW1hZ2VUb1ZpZXdwb3J0RGVsdGEocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIGNvb3JkQS54LFxuICAgICAgICAgICAgY29vcmRBLnksXG4gICAgICAgICAgICBjb29yZEIueCxcbiAgICAgICAgICAgIGNvb3JkQi55LFxuICAgICAgICAgICAgcmVjdC5kZWdyZWVzXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZnJvbSBhIHJlY3RhbmdsZSB3aGljaCBkZXNjcmliZXMgYSBwb3J0aW9uIG9mXG4gICAgICogdGhlIHZpZXdwb3J0IGluIHBvaW50IGNvb3JkaW5hdGVzIHRvIGltYWdlIHJlY3RhbmdsZSBjb29yZGluYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGVpdGhlciBieSBwYXNzaW5nIFgsWSx3aWR0aCxoZWlnaHQgb3IgYW5cbiAgICAgKiBPcGVuU2VhZHJhZ29uLlJlY3RcbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZTsgdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlIGluc3RlYWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoT3BlblNlYWRyYWdvbi5SZWN0IHwgTnVtYmVyKX0gdmlld2VyWCBlaXRoZXIgYSByZWN0YW5nbGUgb3JcbiAgICAgKiB0aGUgWCBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZSBpbiB2aWV3cG9ydFxuICAgICAqIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdmlld2VyWV0gdGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BvaW50V2lkdGhdIHRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9pbnRIZWlnaHRdIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKi9cbiAgICB2aWV3cG9ydFRvSW1hZ2VSZWN0YW5nbGU6IGZ1bmN0aW9uKHZpZXdlclgsIHZpZXdlclksIHBvaW50V2lkdGgsIHBvaW50SGVpZ2h0KSB7XG4gICAgICAgIHZhciByZWN0ID0gdmlld2VyWDtcbiAgICAgICAgaWYgKCEocmVjdCBpbnN0YW5jZW9mICQuUmVjdCkpIHtcbiAgICAgICAgICAgIC8vdGhleSBwYXNzZWQgaW5kaXZpZHVhbCBjb21wb25lbnRzIGluc3RlYWQgb2YgYSByZWN0YW5nbGVcbiAgICAgICAgICAgIHJlY3QgPSBuZXcgJC5SZWN0KHZpZXdlclgsIHZpZXdlclksIHBvaW50V2lkdGgsIHBvaW50SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZpZXdlcikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUNvdW50KCk7XG4gICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgJC5jb25zb2xlLmVycm9yKCdbVmlld3BvcnQudmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlXSBpcyBub3QgYWNjdXJhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRoIG11bHRpLWltYWdlOyB1c2UgVGlsZWRJbWFnZS52aWV3cG9ydFRvSW1hZ2VSZWN0YW5nbGUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBiZXR0ZXIgdG8gdXNlIFRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZSBjYW4gbm90IGJlIHJlbGllZCBvblxuICAgICAgICAgICAgICAgIC8vIHdpdGggY2xpcHBpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICB2aWV3ZXJYLCB2aWV3ZXJZLCBwb2ludFdpZHRoLCBwb2ludEhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRBID0gdGhpcy52aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlcyhyZWN0LngsIHJlY3QueSk7XG4gICAgICAgIHZhciBjb29yZEIgPSB0aGlzLl92aWV3cG9ydFRvSW1hZ2VEZWx0YShyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIHJldHVybiBuZXcgJC5SZWN0KFxuICAgICAgICAgICAgY29vcmRBLngsXG4gICAgICAgICAgICBjb29yZEEueSxcbiAgICAgICAgICAgIGNvb3JkQi54LFxuICAgICAgICAgICAgY29vcmRCLnksXG4gICAgICAgICAgICByZWN0LmRlZ3JlZXNcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgdmlld2VyIGVsZW1lbnQgdG8gaW1hZ2VcbiAgICAgKiBjb29yZGluYXRlcy5cbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgdmlld2VyRWxlbWVudFRvSW1hZ2VDb29yZGluYXRlczogZnVuY3Rpb24oIHBpeGVsICkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50RnJvbVBpeGVsKCBwaXhlbCwgdHJ1ZSApO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRvSW1hZ2VDb29yZGluYXRlcyggcG9pbnQgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgaW1hZ2UgdG9cbiAgICAgKiB2aWV3ZXIgZWxlbWVudCBjb29yZGluYXRlcy5cbiAgICAgKiBOb3RlOiBub3QgYWNjdXJhdGUgd2l0aCBtdWx0aS1pbWFnZS5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgaW1hZ2VUb1ZpZXdlckVsZW1lbnRDb29yZGluYXRlczogZnVuY3Rpb24oIHBpeGVsICkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmltYWdlVG9WaWV3cG9ydENvb3JkaW5hdGVzKCBwaXhlbCApO1xuICAgICAgICByZXR1cm4gdGhpcy5waXhlbEZyb21Qb2ludCggcG9pbnQsIHRydWUgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgd2luZG93IHRvIGltYWdlIGNvb3JkaW5hdGVzLlxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcGl4ZWxcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICB3aW5kb3dUb0ltYWdlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQodGhpcy52aWV3ZXIsXG4gICAgICAgICAgICBcIltWaWV3cG9ydC53aW5kb3dUb0ltYWdlQ29vcmRpbmF0ZXNdIHRoZSB2aWV3cG9ydCBtdXN0IGhhdmUgYSB2aWV3ZXIuXCIpO1xuICAgICAgICB2YXIgdmlld2VyQ29vcmRpbmF0ZXMgPSBwaXhlbC5taW51cyhcbiAgICAgICAgICAgICAgICAkLmdldEVsZW1lbnRQb3NpdGlvbih0aGlzLnZpZXdlci5lbGVtZW50KSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdlckVsZW1lbnRUb0ltYWdlQ29vcmRpbmF0ZXModmlld2VyQ29vcmRpbmF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGltYWdlIGNvb3JkaW5hdGVzIHRvIHBpeGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG4gICAgICogTm90ZTogbm90IGFjY3VyYXRlIHdpdGggbXVsdGktaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIGltYWdlVG9XaW5kb3dDb29yZGluYXRlczogZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCh0aGlzLnZpZXdlcixcbiAgICAgICAgICAgIFwiW1ZpZXdwb3J0LmltYWdlVG9XaW5kb3dDb29yZGluYXRlc10gdGhlIHZpZXdwb3J0IG11c3QgaGF2ZSBhIHZpZXdlci5cIik7XG4gICAgICAgIHZhciB2aWV3ZXJDb29yZGluYXRlcyA9IHRoaXMuaW1hZ2VUb1ZpZXdlckVsZW1lbnRDb29yZGluYXRlcyhwaXhlbCk7XG4gICAgICAgIHJldHVybiB2aWV3ZXJDb29yZGluYXRlcy5wbHVzKFxuICAgICAgICAgICAgICAgICQuZ2V0RWxlbWVudFBvc2l0aW9uKHRoaXMudmlld2VyLmVsZW1lbnQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgdmlld2VyIGVsZW1lbnQgdG8gdmlld3BvcnRcbiAgICAgKiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgdmlld2VyRWxlbWVudFRvVmlld3BvcnRDb29yZGluYXRlczogZnVuY3Rpb24oIHBpeGVsICkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEZyb21QaXhlbCggcGl4ZWwsIHRydWUgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB2aWV3cG9ydCBjb29yZGluYXRlcyB0byBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGVcbiAgICAgKiB2aWV3ZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgdmlld3BvcnRUb1ZpZXdlckVsZW1lbnRDb29yZGluYXRlczogZnVuY3Rpb24oIHBvaW50ICkge1xuICAgICAgICByZXR1cm4gdGhpcy5waXhlbEZyb21Qb2ludCggcG9pbnQsIHRydWUgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHJlY3RhbmdsZSBpbiBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgdmlld2VyIGVsZW1lbnRcbiAgICAgKiB0byB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gcmVjdGFuZ2xlIHRoZSByZWN0YW5nbGUgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IHRoZSBjb252ZXJ0ZWQgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgdmlld2VyRWxlbWVudFRvVmlld3BvcnRSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICAgICAgICByZXR1cm4gJC5SZWN0LmZyb21TdW1taXRzKFxuICAgICAgICAgICAgdGhpcy5wb2ludEZyb21QaXhlbChyZWN0YW5nbGUuZ2V0VG9wTGVmdCgpLCB0cnVlKSxcbiAgICAgICAgICAgIHRoaXMucG9pbnRGcm9tUGl4ZWwocmVjdGFuZ2xlLmdldFRvcFJpZ2h0KCksIHRydWUpLFxuICAgICAgICAgICAgdGhpcy5wb2ludEZyb21QaXhlbChyZWN0YW5nbGUuZ2V0Qm90dG9tTGVmdCgpLCB0cnVlKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgcmVjdGFuZ2xlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIHBpeGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlXG4gICAgICogdG8gdGhlIHZpZXdlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSByZWN0YW5nbGUgdGhlIHJlY3RhbmdsZSB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUmVjdH0gdGhlIGNvbnZlcnRlZCByZWN0YW5nbGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydFRvVmlld2VyRWxlbWVudFJlY3RhbmdsZTogZnVuY3Rpb24ocmVjdGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiAkLlJlY3QuZnJvbVN1bW1pdHMoXG4gICAgICAgICAgICB0aGlzLnBpeGVsRnJvbVBvaW50KHJlY3RhbmdsZS5nZXRUb3BMZWZ0KCksIHRydWUpLFxuICAgICAgICAgICAgdGhpcy5waXhlbEZyb21Qb2ludChyZWN0YW5nbGUuZ2V0VG9wUmlnaHQoKSwgdHJ1ZSksXG4gICAgICAgICAgICB0aGlzLnBpeGVsRnJvbVBvaW50KHJlY3RhbmdsZS5nZXRCb3R0b21MZWZ0KCksIHRydWUpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdyB0byB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgd2luZG93VG9WaWV3cG9ydENvb3JkaW5hdGVzOiBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KHRoaXMudmlld2VyLFxuICAgICAgICAgICAgXCJbVmlld3BvcnQud2luZG93VG9WaWV3cG9ydENvb3JkaW5hdGVzXSB0aGUgdmlld3BvcnQgbXVzdCBoYXZlIGEgdmlld2VyLlwiKTtcbiAgICAgICAgdmFyIHZpZXdlckNvb3JkaW5hdGVzID0gcGl4ZWwubWludXMoXG4gICAgICAgICAgICAgICAgJC5nZXRFbGVtZW50UG9zaXRpb24odGhpcy52aWV3ZXIuZWxlbWVudCkpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3ZXJFbGVtZW50VG9WaWV3cG9ydENvb3JkaW5hdGVzKHZpZXdlckNvb3JkaW5hdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB2aWV3cG9ydCBjb29yZGluYXRlcyB0byBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH1cbiAgICAgKi9cbiAgICB2aWV3cG9ydFRvV2luZG93Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQodGhpcy52aWV3ZXIsXG4gICAgICAgICAgICBcIltWaWV3cG9ydC52aWV3cG9ydFRvV2luZG93Q29vcmRpbmF0ZXNdIHRoZSB2aWV3cG9ydCBtdXN0IGhhdmUgYSB2aWV3ZXIuXCIpO1xuICAgICAgICB2YXIgdmlld2VyQ29vcmRpbmF0ZXMgPSB0aGlzLnZpZXdwb3J0VG9WaWV3ZXJFbGVtZW50Q29vcmRpbmF0ZXMocG9pbnQpO1xuICAgICAgICByZXR1cm4gdmlld2VyQ29vcmRpbmF0ZXMucGx1cyhcbiAgICAgICAgICAgICAgICAkLmdldEVsZW1lbnRQb3NpdGlvbih0aGlzLnZpZXdlci5lbGVtZW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB2aWV3cG9ydCB6b29tIHRvIGFuIGltYWdlIHpvb20uXG4gICAgICogSW1hZ2Ugem9vbTogcmF0aW8gb2YgdGhlIG9yaWdpbmFsIGltYWdlIHNpemUgdG8gZGlzcGxheWVkIGltYWdlIHNpemUuXG4gICAgICogMSBtZWFucyBvcmlnaW5hbCBpbWFnZSBzaXplLCAwLjUgaGFsZiBzaXplLi4uXG4gICAgICogVmlld3BvcnQgem9vbTogcmF0aW8gb2YgdGhlIGRpc3BsYXllZCBpbWFnZSdzIHdpZHRoIHRvIHZpZXdwb3J0J3Mgd2lkdGguXG4gICAgICogMSBtZWFucyBpZGVudGljYWwgd2lkdGgsIDIgbWVhbnMgaW1hZ2UncyB3aWR0aCBpcyB0d2ljZSB0aGUgdmlld3BvcnQncyB3aWR0aC4uLlxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2aWV3cG9ydFpvb20gVGhlIHZpZXdwb3J0IHpvb21cbiAgICAgKiB0YXJnZXQgem9vbS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbWFnZVpvb20gVGhlIGltYWdlIHpvb21cbiAgICAgKi9cbiAgICB2aWV3cG9ydFRvSW1hZ2Vab29tOiBmdW5jdGlvbih2aWV3cG9ydFpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMudmlld2VyKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQ291bnQoKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAkLmNvbnNvbGUuZXJyb3IoJ1tWaWV3cG9ydC52aWV3cG9ydFRvSW1hZ2Vab29tXSBpcyBub3QgJyArXG4gICAgICAgICAgICAgICAgICAgICdhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGJldHRlciB0byB1c2UgVGlsZWRJbWFnZS52aWV3cG9ydFRvSW1hZ2Vab29tXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUgY2FuIG5vdCBiZSByZWxpZWQgb25cbiAgICAgICAgICAgICAgICAvLyB3aXRoIGNsaXBwaW5nLlxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy52aWV3ZXIud29ybGQuZ2V0SXRlbUF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZpZXdwb3J0VG9JbWFnZVpvb20odmlld3BvcnRab29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWFnZVdpZHRoID0gdGhpcy5fY29udGVudFNpemVOb1JvdGF0ZS54O1xuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJJbm5lclNpemUueDtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5fY29udGVudEJvdW5kc05vUm90YXRlLndpZHRoO1xuICAgICAgICB2YXIgdmlld3BvcnRUb0ltYWdlWm9vbVJhdGlvID0gKGNvbnRhaW5lcldpZHRoIC8gaW1hZ2VXaWR0aCkgKiBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0Wm9vbSAqIHZpZXdwb3J0VG9JbWFnZVpvb21SYXRpbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiBpbWFnZSB6b29tIHRvIGEgdmlld3BvcnQgem9vbS5cbiAgICAgKiBJbWFnZSB6b29tOiByYXRpbyBvZiB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZSB0byBkaXNwbGF5ZWQgaW1hZ2Ugc2l6ZS5cbiAgICAgKiAxIG1lYW5zIG9yaWdpbmFsIGltYWdlIHNpemUsIDAuNSBoYWxmIHNpemUuLi5cbiAgICAgKiBWaWV3cG9ydCB6b29tOiByYXRpbyBvZiB0aGUgZGlzcGxheWVkIGltYWdlJ3Mgd2lkdGggdG8gdmlld3BvcnQncyB3aWR0aC5cbiAgICAgKiAxIG1lYW5zIGlkZW50aWNhbCB3aWR0aCwgMiBtZWFucyBpbWFnZSdzIHdpZHRoIGlzIHR3aWNlIHRoZSB2aWV3cG9ydCdzIHdpZHRoLi4uXG4gICAgICogTm90ZTogbm90IGFjY3VyYXRlIHdpdGggbXVsdGktaW1hZ2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGltYWdlWm9vbSBUaGUgaW1hZ2Ugem9vbVxuICAgICAqIHRhcmdldCB6b29tLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZpZXdwb3J0Wm9vbSBUaGUgdmlld3BvcnQgem9vbVxuICAgICAqL1xuICAgIGltYWdlVG9WaWV3cG9ydFpvb206IGZ1bmN0aW9uKGltYWdlWm9vbSkge1xuICAgICAgICBpZiAodGhpcy52aWV3ZXIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMudmlld2VyLndvcmxkLmdldEl0ZW1Db3VudCgpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICQuY29uc29sZS5lcnJvcignW1ZpZXdwb3J0LmltYWdlVG9WaWV3cG9ydFpvb21dIGlzIG5vdCBhY2N1cmF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGggbXVsdGktaW1hZ2UuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYmV0dGVyIHRvIHVzZSBUaWxlZEltYWdlLmltYWdlVG9WaWV3cG9ydFpvb21cbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMuX2NvbnRlbnRCb3VuZHNOb1JvdGF0ZSBjYW4gbm90IGJlIHJlbGllZCBvblxuICAgICAgICAgICAgICAgIC8vIHdpdGggY2xpcHBpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW1hZ2VUb1ZpZXdwb3J0Wm9vbShpbWFnZVpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlV2lkdGggPSB0aGlzLl9jb250ZW50U2l6ZU5vUm90YXRlLng7XG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcklubmVyU2l6ZS54O1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl9jb250ZW50Qm91bmRzTm9Sb3RhdGUud2lkdGg7XG4gICAgICAgIHZhciB2aWV3cG9ydFRvSW1hZ2Vab29tUmF0aW8gPSAoaW1hZ2VXaWR0aCAvIGNvbnRhaW5lcldpZHRoKSAvIHNjYWxlO1xuICAgICAgICByZXR1cm4gaW1hZ2Vab29tICogdmlld3BvcnRUb0ltYWdlWm9vbVJhdGlvO1xuICAgIH1cbn07XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8qXG4gKiBPcGVuU2VhZHJhZ29uIC0gVGlsZWRJbWFnZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLyoqXG4gKiBZb3Ugc2hvdWxkbid0IGhhdmUgdG8gY3JlYXRlIGEgVGlsZWRJbWFnZSBkaXJlY3RseTsgdXNlIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlciNvcGVufVxuICogb3Ige0BsaW5rIE9wZW5TZWFkcmFnb24uVmlld2VyI2FkZFRpbGVkSW1hZ2V9IGluc3RlYWQuXG4gKiBAY2xhc3MgVGlsZWRJbWFnZVxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uRXZlbnRTb3VyY2VcbiAqIEBjbGFzc2Rlc2MgSGFuZGxlcyByZW5kZXJpbmcgb2YgdGlsZXMgZm9yIGFuIHtAbGluayBPcGVuU2VhZHJhZ29uLlZpZXdlcn0uXG4gKiBBIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGZvciBlYWNoIFRpbGVTb3VyY2Ugb3BlbmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIGZvciB0aGlzIFRpbGVkSW1hZ2UuXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVGlsZVNvdXJjZX0gb3B0aW9ucy5zb3VyY2UgLSBUaGUgVGlsZVNvdXJjZSB0aGF0IGRlZmluZXMgdGhpcyBUaWxlZEltYWdlLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gb3B0aW9ucy52aWV3ZXIgLSBUaGUgVmlld2VyIHRoYXQgb3ducyB0aGlzIFRpbGVkSW1hZ2UuXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVGlsZUNhY2hlfSBvcHRpb25zLnRpbGVDYWNoZSAtIFRoZSBUaWxlQ2FjaGUgZm9yIHRoaXMgVGlsZWRJbWFnZSB0byB1c2UuXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uRHJhd2VyfSBvcHRpb25zLmRyYXdlciAtIFRoZSBEcmF3ZXIgZm9yIHRoaXMgVGlsZWRJbWFnZSB0byBkcmF3IG9udG8uXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uSW1hZ2VMb2FkZXJ9IG9wdGlvbnMuaW1hZ2VMb2FkZXIgLSBUaGUgSW1hZ2VMb2FkZXIgZm9yIHRoaXMgVGlsZWRJbWFnZSB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueD0wXSAtIExlZnQgcG9zaXRpb24sIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnk9MF0gLSBUb3AgcG9zaXRpb24sIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTFdIC0gV2lkdGgsIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gLSBIZWlnaHQsIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFtvcHRpb25zLmZpdEJvdW5kc10gVGhlIGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlc1xuICogdG8gZml0IHRoZSBpbWFnZSBpbnRvLiBJZiBzcGVjaWZpZWQsIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQgZ2V0IGlnbm9yZWQuXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUGxhY2VtZW50fSBbb3B0aW9ucy5maXRCb3VuZHNQbGFjZW1lbnQ9T3BlblNlYWRyYWdvbi5QbGFjZW1lbnQuQ0VOVEVSXVxuICogSG93IHRvIGFuY2hvciB0aGUgaW1hZ2UgaW4gdGhlIGJvdW5kcyBpZiBvcHRpb25zLmZpdEJvdW5kcyBpcyBzZXQuXG4gKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUmVjdH0gW29wdGlvbnMuY2xpcF0gLSBBbiBhcmVhLCBpbiBpbWFnZSBwaXhlbHMsIHRvIGNsaXAgdG9cbiAqIChwb3J0aW9ucyBvZiB0aGUgaW1hZ2Ugb3V0c2lkZSBvZiB0aGlzIGFyZWEgd2lsbCBub3QgYmUgdmlzaWJsZSkuIE9ubHkgd29ya3Mgb25cbiAqIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0aGUgSFRNTDUgY2FudmFzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNwcmluZ1N0aWZmbmVzc10gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFuaW1hdGlvblRpbWVdIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblpvb21JbWFnZVJhdGlvXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud3JhcEhvcml6b250YWxdIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53cmFwVmVydGljYWxdIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbW1lZGlhdGVSZW5kZXJdIC0gU2VlIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJsZW5kVGltZV0gLSBTZWUge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsd2F5c0JsZW5kXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5QaXhlbFJhdGlvXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zbW9vdGhUaWxlRWRnZXNNaW5ab29tXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaU9TRGV2aWNlXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vcGFjaXR5PTFdIC0gT3BhY2l0eSB0aGUgdGlsZWQgaW1hZ2Ugc2hvdWxkIGJlIGRyYXduIGF0LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbXBvc2l0ZU9wZXJhdGlvbl0gLSBIb3cgdGhlIGltYWdlIGlzIGNvbXBvc2l0ZWQgb250byBvdGhlciBpbWFnZXM7IHNlZSBjb21wb3NpdGVPcGVyYXRpb24gaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30gZm9yIHBvc3NpYmxlIHZhbHVlcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGVidWdNb2RlXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7U3RyaW5nfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm58RnVuY3Rpb259IFtvcHRpb25zLnBsYWNlaG9sZGVyRmlsbFN0eWxlXSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtvcHRpb25zLmNyb3NzT3JpZ2luUG9saWN5XSAtIFNlZSB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAqL1xuJC5UaWxlZEltYWdlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMudGlsZUNhY2hlLCBcIltUaWxlZEltYWdlXSBvcHRpb25zLnRpbGVDYWNoZSBpcyByZXF1aXJlZFwiICk7XG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy5kcmF3ZXIsIFwiW1RpbGVkSW1hZ2VdIG9wdGlvbnMuZHJhd2VyIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLnZpZXdlciwgXCJbVGlsZWRJbWFnZV0gb3B0aW9ucy52aWV3ZXIgaXMgcmVxdWlyZWRcIiApO1xuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMuaW1hZ2VMb2FkZXIsIFwiW1RpbGVkSW1hZ2VdIG9wdGlvbnMuaW1hZ2VMb2FkZXIgaXMgcmVxdWlyZWRcIiApO1xuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMuc291cmNlLCBcIltUaWxlZEltYWdlXSBvcHRpb25zLnNvdXJjZSBpcyByZXF1aXJlZFwiICk7XG4gICAgJC5jb25zb2xlLmFzc2VydCghb3B0aW9ucy5jbGlwIHx8IG9wdGlvbnMuY2xpcCBpbnN0YW5jZW9mICQuUmVjdCxcbiAgICAgICAgXCJbVGlsZWRJbWFnZV0gb3B0aW9ucy5jbGlwIG11c3QgYmUgYW4gT3BlblNlYWRyYWdvbi5SZWN0IGlmIHByZXNlbnRcIik7XG5cbiAgICAkLkV2ZW50U291cmNlLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMuX3RpbGVDYWNoZSA9IG9wdGlvbnMudGlsZUNhY2hlO1xuICAgIGRlbGV0ZSBvcHRpb25zLnRpbGVDYWNoZTtcblxuICAgIHRoaXMuX2RyYXdlciA9IG9wdGlvbnMuZHJhd2VyO1xuICAgIGRlbGV0ZSBvcHRpb25zLmRyYXdlcjtcblxuICAgIHRoaXMuX2ltYWdlTG9hZGVyID0gb3B0aW9ucy5pbWFnZUxvYWRlcjtcbiAgICBkZWxldGUgb3B0aW9ucy5pbWFnZUxvYWRlcjtcblxuICAgIGlmIChvcHRpb25zLmNsaXAgaW5zdGFuY2VvZiAkLlJlY3QpIHtcbiAgICAgICAgdGhpcy5fY2xpcCA9IG9wdGlvbnMuY2xpcC5jbG9uZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHRpb25zLmNsaXA7XG5cbiAgICB2YXIgeCA9IG9wdGlvbnMueCB8fCAwO1xuICAgIGRlbGV0ZSBvcHRpb25zLng7XG4gICAgdmFyIHkgPSBvcHRpb25zLnkgfHwgMDtcbiAgICBkZWxldGUgb3B0aW9ucy55O1xuXG4gICAgLy8gUmF0aW8gb2Ygem9vbWFibGUgaW1hZ2UgaGVpZ2h0IHRvIHdpZHRoLlxuICAgIHRoaXMubm9ybUhlaWdodCA9IG9wdGlvbnMuc291cmNlLmRpbWVuc2lvbnMueSAvIG9wdGlvbnMuc291cmNlLmRpbWVuc2lvbnMueDtcbiAgICB0aGlzLmNvbnRlbnRBc3BlY3RYID0gb3B0aW9ucy5zb3VyY2UuZGltZW5zaW9ucy54IC8gb3B0aW9ucy5zb3VyY2UuZGltZW5zaW9ucy55O1xuXG4gICAgdmFyIHNjYWxlID0gMTtcbiAgICBpZiAoIG9wdGlvbnMud2lkdGggKSB7XG4gICAgICAgIHNjYWxlID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMud2lkdGg7XG5cbiAgICAgICAgaWYgKCBvcHRpb25zLmhlaWdodCApIHtcbiAgICAgICAgICAgICQuY29uc29sZS5lcnJvciggXCJzcGVjaWZ5aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodCB0byBhIHRpbGVkSW1hZ2UgaXMgbm90IHN1cHBvcnRlZFwiICk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCBvcHRpb25zLmhlaWdodCApIHtcbiAgICAgICAgc2NhbGUgPSBvcHRpb25zLmhlaWdodCAvIHRoaXMubm9ybUhlaWdodDtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciBmaXRCb3VuZHMgPSBvcHRpb25zLmZpdEJvdW5kcztcbiAgICBkZWxldGUgb3B0aW9ucy5maXRCb3VuZHM7XG4gICAgdmFyIGZpdEJvdW5kc1BsYWNlbWVudCA9IG9wdGlvbnMuZml0Qm91bmRzUGxhY2VtZW50IHx8IE9wZW5TZWFkcmFnb24uUGxhY2VtZW50LkNFTlRFUjtcbiAgICBkZWxldGUgb3B0aW9ucy5maXRCb3VuZHNQbGFjZW1lbnQ7XG5cbiAgICAkLmV4dGVuZCggdHJ1ZSwgdGhpcywge1xuXG4gICAgICAgIC8vaW50ZXJuYWwgc3RhdGUgcHJvcGVydGllc1xuICAgICAgICB2aWV3ZXI6ICAgICAgICAgbnVsbCxcbiAgICAgICAgdGlsZXNNYXRyaXg6ICAgIHt9LCAgICAvLyBBICczZCcgZGljdGlvbmFyeSBbbGV2ZWxdW3hdW3ldIC0tPiBUaWxlLlxuICAgICAgICBjb3ZlcmFnZTogICAgICAge30sICAgIC8vIEEgJzNkJyBkaWN0aW9uYXJ5IFtsZXZlbF1beF1beV0gLS0+IEJvb2xlYW4uXG4gICAgICAgIGxhc3REcmF3bjogICAgICBbXSwgICAgLy8gQW4gdW5vcmRlcmVkIGxpc3Qgb2YgVGlsZXMgZHJhd24gbGFzdCBmcmFtZS5cbiAgICAgICAgbGFzdFJlc2V0VGltZTogIDAsICAgICAvLyBMYXN0IHRpbWUgZm9yIHdoaWNoIHRoZSB0aWxlZEltYWdlIHdhcyByZXNldC5cbiAgICAgICAgX21pZERyYXc6ICAgICAgIGZhbHNlLCAvLyBJcyB0aGUgdGlsZWRJbWFnZSBjdXJyZW50bHkgdXBkYXRpbmcgdGhlIHZpZXdwb3J0P1xuICAgICAgICBfbmVlZHNEcmF3OiAgICAgdHJ1ZSwgIC8vIERvZXMgdGhlIHRpbGVkSW1hZ2UgbmVlZCB0byB1cGRhdGUgdGhlIHZpZXdwb3J0IGFnYWluP1xuICAgICAgICBfaGFzT3BhcXVlVGlsZTogZmFsc2UsICAvLyBEbyB3ZSBoYXZlIGV2ZW4gb25lIGZ1bGx5IG9wYXF1ZSB0aWxlP1xuICAgICAgICAvL2NvbmZpZ3VyYWJsZSBzZXR0aW5nc1xuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6ICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1Muc3ByaW5nU3RpZmZuZXNzLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAgICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuYW5pbWF0aW9uVGltZSxcbiAgICAgICAgbWluWm9vbUltYWdlUmF0aW86ICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLm1pblpvb21JbWFnZVJhdGlvLFxuICAgICAgICB3cmFwSG9yaXpvbnRhbDogICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1Mud3JhcEhvcml6b250YWwsXG4gICAgICAgIHdyYXBWZXJ0aWNhbDogICAgICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy53cmFwVmVydGljYWwsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgIGJsZW5kVGltZTogICAgICAgICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5ibGVuZFRpbWUsXG4gICAgICAgIGFsd2F5c0JsZW5kOiAgICAgICAgICAgICQuREVGQVVMVF9TRVRUSU5HUy5hbHdheXNCbGVuZCxcbiAgICAgICAgbWluUGl4ZWxSYXRpbzogICAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLm1pblBpeGVsUmF0aW8sXG4gICAgICAgIHNtb290aFRpbGVFZGdlc01pblpvb206ICQuREVGQVVMVF9TRVRUSU5HUy5zbW9vdGhUaWxlRWRnZXNNaW5ab29tLFxuICAgICAgICBpT1NEZXZpY2U6ICAgICAgICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuaU9TRGV2aWNlLFxuICAgICAgICBkZWJ1Z01vZGU6ICAgICAgICAgICAgICAkLkRFRkFVTFRfU0VUVElOR1MuZGVidWdNb2RlLFxuICAgICAgICBjcm9zc09yaWdpblBvbGljeTogICAgICAkLkRFRkFVTFRfU0VUVElOR1MuY3Jvc3NPcmlnaW5Qb2xpY3ksXG4gICAgICAgIHBsYWNlaG9sZGVyRmlsbFN0eWxlOiAgICQuREVGQVVMVF9TRVRUSU5HUy5wbGFjZWhvbGRlckZpbGxTdHlsZSxcbiAgICAgICAgb3BhY2l0eTogICAgICAgICAgICAgICAgJC5ERUZBVUxUX1NFVFRJTkdTLm9wYWNpdHksXG4gICAgICAgIGNvbXBvc2l0ZU9wZXJhdGlvbjogICAgICQuREVGQVVMVF9TRVRUSU5HUy5jb21wb3NpdGVPcGVyYXRpb25cblxuICAgIH0sIG9wdGlvbnMgKTtcblxuICAgIHRoaXMuX3hTcHJpbmcgPSBuZXcgJC5TcHJpbmcoe1xuICAgICAgICBpbml0aWFsOiB4LFxuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6IHRoaXMuc3ByaW5nU3RpZmZuZXNzLFxuICAgICAgICBhbmltYXRpb25UaW1lOiB0aGlzLmFuaW1hdGlvblRpbWVcbiAgICB9KTtcblxuICAgIHRoaXMuX3lTcHJpbmcgPSBuZXcgJC5TcHJpbmcoe1xuICAgICAgICBpbml0aWFsOiB5LFxuICAgICAgICBzcHJpbmdTdGlmZm5lc3M6IHRoaXMuc3ByaW5nU3RpZmZuZXNzLFxuICAgICAgICBhbmltYXRpb25UaW1lOiB0aGlzLmFuaW1hdGlvblRpbWVcbiAgICB9KTtcblxuICAgIHRoaXMuX3NjYWxlU3ByaW5nID0gbmV3ICQuU3ByaW5nKHtcbiAgICAgICAgaW5pdGlhbDogc2NhbGUsXG4gICAgICAgIHNwcmluZ1N0aWZmbmVzczogdGhpcy5zcHJpbmdTdGlmZm5lc3MsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IHRoaXMuYW5pbWF0aW9uVGltZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdXBkYXRlRm9yU2NhbGUoKTtcblxuICAgIGlmIChmaXRCb3VuZHMpIHtcbiAgICAgICAgdGhpcy5maXRCb3VuZHMoZml0Qm91bmRzLCBmaXRCb3VuZHNQbGFjZW1lbnQsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgYSBjYWxsYmFjayB0byBnaXZlIGltYWdlIG1hbmlwdWxhdGlvbiBhIGNoYW5jZSB0byBoYXBwZW5cbiAgICB0aGlzLl9kcmF3aW5nSGFuZGxlciA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBqdXN0IGJlZm9yZSB0aGUgdGlsZSBpcyBkcmF3biBnaXZpbmcgdGhlIGFwcGxpY2F0aW9uIGEgY2hhbmNlIHRvIGFsdGVyIHRoZSBpbWFnZS5cbiAgICAgICAqXG4gICAgICAgKiBOT1RFOiBUaGlzIGV2ZW50IGlzIG9ubHkgZmlyZWQgd2hlbiB0aGUgZHJhd2VyIGlzIHVzaW5nIGEgJmx0O2NhbnZhcyZndDsuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IHRpbGUtZHJhd2luZ1xuICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZX0gdGlsZSAtIFRoZSBUaWxlIGJlaW5nIGRyYXduLlxuICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IHRpbGVkSW1hZ2UgLSBXaGljaCBUaWxlZEltYWdlIGlzIGJlaW5nIGRyYXduLlxuICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGV9IGNvbnRleHQgLSBUaGUgSFRNTCBjYW52YXMgY29udGV4dCBiZWluZyBkcmF3biBpbnRvLlxuICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGV9IHJlbmRlcmVkIC0gVGhlIEhUTUwgY2FudmFzIGNvbnRleHQgY29udGFpbmluZyB0aGUgdGlsZSBpbWFnZXJ5LlxuICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICovXG4gICAgICAgIF90aGlzLnZpZXdlci5yYWlzZUV2ZW50KCd0aWxlLWRyYXdpbmcnLCAkLmV4dGVuZCh7XG4gICAgICAgICAgICB0aWxlZEltYWdlOiBfdGhpc1xuICAgICAgICB9LCBhcmdzKSk7XG4gICAgfTtcbn07XG5cbiQuZXh0ZW5kKCQuVGlsZWRJbWFnZS5wcm90b3R5cGUsICQuRXZlbnRTb3VyY2UucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uVGlsZWRJbWFnZS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIFRpbGVkSW1hZ2UgbmVlZHMgdG8gYmUgZHJhd24uXG4gICAgICovXG4gICAgbmVlZHNEcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZWRzRHJhdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCB0aWxlcyBhbmQgdHJpZ2dlcnMgYW4gdXBkYXRlIG9uIHRoZSBuZXh0IGNhbGwgdG9cbiAgICAgKiB7QGxpbmsgT3BlblNlYWRyYWdvbi5UaWxlZEltYWdlI3VwZGF0ZX0uXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aWxlQ2FjaGUuY2xlYXJUaWxlc0Zvcih0aGlzKTtcbiAgICAgICAgdGhpcy5sYXN0UmVzZXRUaW1lID0gJC5ub3coKTtcbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgVGlsZWRJbWFnZSdzIGJvdW5kcywgYW5pbWF0aW5nIGlmIG5lZWRlZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgVGlsZWRJbWFnZSBhbmltYXRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2xkWCA9IHRoaXMuX3hTcHJpbmcuY3VycmVudC52YWx1ZTtcbiAgICAgICAgdmFyIG9sZFkgPSB0aGlzLl95U3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgICAgIHZhciBvbGRTY2FsZSA9IHRoaXMuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWU7XG5cbiAgICAgICAgdGhpcy5feFNwcmluZy51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5feVNwcmluZy51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fc2NhbGVTcHJpbmcudXBkYXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3hTcHJpbmcuY3VycmVudC52YWx1ZSAhPT0gb2xkWCB8fCB0aGlzLl95U3ByaW5nLmN1cnJlbnQudmFsdWUgIT09IG9sZFkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlICE9PSBvbGRTY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9yU2NhbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIFRpbGVkSW1hZ2UgdG8gaXRzIERyYXdlci5cbiAgICAgKi9cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbWlkRHJhdyA9IHRydWU7XG4gICAgICAgICAgICB1cGRhdGVWaWV3cG9ydCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX21pZERyYXcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBUaWxlZEltYWdlICh1bmxvYWQgY3VycmVudCBsb2FkZWQgdGlsZXMpLlxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlJlY3R9IFRoaXMgVGlsZWRJbWFnZSdzIGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb247IGZhbHNlIGZvciB0YXJnZXQgbG9jYXRpb24uXG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbihjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3ICQuUmVjdCggdGhpcy5feFNwcmluZy5jdXJyZW50LnZhbHVlLCB0aGlzLl95U3ByaW5nLmN1cnJlbnQudmFsdWUsXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ybGRXaWR0aEN1cnJlbnQsIHRoaXMuX3dvcmxkSGVpZ2h0Q3VycmVudCApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkLlJlY3QoIHRoaXMuX3hTcHJpbmcudGFyZ2V0LnZhbHVlLCB0aGlzLl95U3ByaW5nLnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkV2lkdGhUYXJnZXQsIHRoaXMuX3dvcmxkSGVpZ2h0VGFyZ2V0ICk7XG4gICAgfSxcblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBnZXRXb3JsZEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuY29uc29sZS5lcnJvcignW1RpbGVkSW1hZ2UuZ2V0V29ybGRCb3VuZHNdIGlzIGRlcHJlY2F0ZWQ7IHVzZSBUaWxlZEltYWdlLmdldEJvdW5kcyBpbnN0ZWFkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJvdW5kcyBvZiB0aGUgZGlzcGxheWVkIHBhcnQgb2YgdGhlIHRpbGVkIGltYWdlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnJlbnQ9ZmFsc2VdIFBhc3MgdHJ1ZSBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb24sXG4gICAgICogZmFsc2UgZm9yIHRoZSB0YXJnZXQgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgeyQuUmVjdH0gVGhlIGNsaXBwZWQgYm91bmRzIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldENsaXBwZWRCb3VuZHM6IGZ1bmN0aW9uKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKGN1cnJlbnQpO1xuICAgICAgICBpZiAodGhpcy5fY2xpcCkge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gdGhpcy5fd29ybGRXaWR0aEN1cnJlbnQgLyB0aGlzLnNvdXJjZS5kaW1lbnNpb25zLng7XG4gICAgICAgICAgICB2YXIgY2xpcCA9IHRoaXMuX2NsaXAudGltZXMocmF0aW8pO1xuICAgICAgICAgICAgYm91bmRzID0gbmV3ICQuUmVjdChcbiAgICAgICAgICAgICAgICBib3VuZHMueCArIGNsaXAueCxcbiAgICAgICAgICAgICAgICBib3VuZHMueSArIGNsaXAueSxcbiAgICAgICAgICAgICAgICBjbGlwLndpZHRoLFxuICAgICAgICAgICAgICAgIGNsaXAuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5Qb2ludH0gVGhpcyBUaWxlZEltYWdlJ3MgY29udGVudCBzaXplLCBpbiBvcmlnaW5hbCBwaXhlbHMuXG4gICAgICovXG4gICAgZ2V0Q29udGVudFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQodGhpcy5zb3VyY2UuZGltZW5zaW9ucy54LCB0aGlzLnNvdXJjZS5kaW1lbnNpb25zLnkpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3ZpZXdwb3J0VG9JbWFnZURlbHRhOiBmdW5jdGlvbiggdmlld2VyWCwgdmlld2VyWSwgY3VycmVudCApIHtcbiAgICAgICAgdmFyIHNjYWxlID0gKGN1cnJlbnQgPyB0aGlzLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlIDogdGhpcy5fc2NhbGVTcHJpbmcudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyAkLlBvaW50KHZpZXdlclggKiAodGhpcy5zb3VyY2UuZGltZW5zaW9ucy54IC8gc2NhbGUpLFxuICAgICAgICAgICAgdmlld2VyWSAqICgodGhpcy5zb3VyY2UuZGltZW5zaW9ucy55ICogdGhpcy5jb250ZW50QXNwZWN0WCkgLyBzY2FsZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGZyb20gT3BlblNlYWRyYWdvbiB2aWV3ZXIgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBlaXRoZXIgYnkgcGFzc2luZyBYLFkgY29vcmRpbmF0ZXMgb3IgYW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uUG9pbnR9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9wZW5TZWFkcmFnb24uUG9pbnR9IHZpZXdlclggLSBUaGUgWCBjb29yZGluYXRlIG9yIHBvaW50IGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdmlld2VyWV0gLSBUaGUgWSBjb29yZGluYXRlIGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnJlbnQ9ZmFsc2VdIC0gUGFzcyB0cnVlIHRvIHVzZSB0aGUgY3VycmVudCBsb2NhdGlvbjsgZmFsc2UgZm9yIHRhcmdldCBsb2NhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29vcmRpbmF0ZXMgaW4gdGhlIGltYWdlLlxuICAgICAqL1xuICAgIHZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzOiBmdW5jdGlvbiggdmlld2VyWCwgdmlld2VyWSwgY3VycmVudCApIHtcbiAgICAgICAgaWYgKHZpZXdlclggaW5zdGFuY2VvZiAkLlBvaW50KSB7XG4gICAgICAgICAgICAvL3RoZXkgcGFzc2VkIGEgcG9pbnQgaW5zdGVhZCBvZiBpbmRpdmlkdWFsIGNvbXBvbmVudHNcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2aWV3ZXJZO1xuICAgICAgICAgICAgdmlld2VyWSA9IHZpZXdlclgueTtcbiAgICAgICAgICAgIHZpZXdlclggPSB2aWV3ZXJYLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0VG9JbWFnZURlbHRhKHZpZXdlclggLSB0aGlzLl94U3ByaW5nLmN1cnJlbnQudmFsdWUsXG4gICAgICAgICAgICAgICAgdmlld2VyWSAtIHRoaXMuX3lTcHJpbmcuY3VycmVudC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRUb0ltYWdlRGVsdGEodmlld2VyWCAtIHRoaXMuX3hTcHJpbmcudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgdmlld2VyWSAtIHRoaXMuX3lTcHJpbmcudGFyZ2V0LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9pbWFnZVRvVmlld3BvcnREZWx0YTogZnVuY3Rpb24oIGltYWdlWCwgaW1hZ2VZLCBjdXJyZW50ICkge1xuICAgICAgICB2YXIgc2NhbGUgPSAoY3VycmVudCA/IHRoaXMuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWUgOiB0aGlzLl9zY2FsZVNwcmluZy50YXJnZXQudmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3ICQuUG9pbnQoKGltYWdlWCAvIHRoaXMuc291cmNlLmRpbWVuc2lvbnMueCkgKiBzY2FsZSxcbiAgICAgICAgICAgIChpbWFnZVkgLyB0aGlzLnNvdXJjZS5kaW1lbnNpb25zLnkgLyB0aGlzLmNvbnRlbnRBc3BlY3RYKSAqIHNjYWxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBmcm9tIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtIHRvIE9wZW5TZWFkcmFnb24gdmlld2VyIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBlaXRoZXIgYnkgcGFzc2luZyBYLFkgY29vcmRpbmF0ZXMgb3IgYW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uUG9pbnR9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9wZW5TZWFkcmFnb24uUG9pbnR9IGltYWdlWCAtIFRoZSBYIGNvb3JkaW5hdGUgb3IgcG9pbnQgaW4gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbWFnZVldIC0gVGhlIFkgY29vcmRpbmF0ZSBpbiBpbWFnZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIGN1cnJlbnQgbG9jYXRpb247IGZhbHNlIGZvciB0YXJnZXQgbG9jYXRpb24uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5Qb2ludH0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvb3JkaW5hdGVzIGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICBpbWFnZVRvVmlld3BvcnRDb29yZGluYXRlczogZnVuY3Rpb24oIGltYWdlWCwgaW1hZ2VZLCBjdXJyZW50ICkge1xuICAgICAgICBpZiAoaW1hZ2VYIGluc3RhbmNlb2YgJC5Qb2ludCkge1xuICAgICAgICAgICAgLy90aGV5IHBhc3NlZCBhIHBvaW50IGluc3RlYWQgb2YgaW5kaXZpZHVhbCBjb21wb25lbnRzXG4gICAgICAgICAgICBjdXJyZW50ID0gaW1hZ2VZO1xuICAgICAgICAgICAgaW1hZ2VZID0gaW1hZ2VYLnk7XG4gICAgICAgICAgICBpbWFnZVggPSBpbWFnZVgueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuX2ltYWdlVG9WaWV3cG9ydERlbHRhKGltYWdlWCwgaW1hZ2VZKTtcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHBvaW50LnggKz0gdGhpcy5feFNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgICAgICAgICAgcG9pbnQueSArPSB0aGlzLl95U3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludC54ICs9IHRoaXMuX3hTcHJpbmcudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgcG9pbnQueSArPSB0aGlzLl95U3ByaW5nLnRhcmdldC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBmcm9tIGEgcmVjdGFuZ2xlIHdoaWNoIGRlc2NyaWJlcyBhIHBvcnRpb24gb2YgdGhlIGltYWdlIGluXG4gICAgICogcGl4ZWwgY29vcmRpbmF0ZXMgdG8gT3BlblNlYWRyYWdvbiB2aWV3cG9ydCByZWN0YW5nbGUgY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBlaXRoZXIgYnkgcGFzc2luZyBYLFksd2lkdGgsaGVpZ2h0IG9yIGFuIHtAbGluayBPcGVuU2VhZHJhZ29uLlJlY3R9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9wZW5TZWFkcmFnb24uUmVjdH0gaW1hZ2VYIC0gVGhlIGxlZnQgY29vcmRpbmF0ZSBvciByZWN0YW5nbGUgaW4gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbWFnZVldIC0gVGhlIHRvcCBjb29yZGluYXRlIGluIGltYWdlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGl4ZWxXaWR0aF0gLSBUaGUgd2lkdGggaW4gcGl4ZWwgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BpeGVsSGVpZ2h0XSAtIFRoZSBoZWlnaHQgaW4gcGl4ZWwgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIGN1cnJlbnQgbG9jYXRpb247IGZhbHNlIGZvciB0YXJnZXQgbG9jYXRpb24uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5SZWN0fSBBIHJlY3QgcmVwcmVzZW50aW5nIHRoZSBjb29yZGluYXRlcyBpbiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgaW1hZ2VUb1ZpZXdwb3J0UmVjdGFuZ2xlOiBmdW5jdGlvbiggaW1hZ2VYLCBpbWFnZVksIHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0LCBjdXJyZW50ICkge1xuICAgICAgICB2YXIgcmVjdCA9IGltYWdlWDtcbiAgICAgICAgaWYgKHJlY3QgaW5zdGFuY2VvZiAkLlJlY3QpIHtcbiAgICAgICAgICAgIC8vdGhleSBwYXNzZWQgYSByZWN0IGluc3RlYWQgb2YgaW5kaXZpZHVhbCBjb21wb25lbnRzXG4gICAgICAgICAgICBjdXJyZW50ID0gaW1hZ2VZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdCA9IG5ldyAkLlJlY3QoaW1hZ2VYLCBpbWFnZVksIHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZEEgPSB0aGlzLmltYWdlVG9WaWV3cG9ydENvb3JkaW5hdGVzKHJlY3QuZ2V0VG9wTGVmdCgpLCBjdXJyZW50KTtcbiAgICAgICAgdmFyIGNvb3JkQiA9IHRoaXMuX2ltYWdlVG9WaWV3cG9ydERlbHRhKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCBjdXJyZW50KTtcblxuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIGNvb3JkQS54LFxuICAgICAgICAgICAgY29vcmRBLnksXG4gICAgICAgICAgICBjb29yZEIueCxcbiAgICAgICAgICAgIGNvb3JkQi55LFxuICAgICAgICAgICAgcmVjdC5kZWdyZWVzXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZnJvbSBhIHJlY3RhbmdsZSB3aGljaCBkZXNjcmliZXMgYSBwb3J0aW9uIG9mXG4gICAgICogdGhlIHZpZXdwb3J0IGluIHBvaW50IGNvb3JkaW5hdGVzIHRvIGltYWdlIHJlY3RhbmdsZSBjb29yZGluYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGVpdGhlciBieSBwYXNzaW5nIFgsWSx3aWR0aCxoZWlnaHQgb3IgYW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uUmVjdH0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T3BlblNlYWRyYWdvbi5SZWN0fSB2aWV3ZXJYIC0gVGhlIGxlZnQgY29vcmRpbmF0ZSBvciByZWN0YW5nbGUgaW4gdmlld3BvcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt2aWV3ZXJZXSAtIFRoZSB0b3AgY29vcmRpbmF0ZSBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BvaW50V2lkdGhdIC0gVGhlIHdpZHRoIGluIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9pbnRIZWlnaHRdIC0gVGhlIGhlaWdodCBpbiB2aWV3cG9ydCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50PWZhbHNlXSAtIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIGN1cnJlbnQgbG9jYXRpb247IGZhbHNlIGZvciB0YXJnZXQgbG9jYXRpb24uXG4gICAgICogQHJldHVybiB7T3BlblNlYWRyYWdvbi5SZWN0fSBBIHJlY3QgcmVwcmVzZW50aW5nIHRoZSBjb29yZGluYXRlcyBpbiB0aGUgaW1hZ2UuXG4gICAgICovXG4gICAgdmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlOiBmdW5jdGlvbiggdmlld2VyWCwgdmlld2VyWSwgcG9pbnRXaWR0aCwgcG9pbnRIZWlnaHQsIGN1cnJlbnQgKSB7XG4gICAgICAgIHZhciByZWN0ID0gdmlld2VyWDtcbiAgICAgICAgaWYgKHZpZXdlclggaW5zdGFuY2VvZiAkLlJlY3QpIHtcbiAgICAgICAgICAgIC8vdGhleSBwYXNzZWQgYSByZWN0IGluc3RlYWQgb2YgaW5kaXZpZHVhbCBjb21wb25lbnRzXG4gICAgICAgICAgICBjdXJyZW50ID0gdmlld2VyWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QgPSBuZXcgJC5SZWN0KHZpZXdlclgsIHZpZXdlclksIHBvaW50V2lkdGgsIHBvaW50SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZEEgPSB0aGlzLnZpZXdwb3J0VG9JbWFnZUNvb3JkaW5hdGVzKHJlY3QuZ2V0VG9wTGVmdCgpLCBjdXJyZW50KTtcbiAgICAgICAgdmFyIGNvb3JkQiA9IHRoaXMuX3ZpZXdwb3J0VG9JbWFnZURlbHRhKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCBjdXJyZW50KTtcblxuICAgICAgICByZXR1cm4gbmV3ICQuUmVjdChcbiAgICAgICAgICAgIGNvb3JkQS54LFxuICAgICAgICAgICAgY29vcmRBLnksXG4gICAgICAgICAgICBjb29yZEIueCxcbiAgICAgICAgICAgIGNvb3JkQi55LFxuICAgICAgICAgICAgcmVjdC5kZWdyZWVzXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdlciBlbGVtZW50IHRvIGltYWdlXG4gICAgICogY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIHZpZXdlckVsZW1lbnRUb0ltYWdlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBwaXhlbCApIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy52aWV3cG9ydC5wb2ludEZyb21QaXhlbCggcGl4ZWwsIHRydWUgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRUb0ltYWdlQ29vcmRpbmF0ZXMoIHBvaW50ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIGltYWdlIHRvXG4gICAgICogdmlld2VyIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIGltYWdlVG9WaWV3ZXJFbGVtZW50Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCBwaXhlbCApIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5pbWFnZVRvVmlld3BvcnRDb29yZGluYXRlcyggcGl4ZWwgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQucGl4ZWxGcm9tUG9pbnQoIHBvaW50LCB0cnVlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcGl4ZWwgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdyB0byBpbWFnZSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uUG9pbnR9IHBpeGVsXG4gICAgICogQHJldHVybnMge09wZW5TZWFkcmFnb24uUG9pbnR9XG4gICAgICovXG4gICAgd2luZG93VG9JbWFnZUNvb3JkaW5hdGVzOiBmdW5jdGlvbiggcGl4ZWwgKSB7XG4gICAgICAgIHZhciB2aWV3ZXJDb29yZGluYXRlcyA9IHBpeGVsLm1pbnVzKFxuICAgICAgICAgICAgICAgIE9wZW5TZWFkcmFnb24uZ2V0RWxlbWVudFBvc2l0aW9uKCB0aGlzLnZpZXdlci5lbGVtZW50ICkpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3ZXJFbGVtZW50VG9JbWFnZUNvb3JkaW5hdGVzKCB2aWV3ZXJDb29yZGluYXRlcyApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGltYWdlIGNvb3JkaW5hdGVzIHRvIHBpeGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBvaW50fSBwaXhlbFxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlBvaW50fVxuICAgICAqL1xuICAgIGltYWdlVG9XaW5kb3dDb29yZGluYXRlczogZnVuY3Rpb24oIHBpeGVsICkge1xuICAgICAgICB2YXIgdmlld2VyQ29vcmRpbmF0ZXMgPSB0aGlzLmltYWdlVG9WaWV3ZXJFbGVtZW50Q29vcmRpbmF0ZXMoIHBpeGVsICk7XG4gICAgICAgIHJldHVybiB2aWV3ZXJDb29yZGluYXRlcy5wbHVzKFxuICAgICAgICAgICAgICAgIE9wZW5TZWFkcmFnb24uZ2V0RWxlbWVudFBvc2l0aW9uKCB0aGlzLnZpZXdlci5lbGVtZW50ICkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmlld3BvcnQgem9vbSB0byBhbiBpbWFnZSB6b29tLlxuICAgICAqIEltYWdlIHpvb206IHJhdGlvIG9mIHRoZSBvcmlnaW5hbCBpbWFnZSBzaXplIHRvIGRpc3BsYXllZCBpbWFnZSBzaXplLlxuICAgICAqIDEgbWVhbnMgb3JpZ2luYWwgaW1hZ2Ugc2l6ZSwgMC41IGhhbGYgc2l6ZS4uLlxuICAgICAqIFZpZXdwb3J0IHpvb206IHJhdGlvIG9mIHRoZSBkaXNwbGF5ZWQgaW1hZ2UncyB3aWR0aCB0byB2aWV3cG9ydCdzIHdpZHRoLlxuICAgICAqIDEgbWVhbnMgaWRlbnRpY2FsIHdpZHRoLCAyIG1lYW5zIGltYWdlJ3Mgd2lkdGggaXMgdHdpY2UgdGhlIHZpZXdwb3J0J3Mgd2lkdGguLi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRab29tIFRoZSB2aWV3cG9ydCB6b29tXG4gICAgICogQHJldHVybnMge051bWJlcn0gaW1hZ2Vab29tIFRoZSBpbWFnZSB6b29tXG4gICAgICovXG4gICAgdmlld3BvcnRUb0ltYWdlWm9vbTogZnVuY3Rpb24oIHZpZXdwb3J0Wm9vbSApIHtcbiAgICAgICAgdmFyIHJhdGlvID0gdGhpcy5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZSAqXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5fY29udGFpbmVySW5uZXJTaXplLnggLyB0aGlzLnNvdXJjZS5kaW1lbnNpb25zLng7XG4gICAgICAgIHJldHVybiByYXRpbyAqIHZpZXdwb3J0Wm9vbSA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gaW1hZ2Ugem9vbSB0byBhIHZpZXdwb3J0IHpvb20uXG4gICAgICogSW1hZ2Ugem9vbTogcmF0aW8gb2YgdGhlIG9yaWdpbmFsIGltYWdlIHNpemUgdG8gZGlzcGxheWVkIGltYWdlIHNpemUuXG4gICAgICogMSBtZWFucyBvcmlnaW5hbCBpbWFnZSBzaXplLCAwLjUgaGFsZiBzaXplLi4uXG4gICAgICogVmlld3BvcnQgem9vbTogcmF0aW8gb2YgdGhlIGRpc3BsYXllZCBpbWFnZSdzIHdpZHRoIHRvIHZpZXdwb3J0J3Mgd2lkdGguXG4gICAgICogMSBtZWFucyBpZGVudGljYWwgd2lkdGgsIDIgbWVhbnMgaW1hZ2UncyB3aWR0aCBpcyB0d2ljZSB0aGUgdmlld3BvcnQncyB3aWR0aC4uLlxuICAgICAqIE5vdGU6IG5vdCBhY2N1cmF0ZSB3aXRoIG11bHRpLWltYWdlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbWFnZVpvb20gVGhlIGltYWdlIHpvb21cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2aWV3cG9ydFpvb20gVGhlIHZpZXdwb3J0IHpvb21cbiAgICAgKi9cbiAgICBpbWFnZVRvVmlld3BvcnRab29tOiBmdW5jdGlvbiggaW1hZ2Vab29tICkge1xuICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlICpcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0Ll9jb250YWluZXJJbm5lclNpemUueCAvIHRoaXMuc291cmNlLmRpbWVuc2lvbnMueDtcbiAgICAgICAgcmV0dXJuIGltYWdlWm9vbSAvIHJhdGlvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBUaWxlZEltYWdlJ3MgcG9zaXRpb24gaW4gdGhlIHdvcmxkLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5Qb2ludH0gcG9zaXRpb24gLSBUaGUgbmV3IHBvc2l0aW9uLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV0gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdG8gdGhlIG5ldyBwb3NpdGlvbiBvciBzbmFwIGltbWVkaWF0ZWx5LlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2UuZXZlbnQ6Ym91bmRzLWNoYW5nZVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbiwgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIHNhbWVUYXJnZXQgPSAodGhpcy5feFNwcmluZy50YXJnZXQudmFsdWUgPT09IHBvc2l0aW9uLnggJiZcbiAgICAgICAgICAgIHRoaXMuX3lTcHJpbmcudGFyZ2V0LnZhbHVlID09PSBwb3NpdGlvbi55KTtcblxuICAgICAgICBpZiAoaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIGlmIChzYW1lVGFyZ2V0ICYmIHRoaXMuX3hTcHJpbmcuY3VycmVudC52YWx1ZSA9PT0gcG9zaXRpb24ueCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl95U3ByaW5nLmN1cnJlbnQudmFsdWUgPT09IHBvc2l0aW9uLnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hTcHJpbmcucmVzZXRUbyhwb3NpdGlvbi54KTtcbiAgICAgICAgICAgIHRoaXMuX3lTcHJpbmcucmVzZXRUbyhwb3NpdGlvbi55KTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2FtZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5feFNwcmluZy5zcHJpbmdUbyhwb3NpdGlvbi54KTtcbiAgICAgICAgICAgIHRoaXMuX3lTcHJpbmcuc3ByaW5nVG8ocG9zaXRpb24ueSk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzYW1lVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9yYWlzZUJvdW5kc0NoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFRpbGVkSW1hZ2UncyB3aWR0aCBpbiB0aGUgd29ybGQsIGFkanVzdGluZyB0aGUgaGVpZ2h0IHRvIG1hdGNoIGJhc2VkIG9uIGFzcGVjdCByYXRpby5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV0gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdG8gdGhlIG5ldyBzaXplIG9yIHNuYXAgaW1tZWRpYXRlbHkuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVGlsZWRJbWFnZS5ldmVudDpib3VuZHMtY2hhbmdlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoLCBpbW1lZGlhdGVseSkge1xuICAgICAgICB0aGlzLl9zZXRTY2FsZSh3aWR0aCwgaW1tZWRpYXRlbHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBUaWxlZEltYWdlJ3MgaGVpZ2h0IGluIHRoZSB3b3JsZCwgYWRqdXN0aW5nIHRoZSB3aWR0aCB0byBtYXRjaCBiYXNlZCBvbiBhc3BlY3QgcmF0aW8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0LCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV0gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdG8gdGhlIG5ldyBzaXplIG9yIHNuYXAgaW1tZWRpYXRlbHkuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVGlsZWRJbWFnZS5ldmVudDpib3VuZHMtY2hhbmdlXG4gICAgICovXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIGltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHRoaXMuX3NldFNjYWxlKGhlaWdodCAvIHRoaXMubm9ybUhlaWdodCwgaW1tZWRpYXRlbHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbnMgYW5kIHNjYWxlcyB0aGUgVGlsZWRJbWFnZSB0byBmaXQgaW4gdGhlIHNwZWNpZmllZCBib3VuZHMuXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgZmlyZXMgT3BlblNlYWRyYWdvbi5UaWxlZEltYWdlLmV2ZW50OmJvdW5kcy1jaGFuZ2VcbiAgICAgKiB0d2ljZVxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5SZWN0fSBib3VuZHMgVGhlIGJvdW5kcyB0byBmaXQgdGhlIGltYWdlIGludG8uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlBsYWNlbWVudH0gW2FuY2hvcj1PcGVuU2VhZHJhZ29uLlBsYWNlbWVudC5DRU5URVJdXG4gICAgICogSG93IHRvIGFuY2hvciB0aGUgaW1hZ2UgaW4gdGhlIGJvdW5kcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV0gV2hldGhlciB0byBhbmltYXRlIHRvIHRoZSBuZXcgc2l6ZVxuICAgICAqIG9yIHNuYXAgaW1tZWRpYXRlbHkuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uVGlsZWRJbWFnZS5ldmVudDpib3VuZHMtY2hhbmdlXG4gICAgICovXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMsIGFuY2hvciwgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgYW5jaG9yID0gYW5jaG9yIHx8ICQuUGxhY2VtZW50LkNFTlRFUjtcbiAgICAgICAgdmFyIGFuY2hvclByb3BlcnRpZXMgPSAkLlBsYWNlbWVudC5wcm9wZXJ0aWVzW2FuY2hvcl07XG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IHRoaXMuY29udGVudEFzcGVjdFg7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgZGlzcGxheWVkV2lkdGhSYXRpbyA9IDE7XG4gICAgICAgIHZhciBkaXNwbGF5ZWRIZWlnaHRSYXRpbyA9IDE7XG4gICAgICAgIGlmICh0aGlzLl9jbGlwKSB7XG4gICAgICAgICAgICBhc3BlY3RSYXRpbyA9IHRoaXMuX2NsaXAuZ2V0QXNwZWN0UmF0aW8oKTtcbiAgICAgICAgICAgIGRpc3BsYXllZFdpZHRoUmF0aW8gPSB0aGlzLl9jbGlwLndpZHRoIC8gdGhpcy5zb3VyY2UuZGltZW5zaW9ucy54O1xuICAgICAgICAgICAgZGlzcGxheWVkSGVpZ2h0UmF0aW8gPSB0aGlzLl9jbGlwLmhlaWdodCAvIHRoaXMuc291cmNlLmRpbWVuc2lvbnMueTtcbiAgICAgICAgICAgIGlmIChib3VuZHMuZ2V0QXNwZWN0UmF0aW8oKSA+IGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgeE9mZnNldCA9IHRoaXMuX2NsaXAueCAvIHRoaXMuX2NsaXAuaGVpZ2h0ICogYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gdGhpcy5fY2xpcC55IC8gdGhpcy5fY2xpcC5oZWlnaHQgKiBib3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gdGhpcy5fY2xpcC54IC8gdGhpcy5fY2xpcC53aWR0aCAqIGJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gdGhpcy5fY2xpcC55IC8gdGhpcy5fY2xpcC53aWR0aCAqIGJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3VuZHMuZ2V0QXNwZWN0UmF0aW8oKSA+IGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAvLyBXZSB3aWxsIGhhdmUgbWFyZ2lucyBvbiB0aGUgWCBheGlzXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCAvIGRpc3BsYXllZEhlaWdodFJhdGlvO1xuICAgICAgICAgICAgdmFyIG1hcmdpbkxlZnQgPSAwO1xuICAgICAgICAgICAgaWYgKGFuY2hvclByb3BlcnRpZXMuaXNIb3Jpem9udGFsbHlDZW50ZXJlZCkge1xuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSAoYm91bmRzLndpZHRoIC0gYm91bmRzLmhlaWdodCAqIGFzcGVjdFJhdGlvKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvclByb3BlcnRpZXMuaXNSaWdodCkge1xuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBib3VuZHMud2lkdGggLSBib3VuZHMuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgIG5ldyAkLlBvaW50KGJvdW5kcy54IC0geE9mZnNldCArIG1hcmdpbkxlZnQsIGJvdW5kcy55IC0geU9mZnNldCksXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlbHkpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0LCBpbW1lZGlhdGVseSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSB3aWxsIGhhdmUgbWFyZ2lucyBvbiB0aGUgWSBheGlzXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBib3VuZHMud2lkdGggLyBkaXNwbGF5ZWRXaWR0aFJhdGlvO1xuICAgICAgICAgICAgdmFyIG1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgICBpZiAoYW5jaG9yUHJvcGVydGllcy5pc1ZlcnRpY2FsbHlDZW50ZXJlZCkge1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IChib3VuZHMuaGVpZ2h0IC0gYm91bmRzLndpZHRoIC8gYXNwZWN0UmF0aW8pIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yUHJvcGVydGllcy5pc0JvdHRvbSkge1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IGJvdW5kcy5oZWlnaHQgLSBib3VuZHMud2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oXG4gICAgICAgICAgICAgICAgbmV3ICQuUG9pbnQoYm91bmRzLnggLSB4T2Zmc2V0LCBib3VuZHMueSAtIHlPZmZzZXQgKyBtYXJnaW5Ub3ApLFxuICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0V2lkdGgod2lkdGgsIGltbWVkaWF0ZWx5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fG51bGx9IFRoZSBUaWxlZEltYWdlJ3MgY3VycmVudCBjbGlwIHJlY3RhbmdsZSxcbiAgICAgKiBpbiBpbWFnZSBwaXhlbHMsIG9yIG51bGwgaWYgbm9uZS5cbiAgICAgKi9cbiAgICBnZXRDbGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsaXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwLmNsb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlJlY3R8bnVsbH0gbmV3Q2xpcCAtIEFuIGFyZWEsIGluIGltYWdlIHBpeGVscywgdG8gY2xpcCB0b1xuICAgICAqIChwb3J0aW9ucyBvZiB0aGUgaW1hZ2Ugb3V0c2lkZSBvZiB0aGlzIGFyZWEgd2lsbCBub3QgYmUgdmlzaWJsZSkuIE9ubHkgd29ya3Mgb25cbiAgICAgKiBicm93c2VycyB0aGF0IHN1cHBvcnQgdGhlIEhUTUw1IGNhbnZhcy5cbiAgICAgKi9cbiAgICBzZXRDbGlwOiBmdW5jdGlvbihuZXdDbGlwKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoIW5ld0NsaXAgfHwgbmV3Q2xpcCBpbnN0YW5jZW9mICQuUmVjdCxcbiAgICAgICAgICAgIFwiW1RpbGVkSW1hZ2Uuc2V0Q2xpcF0gbmV3Q2xpcCBtdXN0IGJlIGFuIE9wZW5TZWFkcmFnb24uUmVjdCBvciBudWxsXCIpO1xuXG4gICAgICAgIGlmIChuZXdDbGlwIGluc3RhbmNlb2YgJC5SZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwID0gbmV3Q2xpcC5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2xpcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgVGlsZWRJbWFnZSdzIGN1cnJlbnQgb3BhY2l0eS5cbiAgICAgKi9cbiAgICBnZXRPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BhY2l0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wYWNpdHkgT3BhY2l0eSB0aGUgdGlsZWQgaW1hZ2Ugc2hvdWxkIGJlIGRyYXduIGF0LlxuICAgICAqL1xuICAgIHNldE9wYWNpdHk6IGZ1bmN0aW9uKG9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFRpbGVkSW1hZ2UncyBjdXJyZW50IGNvbXBvc2l0ZU9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRDb21wb3NpdGVPcGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NpdGVPcGVyYXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gdGhlIHRpbGVkIGltYWdlIHNob3VsZCBiZSBkcmF3biB3aXRoIHRoaXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHNldENvbXBvc2l0ZU9wZXJhdGlvbjogZnVuY3Rpb24oY29tcG9zaXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3NldFNjYWxlOiBmdW5jdGlvbihzY2FsZSwgaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIHNhbWVUYXJnZXQgPSAodGhpcy5fc2NhbGVTcHJpbmcudGFyZ2V0LnZhbHVlID09PSBzY2FsZSk7XG4gICAgICAgIGlmIChpbW1lZGlhdGVseSkge1xuICAgICAgICAgICAgaWYgKHNhbWVUYXJnZXQgJiYgdGhpcy5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZSA9PT0gc2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NjYWxlU3ByaW5nLnJlc2V0VG8oc2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9yU2NhbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2FtZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2NhbGVTcHJpbmcuc3ByaW5nVG8oc2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9yU2NhbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzRHJhdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNhbWVUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhaXNlQm91bmRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF91cGRhdGVGb3JTY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3dvcmxkV2lkdGhUYXJnZXQgPSB0aGlzLl9zY2FsZVNwcmluZy50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMuX3dvcmxkSGVpZ2h0VGFyZ2V0ID0gdGhpcy5ub3JtSGVpZ2h0ICogdGhpcy5fc2NhbGVTcHJpbmcudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0aGlzLl93b3JsZFdpZHRoQ3VycmVudCA9IHRoaXMuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgICAgIHRoaXMuX3dvcmxkSGVpZ2h0Q3VycmVudCA9IHRoaXMubm9ybUhlaWdodCAqIHRoaXMuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfcmFpc2VCb3VuZHNDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIFRpbGVkSW1hZ2UncyBib3VuZHMgYXJlIGNoYW5nZWQuXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIGV2ZW50IGlzIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIGFuaW1hdGlvbiB0YXJnZXQgaXMgY2hhbmdlZDtcbiAgICAgICAgICogbm90IGZvciBldmVyeSBmcmFtZSBvZiBhbmltYXRpb24uXG4gICAgICAgICAqIEBldmVudCBib3VuZHMtY2hhbmdlXG4gICAgICAgICAqIEBtZW1iZXJPZiBPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2VcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLldvcmxkfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBUaWxlZEltYWdlIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCgnYm91bmRzLWNoYW5nZScpO1xuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX2lzQm90dG9tSXRlbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdlci53b3JsZC5nZXRJdGVtQXQoMCkgPT09IHRoaXM7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbm5lclxuICogUHJldHR5IG11Y2ggZXZlcnkgb3RoZXIgbGluZSBpbiB0aGlzIG5lZWRzIHRvIGJlIGRvY3VtZW50ZWQgc28gaXQncyBjbGVhclxuICogaG93IGVhY2ggcGllY2Ugb2YgdGhpcyByb3V0aW5lIGNvbnRyaWJ1dGVzIHRvIHRoZSBkcmF3aW5nIHByb2Nlc3MuICBUaGF0J3NcbiAqIHdoeSB0aGVyZSBhcmUgc28gbWFueSBUT0RPJ3MgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0KCB0aWxlZEltYWdlICkge1xuXG4gICAgdGlsZWRJbWFnZS5fbmVlZHNEcmF3ID0gZmFsc2U7XG5cbiAgICB2YXIgdGlsZSxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIGJlc3QgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgIGhhdmVEcmF3biAgICAgICA9IGZhbHNlLFxuICAgICAgICBjdXJyZW50VGltZSAgICAgPSAkLm5vdygpLFxuICAgICAgICB2aWV3cG9ydEJvdW5kcyAgPSB0aWxlZEltYWdlLnZpZXdwb3J0LmdldEJvdW5kc1dpdGhNYXJnaW5zKCB0cnVlICksXG4gICAgICAgIHplcm9SYXRpb0MgICAgICA9IHRpbGVkSW1hZ2Uudmlld3BvcnQuZGVsdGFQaXhlbHNGcm9tUG9pbnRzTm9Sb3RhdGUoXG4gICAgICAgICAgICB0aWxlZEltYWdlLnNvdXJjZS5nZXRQaXhlbFJhdGlvKCAwICksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICkueCAqIHRpbGVkSW1hZ2UuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWUsXG4gICAgICAgIGxvd2VzdExldmVsICAgICA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGlsZWRJbWFnZS5zb3VyY2UubWluTGV2ZWwsXG4gICAgICAgICAgICBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIE1hdGgubG9nKCB0aWxlZEltYWdlLm1pblpvb21JbWFnZVJhdGlvICkgL1xuICAgICAgICAgICAgICAgIE1hdGgubG9nKCAyIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgaGlnaGVzdExldmVsICAgID0gTWF0aC5taW4oXG4gICAgICAgICAgICBNYXRoLmFicyh0aWxlZEltYWdlLnNvdXJjZS5tYXhMZXZlbCksXG4gICAgICAgICAgICBNYXRoLmFicyhNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIE1hdGgubG9nKCB6ZXJvUmF0aW9DIC8gdGlsZWRJbWFnZS5taW5QaXhlbFJhdGlvICkgL1xuICAgICAgICAgICAgICAgIE1hdGgubG9nKCAyIClcbiAgICAgICAgICAgICkpXG4gICAgICAgICksXG4gICAgICAgIHJlbmRlclBpeGVsUmF0aW9DLFxuICAgICAgICByZW5kZXJQaXhlbFJhdGlvVCxcbiAgICAgICAgemVyb1JhdGlvVCxcbiAgICAgICAgb3B0aW1hbFJhdGlvLFxuICAgICAgICBsZXZlbE9wYWNpdHksXG4gICAgICAgIGxldmVsVmlzaWJpbGl0eTtcblxuICAgIC8vIFJlc2V0IHRpbGUncyBpbnRlcm5hbCBkcmF3biBzdGF0ZVxuICAgIHdoaWxlICh0aWxlZEltYWdlLmxhc3REcmF3bi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRpbGUgPSB0aWxlZEltYWdlLmxhc3REcmF3bi5wb3AoKTtcbiAgICAgICAgdGlsZS5iZWluZ0RyYXduID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aWxlZEltYWdlLndyYXBIb3Jpem9udGFsICYmICF0aWxlZEltYWdlLndyYXBWZXJ0aWNhbCkge1xuICAgICAgICB2YXIgdGlsZWRJbWFnZUJvdW5kcyA9IHRpbGVkSW1hZ2UuZ2V0Q2xpcHBlZEJvdW5kcyh0cnVlKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHZpZXdwb3J0Qm91bmRzLmludGVyc2VjdGlvbih0aWxlZEltYWdlQm91bmRzKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdwb3J0Qm91bmRzID0gaW50ZXJzZWN0aW9uO1xuICAgIH1cbiAgICB2aWV3cG9ydEJvdW5kcyA9IHZpZXdwb3J0Qm91bmRzLmdldEJvdW5kaW5nQm94KCk7XG4gICAgdmlld3BvcnRCb3VuZHMueCAtPSB0aWxlZEltYWdlLl94U3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgdmlld3BvcnRCb3VuZHMueSAtPSB0aWxlZEltYWdlLl95U3ByaW5nLmN1cnJlbnQudmFsdWU7XG5cbiAgICB2YXIgdmlld3BvcnRUTCA9IHZpZXdwb3J0Qm91bmRzLmdldFRvcExlZnQoKTtcbiAgICB2YXIgdmlld3BvcnRCUiA9IHZpZXdwb3J0Qm91bmRzLmdldEJvdHRvbVJpZ2h0KCk7XG5cbiAgICAvL0Rvbid0IGRyYXcgaWYgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydFxuICAgIGlmICAoICF0aWxlZEltYWdlLndyYXBIb3Jpem9udGFsICYmICh2aWV3cG9ydEJSLnggPCAwIHx8IHZpZXdwb3J0VEwueCA+IHRpbGVkSW1hZ2UuX3dvcmxkV2lkdGhDdXJyZW50ICkgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoICF0aWxlZEltYWdlLndyYXBWZXJ0aWNhbCAmJiAoIHZpZXdwb3J0QlIueSA8IDAgfHwgdmlld3BvcnRUTC55ID4gdGlsZWRJbWFnZS5fd29ybGRIZWlnaHRDdXJyZW50ICkgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdmlld3BvcnQgcmVjdCAvIGJvdW5kc1xuICAgIGlmICggIXRpbGVkSW1hZ2Uud3JhcEhvcml6b250YWwgKSB7XG4gICAgICAgIHZpZXdwb3J0VEwueCA9IE1hdGgubWF4KCB2aWV3cG9ydFRMLngsIDAgKTtcbiAgICAgICAgdmlld3BvcnRCUi54ID0gTWF0aC5taW4oIHZpZXdwb3J0QlIueCwgdGlsZWRJbWFnZS5fd29ybGRXaWR0aEN1cnJlbnQgKTtcbiAgICB9XG5cbiAgICBpZiAoICF0aWxlZEltYWdlLndyYXBWZXJ0aWNhbCApIHtcbiAgICAgICAgdmlld3BvcnRUTC55ID0gTWF0aC5tYXgoIHZpZXdwb3J0VEwueSwgMCApO1xuICAgICAgICB2aWV3cG9ydEJSLnkgPSBNYXRoLm1pbiggdmlld3BvcnRCUi55LCB0aWxlZEltYWdlLl93b3JsZEhlaWdodEN1cnJlbnQgKTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGlvbnMgZm9yIHRoZSBpbnRlcnZhbCBvZiBsZXZlbHMgdG8gZHJhd1xuICAgIC8vIChhYm92ZSBpbiBpbml0aWFsIHZhciBzdGF0ZW1lbnQpXG4gICAgLy8gY2FuIHJldHVybiBpbnZhbGlkIGludGVydmFsczsgZml4IHRoYXQgaGVyZSBpZiBuZWNlc3NhcnlcbiAgICBsb3dlc3RMZXZlbCA9IE1hdGgubWluKCBsb3dlc3RMZXZlbCwgaGlnaGVzdExldmVsICk7XG5cbiAgICAvLyBVcGRhdGUgYW55IGxldmVsIHRoYXQgd2lsbCBiZSBkcmF3blxuICAgIHZhciBkcmF3TGV2ZWw7IC8vIEZJWE1FOiBkcmF3TGV2ZWwgc2hvdWxkIGhhdmUgYSBtb3JlIGV4cGxhbmF0b3J5IG5hbWVcbiAgICBmb3IgKCBsZXZlbCA9IGhpZ2hlc3RMZXZlbDsgbGV2ZWwgPj0gbG93ZXN0TGV2ZWw7IGxldmVsLS0gKSB7XG4gICAgICAgIGRyYXdMZXZlbCA9IGZhbHNlO1xuXG4gICAgICAgIC8vQXZvaWQgY2FsY3VsYXRpb25zIGZvciBkcmF3IGlmIHdlIGhhdmUgYWxyZWFkeSBkcmF3biB0aGlzXG4gICAgICAgIHJlbmRlclBpeGVsUmF0aW9DID0gdGlsZWRJbWFnZS52aWV3cG9ydC5kZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZShcbiAgICAgICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLmdldFBpeGVsUmF0aW8oIGxldmVsICksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICkueCAqIHRpbGVkSW1hZ2UuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWU7XG5cbiAgICAgICAgaWYgKCAoICFoYXZlRHJhd24gJiYgcmVuZGVyUGl4ZWxSYXRpb0MgPj0gdGlsZWRJbWFnZS5taW5QaXhlbFJhdGlvICkgfHxcbiAgICAgICAgICAgICAoIGxldmVsID09IGxvd2VzdExldmVsICkgKSB7XG4gICAgICAgICAgICBkcmF3TGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgaGF2ZURyYXduID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICggIWhhdmVEcmF3biApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9QZXJmb3JtIGNhbGN1bGF0aW9ucyBmb3IgZHJhdyBpZiB3ZSBoYXZlbid0IGRyYXduIHRoaXNcbiAgICAgICAgcmVuZGVyUGl4ZWxSYXRpb1QgPSB0aWxlZEltYWdlLnZpZXdwb3J0LmRlbHRhUGl4ZWxzRnJvbVBvaW50c05vUm90YXRlKFxuICAgICAgICAgICAgdGlsZWRJbWFnZS5zb3VyY2UuZ2V0UGl4ZWxSYXRpbyggbGV2ZWwgKSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICkueCAqIHRpbGVkSW1hZ2UuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWU7XG5cbiAgICAgICAgemVyb1JhdGlvVCAgICAgID0gdGlsZWRJbWFnZS52aWV3cG9ydC5kZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZShcbiAgICAgICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLmdldFBpeGVsUmF0aW8oXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLmdldENsb3Nlc3RMZXZlbCggdGlsZWRJbWFnZS52aWV3cG9ydC5jb250YWluZXJTaXplICkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICkueCAqIHRpbGVkSW1hZ2UuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWU7XG5cbiAgICAgICAgb3B0aW1hbFJhdGlvICAgID0gdGlsZWRJbWFnZS5pbW1lZGlhdGVSZW5kZXIgP1xuICAgICAgICAgICAgMSA6XG4gICAgICAgICAgICB6ZXJvUmF0aW9UO1xuXG4gICAgICAgIGxldmVsT3BhY2l0eSAgICA9IE1hdGgubWluKCAxLCAoIHJlbmRlclBpeGVsUmF0aW9DIC0gMC41ICkgLyAwLjUgKTtcblxuICAgICAgICBsZXZlbFZpc2liaWxpdHkgPSBvcHRpbWFsUmF0aW8gLyBNYXRoLmFicyhcbiAgICAgICAgICAgIG9wdGltYWxSYXRpbyAtIHJlbmRlclBpeGVsUmF0aW9UXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsZXZlbCBhbmQga2VlcCB0cmFjayBvZiAnYmVzdCcgdGlsZSB0byBsb2FkXG4gICAgICAgIGJlc3QgPSB1cGRhdGVMZXZlbChcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UsXG4gICAgICAgICAgICBoYXZlRHJhd24sXG4gICAgICAgICAgICBkcmF3TGV2ZWwsXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIGxldmVsT3BhY2l0eSxcbiAgICAgICAgICAgIGxldmVsVmlzaWJpbGl0eSxcbiAgICAgICAgICAgIHZpZXdwb3J0VEwsXG4gICAgICAgICAgICB2aWV3cG9ydEJSLFxuICAgICAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgICAgICBiZXN0XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3RvcCB0aGUgbG9vcCBpZiBsb3dlci1yZXMgdGlsZXMgd291bGQgYWxsIGJlIGNvdmVyZWQgYnlcbiAgICAgICAgLy8gYWxyZWFkeSBkcmF3biB0aWxlc1xuICAgICAgICBpZiAoICBwcm92aWRlc0NvdmVyYWdlKCB0aWxlZEltYWdlLmNvdmVyYWdlLCBsZXZlbCApICkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgZHJhd2luZ1xuICAgIGRyYXdUaWxlcyggdGlsZWRJbWFnZSwgdGlsZWRJbWFnZS5sYXN0RHJhd24gKTtcblxuICAgIC8vIExvYWQgdGhlIG5ldyAnYmVzdCcgdGlsZVxuICAgIGlmIChiZXN0ICYmICFiZXN0LmNvbnRleHQyRCkge1xuICAgICAgICBsb2FkVGlsZSggdGlsZWRJbWFnZSwgYmVzdCwgY3VycmVudFRpbWUgKTtcbiAgICB9XG5cbn1cblxuXG5mdW5jdGlvbiB1cGRhdGVMZXZlbCggdGlsZWRJbWFnZSwgaGF2ZURyYXduLCBkcmF3TGV2ZWwsIGxldmVsLCBsZXZlbE9wYWNpdHksIGxldmVsVmlzaWJpbGl0eSwgdmlld3BvcnRUTCwgdmlld3BvcnRCUiwgY3VycmVudFRpbWUsIGJlc3QgKXtcblxuICAgIHZhciB4LCB5LFxuICAgICAgICB0aWxlVEwsXG4gICAgICAgIHRpbGVCUixcbiAgICAgICAgbnVtYmVyT2ZUaWxlcyxcbiAgICAgICAgdmlld3BvcnRDZW50ZXIgID0gdGlsZWRJbWFnZS52aWV3cG9ydC5waXhlbEZyb21Qb2ludCggdGlsZWRJbWFnZS52aWV3cG9ydC5nZXRDZW50ZXIoKSApO1xuXG5cbiAgICBpZiggdGlsZWRJbWFnZS52aWV3ZXIgKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxlbT4tIE5lZWRzIGRvY3VtZW50YXRpb24gLTwvZW0+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCB1cGRhdGUtbGV2ZWxcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZWRJbWFnZX0gdGlsZWRJbWFnZSAtIFdoaWNoIFRpbGVkSW1hZ2UgaXMgYmVpbmcgZHJhd24uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoYXZlZHJhd25cbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGxldmVsXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcGFjaXR5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB2aXNpYmlsaXR5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0b3BsZWZ0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBib3R0b21yaWdodFxuICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY3VycmVudHRpbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGJlc3RcbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGlsZWRJbWFnZS52aWV3ZXIucmFpc2VFdmVudCggJ3VwZGF0ZS1sZXZlbCcsIHtcbiAgICAgICAgICAgIHRpbGVkSW1hZ2U6IHRpbGVkSW1hZ2UsXG4gICAgICAgICAgICBoYXZlZHJhd246IGhhdmVEcmF3bixcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIG9wYWNpdHk6IGxldmVsT3BhY2l0eSxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGxldmVsVmlzaWJpbGl0eSxcbiAgICAgICAgICAgIHRvcGxlZnQ6IHZpZXdwb3J0VEwsXG4gICAgICAgICAgICBib3R0b21yaWdodDogdmlld3BvcnRCUixcbiAgICAgICAgICAgIGN1cnJlbnR0aW1lOiBjdXJyZW50VGltZSxcbiAgICAgICAgICAgIGJlc3Q6IGJlc3RcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy9PSywgYSBuZXcgZHJhd2luZyBzbyBkbyB5b3VyIGNhbGN1bGF0aW9uc1xuICAgIHRpbGVUTCAgICA9IHRpbGVkSW1hZ2Uuc291cmNlLmdldFRpbGVBdFBvaW50KCBsZXZlbCwgdmlld3BvcnRUTC5kaXZpZGUoIHRpbGVkSW1hZ2UuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWUgKSk7XG4gICAgdGlsZUJSICAgID0gdGlsZWRJbWFnZS5zb3VyY2UuZ2V0VGlsZUF0UG9pbnQoIGxldmVsLCB2aWV3cG9ydEJSLmRpdmlkZSggdGlsZWRJbWFnZS5fc2NhbGVTcHJpbmcuY3VycmVudC52YWx1ZSApKTtcbiAgICBudW1iZXJPZlRpbGVzICA9IHRpbGVkSW1hZ2Uuc291cmNlLmdldE51bVRpbGVzKCBsZXZlbCApO1xuXG4gICAgcmVzZXRDb3ZlcmFnZSggdGlsZWRJbWFnZS5jb3ZlcmFnZSwgbGV2ZWwgKTtcblxuICAgIGlmICggIXRpbGVkSW1hZ2Uud3JhcEhvcml6b250YWwgKSB7XG4gICAgICAgIHRpbGVCUi54ID0gTWF0aC5taW4oIHRpbGVCUi54LCBudW1iZXJPZlRpbGVzLnggLSAxICk7XG4gICAgfVxuICAgIGlmICggIXRpbGVkSW1hZ2Uud3JhcFZlcnRpY2FsICkge1xuICAgICAgICB0aWxlQlIueSA9IE1hdGgubWluKCB0aWxlQlIueSwgbnVtYmVyT2ZUaWxlcy55IC0gMSApO1xuICAgIH1cblxuICAgIGZvciAoIHggPSB0aWxlVEwueDsgeCA8PSB0aWxlQlIueDsgeCsrICkge1xuICAgICAgICBmb3IgKCB5ID0gdGlsZVRMLnk7IHkgPD0gdGlsZUJSLnk7IHkrKyApIHtcblxuICAgICAgICAgICAgYmVzdCA9IHVwZGF0ZVRpbGUoXG4gICAgICAgICAgICAgICAgdGlsZWRJbWFnZSxcbiAgICAgICAgICAgICAgICBkcmF3TGV2ZWwsXG4gICAgICAgICAgICAgICAgaGF2ZURyYXduLFxuICAgICAgICAgICAgICAgIHgsIHksXG4gICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgbGV2ZWxPcGFjaXR5LFxuICAgICAgICAgICAgICAgIGxldmVsVmlzaWJpbGl0eSxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydENlbnRlcixcbiAgICAgICAgICAgICAgICBudW1iZXJPZlRpbGVzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgIGJlc3RcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUaWxlKCB0aWxlZEltYWdlLCBkcmF3TGV2ZWwsIGhhdmVEcmF3biwgeCwgeSwgbGV2ZWwsIGxldmVsT3BhY2l0eSwgbGV2ZWxWaXNpYmlsaXR5LCB2aWV3cG9ydENlbnRlciwgbnVtYmVyT2ZUaWxlcywgY3VycmVudFRpbWUsIGJlc3Qpe1xuXG4gICAgdmFyIHRpbGUgPSBnZXRUaWxlKFxuICAgICAgICAgICAgeCwgeSxcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgdGlsZWRJbWFnZS5zb3VyY2UsXG4gICAgICAgICAgICB0aWxlZEltYWdlLnRpbGVzTWF0cml4LFxuICAgICAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgICAgICBudW1iZXJPZlRpbGVzLFxuICAgICAgICAgICAgdGlsZWRJbWFnZS5fd29ybGRXaWR0aEN1cnJlbnQsXG4gICAgICAgICAgICB0aWxlZEltYWdlLl93b3JsZEhlaWdodEN1cnJlbnRcbiAgICAgICAgKSxcbiAgICAgICAgZHJhd1RpbGUgPSBkcmF3TGV2ZWw7XG5cbiAgICBpZiggdGlsZWRJbWFnZS52aWV3ZXIgKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxlbT4tIE5lZWRzIGRvY3VtZW50YXRpb24gLTwvZW0+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCB1cGRhdGUtdGlsZVxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgVmlld2VyIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSB0aWxlZEltYWdlIC0gV2hpY2ggVGlsZWRJbWFnZSBpcyBiZWluZyBkcmF3bi5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGV9IHRpbGVcbiAgICAgICAgICogQHByb3BlcnR5IHs/T2JqZWN0fSB1c2VyRGF0YSAtIEFyYml0cmFyeSBzdWJzY3JpYmVyLWRlZmluZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGlsZWRJbWFnZS52aWV3ZXIucmFpc2VFdmVudCggJ3VwZGF0ZS10aWxlJywge1xuICAgICAgICAgICAgdGlsZWRJbWFnZTogdGlsZWRJbWFnZSxcbiAgICAgICAgICAgIHRpbGU6IHRpbGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0Q292ZXJhZ2UoIHRpbGVkSW1hZ2UuY292ZXJhZ2UsIGxldmVsLCB4LCB5LCBmYWxzZSApO1xuXG4gICAgaWYgKCAhdGlsZS5leGlzdHMgKSB7XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgIH1cblxuICAgIGlmICggaGF2ZURyYXduICYmICFkcmF3VGlsZSApIHtcbiAgICAgICAgaWYgKCBpc0NvdmVyZWQoIHRpbGVkSW1hZ2UuY292ZXJhZ2UsIGxldmVsLCB4LCB5ICkgKSB7XG4gICAgICAgICAgICBzZXRDb3ZlcmFnZSggdGlsZWRJbWFnZS5jb3ZlcmFnZSwgbGV2ZWwsIHgsIHksIHRydWUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdUaWxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICggIWRyYXdUaWxlICkge1xuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICB9XG5cbiAgICBwb3NpdGlvblRpbGUoXG4gICAgICAgIHRpbGUsXG4gICAgICAgIHRpbGVkSW1hZ2Uuc291cmNlLnRpbGVPdmVybGFwLFxuICAgICAgICB0aWxlZEltYWdlLnZpZXdwb3J0LFxuICAgICAgICB2aWV3cG9ydENlbnRlcixcbiAgICAgICAgbGV2ZWxWaXNpYmlsaXR5LFxuICAgICAgICB0aWxlZEltYWdlXG4gICAgKTtcblxuICAgIGlmICghdGlsZS5sb2FkZWQpIHtcbiAgICAgICAgaWYgKHRpbGUuY29udGV4dDJEKSB7XG4gICAgICAgICAgICBzZXRUaWxlTG9hZGVkKHRpbGVkSW1hZ2UsIHRpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltYWdlUmVjb3JkID0gdGlsZWRJbWFnZS5fdGlsZUNhY2hlLmdldEltYWdlUmVjb3JkKHRpbGUudXJsKTtcbiAgICAgICAgICAgIGlmIChpbWFnZVJlY29yZCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGltYWdlUmVjb3JkLmdldEltYWdlKCk7XG4gICAgICAgICAgICAgICAgc2V0VGlsZUxvYWRlZCh0aWxlZEltYWdlLCB0aWxlLCBpbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIHRpbGUubG9hZGVkICkge1xuICAgICAgICB2YXIgbmVlZHNEcmF3ID0gYmxlbmRUaWxlKFxuICAgICAgICAgICAgdGlsZWRJbWFnZSxcbiAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBsZXZlbE9wYWNpdHksXG4gICAgICAgICAgICBjdXJyZW50VGltZVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICggbmVlZHNEcmF3ICkge1xuICAgICAgICAgICAgdGlsZWRJbWFnZS5fbmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIHRpbGUubG9hZGluZyApIHtcbiAgICAgICAgLy8gdGhlIHRpbGUgaXMgYWxyZWFkeSBpbiB0aGUgZG93bmxvYWQgcXVldWVcbiAgICAgICAgLy8gdGhhbmtzIGpvc2gxMDkzIGZvciBmaW5hbGx5IHRyYW5zbGF0aW5nIHRoaXMgdHlwb1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJlc3QgPSBjb21wYXJlVGlsZXMoIGJlc3QsIHRpbGUgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdDtcbn1cblxuZnVuY3Rpb24gZ2V0VGlsZSggeCwgeSwgbGV2ZWwsIHRpbGVTb3VyY2UsIHRpbGVzTWF0cml4LCB0aW1lLCBudW1UaWxlcywgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQgKSB7XG4gICAgdmFyIHhNb2QsXG4gICAgICAgIHlNb2QsXG4gICAgICAgIGJvdW5kcyxcbiAgICAgICAgZXhpc3RzLFxuICAgICAgICB1cmwsXG4gICAgICAgIGNvbnRleHQyRCxcbiAgICAgICAgdGlsZTtcblxuICAgIGlmICggIXRpbGVzTWF0cml4WyBsZXZlbCBdICkge1xuICAgICAgICB0aWxlc01hdHJpeFsgbGV2ZWwgXSA9IHt9O1xuICAgIH1cbiAgICBpZiAoICF0aWxlc01hdHJpeFsgbGV2ZWwgXVsgeCBdICkge1xuICAgICAgICB0aWxlc01hdHJpeFsgbGV2ZWwgXVsgeCBdID0ge307XG4gICAgfVxuXG4gICAgaWYgKCAhdGlsZXNNYXRyaXhbIGxldmVsIF1bIHggXVsgeSBdICkge1xuICAgICAgICB4TW9kICAgID0gKCBudW1UaWxlcy54ICsgKCB4ICUgbnVtVGlsZXMueCApICkgJSBudW1UaWxlcy54O1xuICAgICAgICB5TW9kICAgID0gKCBudW1UaWxlcy55ICsgKCB5ICUgbnVtVGlsZXMueSApICkgJSBudW1UaWxlcy55O1xuICAgICAgICBib3VuZHMgID0gdGlsZVNvdXJjZS5nZXRUaWxlQm91bmRzKCBsZXZlbCwgeE1vZCwgeU1vZCApO1xuICAgICAgICBleGlzdHMgID0gdGlsZVNvdXJjZS50aWxlRXhpc3RzKCBsZXZlbCwgeE1vZCwgeU1vZCApO1xuICAgICAgICB1cmwgICAgID0gdGlsZVNvdXJjZS5nZXRUaWxlVXJsKCBsZXZlbCwgeE1vZCwgeU1vZCApO1xuICAgICAgICBjb250ZXh0MkQgPSB0aWxlU291cmNlLmdldENvbnRleHQyRCA/XG4gICAgICAgICAgICB0aWxlU291cmNlLmdldENvbnRleHQyRChsZXZlbCwgeE1vZCwgeU1vZCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgYm91bmRzLnggKz0gKCB4IC0geE1vZCApIC8gbnVtVGlsZXMueDtcbiAgICAgICAgYm91bmRzLnkgKz0gKHdvcmxkSGVpZ2h0IC8gd29ybGRXaWR0aCkgKiAoKCB5IC0geU1vZCApIC8gbnVtVGlsZXMueSk7XG5cbiAgICAgICAgdGlsZXNNYXRyaXhbIGxldmVsIF1bIHggXVsgeSBdID0gbmV3ICQuVGlsZShcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICBleGlzdHMsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBjb250ZXh0MkRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB0aWxlID0gdGlsZXNNYXRyaXhbIGxldmVsIF1bIHggXVsgeSBdO1xuICAgIHRpbGUubGFzdFRvdWNoVGltZSA9IHRpbWU7XG5cbiAgICByZXR1cm4gdGlsZTtcbn1cblxuZnVuY3Rpb24gbG9hZFRpbGUoIHRpbGVkSW1hZ2UsIHRpbGUsIHRpbWUgKSB7XG4gICAgdGlsZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICB0aWxlZEltYWdlLl9pbWFnZUxvYWRlci5hZGRKb2Ioe1xuICAgICAgICBzcmM6IHRpbGUudXJsLFxuICAgICAgICBjcm9zc09yaWdpblBvbGljeTogdGlsZWRJbWFnZS5jcm9zc09yaWdpblBvbGljeSxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCBpbWFnZSwgZXJyb3JNc2cgKXtcbiAgICAgICAgICAgIG9uVGlsZUxvYWQoIHRpbGVkSW1hZ2UsIHRpbGUsIHRpbWUsIGltYWdlLCBlcnJvck1zZyApO1xuICAgICAgICB9LFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvblRpbGVMb2FkKCB0aWxlZEltYWdlLCB0aWxlLCB0aW1lLCBpbWFnZSwgZXJyb3JNc2cgKSB7XG4gICAgaWYgKCAhaW1hZ2UgKSB7XG4gICAgICAgICQuY29uc29sZS5sb2coIFwiVGlsZSAlcyBmYWlsZWQgdG8gbG9hZDogJXMgLSBlcnJvcjogJXNcIiwgdGlsZSwgdGlsZS51cmwsIGVycm9yTXNnICk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgZmFpbHMgdG8gbG9hZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IHRpbGUtbG9hZC1mYWlsZWRcbiAgICAgICAgICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb24uVmlld2VyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlfSB0aWxlIC0gVGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IHRpbGVkSW1hZ2UgLSBUaGUgdGlsZWQgaW1hZ2UgdGhlIHRpbGUgYmVsb25ncyB0by5cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgd2hlbiB0aGUgdGlsZSBsb2FkIGJlZ2FuLlxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGlsZWRJbWFnZS52aWV3ZXIucmFpc2VFdmVudChcInRpbGUtbG9hZC1mYWlsZWRcIiwge3RpbGU6IHRpbGUsIHRpbGVkSW1hZ2U6IHRpbGVkSW1hZ2UsIHRpbWU6IHRpbWUsIG1lc3NhZ2U6IGVycm9yTXNnfSk7XG4gICAgICAgIHRpbGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aWxlLmV4aXN0cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCB0aW1lIDwgdGlsZWRJbWFnZS5sYXN0UmVzZXRUaW1lICkge1xuICAgICAgICAkLmNvbnNvbGUubG9nKCBcIklnbm9yaW5nIHRpbGUgJXMgbG9hZGVkIGJlZm9yZSByZXNldDogJXNcIiwgdGlsZSwgdGlsZS51cmwgKTtcbiAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXRvZmYgPSBNYXRoLmNlaWwoIE1hdGgubG9nKFxuICAgICAgICAgICAgdGlsZWRJbWFnZS5zb3VyY2UuZ2V0VGlsZVdpZHRoKHRpbGUubGV2ZWwpICkgLyBNYXRoLmxvZyggMiApICk7XG4gICAgICAgIHNldFRpbGVMb2FkZWQodGlsZWRJbWFnZSwgdGlsZSwgaW1hZ2UsIGN1dG9mZik7XG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIG1pZC11cGRhdGU7IHRoaXMgY2FuIGhhcHBlbiBvbiBJRTggYmVjYXVzZSBpbWFnZSBsb2FkIGV2ZW50cyBmb3JcbiAgICAvLyBjYWNoZWQgaW1hZ2VzIGhhcHBlbiBpbW1lZGlhdGVseSB0aGVyZVxuICAgIGlmICggIXRpbGVkSW1hZ2UuX21pZERyYXcgKSB7XG4gICAgICAgIGZpbmlzaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdhaXQgdW50aWwgYWZ0ZXIgdGhlIHVwZGF0ZSwgaW4gY2FzZSBjYWNoaW5nIHVubG9hZHMgYW55IHRpbGVzXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBmaW5pc2gsIDEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0VGlsZUxvYWRlZCh0aWxlZEltYWdlLCB0aWxlLCBpbWFnZSwgY3V0b2ZmKSB7XG4gICAgdmFyIGluY3JlbWVudCA9IDA7XG5cbiAgICBmdW5jdGlvbiBnZXRDb21wbGV0aW9uQ2FsbGJhY2soKSB7XG4gICAgICAgIGluY3JlbWVudCsrO1xuICAgICAgICByZXR1cm4gY29tcGxldGlvbkNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRpb25DYWxsYmFjaygpIHtcbiAgICAgICAgaW5jcmVtZW50LS07XG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT09IDApIHtcbiAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0aWxlLmNvbnRleHQyRCkge1xuICAgICAgICAgICAgICAgIHRpbGVkSW1hZ2UuX3RpbGVDYWNoZS5jYWNoZVRpbGUoe1xuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgIGN1dG9mZjogY3V0b2ZmLFxuICAgICAgICAgICAgICAgICAgICB0aWxlZEltYWdlOiB0aWxlZEltYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aWxlZEltYWdlLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIGhhcyBqdXN0IGJlZW4gbG9hZGVkIGluIG1lbW9yeS4gVGhhdCBtZWFucyB0aGF0IHRoZVxuICAgICAqIGltYWdlIGhhcyBiZWVuIGRvd25sb2FkZWQgYW5kIGNhbiBiZSBtb2RpZmllZCBiZWZvcmUgYmVpbmcgZHJhd24gdG8gdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBldmVudCB0aWxlLWxvYWRlZFxuICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtJbWFnZX0gaW1hZ2UgLSBUaGUgaW1hZ2Ugb2YgdGhlIHRpbGUuXG4gICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IHRpbGVkSW1hZ2UgLSBUaGUgdGlsZWQgaW1hZ2Ugb2YgdGhlIGxvYWRlZCB0aWxlLlxuICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlfSB0aWxlIC0gVGhlIHRpbGUgd2hpY2ggaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldENvbXBsZXRpb25DYWxsYmFjayAtIEEgZnVuY3Rpb24gZ2l2aW5nIGEgY2FsbGJhY2sgdG8gY2FsbFxuICAgICAqIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBwcm9jZXNzaW5nIG9mIHRoZSBpbWFnZSBpcyBkb25lLiBUaGUgaW1hZ2Ugd2lsbCBiZVxuICAgICAqIG1hcmtlZCBhcyBlbnRpcmVseSBsb2FkZWQgd2hlbiB0aGUgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkIG9uY2UgZm9yIGVhY2hcbiAgICAgKiBjYWxsIHRvIGdldENvbXBsZXRpb25DYWxsYmFjay5cbiAgICAgKi9cbiAgICB0aWxlZEltYWdlLnZpZXdlci5yYWlzZUV2ZW50KFwidGlsZS1sb2FkZWRcIiwge1xuICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICB0aWxlZEltYWdlOiB0aWxlZEltYWdlLFxuICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgIGdldENvbXBsZXRpb25DYWxsYmFjazogZ2V0Q29tcGxldGlvbkNhbGxiYWNrXG4gICAgfSk7XG4gICAgLy8gSW4gY2FzZSB0aGUgY29tcGxldGlvbiBjYWxsYmFjayBpcyBuZXZlciBjYWxsZWQsIHdlIGF0IGxlYXN0IGZvcmNlIGl0IG9uY2UuXG4gICAgZ2V0Q29tcGxldGlvbkNhbGxiYWNrKCkoKTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25UaWxlKCB0aWxlLCBvdmVybGFwLCB2aWV3cG9ydCwgdmlld3BvcnRDZW50ZXIsIGxldmVsVmlzaWJpbGl0eSwgdGlsZWRJbWFnZSApe1xuICAgIHZhciBib3VuZHNUTCAgICAgPSB0aWxlLmJvdW5kcy5nZXRUb3BMZWZ0KCk7XG5cbiAgICBib3VuZHNUTC54ICo9IHRpbGVkSW1hZ2UuX3NjYWxlU3ByaW5nLmN1cnJlbnQudmFsdWU7XG4gICAgYm91bmRzVEwueSAqPSB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgIGJvdW5kc1RMLnggKz0gdGlsZWRJbWFnZS5feFNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgIGJvdW5kc1RMLnkgKz0gdGlsZWRJbWFnZS5feVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgdmFyIGJvdW5kc1NpemUgICA9IHRpbGUuYm91bmRzLmdldFNpemUoKTtcblxuICAgIGJvdW5kc1NpemUueCAqPSB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuICAgIGJvdW5kc1NpemUueSAqPSB0aWxlZEltYWdlLl9zY2FsZVNwcmluZy5jdXJyZW50LnZhbHVlO1xuXG4gICAgdmFyIHBvc2l0aW9uQyAgICA9IHZpZXdwb3J0LnBpeGVsRnJvbVBvaW50Tm9Sb3RhdGUoYm91bmRzVEwsIHRydWUpLFxuICAgICAgICBwb3NpdGlvblQgICAgPSB2aWV3cG9ydC5waXhlbEZyb21Qb2ludE5vUm90YXRlKGJvdW5kc1RMLCBmYWxzZSksXG4gICAgICAgIHNpemVDICAgICAgICA9IHZpZXdwb3J0LmRlbHRhUGl4ZWxzRnJvbVBvaW50c05vUm90YXRlKGJvdW5kc1NpemUsIHRydWUpLFxuICAgICAgICBzaXplVCAgICAgICAgPSB2aWV3cG9ydC5kZWx0YVBpeGVsc0Zyb21Qb2ludHNOb1JvdGF0ZShib3VuZHNTaXplLCBmYWxzZSksXG4gICAgICAgIHRpbGVDZW50ZXIgICA9IHBvc2l0aW9uVC5wbHVzKCBzaXplVC5kaXZpZGUoIDIgKSApLFxuICAgICAgICB0aWxlRGlzdGFuY2UgPSB2aWV3cG9ydENlbnRlci5kaXN0YW5jZVRvKCB0aWxlQ2VudGVyICk7XG5cbiAgICBpZiAoICFvdmVybGFwICkge1xuICAgICAgICBzaXplQyA9IHNpemVDLnBsdXMoIG5ldyAkLlBvaW50KCAxLCAxICkgKTtcbiAgICB9XG5cbiAgICB0aWxlLnBvc2l0aW9uICAgPSBwb3NpdGlvbkM7XG4gICAgdGlsZS5zaXplICAgICAgID0gc2l6ZUM7XG4gICAgdGlsZS5kaXN0YW5jZSAgID0gdGlsZURpc3RhbmNlO1xuICAgIHRpbGUudmlzaWJpbGl0eSA9IGxldmVsVmlzaWJpbGl0eTtcbn1cblxuXG5mdW5jdGlvbiBibGVuZFRpbGUoIHRpbGVkSW1hZ2UsIHRpbGUsIHgsIHksIGxldmVsLCBsZXZlbE9wYWNpdHksIGN1cnJlbnRUaW1lICl7XG4gICAgdmFyIGJsZW5kVGltZU1pbGxpcyA9IDEwMDAgKiB0aWxlZEltYWdlLmJsZW5kVGltZSxcbiAgICAgICAgZGVsdGFUaW1lLFxuICAgICAgICBvcGFjaXR5O1xuXG4gICAgaWYgKCAhdGlsZS5ibGVuZFN0YXJ0ICkge1xuICAgICAgICB0aWxlLmJsZW5kU3RhcnQgPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICBkZWx0YVRpbWUgICA9IGN1cnJlbnRUaW1lIC0gdGlsZS5ibGVuZFN0YXJ0O1xuICAgIG9wYWNpdHkgICAgID0gYmxlbmRUaW1lTWlsbGlzID8gTWF0aC5taW4oIDEsIGRlbHRhVGltZSAvICggYmxlbmRUaW1lTWlsbGlzICkgKSA6IDE7XG5cbiAgICBpZiAoIHRpbGVkSW1hZ2UuYWx3YXlzQmxlbmQgKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gbGV2ZWxPcGFjaXR5O1xuICAgIH1cblxuICAgIHRpbGUub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICB0aWxlZEltYWdlLmxhc3REcmF3bi5wdXNoKCB0aWxlICk7XG5cbiAgICBpZiAoIG9wYWNpdHkgPT0gMSApIHtcbiAgICAgICAgc2V0Q292ZXJhZ2UoIHRpbGVkSW1hZ2UuY292ZXJhZ2UsIGxldmVsLCB4LCB5LCB0cnVlICk7XG4gICAgICAgIHRpbGVkSW1hZ2UuX2hhc09wYXF1ZVRpbGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIGRlbHRhVGltZSA8IGJsZW5kVGltZU1pbGxpcyApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdGlsZSBwcm92aWRlcyBjb3ZlcmFnZSB0byBsb3dlci1sZXZlbCB0aWxlcyBvZlxuICogbG93ZXIgcmVzb2x1dGlvbiByZXByZXNlbnRpbmcgdGhlIHNhbWUgY29udGVudC4gSWYgbmVpdGhlciB4IG5vciB5IGlzXG4gKiBnaXZlbiwgcmV0dXJucyB0cnVlIGlmIHRoZSBlbnRpcmUgdmlzaWJsZSBsZXZlbCBwcm92aWRlcyBjb3ZlcmFnZS5cbiAqXG4gKiBOb3RlIHRoYXQgb3V0LW9mLWJvdW5kcyB0aWxlcyBwcm92aWRlIGNvdmVyYWdlIGluIHRoaXMgc2Vuc2UsIHNpbmNlXG4gKiB0aGVyZSdzIG5vIGNvbnRlbnQgdGhhdCB0aGV5IHdvdWxkIG5lZWQgdG8gY292ZXIuIFRpbGVzIGF0IG5vbi1leGlzdGVudFxuICogbGV2ZWxzIHRoYXQgYXJlIHdpdGhpbiB0aGUgaW1hZ2UgYm91bmRzLCBob3dldmVyLCBkbyBub3QuXG4gKi9cbmZ1bmN0aW9uIHByb3ZpZGVzQ292ZXJhZ2UoIGNvdmVyYWdlLCBsZXZlbCwgeCwgeSApIHtcbiAgICB2YXIgcm93cyxcbiAgICAgICAgY29scyxcbiAgICAgICAgaSwgajtcblxuICAgIGlmICggIWNvdmVyYWdlWyBsZXZlbCBdICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCB4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICByb3dzID0gY292ZXJhZ2VbIGxldmVsIF07XG4gICAgICAgIGZvciAoIGkgaW4gcm93cyApIHtcbiAgICAgICAgICAgIGlmICggcm93cy5oYXNPd25Qcm9wZXJ0eSggaSApICkge1xuICAgICAgICAgICAgICAgIGNvbHMgPSByb3dzWyBpIF07XG4gICAgICAgICAgICAgICAgZm9yICggaiBpbiBjb2xzICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbHMuaGFzT3duUHJvcGVydHkoIGogKSAmJiAhY29sc1sgaiBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgY292ZXJhZ2VbIGxldmVsIF1bIHhdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgY292ZXJhZ2VbIGxldmVsIF1bIHggXVsgeSBdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgY292ZXJhZ2VbIGxldmVsIF1bIHggXVsgeSBdID09PSB0cnVlXG4gICAgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHRpbGUgaXMgY29tcGxldGVseSBjb3ZlcmVkIGJ5IGhpZ2hlci1sZXZlbFxuICogdGlsZXMgb2YgaGlnaGVyIHJlc29sdXRpb24gcmVwcmVzZW50aW5nIHRoZSBzYW1lIGNvbnRlbnQuIElmIG5laXRoZXIgeFxuICogbm9yIHkgaXMgZ2l2ZW4sIHJldHVybnMgdHJ1ZSBpZiB0aGUgZW50aXJlIHZpc2libGUgbGV2ZWwgaXMgY292ZXJlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb3ZlcmVkKCBjb3ZlcmFnZSwgbGV2ZWwsIHgsIHkgKSB7XG4gICAgaWYgKCB4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXNDb3ZlcmFnZSggY292ZXJhZ2UsIGxldmVsICsgMSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgcHJvdmlkZXNDb3ZlcmFnZSggY292ZXJhZ2UsIGxldmVsICsgMSwgMiAqIHgsIDIgKiB5ICkgJiZcbiAgICAgICAgICAgICBwcm92aWRlc0NvdmVyYWdlKCBjb3ZlcmFnZSwgbGV2ZWwgKyAxLCAyICogeCwgMiAqIHkgKyAxICkgJiZcbiAgICAgICAgICAgICBwcm92aWRlc0NvdmVyYWdlKCBjb3ZlcmFnZSwgbGV2ZWwgKyAxLCAyICogeCArIDEsIDIgKiB5ICkgJiZcbiAgICAgICAgICAgICBwcm92aWRlc0NvdmVyYWdlKCBjb3ZlcmFnZSwgbGV2ZWwgKyAxLCAyICogeCArIDEsIDIgKiB5ICsgMSApXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5uZXJcbiAqIFNldHMgd2hldGhlciB0aGUgZ2l2ZW4gdGlsZSBwcm92aWRlcyBjb3ZlcmFnZSBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIHNldENvdmVyYWdlKCBjb3ZlcmFnZSwgbGV2ZWwsIHgsIHksIGNvdmVycyApIHtcbiAgICBpZiAoICFjb3ZlcmFnZVsgbGV2ZWwgXSApIHtcbiAgICAgICAgJC5jb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIlNldHRpbmcgY292ZXJhZ2UgZm9yIGEgdGlsZSBiZWZvcmUgaXRzIGxldmVsJ3MgY292ZXJhZ2UgaGFzIGJlZW4gcmVzZXQ6ICVzXCIsXG4gICAgICAgICAgICBsZXZlbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCAhY292ZXJhZ2VbIGxldmVsIF1bIHggXSApIHtcbiAgICAgICAgY292ZXJhZ2VbIGxldmVsIF1bIHggXSA9IHt9O1xuICAgIH1cblxuICAgIGNvdmVyYWdlWyBsZXZlbCBdWyB4IF1bIHkgXSA9IGNvdmVycztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBSZXNldHMgY292ZXJhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSBnaXZlbiBsZXZlbC4gVGhpcyBzaG91bGQgYmUgY2FsbGVkXG4gKiBhZnRlciBldmVyeSBkcmF3IHJvdXRpbmUuIE5vdGUgdGhhdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGRyYXdcbiAqIHJvdXRpbmUsIGNvdmVyYWdlIGZvciBldmVyeSB2aXNpYmxlIHRpbGUgc2hvdWxkIGJlIGV4cGxpY2l0bHkgc2V0LlxuICovXG5mdW5jdGlvbiByZXNldENvdmVyYWdlKCBjb3ZlcmFnZSwgbGV2ZWwgKSB7XG4gICAgY292ZXJhZ2VbIGxldmVsIF0gPSB7fTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGlubmVyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlICdsYXN0IGJlc3QnIHRpbGUgZm9yIHRoZSBhcmVhIGlzIGJldHRlciB0aGFuIHRoZVxuICogdGlsZSBpbiBxdWVzdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZVRpbGVzKCBwcmV2aW91c0Jlc3QsIHRpbGUgKSB7XG4gICAgaWYgKCAhcHJldmlvdXNCZXN0ICkge1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9XG5cbiAgICBpZiAoIHRpbGUudmlzaWJpbGl0eSA+IHByZXZpb3VzQmVzdC52aXNpYmlsaXR5ICkge1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9IGVsc2UgaWYgKCB0aWxlLnZpc2liaWxpdHkgPT0gcHJldmlvdXNCZXN0LnZpc2liaWxpdHkgKSB7XG4gICAgICAgIGlmICggdGlsZS5kaXN0YW5jZSA8IHByZXZpb3VzQmVzdC5kaXN0YW5jZSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZpb3VzQmVzdDtcbn1cblxuZnVuY3Rpb24gZHJhd1RpbGVzKCB0aWxlZEltYWdlLCBsYXN0RHJhd24gKSB7XG4gICAgaWYgKGxhc3REcmF3bi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGlsZSA9IGxhc3REcmF3blswXTtcblxuICAgIHZhciB1c2VTa2V0Y2ggPSB0aWxlZEltYWdlLm9wYWNpdHkgPCAxIHx8XG4gICAgICAgICh0aWxlZEltYWdlLmNvbXBvc2l0ZU9wZXJhdGlvbiAmJlxuICAgICAgICAgICAgdGlsZWRJbWFnZS5jb21wb3NpdGVPcGVyYXRpb24gIT09ICdzb3VyY2Utb3ZlcicpIHx8XG4gICAgICAgICghdGlsZWRJbWFnZS5faXNCb3R0b21JdGVtKCkgJiYgdGlsZS5faGFzVHJhbnNwYXJlbmN5Q2hhbm5lbCgpKTtcblxuICAgIHZhciBza2V0Y2hTY2FsZTtcbiAgICB2YXIgc2tldGNoVHJhbnNsYXRlO1xuXG4gICAgdmFyIHpvb20gPSB0aWxlZEltYWdlLnZpZXdwb3J0LmdldFpvb20odHJ1ZSk7XG4gICAgdmFyIGltYWdlWm9vbSA9IHRpbGVkSW1hZ2Uudmlld3BvcnRUb0ltYWdlWm9vbSh6b29tKTtcbiAgICBpZiAoaW1hZ2Vab29tID4gdGlsZWRJbWFnZS5zbW9vdGhUaWxlRWRnZXNNaW5ab29tICYmICF0aWxlZEltYWdlLmlPU0RldmljZSkge1xuICAgICAgICAvLyBXaGVuIHpvb21lZCBpbiBhIGxvdCAoPjEwMCUpIHRoZSB0aWxlIGVkZ2VzIGFyZSB2aXNpYmxlLlxuICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIGNvbXBvc2l0ZSB0aGVtIGF0IH4xMDAlIGFuZCBzY2FsZSB0aGVtIHVwIHRvZ2V0aGVyLlxuICAgICAgICAvLyBOb3RlOiBEaXNhYmxlZCBvbiBpT1MgZGV2aWNlcyBwZXIgZGVmYXVsdCBhcyBpdCBjYXVzZXMgYSBuYXRpdmUgY3Jhc2hcbiAgICAgICAgdXNlU2tldGNoID0gdHJ1ZTtcbiAgICAgICAgc2tldGNoU2NhbGUgPSB0aWxlLmdldFNjYWxlRm9yRWRnZVNtb290aGluZygpO1xuICAgICAgICBza2V0Y2hUcmFuc2xhdGUgPSB0aWxlLmdldFRyYW5zbGF0aW9uRm9yRWRnZVNtb290aGluZyhza2V0Y2hTY2FsZSxcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5nZXRDYW52YXNTaXplKGZhbHNlKSxcbiAgICAgICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5nZXRDYW52YXNTaXplKHRydWUpKTtcbiAgICB9XG5cbiAgICB2YXIgYm91bmRzO1xuICAgIGlmICh1c2VTa2V0Y2gpIHtcbiAgICAgICAgaWYgKCFza2V0Y2hTY2FsZSkge1xuICAgICAgICAgICAgLy8gRXhjZXB0IHdoZW4gZWRnZSBzbW9vdGhpbmcsIHdlIG9ubHkgY2xlYW4gdGhlIHBhcnQgb2YgdGhlXG4gICAgICAgICAgICAvLyBza2V0Y2ggY2FudmFzIHdlIGFyZSBnb2luZyB0byB1c2UgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICAgICAgICBib3VuZHMgPSB0aWxlZEltYWdlLnZpZXdwb3J0LnZpZXdwb3J0VG9WaWV3ZXJFbGVtZW50UmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgIHRpbGVkSW1hZ2UuZ2V0Q2xpcHBlZEJvdW5kcyh0cnVlKSlcbiAgICAgICAgICAgICAgICAuZ2V0SW50ZWdlckJvdW5kaW5nQm94KClcbiAgICAgICAgICAgICAgICAudGltZXMoJC5waXhlbERlbnNpdHlSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLl9jbGVhcih0cnVlLCBib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gc2NhbGluZywgd2UgbXVzdCByb3RhdGUgb25seSB3aGVuIGJsZW5kaW5nIHRoZSBza2V0Y2ggY2FudmFzIHRvIGF2b2lkXG4gICAgLy8gaW50ZXJwb2xhdGlvblxuICAgIGlmICh0aWxlZEltYWdlLnZpZXdwb3J0LmRlZ3JlZXMgIT09IDAgJiYgIXNrZXRjaFNjYWxlKSB7XG4gICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5fb2Zmc2V0Rm9yUm90YXRpb24odGlsZWRJbWFnZS52aWV3cG9ydC5kZWdyZWVzLCB1c2VTa2V0Y2gpO1xuICAgIH1cblxuICAgIHZhciB1c2VkQ2xpcCA9IGZhbHNlO1xuICAgIGlmICggdGlsZWRJbWFnZS5fY2xpcCApIHtcbiAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLnNhdmVDb250ZXh0KHVzZVNrZXRjaCk7XG5cbiAgICAgICAgdmFyIGJveCA9IHRpbGVkSW1hZ2UuaW1hZ2VUb1ZpZXdwb3J0UmVjdGFuZ2xlKHRpbGVkSW1hZ2UuX2NsaXAsIHRydWUpO1xuICAgICAgICB2YXIgY2xpcFJlY3QgPSB0aWxlZEltYWdlLl9kcmF3ZXIudmlld3BvcnRUb0RyYXdlclJlY3RhbmdsZShib3gpO1xuICAgICAgICBpZiAoc2tldGNoU2NhbGUpIHtcbiAgICAgICAgICAgIGNsaXBSZWN0ID0gY2xpcFJlY3QudGltZXMoc2tldGNoU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2V0Y2hUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIGNsaXBSZWN0ID0gY2xpcFJlY3QudHJhbnNsYXRlKHNrZXRjaFRyYW5zbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLnNldENsaXAoY2xpcFJlY3QsIHVzZVNrZXRjaCk7XG5cbiAgICAgICAgdXNlZENsaXAgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICggdGlsZWRJbWFnZS5wbGFjZWhvbGRlckZpbGxTdHlsZSAmJiB0aWxlZEltYWdlLl9oYXNPcGFxdWVUaWxlID09PSBmYWxzZSApIHtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyUmVjdCA9IHRpbGVkSW1hZ2UuX2RyYXdlci52aWV3cG9ydFRvRHJhd2VyUmVjdGFuZ2xlKHRpbGVkSW1hZ2UuZ2V0Qm91bmRzKHRydWUpKTtcbiAgICAgICAgaWYgKHNrZXRjaFNjYWxlKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlclJlY3QgPSBwbGFjZWhvbGRlclJlY3QudGltZXMoc2tldGNoU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2V0Y2hUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyUmVjdCA9IHBsYWNlaG9sZGVyUmVjdC50cmFuc2xhdGUoc2tldGNoVHJhbnNsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWxsU3R5bGUgPSBudWxsO1xuICAgICAgICBpZiAoIHR5cGVvZiB0aWxlZEltYWdlLnBsYWNlaG9sZGVyRmlsbFN0eWxlID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICBmaWxsU3R5bGUgPSB0aWxlZEltYWdlLnBsYWNlaG9sZGVyRmlsbFN0eWxlKHRpbGVkSW1hZ2UsIHRpbGVkSW1hZ2UuX2RyYXdlci5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbGxTdHlsZSA9IHRpbGVkSW1hZ2UucGxhY2Vob2xkZXJGaWxsU3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aWxlZEltYWdlLl9kcmF3ZXIuZHJhd1JlY3RhbmdsZShwbGFjZWhvbGRlclJlY3QsIGZpbGxTdHlsZSwgdXNlU2tldGNoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gbGFzdERyYXduLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRpbGUgPSBsYXN0RHJhd25bIGkgXTtcbiAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLmRyYXdUaWxlKCB0aWxlLCB0aWxlZEltYWdlLl9kcmF3aW5nSGFuZGxlciwgdXNlU2tldGNoLCBza2V0Y2hTY2FsZSwgc2tldGNoVHJhbnNsYXRlICk7XG4gICAgICAgIHRpbGUuYmVpbmdEcmF3biA9IHRydWU7XG5cbiAgICAgICAgaWYoIHRpbGVkSW1hZ2Uudmlld2VyICl7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIDxlbT4tIE5lZWRzIGRvY3VtZW50YXRpb24gLTwvZW0+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IHRpbGUtZHJhd25cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBPcGVuU2VhZHJhZ29uLlZpZXdlclxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5WaWV3ZXJ9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFZpZXdlciB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IHRpbGVkSW1hZ2UgLSBXaGljaCBUaWxlZEltYWdlIGlzIGJlaW5nIGRyYXduLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGV9IHRpbGVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGlsZWRJbWFnZS52aWV3ZXIucmFpc2VFdmVudCggJ3RpbGUtZHJhd24nLCB7XG4gICAgICAgICAgICAgICAgdGlsZWRJbWFnZTogdGlsZWRJbWFnZSxcbiAgICAgICAgICAgICAgICB0aWxlOiB0aWxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICggdXNlZENsaXAgKSB7XG4gICAgICAgIHRpbGVkSW1hZ2UuX2RyYXdlci5yZXN0b3JlQ29udGV4dCggdXNlU2tldGNoICk7XG4gICAgfVxuXG4gICAgaWYgKHRpbGVkSW1hZ2Uudmlld3BvcnQuZGVncmVlcyAhPT0gMCAmJiAhc2tldGNoU2NhbGUpIHtcbiAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLl9yZXN0b3JlUm90YXRpb25DaGFuZ2VzKHVzZVNrZXRjaCk7XG4gICAgfVxuXG4gICAgaWYgKHVzZVNrZXRjaCkge1xuICAgICAgICB2YXIgb2Zmc2V0Rm9yUm90YXRpb24gPSB0aWxlZEltYWdlLnZpZXdwb3J0LmRlZ3JlZXMgIT09IDAgJiYgc2tldGNoU2NhbGU7XG4gICAgICAgIGlmIChvZmZzZXRGb3JSb3RhdGlvbikge1xuICAgICAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLl9vZmZzZXRGb3JSb3RhdGlvbih0aWxlZEltYWdlLnZpZXdwb3J0LmRlZ3JlZXMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlZEltYWdlLl9kcmF3ZXIuYmxlbmRTa2V0Y2goe1xuICAgICAgICAgICAgb3BhY2l0eTogdGlsZWRJbWFnZS5vcGFjaXR5LFxuICAgICAgICAgICAgc2NhbGU6IHNrZXRjaFNjYWxlLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBza2V0Y2hUcmFuc2xhdGUsXG4gICAgICAgICAgICBjb21wb3NpdGVPcGVyYXRpb246IHRpbGVkSW1hZ2UuY29tcG9zaXRlT3BlcmF0aW9uLFxuICAgICAgICAgICAgYm91bmRzOiBib3VuZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvZmZzZXRGb3JSb3RhdGlvbikge1xuICAgICAgICAgICAgdGlsZWRJbWFnZS5fZHJhd2VyLl9yZXN0b3JlUm90YXRpb25DaGFuZ2VzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3RGVidWdJbmZvKCB0aWxlZEltYWdlLCBsYXN0RHJhd24gKTtcbn1cblxuZnVuY3Rpb24gZHJhd0RlYnVnSW5mbyggdGlsZWRJbWFnZSwgbGFzdERyYXduICkge1xuICAgIGlmKCB0aWxlZEltYWdlLmRlYnVnTW9kZSApIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSBsYXN0RHJhd24ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IGxhc3REcmF3blsgaSBdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aWxlZEltYWdlLl9kcmF3ZXIuZHJhd0RlYnVnSW5mbyggdGlsZSwgbGFzdERyYXduLmxlbmd0aCwgaSApO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgJC5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFRpbGVDYWNoZVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOSBDb2RlUGxleCBGb3VuZGF0aW9uXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMyBPcGVuU2VhZHJhZ29uIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIC0gTmVpdGhlciB0aGUgbmFtZSBvZiBDb2RlUGxleCBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiAgIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4oZnVuY3Rpb24oICQgKXtcblxuLy8gcHJpdmF0ZSBjbGFzc1xudmFyIFRpbGVSZWNvcmQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLnRpbGUsIFwiW1RpbGVDYWNoZS5jYWNoZVRpbGVdIG9wdGlvbnMudGlsZSBpcyByZXF1aXJlZFwiICk7XG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy50aWxlZEltYWdlLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zLnRpbGVkSW1hZ2UgaXMgcmVxdWlyZWRcIiApO1xuICAgIHRoaXMudGlsZSA9IG9wdGlvbnMudGlsZTtcbiAgICB0aGlzLnRpbGVkSW1hZ2UgPSBvcHRpb25zLnRpbGVkSW1hZ2U7XG59O1xuXG4vLyBwcml2YXRlIGNsYXNzXG52YXIgSW1hZ2VSZWNvcmQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucywgXCJbSW1hZ2VSZWNvcmRdIG9wdGlvbnMgaXMgcmVxdWlyZWRcIiApO1xuICAgICQuY29uc29sZS5hc3NlcnQoIG9wdGlvbnMuaW1hZ2UsIFwiW0ltYWdlUmVjb3JkXSBvcHRpb25zLmltYWdlIGlzIHJlcXVpcmVkXCIgKTtcbiAgICB0aGlzLl9pbWFnZSA9IG9wdGlvbnMuaW1hZ2U7XG4gICAgdGhpcy5fdGlsZXMgPSBbXTtcbn07XG5cbkltYWdlUmVjb3JkLnByb3RvdHlwZSA9IHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl90aWxlcyA9IG51bGw7XG4gICAgfSxcblxuICAgIGdldEltYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xuICAgIH0sXG5cbiAgICBnZXRSZW5kZXJlZENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLl9pbWFnZS53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9pbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGV4dC5kcmF3SW1hZ2UoIHRoaXMuX2ltYWdlLCAwLCAwICk7XG4gICAgICAgICAgICAvL3NpbmNlIHdlIGFyZSBjYWNoaW5nIHRoZSBwcmVyZW5kZXJlZCBpbWFnZSBvbiBhIGNhbnZhc1xuICAgICAgICAgICAgLy9hbGxvdyB0aGUgaW1hZ2UgdG8gbm90IGJlIGhlbGQgaW4gbWVtb3J5XG4gICAgICAgICAgICB0aGlzLl9pbWFnZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkQ29udGV4dDtcbiAgICB9LFxuXG4gICAgc2V0UmVuZGVyZWRDb250ZXh0OiBmdW5jdGlvbihyZW5kZXJlZENvbnRleHQpIHtcbiAgICAgICAgJC5jb25zb2xlLmVycm9yKFwiSW1hZ2VSZWNvcmQuc2V0UmVuZGVyZWRDb250ZXh0IGlzIGRlcHJlY2F0ZWQuIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoZSByZW5kZXJlZCBjb250ZXh0IHNob3VsZCBiZSBjcmVhdGVkIGJ5IHRoZSBJbWFnZVJlY29yZCBcIiArXG4gICAgICAgICAgICAgICAgXCJpdHNlbGYgd2hlbiBjYWxsaW5nIEltYWdlUmVjb3JkLmdldFJlbmRlcmVkQ29udGV4dC5cIik7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGV4dCA9IHJlbmRlcmVkQ29udGV4dDtcbiAgICB9LFxuXG4gICAgYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KHRpbGUsICdbSW1hZ2VSZWNvcmQuYWRkVGlsZV0gdGlsZSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB0aGlzLl90aWxlcy5wdXNoKHRpbGUpO1xuICAgIH0sXG5cbiAgICByZW1vdmVUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90aWxlc1tpXSA9PT0gdGlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkLmNvbnNvbGUud2FybignW0ltYWdlUmVjb3JkLnJlbW92ZVRpbGVdIHRyeWluZyB0byByZW1vdmUgdW5rbm93biB0aWxlJywgdGlsZSk7XG4gICAgfSxcblxuICAgIGdldFRpbGVDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlcy5sZW5ndGg7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAY2xhc3MgVGlsZUNhY2hlXG4gKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvblxuICogQGNsYXNzZGVzYyBTdG9yZXMgYWxsIHRoZSB0aWxlcyBkaXNwbGF5ZWQgaW4gYSB7QGxpbmsgT3BlblNlYWRyYWdvbi5WaWV3ZXJ9LlxuICogWW91IGdlbmVyYWxseSB3b24ndCBoYXZlIHRvIGludGVyYWN0IHdpdGggdGhlIFRpbGVDYWNoZSBkaXJlY3RseS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhpcyBUaWxlQ2FjaGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4SW1hZ2VDYWNoZUNvdW50XSAtIFNlZSBtYXhJbWFnZUNhY2hlQ291bnQgaW5cbiAqIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICovXG4kLlRpbGVDYWNoZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fbWF4SW1hZ2VDYWNoZUNvdW50ID0gb3B0aW9ucy5tYXhJbWFnZUNhY2hlQ291bnQgfHwgJC5ERUZBVUxUX1NFVFRJTkdTLm1heEltYWdlQ2FjaGVDb3VudDtcbiAgICB0aGlzLl90aWxlc0xvYWRlZCA9IFtdO1xuICAgIHRoaXMuX2ltYWdlc0xvYWRlZCA9IFtdO1xuICAgIHRoaXMuX2ltYWdlc0xvYWRlZENvdW50ID0gMDtcbn07XG5cbi8qKiBAbGVuZHMgT3BlblNlYWRyYWdvbi5UaWxlQ2FjaGUucHJvdG90eXBlICovXG4kLlRpbGVDYWNoZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiB0aWxlcyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQgYnlcbiAgICAgKiB0aGlzIFRpbGVDYWNoZS5cbiAgICAgKi9cbiAgICBudW1UaWxlc0xvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlc0xvYWRlZC5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhY2hlcyB0aGUgc3BlY2lmaWVkIHRpbGUsIHJlbW92aW5nIGFuIG9sZCB0aWxlIGlmIG5lY2Vzc2FyeSB0byBzdGF5IHVuZGVyIHRoZVxuICAgICAqIG1heEltYWdlQ2FjaGVDb3VudCBzcGVjaWZpZWQgb24gY29uc3RydWN0aW9uLiBOb3RlIHRoYXQgaWYgbXVsdGlwbGUgdGlsZXMgcmVmZXJlbmNlXG4gICAgICogdGhlIHNhbWUgaW1hZ2UsIHRoZXJlIG1heSBiZSBtb3JlIHRpbGVzIHRoYW4gbWF4SW1hZ2VDYWNoZUNvdW50OyB0aGUgZ29hbCBpcyB0byBrZWVwXG4gICAgICogdGhlIG51bWJlciBvZiBpbWFnZXMgYmVsb3cgdGhhdCBudW1iZXIuIE5vdGUsIGFzIHdlbGwsIHRoYXQgZXZlbiB0aGUgbnVtYmVyIG9mIGltYWdlc1xuICAgICAqIG1heSB0ZW1wb3JhcmlseSBzdXJwYXNzIHRoYXQgbnVtYmVyLCBidXQgc2hvdWxkIGV2ZW50dWFsbHkgY29tZSBiYWNrIGRvd24gdG8gdGhlIG1heCBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaWxlIGluZm8uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGV9IG9wdGlvbnMudGlsZSAtIFRoZSB0aWxlIHRvIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IG9wdGlvbnMuaW1hZ2UgLSBUaGUgaW1hZ2Ugb2YgdGhlIHRpbGUgdG8gY2FjaGUuXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IG9wdGlvbnMudGlsZWRJbWFnZSAtIFRoZSBUaWxlZEltYWdlIHRoYXQgb3ducyB0aGF0IHRpbGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmN1dG9mZj0wXSAtIElmIGFkZGluZyB0aGlzIHRpbGUgZ29lcyBvdmVyIHRoZSBjYWNoZSBtYXggY291bnQsIHRoaXNcbiAgICAgKiBmdW5jdGlvbiB3aWxsIHJlbGVhc2UgYW4gb2xkIHRpbGUuIFRoZSBjdXRvZmYgb3B0aW9uIHNwZWNpZmllcyBhIHRpbGUgbGV2ZWwgYXQgb3IgYmVsb3cgd2hpY2hcbiAgICAgKiB0aWxlcyB3aWxsIG5vdCBiZSByZWxlYXNlZC5cbiAgICAgKi9cbiAgICBjYWNoZVRpbGU6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy50aWxlLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zLnRpbGUgaXMgcmVxdWlyZWRcIiApO1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLnRpbGUudXJsLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zLnRpbGUudXJsIGlzIHJlcXVpcmVkXCIgKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydCggb3B0aW9ucy50aWxlZEltYWdlLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zLnRpbGVkSW1hZ2UgaXMgcmVxdWlyZWRcIiApO1xuXG4gICAgICAgIHZhciBjdXRvZmYgPSBvcHRpb25zLmN1dG9mZiB8fCAwO1xuICAgICAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLl90aWxlc0xvYWRlZC5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGltYWdlUmVjb3JkID0gdGhpcy5faW1hZ2VzTG9hZGVkW29wdGlvbnMudGlsZS51cmxdO1xuICAgICAgICBpZiAoIWltYWdlUmVjb3JkKSB7XG4gICAgICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLmltYWdlLCBcIltUaWxlQ2FjaGUuY2FjaGVUaWxlXSBvcHRpb25zLmltYWdlIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBhbiBJbWFnZVJlY29yZFwiICk7XG4gICAgICAgICAgICBpbWFnZVJlY29yZCA9IHRoaXMuX2ltYWdlc0xvYWRlZFtvcHRpb25zLnRpbGUudXJsXSA9IG5ldyBJbWFnZVJlY29yZCh7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IG9wdGlvbnMuaW1hZ2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9pbWFnZXNMb2FkZWRDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2VSZWNvcmQuYWRkVGlsZShvcHRpb25zLnRpbGUpO1xuICAgICAgICBvcHRpb25zLnRpbGUuY2FjaGVJbWFnZVJlY29yZCA9IGltYWdlUmVjb3JkO1xuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBqdXN0IGJlY2F1c2Ugd2UncmUgdW5sb2FkaW5nIGEgdGlsZSBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW5cbiAgICAgICAgLy8gd2UncmUgdW5sb2FkaW5nIGFuIGltYWdlLiBXaXRoIHJlcGVhdGVkIGNhbGxzIGl0IHNob3VsZCBzb3J0IGl0c2VsZiBvdXQsIHRob3VnaC5cbiAgICAgICAgaWYgKCB0aGlzLl9pbWFnZXNMb2FkZWRDb3VudCA+IHRoaXMuX21heEltYWdlQ2FjaGVDb3VudCApIHtcbiAgICAgICAgICAgIHZhciB3b3JzdFRpbGUgICAgICAgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHdvcnN0VGlsZUluZGV4ICA9IC0xO1xuICAgICAgICAgICAgdmFyIHdvcnN0VGlsZVJlY29yZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcHJldlRpbGUsIHdvcnN0VGltZSwgd29yc3RMZXZlbCwgcHJldlRpbWUsIHByZXZMZXZlbCwgcHJldlRpbGVSZWNvcmQ7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gdGhpcy5fdGlsZXNMb2FkZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgICAgICAgICAgcHJldlRpbGVSZWNvcmQgPSB0aGlzLl90aWxlc0xvYWRlZFsgaSBdO1xuICAgICAgICAgICAgICAgIHByZXZUaWxlID0gcHJldlRpbGVSZWNvcmQudGlsZTtcblxuICAgICAgICAgICAgICAgIGlmICggcHJldlRpbGUubGV2ZWwgPD0gY3V0b2ZmIHx8IHByZXZUaWxlLmJlaW5nRHJhd24gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICF3b3JzdFRpbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcnN0VGlsZSAgICAgICA9IHByZXZUaWxlO1xuICAgICAgICAgICAgICAgICAgICB3b3JzdFRpbGVJbmRleCAgPSBpO1xuICAgICAgICAgICAgICAgICAgICB3b3JzdFRpbGVSZWNvcmQgPSBwcmV2VGlsZVJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJldlRpbWUgICAgPSBwcmV2VGlsZS5sYXN0VG91Y2hUaW1lO1xuICAgICAgICAgICAgICAgIHdvcnN0VGltZSAgID0gd29yc3RUaWxlLmxhc3RUb3VjaFRpbWU7XG4gICAgICAgICAgICAgICAgcHJldkxldmVsICAgPSBwcmV2VGlsZS5sZXZlbDtcbiAgICAgICAgICAgICAgICB3b3JzdExldmVsICA9IHdvcnN0VGlsZS5sZXZlbDtcblxuICAgICAgICAgICAgICAgIGlmICggcHJldlRpbWUgPCB3b3JzdFRpbWUgfHxcbiAgICAgICAgICAgICAgICAgICAoIHByZXZUaW1lID09IHdvcnN0VGltZSAmJiBwcmV2TGV2ZWwgPiB3b3JzdExldmVsICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcnN0VGlsZSAgICAgICA9IHByZXZUaWxlO1xuICAgICAgICAgICAgICAgICAgICB3b3JzdFRpbGVJbmRleCAgPSBpO1xuICAgICAgICAgICAgICAgICAgICB3b3JzdFRpbGVSZWNvcmQgPSBwcmV2VGlsZVJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggd29yc3RUaWxlICYmIHdvcnN0VGlsZUluZGV4ID49IDAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5sb2FkVGlsZSh3b3JzdFRpbGVSZWNvcmQpO1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gd29yc3RUaWxlSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90aWxlc0xvYWRlZFsgaW5zZXJ0aW9uSW5kZXggXSA9IG5ldyBUaWxlUmVjb3JkKHtcbiAgICAgICAgICAgIHRpbGU6IG9wdGlvbnMudGlsZSxcbiAgICAgICAgICAgIHRpbGVkSW1hZ2U6IG9wdGlvbnMudGlsZWRJbWFnZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCB0aWxlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0aWxlZEltYWdlLlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSB0aWxlZEltYWdlXG4gICAgICovXG4gICAgY2xlYXJUaWxlc0ZvcjogZnVuY3Rpb24oIHRpbGVkSW1hZ2UgKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQodGlsZWRJbWFnZSwgJ1tUaWxlQ2FjaGUuY2xlYXJUaWxlc0Zvcl0gdGlsZWRJbWFnZSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB2YXIgdGlsZVJlY29yZDtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5fdGlsZXNMb2FkZWQubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICB0aWxlUmVjb3JkID0gdGhpcy5fdGlsZXNMb2FkZWRbIGkgXTtcbiAgICAgICAgICAgIGlmICggdGlsZVJlY29yZC50aWxlZEltYWdlID09PSB0aWxlZEltYWdlICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubG9hZFRpbGUodGlsZVJlY29yZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlsZXNMb2FkZWQuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHByaXZhdGVcbiAgICBnZXRJbWFnZVJlY29yZDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQodXJsLCAnW1RpbGVDYWNoZS5nZXRJbWFnZVJlY29yZF0gdXJsIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZXNMb2FkZWRbdXJsXTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlUmVjb3JkKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQodGlsZVJlY29yZCwgJ1tUaWxlQ2FjaGUuX3VubG9hZFRpbGVdIHRpbGVSZWNvcmQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgdmFyIHRpbGUgPSB0aWxlUmVjb3JkLnRpbGU7XG4gICAgICAgIHZhciB0aWxlZEltYWdlID0gdGlsZVJlY29yZC50aWxlZEltYWdlO1xuXG4gICAgICAgIHRpbGUudW5sb2FkKCk7XG4gICAgICAgIHRpbGUuY2FjaGVJbWFnZVJlY29yZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGltYWdlUmVjb3JkID0gdGhpcy5faW1hZ2VzTG9hZGVkW3RpbGUudXJsXTtcbiAgICAgICAgaW1hZ2VSZWNvcmQucmVtb3ZlVGlsZSh0aWxlKTtcbiAgICAgICAgaWYgKCFpbWFnZVJlY29yZC5nZXRUaWxlQ291bnQoKSkge1xuICAgICAgICAgICAgaW1hZ2VSZWNvcmQuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ltYWdlc0xvYWRlZFt0aWxlLnVybF07XG4gICAgICAgICAgICB0aGlzLl9pbWFnZXNMb2FkZWRDb3VudC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBoYXMganVzdCBiZWVuIHVubG9hZGVkIGZyb20gbWVtb3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgdGlsZS11bmxvYWRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgT3BlblNlYWRyYWdvbi5WaWV3ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IHRpbGVkSW1hZ2UgLSBUaGUgdGlsZWQgaW1hZ2Ugb2YgdGhlIHVubG9hZGVkIHRpbGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlfSB0aWxlIC0gVGhlIHRpbGUgd2hpY2ggaGFzIGJlZW4gdW5sb2FkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aWxlZEltYWdlLnZpZXdlci5yYWlzZUV2ZW50KFwidGlsZS11bmxvYWRlZFwiLCB7XG4gICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgdGlsZWRJbWFnZTogdGlsZWRJbWFnZVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG59KCBPcGVuU2VhZHJhZ29uICkpO1xuXG4vKlxuICogT3BlblNlYWRyYWdvbiAtIFdvcmxkXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDA5IENvZGVQbGV4IEZvdW5kYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDEzIE9wZW5TZWFkcmFnb24gY29udHJpYnV0b3JzXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogLSBOZWl0aGVyIHRoZSBuYW1lIG9mIENvZGVQbGV4IEZvdW5kYXRpb24gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbihmdW5jdGlvbiggJCApe1xuXG4vKipcbiAqIEBjbGFzcyBXb3JsZFxuICogQG1lbWJlcm9mIE9wZW5TZWFkcmFnb25cbiAqIEBleHRlbmRzIE9wZW5TZWFkcmFnb24uRXZlbnRTb3VyY2VcbiAqIEBjbGFzc2Rlc2MgS2VlcHMgdHJhY2sgb2YgYWxsIG9mIHRoZSB0aWxlZCBpbWFnZXMgaW4gdGhlIHNjZW5lLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBXb3JsZCBvcHRpb25zLlxuICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gb3B0aW9ucy52aWV3ZXIgLSBUaGUgVmlld2VyIHRoYXQgb3ducyB0aGlzIFdvcmxkLlxuICoqL1xuJC5Xb3JsZCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAkLmNvbnNvbGUuYXNzZXJ0KCBvcHRpb25zLnZpZXdlciwgXCJbV29ybGRdIG9wdGlvbnMudmlld2VyIGlzIHJlcXVpcmVkXCIgKTtcblxuICAgICQuRXZlbnRTb3VyY2UuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy52aWV3ZXIgPSBvcHRpb25zLnZpZXdlcjtcbiAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25lZWRzRHJhdyA9IGZhbHNlO1xuICAgIHRoaXMuX2F1dG9SZWZpZ3VyZVNpemVzID0gdHJ1ZTtcbiAgICB0aGlzLl9uZWVkc1NpemVzRmlndXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RlbGVnYXRlZEZpZ3VyZVNpemVzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzLl9hdXRvUmVmaWd1cmVTaXplcykge1xuICAgICAgICAgICAgX3RoaXMuX2ZpZ3VyZVNpemVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5fbmVlZHNTaXplc0ZpZ3VyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2ZpZ3VyZVNpemVzKCk7XG59O1xuXG4kLmV4dGVuZCggJC5Xb3JsZC5wcm90b3R5cGUsICQuRXZlbnRTb3VyY2UucHJvdG90eXBlLCAvKiogQGxlbmRzIE9wZW5TZWFkcmFnb24uV29ybGQucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgc3BlY2lmaWVkIGl0ZW0uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IGl0ZW0gLSBUaGUgaXRlbSB0byBhZGQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmluZGV4XSAtIEluZGV4IGZvciB0aGUgaXRlbS4gSWYgbm90IHNwZWNpZmllZCwgZ29lcyBhdCB0aGUgdG9wLlxuICAgICAqIEBmaXJlcyBPcGVuU2VhZHJhZ29uLldvcmxkLmV2ZW50OmFkZC1pdGVtXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6bWV0cmljcy1jaGFuZ2VcbiAgICAgKi9cbiAgICBhZGRJdGVtOiBmdW5jdGlvbiggaXRlbSwgb3B0aW9ucyApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChpdGVtLCBcIltXb3JsZC5hZGRJdGVtXSBpdGVtIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGl0ZW0gaW5zdGFuY2VvZiAkLlRpbGVkSW1hZ2UsIFwiW1dvcmxkLmFkZEl0ZW1dIG9ubHkgVGlsZWRJbWFnZXMgc3VwcG9ydGVkIGF0IHRoaXMgdGltZVwiKTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5faXRlbXMubGVuZ3RoLCBvcHRpb25zLmluZGV4KSk7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaCggaXRlbSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2F1dG9SZWZpZ3VyZVNpemVzKSB7XG4gICAgICAgICAgICB0aGlzLl9maWd1cmVTaXplcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNTaXplc0ZpZ3VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcblxuICAgICAgICBpdGVtLmFkZEhhbmRsZXIoJ2JvdW5kcy1jaGFuZ2UnLCB0aGlzLl9kZWxlZ2F0ZWRGaWd1cmVTaXplcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhaXNlZCB3aGVuIGFuIGl0ZW0gaXMgYWRkZWQgdG8gdGhlIFdvcmxkLlxuICAgICAgICAgKiBAZXZlbnQgYWRkLWl0ZW1cbiAgICAgICAgICogQG1lbWJlck9mIE9wZW5TZWFkcmFnb24uV29ybGRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlZpZXdlcn0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgV29ybGQgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IGl0ZW0gLSBUaGUgaXRlbSB0aGF0IGhhcyBiZWVuIGFkZGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdhZGQtaXRlbScsIHtcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaXRlbSdzIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IFRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICovXG4gICAgZ2V0SXRlbUF0OiBmdW5jdGlvbiggaW5kZXggKSB7XG4gICAgICAgICQuY29uc29sZS5hc3NlcnQoaW5kZXggIT09IHVuZGVmaW5lZCwgXCJbV29ybGQuZ2V0SXRlbUF0XSBpbmRleCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zWyBpbmRleCBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBpdGVtIG9yIC0xIGlmIG5vdCBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSBpdGVtIC0gVGhlIGl0ZW0uXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBpdGVtIG9yIC0xIGlmIG5vdCBwcmVzZW50LlxuICAgICAqL1xuICAgIGdldEluZGV4T2ZJdGVtOiBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChpdGVtLCBcIltXb3JsZC5nZXRJbmRleE9mSXRlbV0gaXRlbSBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgcmV0dXJuICQuaW5kZXhPZiggdGhpcy5faXRlbXMsIGl0ZW0gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBpdGVtcyB1c2VkLlxuICAgICAqL1xuICAgIGdldEl0ZW1Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgaW5kZXggb2YgYSBpdGVtIHNvIHRoYXQgaXQgYXBwZWFycyBvdmVyIG9yIHVuZGVyIG90aGVycy5cbiAgICAgKiBAcGFyYW0ge09wZW5TZWFkcmFnb24uVGlsZWRJbWFnZX0gaXRlbSAtIFRoZSBpdGVtIHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5Xb3JsZC5ldmVudDppdGVtLWluZGV4LWNoYW5nZVxuICAgICAqL1xuICAgIHNldEl0ZW1JbmRleDogZnVuY3Rpb24oIGl0ZW0sIGluZGV4ICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGl0ZW0sIFwiW1dvcmxkLnNldEl0ZW1JbmRleF0gaXRlbSBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgJC5jb25zb2xlLmFzc2VydChpbmRleCAhPT0gdW5kZWZpbmVkLCBcIltXb3JsZC5zZXRJdGVtSW5kZXhdIGluZGV4IGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICAgIHZhciBvbGRJbmRleCA9IHRoaXMuZ2V0SW5kZXhPZkl0ZW0oIGl0ZW0gKTtcblxuICAgICAgICBpZiAoIGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJJbmRleCBiaWdnZXIgdGhhbiBudW1iZXIgb2YgbGF5ZXJzLlwiICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGluZGV4ID09PSBvbGRJbmRleCB8fCBvbGRJbmRleCA9PT0gLTEgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoIG9sZEluZGV4LCAxICk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZSggaW5kZXgsIDAsIGl0ZW0gKTtcbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gdGhlIG9yZGVyIG9mIHRoZSBpbmRleGVzIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICAgICAqIEBldmVudCBpdGVtLWluZGV4LWNoYW5nZVxuICAgICAgICAgKiBAbWVtYmVyT2YgT3BlblNlYWRyYWdvbi5Xb3JsZFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uV29ybGR9IGV2ZW50U291cmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIFdvcmxkIHdoaWNoIHJhaXNlZCB0aGUgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5UaWxlZEltYWdlfSBpdGVtIC0gVGhlIGl0ZW0gd2hvc2UgaW5kZXggaGFzXG4gICAgICAgICAqIGJlZW4gY2hhbmdlZFxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJldmlvdXNJbmRleCAtIFRoZSBwcmV2aW91cyBpbmRleCBvZiB0aGUgaXRlbVxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbmV3SW5kZXggLSBUaGUgbmV3IGluZGV4IG9mIHRoZSBpdGVtXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VFdmVudCggJ2l0ZW0taW5kZXgtY2hhbmdlJywge1xuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IG9sZEluZGV4LFxuICAgICAgICAgICAgbmV3SW5kZXg6IGluZGV4XG4gICAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGl0ZW0uXG4gICAgICogQHBhcmFtIHtPcGVuU2VhZHJhZ29uLlRpbGVkSW1hZ2V9IGl0ZW0gLSBUaGUgaXRlbSB0byByZW1vdmUuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6cmVtb3ZlLWl0ZW1cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5Xb3JsZC5ldmVudDptZXRyaWNzLWNoYW5nZVxuICAgICAqL1xuICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKCBpdGVtICkge1xuICAgICAgICAkLmNvbnNvbGUuYXNzZXJ0KGl0ZW0sIFwiW1dvcmxkLnJlbW92ZUl0ZW1dIGl0ZW0gaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gJC5pbmRleE9mKHRoaXMuX2l0ZW1zLCBpdGVtICk7XG4gICAgICAgIGlmICggaW5kZXggPT09IC0xICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5yZW1vdmVIYW5kbGVyKCdib3VuZHMtY2hhbmdlJywgdGhpcy5fZGVsZWdhdGVkRmlndXJlU2l6ZXMpO1xuICAgICAgICBpdGVtLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB0aGlzLl9maWd1cmVTaXplcygpO1xuICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yYWlzZVJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgaXRlbXMuXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6cmVtb3ZlLWl0ZW1cbiAgICAgKiBAZmlyZXMgT3BlblNlYWRyYWdvbi5Xb3JsZC5ldmVudDptZXRyaWNzLWNoYW5nZVxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIGFueSBwZW5kaW5nIGltYWdlcyBhcmUgY2FuY2VsZWQgc28gdGhlIHdvcmxkIGl0ZW1zIGRvbid0IGdldCBtZXNzZWQgdXBcbiAgICAgICAgdGhpcy52aWV3ZXIuX2NhbmNlbFBlbmRpbmdJbWFnZXMoKTtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9pdGVtc1tpXTtcbiAgICAgICAgICAgIGl0ZW0ucmVtb3ZlSGFuZGxlcignYm91bmRzLWNoYW5nZScsIHRoaXMuX2RlbGVnYXRlZEZpZ3VyZVNpemVzKTtcbiAgICAgICAgICAgIGl0ZW0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbW92ZWRJdGVtcyA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9maWd1cmVTaXplcygpO1xuICAgICAgICB0aGlzLl9uZWVkc0RyYXcgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmVkSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZW1vdmVkSXRlbXNbaV07XG4gICAgICAgICAgICB0aGlzLl9yYWlzZVJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCB0aWxlcyBhbmQgdHJpZ2dlcnMgdXBkYXRlcyBmb3IgYWxsIGl0ZW1zLlxuICAgICAqL1xuICAgIHJlc2V0SXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2ldLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyAoaS5lLiBhbmltYXRlcyBib3VuZHMgb2YpIGFsbCBpdGVtcy5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBhbmltYXRlZCA9IHRoaXMuX2l0ZW1zW2ldLnVwZGF0ZSgpIHx8IGFuaW1hdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFuaW1hdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhbGwgaXRlbXMuXG4gICAgICovXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXNbaV0uZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmVlZHNEcmF3ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGFueSBpdGVtcyBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIG5lZWRzRHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCB0aGlzLl9pdGVtc1tpXS5uZWVkc0RyYXcoKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbmVlZHNEcmF3O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3BlblNlYWRyYWdvbi5SZWN0fSBUaGUgc21hbGxlc3QgcmVjdGFuZ2xlIHRoYXQgZW5jbG9zZXMgYWxsIGl0ZW1zLCBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRIb21lQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvbWVCb3VuZHMuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gZmFjaWxpdGF0ZSB6b29tIGNvbnN0cmFpbnRzLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBwaXhlbCBkZW5zaXR5IG9mIHRoZVxuICAgICAqIGRlbnNlc3QgaXRlbSBpbiB0aGUgV29ybGQgKGkuZS4gdGhlIGl0ZW0gd2hvc2UgY29udGVudCBzaXplIHRvIHZpZXdwb3J0IHNpemVcbiAgICAgKiByYXRpbyBpcyB0aGUgaGlnaGVzdCkgYW5kIHNhdmUgaXQgYXMgdGhpcyBcImNvbnRlbnQgZmFjdG9yXCIuXG4gICAgICogQHJldHVybnMge051bWJlcn0gdGhlIG51bWJlciBvZiBjb250ZW50IHVuaXRzIHBlciB2aWV3cG9ydCB1bml0LlxuICAgICAqL1xuICAgIGdldENvbnRlbnRGYWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudEZhY3RvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIHNldHRpbmcgdGhpcyBmbGFnIHRvIGZhbHNlIGFsbG93cyB0aGUgYm91bmRzLWNoYW5nZSBldmVudCBoYW5kbGVyXG4gICAgICogb24gdGlsZWRJbWFnZXMgdG8gc2tpcCBjYWxjdWxhdGlvbnMgb24gdGhlIHdvcmxkIGJvdW5kcy4gSWYgYSBsb3Qgb2YgaW1hZ2VzIGFyZSBnb2luZyB0byBiZSBwb3NpdGlvbmVkIGluXG4gICAgICogcmFwaWQgc3VjY2Vzc2lvbiwgdGhpcyBpcyBhIGdvb2QgaWRlYS4gV2hlbiBmaW5pc2hlZCwgc2V0QXV0b1JlZmlndXJlU2l6ZXMgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRydWVcbiAgICAgKiBvciB0aGUgc3lzdGVtIG1heSBiZWhhdmUgb2RkbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdmFsdWVdIFRoZSB2YWx1ZSB0byB3aGljaCB0byBzZXQgdGhlIGZsYWcuXG4gICAgICovXG4gICAgc2V0QXV0b1JlZmlndXJlU2l6ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2F1dG9SZWZpZ3VyZVNpemVzID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmIHRoaXMuX25lZWRzU2l6ZXNGaWd1cmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maWd1cmVTaXplcygpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNTaXplc0ZpZ3VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcnJhbmdlcyBhbGwgb2YgdGhlIFRpbGVkSW1hZ2VzIHdpdGggdGhlIHNwZWNpZmllZCBzZXR0aW5ncy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFNwZWNpZmllcyBob3cgdG8gYXJyYW5nZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmltbWVkaWF0ZWx5PWZhbHNlXSAtIFdoZXRoZXIgdG8gYW5pbWF0ZSB0byB0aGUgbmV3IGFycmFuZ2VtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sYXlvdXRdIC0gU2VlIGNvbGxlY3Rpb25MYXlvdXQgaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvd3NdIC0gU2VlIGNvbGxlY3Rpb25Sb3dzIGluIHtAbGluayBPcGVuU2VhZHJhZ29uLk9wdGlvbnN9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2x1bW5zXSAtIFNlZSBjb2xsZWN0aW9uQ29sdW1ucyBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGlsZVNpemVdIC0gU2VlIGNvbGxlY3Rpb25UaWxlU2l6ZSBpbiB7QGxpbmsgT3BlblNlYWRyYWdvbi5PcHRpb25zfS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGlsZU1hcmdpbl0gLSBTZWUgY29sbGVjdGlvblRpbGVNYXJnaW4gaW4ge0BsaW5rIE9wZW5TZWFkcmFnb24uT3B0aW9uc30uXG4gICAgICogQGZpcmVzIE9wZW5TZWFkcmFnb24uV29ybGQuZXZlbnQ6bWV0cmljcy1jaGFuZ2VcbiAgICAgKi9cbiAgICBhcnJhbmdlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgaW1tZWRpYXRlbHkgPSBvcHRpb25zLmltbWVkaWF0ZWx5IHx8IGZhbHNlO1xuICAgICAgICB2YXIgbGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQgfHwgJC5ERUZBVUxUX1NFVFRJTkdTLmNvbGxlY3Rpb25MYXlvdXQ7XG4gICAgICAgIHZhciByb3dzID0gb3B0aW9ucy5yb3dzIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5jb2xsZWN0aW9uUm93cztcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBvcHRpb25zLmNvbHVtbnMgfHwgJC5ERUZBVUxUX1NFVFRJTkdTLmNvbGxlY3Rpb25Db2x1bW5zO1xuICAgICAgICB2YXIgdGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5jb2xsZWN0aW9uVGlsZVNpemU7XG4gICAgICAgIHZhciB0aWxlTWFyZ2luID0gb3B0aW9ucy50aWxlTWFyZ2luIHx8ICQuREVGQVVMVF9TRVRUSU5HUy5jb2xsZWN0aW9uVGlsZU1hcmdpbjtcbiAgICAgICAgdmFyIGluY3JlbWVudCA9IHRpbGVTaXplICsgdGlsZU1hcmdpbjtcbiAgICAgICAgdmFyIHdyYXA7XG4gICAgICAgIGlmICghb3B0aW9ucy5yb3dzICYmIGNvbHVtbnMpIHtcbiAgICAgICAgICAgIHdyYXAgPSBjb2x1bW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcCA9IE1hdGguY2VpbCh0aGlzLl9pdGVtcy5sZW5ndGggLyByb3dzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgdmFyIGl0ZW0sIGJveCwgd2lkdGgsIGhlaWdodCwgcG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5zZXRBdXRvUmVmaWd1cmVTaXplcyhmYWxzZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpICYmIChpICUgd3JhcCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9pdGVtc1tpXTtcbiAgICAgICAgICAgIGJveCA9IGl0ZW0uZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBpZiAoYm94LndpZHRoID4gYm94LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gdGlsZVNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gdGlsZVNpemUgKiAoYm94LndpZHRoIC8gYm94LmhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoICogKGJveC5oZWlnaHQgLyBib3gud2lkdGgpO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBuZXcgJC5Qb2ludCh4ICsgKCh0aWxlU2l6ZSAtIHdpZHRoKSAvIDIpLFxuICAgICAgICAgICAgICAgIHkgKyAoKHRpbGVTaXplIC0gaGVpZ2h0KSAvIDIpKTtcblxuICAgICAgICAgICAgaXRlbS5zZXRQb3NpdGlvbihwb3NpdGlvbiwgaW1tZWRpYXRlbHkpO1xuICAgICAgICAgICAgaXRlbS5zZXRXaWR0aCh3aWR0aCwgaW1tZWRpYXRlbHkpO1xuXG4gICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdXRvUmVmaWd1cmVTaXplcyh0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIF9maWd1cmVTaXplczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRIb21lQm91bmRzID0gdGhpcy5faG9tZUJvdW5kcyA/IHRoaXMuX2hvbWVCb3VuZHMuY2xvbmUoKSA6IG51bGw7XG4gICAgICAgIHZhciBvbGRDb250ZW50U2l6ZSA9IHRoaXMuX2NvbnRlbnRTaXplID8gdGhpcy5fY29udGVudFNpemUuY2xvbmUoKSA6IG51bGw7XG4gICAgICAgIHZhciBvbGRDb250ZW50RmFjdG9yID0gdGhpcy5fY29udGVudEZhY3RvciB8fCAwO1xuXG4gICAgICAgIGlmICghdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9ob21lQm91bmRzID0gbmV3ICQuUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRTaXplID0gbmV3ICQuUG9pbnQoMSwgMSk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50RmFjdG9yID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gaXRlbS5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRGYWN0b3IgPSBpdGVtLmdldENvbnRlbnRTaXplKCkueCAvIGJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgIHZhciBjbGlwcGVkQm91bmRzID0gaXRlbS5nZXRDbGlwcGVkQm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGNsaXBwZWRCb3VuZHMueDtcbiAgICAgICAgICAgIHZhciB0b3AgPSBjbGlwcGVkQm91bmRzLnk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBjbGlwcGVkQm91bmRzLnggKyBjbGlwcGVkQm91bmRzLndpZHRoO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGNsaXBwZWRCb3VuZHMueSArIGNsaXBwZWRCb3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBpdGVtLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRGYWN0b3IgPSBNYXRoLm1heCh0aGlzLl9jb250ZW50RmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBpdGVtLmdldENvbnRlbnRTaXplKCkueCAvIGJvdW5kcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgY2xpcHBlZEJvdW5kcyA9IGl0ZW0uZ2V0Q2xpcHBlZEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBjbGlwcGVkQm91bmRzLngpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgY2xpcHBlZEJvdW5kcy55KTtcbiAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBjbGlwcGVkQm91bmRzLnggKyBjbGlwcGVkQm91bmRzLndpZHRoKTtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIGNsaXBwZWRCb3VuZHMueSArIGNsaXBwZWRCb3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faG9tZUJvdW5kcyA9IG5ldyAkLlJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IG5ldyAkLlBvaW50KFxuICAgICAgICAgICAgICAgIHRoaXMuX2hvbWVCb3VuZHMud2lkdGggKiB0aGlzLl9jb250ZW50RmFjdG9yLFxuICAgICAgICAgICAgICAgIHRoaXMuX2hvbWVCb3VuZHMuaGVpZ2h0ICogdGhpcy5fY29udGVudEZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29udGVudEZhY3RvciAhPT0gb2xkQ29udGVudEZhY3RvciB8fFxuICAgICAgICAgICAgIXRoaXMuX2hvbWVCb3VuZHMuZXF1YWxzKG9sZEhvbWVCb3VuZHMpIHx8XG4gICAgICAgICAgICAhdGhpcy5fY29udGVudFNpemUuZXF1YWxzKG9sZENvbnRlbnRTaXplKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYWlzZWQgd2hlbiB0aGUgaG9tZSBib3VuZHMgb3IgY29udGVudCBmYWN0b3IgY2hhbmdlLlxuICAgICAgICAgICAgICogQGV2ZW50IG1ldHJpY3MtY2hhbmdlXG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgT3BlblNlYWRyYWdvbi5Xb3JsZFxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T3BlblNlYWRyYWdvbi5Xb3JsZH0gZXZlbnRTb3VyY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgV29ybGQgd2hpY2ggcmFpc2VkIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7P09iamVjdH0gdXNlckRhdGEgLSBBcmJpdHJhcnkgc3Vic2NyaWJlci1kZWZpbmVkIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yYWlzZUV2ZW50KCdtZXRyaWNzLWNoYW5nZScsIHt9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX3JhaXNlUmVtb3ZlSXRlbTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFpc2VkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkLlxuICAgICAgICAgKiBAZXZlbnQgcmVtb3ZlLWl0ZW1cbiAgICAgICAgICogQG1lbWJlck9mIE9wZW5TZWFkcmFnb24uV29ybGRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtPcGVuU2VhZHJhZ29uLldvcmxkfSBldmVudFNvdXJjZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBXb3JsZCB3aGljaCByYWlzZWQgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkge09wZW5TZWFkcmFnb24uVGlsZWRJbWFnZX0gaXRlbSAtIFRoZSBpdGVtJ3MgdW5kZXJseWluZyBpdGVtLlxuICAgICAgICAgKiBAcHJvcGVydHkgez9PYmplY3R9IHVzZXJEYXRhIC0gQXJiaXRyYXJ5IHN1YnNjcmliZXItZGVmaW5lZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhaXNlRXZlbnQoICdyZW1vdmUtaXRlbScsIHsgaXRlbTogaXRlbSB9ICk7XG4gICAgfVxufSk7XG5cbn0oIE9wZW5TZWFkcmFnb24gKSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW5zZWFkcmFnb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9vcGVuc2VhZHJhZ29uL2J1aWxkL29wZW5zZWFkcmFnb24vb3BlbnNlYWRyYWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('!function(t){"use strict";function e(e){this.viewer.setMouseNavEnabled(!1);var i=this.viewer.viewport.deltaPointsFromPixels(e.delta,!0),s=this.viewer.viewport.pointFromPixel(e.position,!0),r=new t.Point(s.x-i.x,s.y-i.y);if(this.rect){var n;if(this.restrictToImage&&(n=this.rect.clone()),this.rectDone){var o=this.rect.getAngleFromCenter(r),h=this.rect.getAngleFromCenter(s);this.rect.rotation=(this.rect.rotation+o-h)%Math.PI}else this.startRotated?this.rect=l(this.rotatedStartPoint,s,this.startRotatedHeight):(this.rect.width+=i.x,this.rect.height+=i.y);var d=this.viewer.world.getHomeBounds();this.restrictToImage&&!this.rect.fitsIn(new t.Rect(0,0,d.width,d.height))&&(this.rect=n)}else{if(this.restrictToImage){if(!a(this,r))return;c(i,s)}this.startRotated?(this.rotatedStartPoint=r,this.rect=l(r,s,this.startRotatedHeight)):this.rect=new t.SelectionRect(r.x,r.y,i.x,i.y),this.rectDone=!1}this.draw()}function i(){this.viewer.setMouseNavEnabled(!0),this.rectDone=!0}function s(){this.viewer.canvas.focus()}function r(e){t.addClass(this.element,"dragging");var i=this.viewer.viewport.deltaPointsFromPixels(e.delta,!0);this.rect.x+=i.x,this.rect.y+=i.y;var s=this.viewer.world.getHomeBounds();this.restrictToImage&&!this.rect.fitsIn(new t.Rect(0,0,s.width,s.height))&&(this.rect.x-=i.x,this.rect.y-=i.y),this.draw()}function n(){t.removeClass(this.element,"dragging")}function o(e,i){var s,r=i.delta,n=this.rect.getDegreeRotation(),o=this.restrictToImage?this.rect.clone():null;switch(0!==n&&(r=r.rotate(-1*n,new t.Point(0,0)),s=this.rect.getCenter()),r=this.viewer.viewport.deltaPointsFromPixels(r,!0),e){case 0:this.rect.y+=r.y,this.rect.height-=r.y;break;case 1:this.rect.width+=r.x;break;case 2:this.rect.height+=r.y;break;case 3:this.rect.x+=r.x,this.rect.width-=r.x;break;case.5:this.rect.y+=r.y,this.rect.height-=r.y,this.rect.x+=r.x,this.rect.width-=r.x;break;case 1.5:this.rect.y+=r.y,this.rect.height-=r.y,this.rect.width+=r.x;break;case 2.5:this.rect.width+=r.x,this.rect.height+=r.y;break;case 3.5:this.rect.height+=r.y,this.rect.x+=r.x,this.rect.width-=r.x}if(0!==n){var h=this.rect.getCenter(),l=h.rotate(n,s);r=l.minus(h),this.rect.x+=r.x,this.rect.y+=r.y}var a=this.viewer.world.getHomeBounds();this.restrictToImage&&!this.rect.fitsIn(new t.Rect(0,0,a.width,a.height))&&(this.rect=o),this.draw()}function h(t){var e=t.keyCode?t.keyCode:t.charCode;13===e?this.confirm():String.fromCharCode(e)===this.keyboardShortcut&&this.toggleState()}function l(e,i,s){if(e.x>i.x){var r=e;e=i,i=r}var n=i.minus(e),o=e.distanceTo(i),h=-1*Math.atan2(n.x,n.y)+Math.PI/2,l=new t.Point(n.x/2+e.x,n.y/2+e.y),a=new t.SelectionRect(l.x-o/2,l.y-s/2,o,s,h),c=new t.Point(0,s);return c=c.rotate(a.getDegreeRotation(),new t.Point(0,0)),a.x+=c.x/2,a.y+=c.y/2,a}function a(t,e){var i=t.viewer.world.getHomeBounds();return e.x>=0&&e.x<=i.width&&e.y>=0&&e.y<=i.height}function c(t,e){var i;for(var s in{x:0,y:0})i=e[s]-t[s],i<1&&i>0&&(e[s]>1?(t[s]-=e[s]-1,e[s]=1):e[s]<0&&(t[s]-=e[s],e[s]=0))}if(!t.version||t.version.major<2)throw new Error("This version of OpenSeadragonSelection requires OpenSeadragon version 2.0.0+");t.Viewer.prototype.selection=function(e){return this.selectionInstance&&!e||(e=e||{},e.viewer=this,this.selectionInstance=new t.Selection(e)),this.selectionInstance},t.Selection=function(l){t.extend(!0,this,{viewer:null,isSelecting:!1,buttonActiveImg:!1,rectDone:!0,element:null,toggleButton:null,showSelectionControl:!0,showConfirmDenyButtons:!0,styleConfirmDenyButtons:!0,returnPixelCoordinates:!0,keyboardShortcut:"c",rect:null,startRotated:!1,startRotatedHeight:.1,restrictToImage:!1,onSelection:null,prefixUrl:null,navImages:{selection:{REST:"selection_rest.png",GROUP:"selection_grouphover.png",HOVER:"selection_hover.png",DOWN:"selection_pressed.png"},selectionConfirm:{REST:"selection_confirm_rest.png",GROUP:"selection_confirm_grouphover.png",HOVER:"selection_confirm_hover.png",DOWN:"selection_confirm_pressed.png"},selectionCancel:{REST:"selection_cancel_rest.png",GROUP:"selection_cancel_grouphover.png",HOVER:"selection_cancel_hover.png",DOWN:"selection_cancel_pressed.png"}}},l),t.extend(!0,this.navImages,this.viewer.navImages),this.element||(this.element=t.makeNeutralElement("div"),this.element.style.background="rgba(0, 0, 0, 0.1)",this.element.className="selection-box"),this.borders=this.borders||[];for(var a,c=[],d=0;d<4;d++)this.borders[d]||(this.borders[d]=t.makeNeutralElement("div"),this.borders[d].className="border-"+d,this.borders[d].style.position="absolute",this.borders[d].style.width="1px",this.borders[d].style.height="1px",this.borders[d].style.background="#fff"),a=t.makeNeutralElement("div"),a.className="border-"+d+"-handle",a.style.position="absolute",a.style.top="50%",a.style.left="50%",a.style.width="6px",a.style.height="6px",a.style.margin="-4px 0 0 -4px",a.style.background="#000",a.style.border="1px solid #ccc",new t.MouseTracker({element:this.borders[d],dragHandler:o.bind(this,d)}),c[d]=t.makeNeutralElement("div"),c[d].className="corner-"+d+"-handle",c[d].style.position="absolute",c[d].style.width="6px",c[d].style.height="6px",c[d].style.background="#000",c[d].style.border="1px solid #ccc",new t.MouseTracker({element:c[d],dragHandler:o.bind(this,d+.5)}),this.borders[d].appendChild(a),this.element.appendChild(this.borders[d]),setTimeout(this.element.appendChild.bind(this.element,c[d]),0);this.borders[0].style.top=0,this.borders[0].style.width="100%",this.borders[1].style.right=0,this.borders[1].style.height="100%",this.borders[2].style.bottom=0,this.borders[2].style.width="100%",this.borders[3].style.left=0,this.borders[3].style.height="100%",c[0].style.top="-3px",c[0].style.left="-3px",c[1].style.top="-3px",c[1].style.right="-3px",c[2].style.bottom="-3px",c[2].style.right="-3px",c[3].style.bottom="-3px",c[3].style.left="-3px",this.overlay||(this.overlay=new t.SelectionOverlay(this.element,this.rect||new t.SelectionRect)),this.innerTracker=new t.MouseTracker({element:this.element,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,dragHandler:t.delegate(this,r),dragEndHandler:t.delegate(this,n),clickHandler:t.delegate(this,s)}),this.outerTracker=new t.MouseTracker({element:this.viewer.canvas,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,dragHandler:t.delegate(this,e),dragEndHandler:t.delegate(this,i),clickHandler:t.delegate(this,s),startDisabled:!this.isSelecting}),this.keyboardShortcut&&t.addEvent(this.viewer.container,"keypress",t.delegate(this,h),!1);var u=this.prefixUrl||this.viewer.prefixUrl||"",g=this.viewer.buttons&&this.viewer.buttons.buttons,m=g?this.viewer.buttons.buttons[0]:null,w=m?m.onFocus:null,v=m?m.onBlur:null;if(this.showSelectionControl&&(this.toggleButton=new t.Button({element:this.toggleButton?t.getElement(this.toggleButton):null,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,tooltip:t.getString("Tooltips.SelectionToggle")||"Toggle selection",srcRest:u+this.navImages.selection.REST,srcGroup:u+this.navImages.selection.GROUP,srcHover:u+this.navImages.selection.HOVER,srcDown:u+this.navImages.selection.DOWN,onRelease:this.toggleState.bind(this),onFocus:w,onBlur:v}),g&&(this.viewer.buttons.buttons.push(this.toggleButton),this.viewer.buttons.element.appendChild(this.toggleButton.element)),this.toggleButton.imgDown&&(this.buttonActiveImg=this.toggleButton.imgDown.cloneNode(!0),this.toggleButton.element.appendChild(this.buttonActiveImg))),this.showConfirmDenyButtons){this.confirmButton=new t.Button({element:this.confirmButton?t.getElement(this.confirmButton):null,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,tooltip:t.getString("Tooltips.SelectionConfirm")||"Confirm selection",srcRest:u+this.navImages.selectionConfirm.REST,srcGroup:u+this.navImages.selectionConfirm.GROUP,srcHover:u+this.navImages.selectionConfirm.HOVER,srcDown:u+this.navImages.selectionConfirm.DOWN,onRelease:this.confirm.bind(this),onFocus:w,onBlur:v});var p=this.confirmButton.element;p.classList.add("confirm-button"),this.element.appendChild(p),this.cancelButton=new t.Button({element:this.cancelButton?t.getElement(this.cancelButton):null,clickTimeThreshold:this.viewer.clickTimeThreshold,clickDistThreshold:this.viewer.clickDistThreshold,tooltip:t.getString("Tooltips.SelectionConfirm")||"Cancel selection",srcRest:u+this.navImages.selectionCancel.REST,srcGroup:u+this.navImages.selectionCancel.GROUP,srcHover:u+this.navImages.selectionCancel.HOVER,srcDown:u+this.navImages.selectionCancel.DOWN,onRelease:this.cancel.bind(this),onFocus:w,onBlur:v});var y=this.cancelButton.element;y.classList.add("cancel-button"),this.element.appendChild(y),this.styleConfirmDenyButtons&&(p.style.position="absolute",p.style.top="50%",p.style.left="50%",p.style.transform="translate(-100%, -50%)",y.style.position="absolute",y.style.top="50%",y.style.left="50%",y.style.transform="translate(0, -50%)")}this.viewer.addHandler("selection",this.onSelection),this.viewer.addHandler("open",this.draw.bind(this)),this.viewer.addHandler("animation",this.draw.bind(this)),this.viewer.addHandler("resize",this.draw.bind(this)),this.viewer.addHandler("rotate",this.draw.bind(this))},t.extend(t.Selection.prototype,t.ControlDock.prototype,{toggleState:function(){return this.setState(!this.isSelecting)},setState:function(t){return this.isSelecting=t,this.outerTracker.setTracking(t),t?this.draw():this.undraw(),this.buttonActiveImg&&(this.buttonActiveImg.style.visibility=t?"visible":"hidden"),this.viewer.raiseEvent("selection_toggle",{enabled:t}),this},enable:function(){return this.setState(!0)},disable:function(){return this.setState(!1)},draw:function(){return this.rect&&(this.overlay.update(this.rect.normalize()),this.overlay.drawHTML(this.viewer.drawer.container,this.viewer.viewport)),this},undraw:function(){return this.overlay.destroy(),this.rect=null,this},confirm:function(){if(this.rect){var e=this.rect.normalize();if(this.returnPixelCoordinates){var i=this.viewer.viewport.viewportToImageRectangle(e);i=t.SelectionRect.fromRect(i).round(),i.rotation=e.rotation,e=i}this.viewer.raiseEvent("selection",e),this.undraw()}return this},cancel:function(){return this.viewer.raiseEvent("selection_cancel",!1),this.undraw()}})}(OpenSeadragon),function(t){"use strict";t.SelectionOverlay=function(e,i){t.Overlay.apply(this,arguments),t.isPlainObject(e)?this.rotation=e.location.rotation||0:this.rotation=i.rotation||0},t.SelectionOverlay.prototype=t.extend(Object.create(t.Overlay.prototype),{drawHTML:function(){t.Overlay.prototype.drawHTML.apply(this,arguments),this.style.transform=this.style.transform.replace(/ ?rotate\\(.+rad\\)/,"")+" rotate("+this.rotation+"rad)"},update:function(e){t.Overlay.prototype.update.apply(this,arguments),this.rotation=e.rotation||0}})}(OpenSeadragon),function(t){"use strict";t.SelectionRect=function(e,i,s,r,n){t.Rect.apply(this,[e,i,s,r]),this.rotation=n||0},t.SelectionRect.fromRect=function(e){return new t.SelectionRect(e.x,e.y,e.width,e.height)},t.SelectionRect.prototype=t.extend(Object.create(t.Rect.prototype),{clone:function(){return new t.SelectionRect(this.x,this.y,this.width,this.height,this.rotation)},equals:function(e){return t.Rect.prototype.equals.apply(this,[e])&&this.rotation===e.rotation},toString:function(){return"["+Math.round(100*this.x)/100+","+Math.round(100*this.y)/100+","+Math.round(100*this.width)/100+"x"+Math.round(100*this.height)/100+"@"+Math.round(100*this.rotation)/100+"]"},swapWidthHeight:function(){var t=this.clone();return t.width=this.height,t.height=this.width,t.x+=(this.width-this.height)/2,t.y+=(this.height-this.width)/2,t},getDegreeRotation:function(){return this.rotation*(180/Math.PI)},getAngleFromCenter:function(t){var e=t.minus(this.getCenter());return Math.atan2(e.x,e.y)},round:function(){return new t.SelectionRect(Math.round(this.x),Math.round(this.y),Math.round(this.width),Math.round(this.height),this.rotation)},normalize:function(){var t=this.clone();return t.width<0&&(t.x+=t.width,t.width*=-1),t.height<0&&(t.y+=t.height,t.height*=-1),t.rotation%=Math.PI,t},fitsIn:function(t){for(var e=this.normalize(),i=[e.getTopLeft(),e.getTopRight(),e.getBottomRight(),e.getBottomLeft()],s=e.getCenter(),r=e.getDegreeRotation(),n=t.getBottomRight(),o=0;o<4;o++)if(i[o]=i[o].rotate(r,s),i[o].x<t.x||i[o].x>n.x||i[o].y<t.y||i[o].y>n.y)return!1;return!0},reduceRotation:function(){var t;return this.rotation<Math.PI/-4?(t=this.swapWidthHeight(),t.rotation+=Math.PI/2):this.rotation>Math.PI/4?(t=this.swapWidthHeight(),t.rotation-=Math.PI/2):t=this.clone(),t}})}(OpenSeadragon);\n//# sourceMappingURL=openseadragonselection.js.map\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9vcGVuc2VhZHJhZ29uc2VsZWN0aW9uL2Rpc3Qvb3BlbnNlYWRyYWdvbnNlbGVjdGlvbi5qcz9mZDAzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsYUFBYSxjQUFjLG1DQUFtQyxpSkFBaUosY0FBYyxNQUFNLDhEQUE4RCx3RUFBd0Usb0RBQW9ELGtJQUFrSSx3Q0FBd0MseUZBQXlGLEtBQUsseUJBQXlCLHFCQUFxQixPQUFPLHNKQUFzSixZQUFZLGFBQWEsb0RBQW9ELGFBQWEsMkJBQTJCLGNBQWMsb0NBQW9DLDZEQUE2RCxrQ0FBa0Msd0NBQXdDLDJIQUEySCxhQUFhLHVDQUF1QyxnQkFBZ0IsOEZBQThGLGdJQUFnSSw4Q0FBOEMsTUFBTSw0QkFBNEIsTUFBTSw2QkFBNkIsTUFBTSw2Q0FBNkMsTUFBTSxvRkFBb0YsTUFBTSxxRUFBcUUsTUFBTSxvREFBb0QsTUFBTSxxRUFBcUUsVUFBVSw0Q0FBNEMsK0NBQStDLHdDQUF3QyxxR0FBcUcsY0FBYyxxQ0FBcUMseUZBQXlGLGtCQUFrQixZQUFZLFFBQVEsUUFBUSx5S0FBeUssa0ZBQWtGLGdCQUFnQixxQ0FBcUMsbURBQW1ELGdCQUFnQixNQUFNLGFBQWEsUUFBUSxrRkFBa0YsaUlBQWlJLHlDQUF5QywyQ0FBMkMsaUZBQWlGLHlCQUF5QixrQkFBa0IsbVVBQW1VLFdBQVcsb0hBQW9ILG1CQUFtQixvSkFBb0osa0JBQWtCLGtKQUFrSix1T0FBdU8sbUJBQW1CLElBQUksdWhCQUF1aEIsbURBQW1ELDBPQUEwTywyQ0FBMkMsMElBQTBJLHVrQkFBdWtCLDBOQUEwTix3Q0FBd0MsZ1FBQWdRLDRGQUE0RixnTEFBZ0wsK0RBQStELG9jQUFvYyxrVEFBa1QsaUNBQWlDLGdlQUFnZSxFQUFFLGlDQUFpQyw4RkFBOEYsd2RBQXdkLEVBQUUsZ0NBQWdDLGlUQUFpVCw4UUFBOFEseURBQXlELHVCQUF1Qix3Q0FBd0Msc0JBQXNCLHFOQUFxTixVQUFVLE9BQU8sbUJBQW1CLHlCQUF5QixvQkFBb0IseUJBQXlCLGlCQUFpQiw2SUFBNkksbUJBQW1CLGtEQUFrRCxvQkFBb0IsY0FBYyw0QkFBNEIsZ0NBQWdDLHVEQUF1RCxnRUFBZ0Usb0RBQW9ELFlBQVksbUJBQW1CLG9FQUFvRSxFQUFFLDRCQUE0QixhQUFhLGlDQUFpQyxvSEFBb0gsMkVBQTJFLG9CQUFvQiw2SkFBNkosb0JBQW9CLDhFQUE4RSxFQUFFLDRCQUE0QixhQUFhLG9DQUFvQyxnREFBZ0Qsc0NBQXNDLHFEQUFxRCxxRUFBcUUsaUJBQWlCLCtFQUErRSxvQkFBb0IsMkVBQTJFLHFCQUFxQixxTEFBcUwsNEJBQTRCLG1CQUFtQixpSEFBaUgsOEJBQThCLG1DQUFtQyxnQ0FBZ0MsZ0NBQWdDLDJCQUEyQixrQkFBa0IsK0hBQStILHNCQUFzQixtQkFBbUIsNEdBQTRHLG9CQUFvQixvS0FBb0ssSUFBSSxxRkFBcUYsU0FBUywyQkFBMkIsTUFBTSw0S0FBNEssRUFBRTtBQUMzMVkiLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShlKXt0aGlzLnZpZXdlci5zZXRNb3VzZU5hdkVuYWJsZWQoITEpO3ZhciBpPXRoaXMudmlld2VyLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhlLmRlbHRhLCEwKSxzPXRoaXMudmlld2VyLnZpZXdwb3J0LnBvaW50RnJvbVBpeGVsKGUucG9zaXRpb24sITApLHI9bmV3IHQuUG9pbnQocy54LWkueCxzLnktaS55KTtpZih0aGlzLnJlY3Qpe3ZhciBuO2lmKHRoaXMucmVzdHJpY3RUb0ltYWdlJiYobj10aGlzLnJlY3QuY2xvbmUoKSksdGhpcy5yZWN0RG9uZSl7dmFyIG89dGhpcy5yZWN0LmdldEFuZ2xlRnJvbUNlbnRlcihyKSxoPXRoaXMucmVjdC5nZXRBbmdsZUZyb21DZW50ZXIocyk7dGhpcy5yZWN0LnJvdGF0aW9uPSh0aGlzLnJlY3Qucm90YXRpb24rby1oKSVNYXRoLlBJfWVsc2UgdGhpcy5zdGFydFJvdGF0ZWQ/dGhpcy5yZWN0PWwodGhpcy5yb3RhdGVkU3RhcnRQb2ludCxzLHRoaXMuc3RhcnRSb3RhdGVkSGVpZ2h0KToodGhpcy5yZWN0LndpZHRoKz1pLngsdGhpcy5yZWN0LmhlaWdodCs9aS55KTt2YXIgZD10aGlzLnZpZXdlci53b3JsZC5nZXRIb21lQm91bmRzKCk7dGhpcy5yZXN0cmljdFRvSW1hZ2UmJiF0aGlzLnJlY3QuZml0c0luKG5ldyB0LlJlY3QoMCwwLGQud2lkdGgsZC5oZWlnaHQpKSYmKHRoaXMucmVjdD1uKX1lbHNle2lmKHRoaXMucmVzdHJpY3RUb0ltYWdlKXtpZighYSh0aGlzLHIpKXJldHVybjtjKGkscyl9dGhpcy5zdGFydFJvdGF0ZWQ/KHRoaXMucm90YXRlZFN0YXJ0UG9pbnQ9cix0aGlzLnJlY3Q9bChyLHMsdGhpcy5zdGFydFJvdGF0ZWRIZWlnaHQpKTp0aGlzLnJlY3Q9bmV3IHQuU2VsZWN0aW9uUmVjdChyLngsci55LGkueCxpLnkpLHRoaXMucmVjdERvbmU9ITF9dGhpcy5kcmF3KCl9ZnVuY3Rpb24gaSgpe3RoaXMudmlld2VyLnNldE1vdXNlTmF2RW5hYmxlZCghMCksdGhpcy5yZWN0RG9uZT0hMH1mdW5jdGlvbiBzKCl7dGhpcy52aWV3ZXIuY2FudmFzLmZvY3VzKCl9ZnVuY3Rpb24gcihlKXt0LmFkZENsYXNzKHRoaXMuZWxlbWVudCxcImRyYWdnaW5nXCIpO3ZhciBpPXRoaXMudmlld2VyLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhlLmRlbHRhLCEwKTt0aGlzLnJlY3QueCs9aS54LHRoaXMucmVjdC55Kz1pLnk7dmFyIHM9dGhpcy52aWV3ZXIud29ybGQuZ2V0SG9tZUJvdW5kcygpO3RoaXMucmVzdHJpY3RUb0ltYWdlJiYhdGhpcy5yZWN0LmZpdHNJbihuZXcgdC5SZWN0KDAsMCxzLndpZHRoLHMuaGVpZ2h0KSkmJih0aGlzLnJlY3QueC09aS54LHRoaXMucmVjdC55LT1pLnkpLHRoaXMuZHJhdygpfWZ1bmN0aW9uIG4oKXt0LnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCxcImRyYWdnaW5nXCIpfWZ1bmN0aW9uIG8oZSxpKXt2YXIgcyxyPWkuZGVsdGEsbj10aGlzLnJlY3QuZ2V0RGVncmVlUm90YXRpb24oKSxvPXRoaXMucmVzdHJpY3RUb0ltYWdlP3RoaXMucmVjdC5jbG9uZSgpOm51bGw7c3dpdGNoKDAhPT1uJiYocj1yLnJvdGF0ZSgtMSpuLG5ldyB0LlBvaW50KDAsMCkpLHM9dGhpcy5yZWN0LmdldENlbnRlcigpKSxyPXRoaXMudmlld2VyLnZpZXdwb3J0LmRlbHRhUG9pbnRzRnJvbVBpeGVscyhyLCEwKSxlKXtjYXNlIDA6dGhpcy5yZWN0LnkrPXIueSx0aGlzLnJlY3QuaGVpZ2h0LT1yLnk7YnJlYWs7Y2FzZSAxOnRoaXMucmVjdC53aWR0aCs9ci54O2JyZWFrO2Nhc2UgMjp0aGlzLnJlY3QuaGVpZ2h0Kz1yLnk7YnJlYWs7Y2FzZSAzOnRoaXMucmVjdC54Kz1yLngsdGhpcy5yZWN0LndpZHRoLT1yLng7YnJlYWs7Y2FzZS41OnRoaXMucmVjdC55Kz1yLnksdGhpcy5yZWN0LmhlaWdodC09ci55LHRoaXMucmVjdC54Kz1yLngsdGhpcy5yZWN0LndpZHRoLT1yLng7YnJlYWs7Y2FzZSAxLjU6dGhpcy5yZWN0LnkrPXIueSx0aGlzLnJlY3QuaGVpZ2h0LT1yLnksdGhpcy5yZWN0LndpZHRoKz1yLng7YnJlYWs7Y2FzZSAyLjU6dGhpcy5yZWN0LndpZHRoKz1yLngsdGhpcy5yZWN0LmhlaWdodCs9ci55O2JyZWFrO2Nhc2UgMy41OnRoaXMucmVjdC5oZWlnaHQrPXIueSx0aGlzLnJlY3QueCs9ci54LHRoaXMucmVjdC53aWR0aC09ci54fWlmKDAhPT1uKXt2YXIgaD10aGlzLnJlY3QuZ2V0Q2VudGVyKCksbD1oLnJvdGF0ZShuLHMpO3I9bC5taW51cyhoKSx0aGlzLnJlY3QueCs9ci54LHRoaXMucmVjdC55Kz1yLnl9dmFyIGE9dGhpcy52aWV3ZXIud29ybGQuZ2V0SG9tZUJvdW5kcygpO3RoaXMucmVzdHJpY3RUb0ltYWdlJiYhdGhpcy5yZWN0LmZpdHNJbihuZXcgdC5SZWN0KDAsMCxhLndpZHRoLGEuaGVpZ2h0KSkmJih0aGlzLnJlY3Q9byksdGhpcy5kcmF3KCl9ZnVuY3Rpb24gaCh0KXt2YXIgZT10LmtleUNvZGU/dC5rZXlDb2RlOnQuY2hhckNvZGU7MTM9PT1lP3RoaXMuY29uZmlybSgpOlN0cmluZy5mcm9tQ2hhckNvZGUoZSk9PT10aGlzLmtleWJvYXJkU2hvcnRjdXQmJnRoaXMudG9nZ2xlU3RhdGUoKX1mdW5jdGlvbiBsKGUsaSxzKXtpZihlLng+aS54KXt2YXIgcj1lO2U9aSxpPXJ9dmFyIG49aS5taW51cyhlKSxvPWUuZGlzdGFuY2VUbyhpKSxoPS0xKk1hdGguYXRhbjIobi54LG4ueSkrTWF0aC5QSS8yLGw9bmV3IHQuUG9pbnQobi54LzIrZS54LG4ueS8yK2UueSksYT1uZXcgdC5TZWxlY3Rpb25SZWN0KGwueC1vLzIsbC55LXMvMixvLHMsaCksYz1uZXcgdC5Qb2ludCgwLHMpO3JldHVybiBjPWMucm90YXRlKGEuZ2V0RGVncmVlUm90YXRpb24oKSxuZXcgdC5Qb2ludCgwLDApKSxhLngrPWMueC8yLGEueSs9Yy55LzIsYX1mdW5jdGlvbiBhKHQsZSl7dmFyIGk9dC52aWV3ZXIud29ybGQuZ2V0SG9tZUJvdW5kcygpO3JldHVybiBlLng+PTAmJmUueDw9aS53aWR0aCYmZS55Pj0wJiZlLnk8PWkuaGVpZ2h0fWZ1bmN0aW9uIGModCxlKXt2YXIgaTtmb3IodmFyIHMgaW57eDowLHk6MH0paT1lW3NdLXRbc10saTwxJiZpPjAmJihlW3NdPjE/KHRbc10tPWVbc10tMSxlW3NdPTEpOmVbc108MCYmKHRbc10tPWVbc10sZVtzXT0wKSl9aWYoIXQudmVyc2lvbnx8dC52ZXJzaW9uLm1ham9yPDIpdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB2ZXJzaW9uIG9mIE9wZW5TZWFkcmFnb25TZWxlY3Rpb24gcmVxdWlyZXMgT3BlblNlYWRyYWdvbiB2ZXJzaW9uIDIuMC4wK1wiKTt0LlZpZXdlci5wcm90b3R5cGUuc2VsZWN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnNlbGVjdGlvbkluc3RhbmNlJiYhZXx8KGU9ZXx8e30sZS52aWV3ZXI9dGhpcyx0aGlzLnNlbGVjdGlvbkluc3RhbmNlPW5ldyB0LlNlbGVjdGlvbihlKSksdGhpcy5zZWxlY3Rpb25JbnN0YW5jZX0sdC5TZWxlY3Rpb249ZnVuY3Rpb24obCl7dC5leHRlbmQoITAsdGhpcyx7dmlld2VyOm51bGwsaXNTZWxlY3Rpbmc6ITEsYnV0dG9uQWN0aXZlSW1nOiExLHJlY3REb25lOiEwLGVsZW1lbnQ6bnVsbCx0b2dnbGVCdXR0b246bnVsbCxzaG93U2VsZWN0aW9uQ29udHJvbDohMCxzaG93Q29uZmlybURlbnlCdXR0b25zOiEwLHN0eWxlQ29uZmlybURlbnlCdXR0b25zOiEwLHJldHVyblBpeGVsQ29vcmRpbmF0ZXM6ITAsa2V5Ym9hcmRTaG9ydGN1dDpcImNcIixyZWN0Om51bGwsc3RhcnRSb3RhdGVkOiExLHN0YXJ0Um90YXRlZEhlaWdodDouMSxyZXN0cmljdFRvSW1hZ2U6ITEsb25TZWxlY3Rpb246bnVsbCxwcmVmaXhVcmw6bnVsbCxuYXZJbWFnZXM6e3NlbGVjdGlvbjp7UkVTVDpcInNlbGVjdGlvbl9yZXN0LnBuZ1wiLEdST1VQOlwic2VsZWN0aW9uX2dyb3VwaG92ZXIucG5nXCIsSE9WRVI6XCJzZWxlY3Rpb25faG92ZXIucG5nXCIsRE9XTjpcInNlbGVjdGlvbl9wcmVzc2VkLnBuZ1wifSxzZWxlY3Rpb25Db25maXJtOntSRVNUOlwic2VsZWN0aW9uX2NvbmZpcm1fcmVzdC5wbmdcIixHUk9VUDpcInNlbGVjdGlvbl9jb25maXJtX2dyb3VwaG92ZXIucG5nXCIsSE9WRVI6XCJzZWxlY3Rpb25fY29uZmlybV9ob3Zlci5wbmdcIixET1dOOlwic2VsZWN0aW9uX2NvbmZpcm1fcHJlc3NlZC5wbmdcIn0sc2VsZWN0aW9uQ2FuY2VsOntSRVNUOlwic2VsZWN0aW9uX2NhbmNlbF9yZXN0LnBuZ1wiLEdST1VQOlwic2VsZWN0aW9uX2NhbmNlbF9ncm91cGhvdmVyLnBuZ1wiLEhPVkVSOlwic2VsZWN0aW9uX2NhbmNlbF9ob3Zlci5wbmdcIixET1dOOlwic2VsZWN0aW9uX2NhbmNlbF9wcmVzc2VkLnBuZ1wifX19LGwpLHQuZXh0ZW5kKCEwLHRoaXMubmF2SW1hZ2VzLHRoaXMudmlld2VyLm5hdkltYWdlcyksdGhpcy5lbGVtZW50fHwodGhpcy5lbGVtZW50PXQubWFrZU5ldXRyYWxFbGVtZW50KFwiZGl2XCIpLHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kPVwicmdiYSgwLCAwLCAwLCAwLjEpXCIsdGhpcy5lbGVtZW50LmNsYXNzTmFtZT1cInNlbGVjdGlvbi1ib3hcIiksdGhpcy5ib3JkZXJzPXRoaXMuYm9yZGVyc3x8W107Zm9yKHZhciBhLGM9W10sZD0wO2Q8NDtkKyspdGhpcy5ib3JkZXJzW2RdfHwodGhpcy5ib3JkZXJzW2RdPXQubWFrZU5ldXRyYWxFbGVtZW50KFwiZGl2XCIpLHRoaXMuYm9yZGVyc1tkXS5jbGFzc05hbWU9XCJib3JkZXItXCIrZCx0aGlzLmJvcmRlcnNbZF0uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMuYm9yZGVyc1tkXS5zdHlsZS53aWR0aD1cIjFweFwiLHRoaXMuYm9yZGVyc1tkXS5zdHlsZS5oZWlnaHQ9XCIxcHhcIix0aGlzLmJvcmRlcnNbZF0uc3R5bGUuYmFja2dyb3VuZD1cIiNmZmZcIiksYT10Lm1ha2VOZXV0cmFsRWxlbWVudChcImRpdlwiKSxhLmNsYXNzTmFtZT1cImJvcmRlci1cIitkK1wiLWhhbmRsZVwiLGEuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGEuc3R5bGUudG9wPVwiNTAlXCIsYS5zdHlsZS5sZWZ0PVwiNTAlXCIsYS5zdHlsZS53aWR0aD1cIjZweFwiLGEuc3R5bGUuaGVpZ2h0PVwiNnB4XCIsYS5zdHlsZS5tYXJnaW49XCItNHB4IDAgMCAtNHB4XCIsYS5zdHlsZS5iYWNrZ3JvdW5kPVwiIzAwMFwiLGEuc3R5bGUuYm9yZGVyPVwiMXB4IHNvbGlkICNjY2NcIixuZXcgdC5Nb3VzZVRyYWNrZXIoe2VsZW1lbnQ6dGhpcy5ib3JkZXJzW2RdLGRyYWdIYW5kbGVyOm8uYmluZCh0aGlzLGQpfSksY1tkXT10Lm1ha2VOZXV0cmFsRWxlbWVudChcImRpdlwiKSxjW2RdLmNsYXNzTmFtZT1cImNvcm5lci1cIitkK1wiLWhhbmRsZVwiLGNbZF0uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGNbZF0uc3R5bGUud2lkdGg9XCI2cHhcIixjW2RdLnN0eWxlLmhlaWdodD1cIjZweFwiLGNbZF0uc3R5bGUuYmFja2dyb3VuZD1cIiMwMDBcIixjW2RdLnN0eWxlLmJvcmRlcj1cIjFweCBzb2xpZCAjY2NjXCIsbmV3IHQuTW91c2VUcmFja2VyKHtlbGVtZW50OmNbZF0sZHJhZ0hhbmRsZXI6by5iaW5kKHRoaXMsZCsuNSl9KSx0aGlzLmJvcmRlcnNbZF0uYXBwZW5kQ2hpbGQoYSksdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuYm9yZGVyc1tkXSksc2V0VGltZW91dCh0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQuYmluZCh0aGlzLmVsZW1lbnQsY1tkXSksMCk7dGhpcy5ib3JkZXJzWzBdLnN0eWxlLnRvcD0wLHRoaXMuYm9yZGVyc1swXS5zdHlsZS53aWR0aD1cIjEwMCVcIix0aGlzLmJvcmRlcnNbMV0uc3R5bGUucmlnaHQ9MCx0aGlzLmJvcmRlcnNbMV0uc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHRoaXMuYm9yZGVyc1syXS5zdHlsZS5ib3R0b209MCx0aGlzLmJvcmRlcnNbMl0uc3R5bGUud2lkdGg9XCIxMDAlXCIsdGhpcy5ib3JkZXJzWzNdLnN0eWxlLmxlZnQ9MCx0aGlzLmJvcmRlcnNbM10uc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLGNbMF0uc3R5bGUudG9wPVwiLTNweFwiLGNbMF0uc3R5bGUubGVmdD1cIi0zcHhcIixjWzFdLnN0eWxlLnRvcD1cIi0zcHhcIixjWzFdLnN0eWxlLnJpZ2h0PVwiLTNweFwiLGNbMl0uc3R5bGUuYm90dG9tPVwiLTNweFwiLGNbMl0uc3R5bGUucmlnaHQ9XCItM3B4XCIsY1szXS5zdHlsZS5ib3R0b209XCItM3B4XCIsY1szXS5zdHlsZS5sZWZ0PVwiLTNweFwiLHRoaXMub3ZlcmxheXx8KHRoaXMub3ZlcmxheT1uZXcgdC5TZWxlY3Rpb25PdmVybGF5KHRoaXMuZWxlbWVudCx0aGlzLnJlY3R8fG5ldyB0LlNlbGVjdGlvblJlY3QpKSx0aGlzLmlubmVyVHJhY2tlcj1uZXcgdC5Nb3VzZVRyYWNrZXIoe2VsZW1lbnQ6dGhpcy5lbGVtZW50LGNsaWNrVGltZVRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja1RpbWVUaHJlc2hvbGQsY2xpY2tEaXN0VGhyZXNob2xkOnRoaXMudmlld2VyLmNsaWNrRGlzdFRocmVzaG9sZCxkcmFnSGFuZGxlcjp0LmRlbGVnYXRlKHRoaXMsciksZHJhZ0VuZEhhbmRsZXI6dC5kZWxlZ2F0ZSh0aGlzLG4pLGNsaWNrSGFuZGxlcjp0LmRlbGVnYXRlKHRoaXMscyl9KSx0aGlzLm91dGVyVHJhY2tlcj1uZXcgdC5Nb3VzZVRyYWNrZXIoe2VsZW1lbnQ6dGhpcy52aWV3ZXIuY2FudmFzLGNsaWNrVGltZVRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja1RpbWVUaHJlc2hvbGQsY2xpY2tEaXN0VGhyZXNob2xkOnRoaXMudmlld2VyLmNsaWNrRGlzdFRocmVzaG9sZCxkcmFnSGFuZGxlcjp0LmRlbGVnYXRlKHRoaXMsZSksZHJhZ0VuZEhhbmRsZXI6dC5kZWxlZ2F0ZSh0aGlzLGkpLGNsaWNrSGFuZGxlcjp0LmRlbGVnYXRlKHRoaXMscyksc3RhcnREaXNhYmxlZDohdGhpcy5pc1NlbGVjdGluZ30pLHRoaXMua2V5Ym9hcmRTaG9ydGN1dCYmdC5hZGRFdmVudCh0aGlzLnZpZXdlci5jb250YWluZXIsXCJrZXlwcmVzc1wiLHQuZGVsZWdhdGUodGhpcyxoKSwhMSk7dmFyIHU9dGhpcy5wcmVmaXhVcmx8fHRoaXMudmlld2VyLnByZWZpeFVybHx8XCJcIixnPXRoaXMudmlld2VyLmJ1dHRvbnMmJnRoaXMudmlld2VyLmJ1dHRvbnMuYnV0dG9ucyxtPWc/dGhpcy52aWV3ZXIuYnV0dG9ucy5idXR0b25zWzBdOm51bGwsdz1tP20ub25Gb2N1czpudWxsLHY9bT9tLm9uQmx1cjpudWxsO2lmKHRoaXMuc2hvd1NlbGVjdGlvbkNvbnRyb2wmJih0aGlzLnRvZ2dsZUJ1dHRvbj1uZXcgdC5CdXR0b24oe2VsZW1lbnQ6dGhpcy50b2dnbGVCdXR0b24/dC5nZXRFbGVtZW50KHRoaXMudG9nZ2xlQnV0dG9uKTpudWxsLGNsaWNrVGltZVRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja1RpbWVUaHJlc2hvbGQsY2xpY2tEaXN0VGhyZXNob2xkOnRoaXMudmlld2VyLmNsaWNrRGlzdFRocmVzaG9sZCx0b29sdGlwOnQuZ2V0U3RyaW5nKFwiVG9vbHRpcHMuU2VsZWN0aW9uVG9nZ2xlXCIpfHxcIlRvZ2dsZSBzZWxlY3Rpb25cIixzcmNSZXN0OnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uLlJFU1Qsc3JjR3JvdXA6dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb24uR1JPVVAsc3JjSG92ZXI6dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb24uSE9WRVIsc3JjRG93bjp1K3RoaXMubmF2SW1hZ2VzLnNlbGVjdGlvbi5ET1dOLG9uUmVsZWFzZTp0aGlzLnRvZ2dsZVN0YXRlLmJpbmQodGhpcyksb25Gb2N1czp3LG9uQmx1cjp2fSksZyYmKHRoaXMudmlld2VyLmJ1dHRvbnMuYnV0dG9ucy5wdXNoKHRoaXMudG9nZ2xlQnV0dG9uKSx0aGlzLnZpZXdlci5idXR0b25zLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50b2dnbGVCdXR0b24uZWxlbWVudCkpLHRoaXMudG9nZ2xlQnV0dG9uLmltZ0Rvd24mJih0aGlzLmJ1dHRvbkFjdGl2ZUltZz10aGlzLnRvZ2dsZUJ1dHRvbi5pbWdEb3duLmNsb25lTm9kZSghMCksdGhpcy50b2dnbGVCdXR0b24uZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmJ1dHRvbkFjdGl2ZUltZykpKSx0aGlzLnNob3dDb25maXJtRGVueUJ1dHRvbnMpe3RoaXMuY29uZmlybUJ1dHRvbj1uZXcgdC5CdXR0b24oe2VsZW1lbnQ6dGhpcy5jb25maXJtQnV0dG9uP3QuZ2V0RWxlbWVudCh0aGlzLmNvbmZpcm1CdXR0b24pOm51bGwsY2xpY2tUaW1lVGhyZXNob2xkOnRoaXMudmlld2VyLmNsaWNrVGltZVRocmVzaG9sZCxjbGlja0Rpc3RUaHJlc2hvbGQ6dGhpcy52aWV3ZXIuY2xpY2tEaXN0VGhyZXNob2xkLHRvb2x0aXA6dC5nZXRTdHJpbmcoXCJUb29sdGlwcy5TZWxlY3Rpb25Db25maXJtXCIpfHxcIkNvbmZpcm0gc2VsZWN0aW9uXCIsc3JjUmVzdDp1K3RoaXMubmF2SW1hZ2VzLnNlbGVjdGlvbkNvbmZpcm0uUkVTVCxzcmNHcm91cDp1K3RoaXMubmF2SW1hZ2VzLnNlbGVjdGlvbkNvbmZpcm0uR1JPVVAsc3JjSG92ZXI6dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb25Db25maXJtLkhPVkVSLHNyY0Rvd246dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb25Db25maXJtLkRPV04sb25SZWxlYXNlOnRoaXMuY29uZmlybS5iaW5kKHRoaXMpLG9uRm9jdXM6dyxvbkJsdXI6dn0pO3ZhciBwPXRoaXMuY29uZmlybUJ1dHRvbi5lbGVtZW50O3AuY2xhc3NMaXN0LmFkZChcImNvbmZpcm0tYnV0dG9uXCIpLHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChwKSx0aGlzLmNhbmNlbEJ1dHRvbj1uZXcgdC5CdXR0b24oe2VsZW1lbnQ6dGhpcy5jYW5jZWxCdXR0b24/dC5nZXRFbGVtZW50KHRoaXMuY2FuY2VsQnV0dG9uKTpudWxsLGNsaWNrVGltZVRocmVzaG9sZDp0aGlzLnZpZXdlci5jbGlja1RpbWVUaHJlc2hvbGQsY2xpY2tEaXN0VGhyZXNob2xkOnRoaXMudmlld2VyLmNsaWNrRGlzdFRocmVzaG9sZCx0b29sdGlwOnQuZ2V0U3RyaW5nKFwiVG9vbHRpcHMuU2VsZWN0aW9uQ29uZmlybVwiKXx8XCJDYW5jZWwgc2VsZWN0aW9uXCIsc3JjUmVzdDp1K3RoaXMubmF2SW1hZ2VzLnNlbGVjdGlvbkNhbmNlbC5SRVNULHNyY0dyb3VwOnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uQ2FuY2VsLkdST1VQLHNyY0hvdmVyOnUrdGhpcy5uYXZJbWFnZXMuc2VsZWN0aW9uQ2FuY2VsLkhPVkVSLHNyY0Rvd246dSt0aGlzLm5hdkltYWdlcy5zZWxlY3Rpb25DYW5jZWwuRE9XTixvblJlbGVhc2U6dGhpcy5jYW5jZWwuYmluZCh0aGlzKSxvbkZvY3VzOncsb25CbHVyOnZ9KTt2YXIgeT10aGlzLmNhbmNlbEJ1dHRvbi5lbGVtZW50O3kuY2xhc3NMaXN0LmFkZChcImNhbmNlbC1idXR0b25cIiksdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHkpLHRoaXMuc3R5bGVDb25maXJtRGVueUJ1dHRvbnMmJihwLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixwLnN0eWxlLnRvcD1cIjUwJVwiLHAuc3R5bGUubGVmdD1cIjUwJVwiLHAuc3R5bGUudHJhbnNmb3JtPVwidHJhbnNsYXRlKC0xMDAlLCAtNTAlKVwiLHkuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHkuc3R5bGUudG9wPVwiNTAlXCIseS5zdHlsZS5sZWZ0PVwiNTAlXCIseS5zdHlsZS50cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwgLTUwJSlcIil9dGhpcy52aWV3ZXIuYWRkSGFuZGxlcihcInNlbGVjdGlvblwiLHRoaXMub25TZWxlY3Rpb24pLHRoaXMudmlld2VyLmFkZEhhbmRsZXIoXCJvcGVuXCIsdGhpcy5kcmF3LmJpbmQodGhpcykpLHRoaXMudmlld2VyLmFkZEhhbmRsZXIoXCJhbmltYXRpb25cIix0aGlzLmRyYXcuYmluZCh0aGlzKSksdGhpcy52aWV3ZXIuYWRkSGFuZGxlcihcInJlc2l6ZVwiLHRoaXMuZHJhdy5iaW5kKHRoaXMpKSx0aGlzLnZpZXdlci5hZGRIYW5kbGVyKFwicm90YXRlXCIsdGhpcy5kcmF3LmJpbmQodGhpcykpfSx0LmV4dGVuZCh0LlNlbGVjdGlvbi5wcm90b3R5cGUsdC5Db250cm9sRG9jay5wcm90b3R5cGUse3RvZ2dsZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0U3RhdGUoIXRoaXMuaXNTZWxlY3RpbmcpfSxzZXRTdGF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc1NlbGVjdGluZz10LHRoaXMub3V0ZXJUcmFja2VyLnNldFRyYWNraW5nKHQpLHQ/dGhpcy5kcmF3KCk6dGhpcy51bmRyYXcoKSx0aGlzLmJ1dHRvbkFjdGl2ZUltZyYmKHRoaXMuYnV0dG9uQWN0aXZlSW1nLnN0eWxlLnZpc2liaWxpdHk9dD9cInZpc2libGVcIjpcImhpZGRlblwiKSx0aGlzLnZpZXdlci5yYWlzZUV2ZW50KFwic2VsZWN0aW9uX3RvZ2dsZVwiLHtlbmFibGVkOnR9KSx0aGlzfSxlbmFibGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZXRTdGF0ZSghMCl9LGRpc2FibGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZXRTdGF0ZSghMSl9LGRyYXc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWN0JiYodGhpcy5vdmVybGF5LnVwZGF0ZSh0aGlzLnJlY3Qubm9ybWFsaXplKCkpLHRoaXMub3ZlcmxheS5kcmF3SFRNTCh0aGlzLnZpZXdlci5kcmF3ZXIuY29udGFpbmVyLHRoaXMudmlld2VyLnZpZXdwb3J0KSksdGhpc30sdW5kcmF3OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3ZlcmxheS5kZXN0cm95KCksdGhpcy5yZWN0PW51bGwsdGhpc30sY29uZmlybTpmdW5jdGlvbigpe2lmKHRoaXMucmVjdCl7dmFyIGU9dGhpcy5yZWN0Lm5vcm1hbGl6ZSgpO2lmKHRoaXMucmV0dXJuUGl4ZWxDb29yZGluYXRlcyl7dmFyIGk9dGhpcy52aWV3ZXIudmlld3BvcnQudmlld3BvcnRUb0ltYWdlUmVjdGFuZ2xlKGUpO2k9dC5TZWxlY3Rpb25SZWN0LmZyb21SZWN0KGkpLnJvdW5kKCksaS5yb3RhdGlvbj1lLnJvdGF0aW9uLGU9aX10aGlzLnZpZXdlci5yYWlzZUV2ZW50KFwic2VsZWN0aW9uXCIsZSksdGhpcy51bmRyYXcoKX1yZXR1cm4gdGhpc30sY2FuY2VsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlld2VyLnJhaXNlRXZlbnQoXCJzZWxlY3Rpb25fY2FuY2VsXCIsITEpLHRoaXMudW5kcmF3KCl9fSl9KE9wZW5TZWFkcmFnb24pLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3QuU2VsZWN0aW9uT3ZlcmxheT1mdW5jdGlvbihlLGkpe3QuT3ZlcmxheS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdC5pc1BsYWluT2JqZWN0KGUpP3RoaXMucm90YXRpb249ZS5sb2NhdGlvbi5yb3RhdGlvbnx8MDp0aGlzLnJvdGF0aW9uPWkucm90YXRpb258fDB9LHQuU2VsZWN0aW9uT3ZlcmxheS5wcm90b3R5cGU9dC5leHRlbmQoT2JqZWN0LmNyZWF0ZSh0Lk92ZXJsYXkucHJvdG90eXBlKSx7ZHJhd0hUTUw6ZnVuY3Rpb24oKXt0Lk92ZXJsYXkucHJvdG90eXBlLmRyYXdIVE1MLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLnN0eWxlLnRyYW5zZm9ybT10aGlzLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC8gP3JvdGF0ZVxcKC4rcmFkXFwpLyxcIlwiKStcIiByb3RhdGUoXCIrdGhpcy5yb3RhdGlvbitcInJhZClcIn0sdXBkYXRlOmZ1bmN0aW9uKGUpe3QuT3ZlcmxheS5wcm90b3R5cGUudXBkYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLnJvdGF0aW9uPWUucm90YXRpb258fDB9fSl9KE9wZW5TZWFkcmFnb24pLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3QuU2VsZWN0aW9uUmVjdD1mdW5jdGlvbihlLGkscyxyLG4pe3QuUmVjdC5hcHBseSh0aGlzLFtlLGkscyxyXSksdGhpcy5yb3RhdGlvbj1ufHwwfSx0LlNlbGVjdGlvblJlY3QuZnJvbVJlY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0LlNlbGVjdGlvblJlY3QoZS54LGUueSxlLndpZHRoLGUuaGVpZ2h0KX0sdC5TZWxlY3Rpb25SZWN0LnByb3RvdHlwZT10LmV4dGVuZChPYmplY3QuY3JlYXRlKHQuUmVjdC5wcm90b3R5cGUpLHtjbG9uZTpmdW5jdGlvbigpe3JldHVybiBuZXcgdC5TZWxlY3Rpb25SZWN0KHRoaXMueCx0aGlzLnksdGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLnJvdGF0aW9uKX0sZXF1YWxzOmZ1bmN0aW9uKGUpe3JldHVybiB0LlJlY3QucHJvdG90eXBlLmVxdWFscy5hcHBseSh0aGlzLFtlXSkmJnRoaXMucm90YXRpb249PT1lLnJvdGF0aW9ufSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW1wiK01hdGgucm91bmQoMTAwKnRoaXMueCkvMTAwK1wiLFwiK01hdGgucm91bmQoMTAwKnRoaXMueSkvMTAwK1wiLFwiK01hdGgucm91bmQoMTAwKnRoaXMud2lkdGgpLzEwMCtcInhcIitNYXRoLnJvdW5kKDEwMCp0aGlzLmhlaWdodCkvMTAwK1wiQFwiK01hdGgucm91bmQoMTAwKnRoaXMucm90YXRpb24pLzEwMCtcIl1cIn0sc3dhcFdpZHRoSGVpZ2h0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jbG9uZSgpO3JldHVybiB0LndpZHRoPXRoaXMuaGVpZ2h0LHQuaGVpZ2h0PXRoaXMud2lkdGgsdC54Kz0odGhpcy53aWR0aC10aGlzLmhlaWdodCkvMix0LnkrPSh0aGlzLmhlaWdodC10aGlzLndpZHRoKS8yLHR9LGdldERlZ3JlZVJvdGF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucm90YXRpb24qKDE4MC9NYXRoLlBJKX0sZ2V0QW5nbGVGcm9tQ2VudGVyOmZ1bmN0aW9uKHQpe3ZhciBlPXQubWludXModGhpcy5nZXRDZW50ZXIoKSk7cmV0dXJuIE1hdGguYXRhbjIoZS54LGUueSl9LHJvdW5kOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0LlNlbGVjdGlvblJlY3QoTWF0aC5yb3VuZCh0aGlzLngpLE1hdGgucm91bmQodGhpcy55KSxNYXRoLnJvdW5kKHRoaXMud2lkdGgpLE1hdGgucm91bmQodGhpcy5oZWlnaHQpLHRoaXMucm90YXRpb24pfSxub3JtYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNsb25lKCk7cmV0dXJuIHQud2lkdGg8MCYmKHQueCs9dC53aWR0aCx0LndpZHRoKj0tMSksdC5oZWlnaHQ8MCYmKHQueSs9dC5oZWlnaHQsdC5oZWlnaHQqPS0xKSx0LnJvdGF0aW9uJT1NYXRoLlBJLHR9LGZpdHNJbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ub3JtYWxpemUoKSxpPVtlLmdldFRvcExlZnQoKSxlLmdldFRvcFJpZ2h0KCksZS5nZXRCb3R0b21SaWdodCgpLGUuZ2V0Qm90dG9tTGVmdCgpXSxzPWUuZ2V0Q2VudGVyKCkscj1lLmdldERlZ3JlZVJvdGF0aW9uKCksbj10LmdldEJvdHRvbVJpZ2h0KCksbz0wO288NDtvKyspaWYoaVtvXT1pW29dLnJvdGF0ZShyLHMpLGlbb10ueDx0Lnh8fGlbb10ueD5uLnh8fGlbb10ueTx0Lnl8fGlbb10ueT5uLnkpcmV0dXJuITE7cmV0dXJuITB9LHJlZHVjZVJvdGF0aW9uOmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHRoaXMucm90YXRpb248TWF0aC5QSS8tND8odD10aGlzLnN3YXBXaWR0aEhlaWdodCgpLHQucm90YXRpb24rPU1hdGguUEkvMik6dGhpcy5yb3RhdGlvbj5NYXRoLlBJLzQ/KHQ9dGhpcy5zd2FwV2lkdGhIZWlnaHQoKSx0LnJvdGF0aW9uLT1NYXRoLlBJLzIpOnQ9dGhpcy5jbG9uZSgpLHR9fSl9KE9wZW5TZWFkcmFnb24pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlbnNlYWRyYWdvbnNlbGVjdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vb3BlbnNlYWRyYWdvbnNlbGVjdGlvbi9kaXN0L29wZW5zZWFkcmFnb25zZWxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"check-circle":{"width":1536,"height":1792,"paths":[{"d":"M1284 734q0-28-18-46l-91-90q-19-19-45-19t-45 19l-408 407-226-226q-19-19-45-19t-45 19l-91 90q-18 18-18 46 0 27 18 45l362 362q19 19 45 19 27 0 46-19l543-543q18-18 18-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9jaGVjay1jaXJjbGUuanM/ODM4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMsK1RBQStULEdBQUciLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcImNoZWNrLWNpcmNsZVwiOntcIndpZHRoXCI6MTUzNixcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMTI4NCA3MzRxMC0yOC0xOC00NmwtOTEtOTBxLTE5LTE5LTQ1LTE5dC00NSAxOWwtNDA4IDQwNy0yMjYtMjI2cS0xOS0xOS00NS0xOXQtNDUgMTlsLTkxIDkwcS0xOCAxOC0xOCA0NiAwIDI3IDE4IDQ1bDM2MiAzNjJxMTkgMTkgNDUgMTkgMjcgMCA0Ni0xOWw1NDMtNTQzcTE4LTE4IDE4LTQ1ek0xNTM2IDg5NnEwIDIwOS0xMDMgMzg1LjV0LTI3OS41IDI3OS41LTM4NS41IDEwMy0zODUuNS0xMDMtMjc5LjUtMjc5LjUtMTAzLTM4NS41IDEwMy0zODUuNSAyNzkuNS0yNzkuNSAzODUuNS0xMDMgMzg1LjUgMTAzIDI3OS41IDI3OS41IDEwMyAzODUuNXpcIn1dfX0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1hd2Vzb21lL2ljb25zL2NoZWNrLWNpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"expand":{"width":1536,"height":1792,"paths":[{"d":"M755 1056q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23zM1536 192v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9leHBhbmQuanM/YWM1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLFVBQVUscUNBQXFDLHFWQUFxVixHQUFHIiwiZmlsZSI6IjgwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJleHBhbmRcIjp7XCJ3aWR0aFwiOjE1MzYsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTc1NSAxMDU2cTAgMTMtMTAgMjNsLTMzMiAzMzIgMTQ0IDE0NHExOSAxOSAxOSA0NXQtMTkgNDUtNDUgMTloLTQ0OHEtMjYgMC00NS0xOXQtMTktNDV2LTQ0OHEwLTI2IDE5LTQ1dDQ1LTE5IDQ1IDE5bDE0NCAxNDQgMzMyLTMzMnExMC0xMCAyMy0xMHQyMyAxMGwxMTQgMTE0cTEwIDEwIDEwIDIzek0xNTM2IDE5MnY0NDhxMCAyNi0xOSA0NXQtNDUgMTktNDUtMTlsLTE0NC0xNDQtMzMyIDMzMnEtMTAgMTAtMjMgMTB0LTIzLTEwbC0xMTQtMTE0cS0xMC0xMC0xMC0yM3QxMC0yM2wzMzItMzMyLTE0NC0xNDRxLTE5LTE5LTE5LTQ1dDE5LTQ1IDQ1LTE5aDQ0OHEyNiAwIDQ1IDE5dDE5IDQ1elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvZXhwYW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"info-circle":{"width":1536,"height":1792,"paths":[{"d":"M1024 1376v-160q0-14-9-23t-23-9h-96v-512q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v160q0 14 9 23t23 9h96v320h-96q-14 0-23 9t-9 23v160q0 14 9 23t23 9h448q14 0 23-9t9-23zM896 480v-160q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v160q0 14 9 23t23 9h192q14 0 23-9t9-23zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9pbmZvLWNpcmNsZS5qcz9lMjM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsdUVBQWUsZUFBZSxxQ0FBcUMsc1pBQXNaLEdBQUciLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcImluZm8tY2lyY2xlXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xMDI0IDEzNzZ2LTE2MHEwLTE0LTktMjN0LTIzLTloLTk2di01MTJxMC0xNC05LTIzdC0yMy05aC0zMjBxLTE0IDAtMjMgOXQtOSAyM3YxNjBxMCAxNCA5IDIzdDIzIDloOTZ2MzIwaC05NnEtMTQgMC0yMyA5dC05IDIzdjE2MHEwIDE0IDkgMjN0MjMgOWg0NDhxMTQgMCAyMy05dDktMjN6TTg5NiA0ODB2LTE2MHEwLTE0LTktMjN0LTIzLTloLTE5MnEtMTQgMC0yMyA5dC05IDIzdjE2MHEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMy05dDktMjN6TTE1MzYgODk2cTAgMjA5LTEwMyAzODUuNXQtMjc5LjUgMjc5LjUtMzg1LjUgMTAzLTM4NS41LTEwMy0yNzkuNS0yNzkuNS0xMDMtMzg1LjUgMTAzLTM4NS41IDI3OS41LTI3OS41IDM4NS41LTEwMyAzODUuNSAxMDMgMjc5LjUgMjc5LjUgMTAzIDM4NS41elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvaW5mby1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"minus-circle":{"width":1536,"height":1792,"paths":[{"d":"M1216 960v-128q0-26-19-45t-45-19h-768q-26 0-45 19t-19 45v128q0 26 19 45t45 19h768q26 0 45-19t19-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9taW51cy1jaXJjbGUuanM/MDJiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLGdCQUFnQixxQ0FBcUMsMlBBQTJQLEdBQUciLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcIm1pbnVzLWNpcmNsZVwiOntcIndpZHRoXCI6MTUzNixcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMTIxNiA5NjB2LTEyOHEwLTI2LTE5LTQ1dC00NS0xOWgtNzY4cS0yNiAwLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWg3NjhxMjYgMCA0NS0xOXQxOS00NXpNMTUzNiA4OTZxMCAyMDktMTAzIDM4NS41dC0yNzkuNSAyNzkuNS0zODUuNSAxMDMtMzg1LjUtMTAzLTI3OS41LTI3OS41LTEwMy0zODUuNSAxMDMtMzg1LjUgMjc5LjUtMjc5LjUgMzg1LjUtMTAzIDM4NS41IDEwMyAyNzkuNSAyNzkuNSAxMDMgMzg1LjV6XCJ9XX19KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtYXdlc29tZS9pY29ucy9taW51cy1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"pencil":{"width":1536,"height":1792,"paths":[{"d":"M363 1536l91-91-235-235-91 91v107h128v128h107zM886 608q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zM832 416l416 416-832 832h-416v-416zM1515 512q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9wZW5jaWwuanM/ZDkwNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLFVBQVUscUNBQXFDLHdRQUF3USxHQUFHIiwiZmlsZSI6IjgzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJwZW5jaWxcIjp7XCJ3aWR0aFwiOjE1MzYsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTM2MyAxNTM2bDkxLTkxLTIzNS0yMzUtOTEgOTF2MTA3aDEyOHYxMjhoMTA3ek04ODYgNjA4cTAtMjItMjItMjItMTAgMC0xNyA3bC01NDIgNTQycS03IDctNyAxNyAwIDIyIDIyIDIyIDEwIDAgMTctN2w1NDItNTQycTctNyA3LTE3ek04MzIgNDE2bDQxNiA0MTYtODMyIDgzMmgtNDE2di00MTZ6TTE1MTUgNTEycTAgNTMtMzcgOTBsLTE2NiAxNjYtNDE2LTQxNiAxNjYtMTY1cTM2LTM4IDkwLTM4IDUzIDAgOTEgMzhsMjM1IDIzNHEzNyAzOSAzNyA5MXpcIn1dfX0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1hd2Vzb21lL2ljb25zL3BlbmNpbC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"plus-circle":{"width":1536,"height":1792,"paths":[{"d":"M1216 960v-128q0-26-19-45t-45-19h-256v-256q0-26-19-45t-45-19h-128q-26 0-45 19t-19 45v256h-256q-26 0-45 19t-19 45v128q0 26 19 45t45 19h256v256q0 26 19 45t45 19h128q26 0 45-19t19-45v-256h256q26 0 45-19t19-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9wbHVzLWNpcmNsZS5qcz8zODBmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsdUVBQWUsZUFBZSxxQ0FBcUMsc1dBQXNXLEdBQUciLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcInBsdXMtY2lyY2xlXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xMjE2IDk2MHYtMTI4cTAtMjYtMTktNDV0LTQ1LTE5aC0yNTZ2LTI1NnEwLTI2LTE5LTQ1dC00NS0xOWgtMTI4cS0yNiAwLTQ1IDE5dC0xOSA0NXYyNTZoLTI1NnEtMjYgMC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMjU2djI1NnEwIDI2IDE5IDQ1dDQ1IDE5aDEyOHEyNiAwIDQ1LTE5dDE5LTQ1di0yNTZoMjU2cTI2IDAgNDUtMTl0MTktNDV6TTE1MzYgODk2cTAgMjA5LTEwMyAzODUuNXQtMjc5LjUgMjc5LjUtMzg1LjUgMTAzLTM4NS41LTEwMy0yNzkuNS0yNzkuNS0xMDMtMzg1LjUgMTAzLTM4NS41IDI3OS41LTI3OS41IDM4NS41LTEwMyAzODUuNSAxMDMgMjc5LjUgMjc5LjUgMTAzIDM4NS41elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvcGx1cy1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"question-circle":{"width":1536,"height":1792,"paths":[{"d":"M896 1376v-192q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v192q0 14 9 23t23 9h192q14 0 23-9t9-23zM1152 704q0-88-55.5-163t-138.5-116-170-41q-243 0-371 213-15 24 8 42l132 100q7 6 19 6 16 0 25-12 53-68 86-92 34-24 86-24 48 0 85.5 26t37.5 59q0 38-20 61t-68 45q-63 28-115.5 86.5t-52.5 125.5v36q0 14 9 23t23 9h192q14 0 23-9t9-23q0-19 21.5-49.5t54.5-49.5q32-18 49-28.5t46-35 44.5-48 28-60.5 12.5-81zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9xdWVzdGlvbi1jaXJjbGUuanM/ZTBhOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLHVFQUFlLG1CQUFtQixxQ0FBcUMsMGhCQUEwaEIsR0FBRyIsImZpbGUiOiI4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi52dWUnXG5cbkljb24ucmVnaXN0ZXIoe1wicXVlc3Rpb24tY2lyY2xlXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk04OTYgMTM3NnYtMTkycTAtMTQtOS0yM3QtMjMtOWgtMTkycS0xNCAwLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzLTl0OS0yM3pNMTE1MiA3MDRxMC04OC01NS41LTE2M3QtMTM4LjUtMTE2LTE3MC00MXEtMjQzIDAtMzcxIDIxMy0xNSAyNCA4IDQybDEzMiAxMDBxNyA2IDE5IDYgMTYgMCAyNS0xMiA1My02OCA4Ni05MiAzNC0yNCA4Ni0yNCA0OCAwIDg1LjUgMjZ0MzcuNSA1OXEwIDM4LTIwIDYxdC02OCA0NXEtNjMgMjgtMTE1LjUgODYuNXQtNTIuNSAxMjUuNXYzNnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMy05dDktMjNxMC0xOSAyMS41LTQ5LjV0NTQuNS00OS41cTMyLTE4IDQ5LTI4LjV0NDYtMzUgNDQuNS00OCAyOC02MC41IDEyLjUtODF6TTE1MzYgODk2cTAgMjA5LTEwMyAzODUuNXQtMjc5LjUgMjc5LjUtMzg1LjUgMTAzLTM4NS41LTEwMy0yNzkuNS0yNzkuNS0xMDMtMzg1LjUgMTAzLTM4NS41IDI3OS41LTI3OS41IDM4NS41LTEwMyAzODUuNSAxMDMgMjc5LjUgMjc5LjUgMTAzIDM4NS41elwifV19fSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWF3ZXNvbWUvaWNvbnMvcXVlc3Rpb24tY2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue__);\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_Icon_vue___default.a.register({"refresh":{"width":1536,"height":1792,"paths":[{"d":"M1511 1056q0 5-1 7-64 268-268 434.5t-478 166.5q-146 0-282.5-55t-243.5-157l-129 129q-19 19-45 19t-45-19-19-45v-448q0-26 19-45t45-19h448q26 0 45 19t19 45-19 45l-137 137q71 66 161 102t187 36q134 0 250-65t186-179q11-17 53-117 8-23 30-23h192q13 0 22.5 9.5t9.5 22.5zM1536 256v448q0 26-19 45t-45 19h-448q-26 0-45-19t-19-45 19-45l138-138q-148-137-349-137-134 0-250 65t-186 179q-11 17-53 117-8 23-30 23h-199q-13 0-22.5-9.5t-9.5-22.5v-7q65-268 270-434.5t480-166.5q146 0 284 55.5t245 156.5l130-129q19-19 45-19t45 19 19 45z"}]}})\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9pY29ucy9yZWZyZXNoLmpzP2E3OTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQSx1RUFBZSxXQUFXLHFDQUFxQyxzZ0JBQXNnQixHQUFHIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJyZWZyZXNoXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xNTExIDEwNTZxMCA1LTEgNy02NCAyNjgtMjY4IDQzNC41dC00NzggMTY2LjVxLTE0NiAwLTI4Mi41LTU1dC0yNDMuNS0xNTdsLTEyOSAxMjlxLTE5IDE5LTQ1IDE5dC00NS0xOS0xOS00NXYtNDQ4cTAtMjYgMTktNDV0NDUtMTloNDQ4cTI2IDAgNDUgMTl0MTkgNDUtMTkgNDVsLTEzNyAxMzdxNzEgNjYgMTYxIDEwMnQxODcgMzZxMTM0IDAgMjUwLTY1dDE4Ni0xNzlxMTEtMTcgNTMtMTE3IDgtMjMgMzAtMjNoMTkycTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6TTE1MzYgMjU2djQ0OHEwIDI2LTE5IDQ1dC00NSAxOWgtNDQ4cS0yNiAwLTQ1LTE5dC0xOS00NSAxOS00NWwxMzgtMTM4cS0xNDgtMTM3LTM0OS0xMzctMTM0IDAtMjUwIDY1dC0xODYgMTc5cS0xMSAxNy01MyAxMTctOCAyMy0zMCAyM2gtMTk5cS0xMyAwLTIyLjUtOS41dC05LjUtMjIuNXYtN3E2NS0yNjggMjcwLTQzNC41dDQ4MC0xNjYuNXExNDYgMCAyODQgNTUuNXQyNDUgMTU2LjVsMTMwLTEyOXExOS0xOSA0NS0xOXQ0NSAxOSAxOSA0NXpcIn1dfX0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1hd2Vzb21lL2ljb25zL3JlZnJlc2guanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(69);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(4)(\"2aa5060a\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlPzA5ZWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBcU07QUFDck07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wNjBjMDUyMFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL01vZGFsLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMmFhNTA2MGFcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0wNjBjMDUyMFwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwudnVlXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(70);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(4)(\"666b599f\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlPzQwNDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBcU07QUFDck07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiODguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zMzE2M2JjM1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0NvbnRyb2xzLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNjY2YjU5OWZcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zMzE2M2JjM1wiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvQ29udHJvbHMudnVlXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(71);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(4)(\"7ee7790d\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/YTMwNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLG9DQUFxTTtBQUNyTTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTRmNDkxZmRmXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vU2lkZWJhci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjdlZTc3OTBkXCIsIGNvbnRlbnQsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNGY0OTFmZGZcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL1NpZGViYXIudnVlXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(72);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(4)(\"7da17536\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc2lkZWJhcnMvU2VsZWN0aW9uLnZ1ZT9lNzlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0Esb0NBQTJNO0FBQzNNO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjkwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzZiZjExYTFcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TZWxlY3Rpb24udnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI3ZGExNzUzNlwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTc2YmYxMWExXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zaWRlYmFycy9TZWxlY3Rpb24udnVlXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(73);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(4)(\"7d601987\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvVmlld2VyLnZ1ZT8yYzhmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0Esb0NBQXNNO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjkxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL2RlbW8vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYWFkNDFiNDJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vVmlld2VyLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiN2Q2MDE5ODdcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1hYWQ0MWI0MlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL1ZpZXdlci52dWVcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(74);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(4)(\"440d0959\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtYXdlc29tZS9jb21wb25lbnRzL0ljb24udnVlP2RjY2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBcU07QUFDck07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz9taW5pbWl6ZSEuLi8uLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTA2NjU5NzBiXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vZGVtby9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0ljb24udnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjQ0MGQwOTU5XCIsIGNvbnRlbnQsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXI/bWluaW1pemUhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDY2NTk3MGJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL34vdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(75);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(4)(\"ae0c0760\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWU/NDA5ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLG9DQUE4TTtBQUM5TTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI5My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9taW5pbWl6ZSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWRmYzYyN2ZlXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9kZW1vL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vTWV0YWRhdGFNb2RhbC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcImFlMGMwNzYwXCIsIGNvbnRlbnQsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXI/bWluaW1pemUhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZGZjNjI3ZmVcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvTWV0YWRhdGFNb2RhbC52dWVcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanM/ODFlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI5NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export Store */\n/* unused harmony export mapState */\n/* unused harmony export mapMutations */\n/* unused harmony export mapGetters */\n/* unused harmony export mapActions */\n/**\n * vuex v2.3.0\n * (c) 2017 Evan You\n * @license MIT\n */\nvar applyMixin = function (Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n};\n\nvar devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\n\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime;\n  this._children = Object.create(null);\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors$1 = { namespaced: {} };\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors$1 );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  var this$1 = this;\n\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false);\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, function (rawModule, key) {\n      this$1.register([key], rawModule, false);\n    });\n  }\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update(this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  var parent = this.get(path.slice(0, -1));\n  var newModule = new Module(rawModule, runtime);\n  parent.addChild(path[path.length - 1], newModule);\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  if (!parent.getChild(key).runtime) { return }\n\n  parent.removeChild(key);\n};\n\nfunction update (targetModule, newModule) {\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        console.warn(\n          \"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" +\n          'manual reload is needed'\n        );\n        return\n      }\n      update(targetModule.getChild(key), newModule.modules[key]);\n    }\n  }\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n\n  var state = options.state; if ( state === void 0 ) state = {};\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  };\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); });\n};\n\nvar prototypeAccessors = { state: {} };\n\nprototypeAccessors.state.get = function () {\n  return this._vm._data.$$state\n};\n\nprototypeAccessors.state.set = function (v) {\n  assert(false, \"Use store.replaceState() to explicit replace store state.\");\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    console.error((\"[vuex] unknown mutation type: \" + type));\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload);\n    });\n  });\n  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });\n\n  if (options && options.silent) {\n    console.warn(\n      \"[vuex] mutation type: \" + type + \". Silent option has been removed. \" +\n      'Use the filter functionality in the vue-devtools'\n    );\n  }\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var entry = this._actions[type];\n  if (!entry) {\n    console.error((\"[vuex] unknown action type: \" + type));\n    return\n  }\n  return entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload)\n};\n\nStore.prototype.subscribe = function subscribe (fn) {\n  var subs = this._subscribers;\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  }\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  assert(typeof getter === 'function', \"store.watch only accepts a function.\");\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule) {\n  if (typeof path === 'string') { path = [path]; }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path));\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path]; }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors );\n\nfunction resetStore (store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM (store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () { return fn(store); };\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () { return oldVm.$destroy(); });\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var namespacedType = namespace + key;\n    registerAction(store, namespacedType, action, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._actions[type]) {\n          console.error((\"[vuex] unknown local action type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._mutations[type]) {\n          console.error((\"[vuex] unknown local mutation type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? function () { return store.getters; }\n        : function () { return makeLocalGetters(store, namespace); }\n    },\n    state: {\n      get: function () { return getNestedState(store.state, path); }\n    }\n  });\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  var gettersProxy = {};\n\n  var splitPos = namespace.length;\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) { return }\n\n    // extract local getter type\n    var localType = type.slice(splitPos);\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function () { return store.getters[type]; },\n      enumerable: true\n    });\n  });\n\n  return gettersProxy\n}\n\nfunction registerMutation (store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler (payload) {\n    handler(local.state, payload);\n  });\n}\n\nfunction registerAction (store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler (payload, cb) {\n    var res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err\n      })\n    } else {\n      return res\n    }\n  });\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    console.error((\"[vuex] duplicate getter key: \" + type));\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  };\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, function () {\n    assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\");\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce(function (state, key) { return state[key]; }, state)\n    : state\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  assert(typeof type === 'string', (\"Expects string as the type, but found \" + (typeof type) + \".\"));\n\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    );\n    return\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue);\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {\n        return\n      }\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n      if (!(val in this.$store.getters)) {\n        console.error((\"[vuex] unknown getter: \" + val));\n        return\n      }\n      return this.$store.getters[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {\n        return\n      }\n      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map)\n  }\n}\n\nfunction getModuleByNamespace (store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (!module) {\n    console.error((\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace));\n  }\n  return module\n}\n\nvar index_esm = {\n  Store: Store,\n  install: install,\n  version: '2.3.0',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (index_esm);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWV4L2Rpc3QvdnVleC5lc20uanM/MjBkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQixJQUFJLHlCQUF5QjtBQUN4RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMEJBQTBCLEVBQUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsZUFBZTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsdUJBQXVCLEVBQUU7QUFDcEY7O0FBRUEsMEJBQTBCLFVBQVU7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCw0Q0FBNEMsb0NBQW9DLEVBQUU7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QixFQUFFO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsNkNBQTZDLEVBQUU7QUFDNUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBLHdCQUF3Qix1QkFBdUIsRUFBRTtBQUNqRDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsOEJBQThCLHlCQUF5QixFQUFFO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDLHVCQUF1QiwyQ0FBMkM7QUFDbEUsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEIsRUFBRTtBQUN0RDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQSxHQUFHLEdBQUcseUJBQXlCO0FBQy9COztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CLEVBQUU7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxxQkFBcUIsRUFBRSxFQUFFO0FBQ2pFLDJDQUEyQyxVQUFVLDBCQUEwQixFQUFFLEVBQUU7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUUiLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZ1ZXggdjIuMy4wXG4gKiAoYykgMjAxNyBFdmFuIFlvdVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbnZhciBhcHBseU1peGluID0gZnVuY3Rpb24gKFZ1ZSkge1xuICB2YXIgdmVyc2lvbiA9IE51bWJlcihWdWUudmVyc2lvbi5zcGxpdCgnLicpWzBdKTtcblxuICBpZiAodmVyc2lvbiA+PSAyKSB7XG4gICAgdmFyIHVzZXNJbml0ID0gVnVlLmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuaW5kZXhPZignaW5pdCcpID4gLTE7XG4gICAgVnVlLm1peGluKHVzZXNJbml0ID8geyBpbml0OiB2dWV4SW5pdCB9IDogeyBiZWZvcmVDcmVhdGU6IHZ1ZXhJbml0IH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB2YXIgX2luaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdFxuICAgICAgICA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdClcbiAgICAgICAgOiB2dWV4SW5pdDtcbiAgICAgIF9pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZ1ZXhJbml0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gc3RvcmUgaW5qZWN0aW9uXG4gICAgaWYgKG9wdGlvbnMuc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5zdG9yZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LiRzdG9yZSkge1xuICAgICAgdGhpcy4kc3RvcmUgPSBvcHRpb25zLnBhcmVudC4kc3RvcmU7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZGV2dG9vbEhvb2sgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuZnVuY3Rpb24gZGV2dG9vbFBsdWdpbiAoc3RvcmUpIHtcbiAgaWYgKCFkZXZ0b29sSG9vaykgeyByZXR1cm4gfVxuXG4gIHN0b3JlLl9kZXZ0b29sSG9vayA9IGRldnRvb2xIb29rO1xuXG4gIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6aW5pdCcsIHN0b3JlKTtcblxuICBkZXZ0b29sSG9vay5vbigndnVleDp0cmF2ZWwtdG8tc3RhdGUnLCBmdW5jdGlvbiAodGFyZ2V0U3RhdGUpIHtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUodGFyZ2V0U3RhdGUpO1xuICB9KTtcblxuICBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKG11dGF0aW9uLCBzdGF0ZSkge1xuICAgIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6bXV0YXRpb24nLCBtdXRhdGlvbiwgc3RhdGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGl0ZW0gdGhhdCBwYXNzIHRoZSB0ZXN0XG4gKiBieSBzZWNvbmQgYXJndW1lbnQgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcmV0dXJuIHsqfVxuICovXG4vKipcbiAqIERlZXAgY29weSB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnNpZGVyaW5nIGNpcmN1bGFyIHN0cnVjdHVyZS5cbiAqIFRoaXMgZnVuY3Rpb24gY2FjaGVzIGFsbCBuZXN0ZWQgb2JqZWN0cyBhbmQgaXRzIGNvcGllcy5cbiAqIElmIGl0IGRldGVjdHMgY2lyY3VsYXIgc3RydWN0dXJlLCB1c2UgY2FjaGVkIGNvcHkgdG8gYXZvaWQgaW5maW5pdGUgbG9vcC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjYWNoZVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbi8qKlxuICogZm9yRWFjaCBmb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hWYWx1ZSAob2JqLCBmbikge1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4ob2JqW2tleV0sIGtleSk7IH0pO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbidcbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1zZykge1xuICBpZiAoIWNvbmRpdGlvbikgeyB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZXhdIFwiICsgbXNnKSkgfVxufVxuXG52YXIgTW9kdWxlID0gZnVuY3Rpb24gTW9kdWxlIChyYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgdGhpcy5fY2hpbGRyZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9yYXdNb2R1bGUgPSByYXdNb2R1bGU7XG4gIHZhciByYXdTdGF0ZSA9IHJhd01vZHVsZS5zdGF0ZTtcbiAgdGhpcy5zdGF0ZSA9ICh0eXBlb2YgcmF3U3RhdGUgPT09ICdmdW5jdGlvbicgPyByYXdTdGF0ZSgpIDogcmF3U3RhdGUpIHx8IHt9O1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyBuYW1lc3BhY2VkOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5uYW1lc3BhY2VkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWRcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAoa2V5LCBtb2R1bGUpIHtcbiAgdGhpcy5fY2hpbGRyZW5ba2V5XSA9IG1vZHVsZTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoa2V5KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltrZXldO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2tleV1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChyYXdNb2R1bGUpIHtcbiAgdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWQgPSByYXdNb2R1bGUubmFtZXNwYWNlZDtcbiAgaWYgKHJhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMgPSByYXdNb2R1bGUuYWN0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMgPSByYXdNb2R1bGUubXV0YXRpb25zO1xuICB9XG4gIGlmIChyYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzID0gcmF3TW9kdWxlLmdldHRlcnM7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gZm9yRWFjaENoaWxkIChmbikge1xuICBmb3JFYWNoVmFsdWUodGhpcy5fY2hpbGRyZW4sIGZuKTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEdldHRlciA9IGZ1bmN0aW9uIGZvckVhY2hHZXR0ZXIgKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycywgZm4pO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hBY3Rpb24gPSBmdW5jdGlvbiBmb3JFYWNoQWN0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoTXV0YXRpb24gPSBmdW5jdGlvbiBmb3JFYWNoTXV0YXRpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1vZHVsZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJvb3QgPSBuZXcgTW9kdWxlKHJhd1Jvb3RNb2R1bGUsIGZhbHNlKTtcblxuICAvLyByZWdpc3RlciBhbGwgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd1Jvb3RNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdSb290TW9kdWxlLm1vZHVsZXMsIGZ1bmN0aW9uIChyYXdNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKFtrZXldLCByYXdNb2R1bGUsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobW9kdWxlLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlLmdldENoaWxkKGtleSlcbiAgfSwgdGhpcy5yb290KVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gZ2V0TmFtZXNwYWNlIChwYXRoKSB7XG4gIHZhciBtb2R1bGUgPSB0aGlzLnJvb3Q7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBrZXkpIHtcbiAgICBtb2R1bGUgPSBtb2R1bGUuZ2V0Q2hpbGQoa2V5KTtcbiAgICByZXR1cm4gbmFtZXNwYWNlICsgKG1vZHVsZS5uYW1lc3BhY2VkID8ga2V5ICsgJy8nIDogJycpXG4gIH0sICcnKVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlJDEgKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdXBkYXRlKHRoaXMucm9vdCwgcmF3Um9vdE1vZHVsZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHJ1bnRpbWUgPT09IHZvaWQgMCApIHJ1bnRpbWUgPSB0cnVlO1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBuZXdNb2R1bGUgPSBuZXcgTW9kdWxlKHJhd01vZHVsZSwgcnVudGltZSk7XG4gIHBhcmVudC5hZGRDaGlsZChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIG5ld01vZHVsZSk7XG5cbiAgLy8gcmVnaXN0ZXIgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3Q2hpbGRNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKHBhdGguY29uY2F0KGtleSksIHJhd0NoaWxkTW9kdWxlLCBydW50aW1lKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIgKHBhdGgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKCFwYXJlbnQuZ2V0Q2hpbGQoa2V5KS5ydW50aW1lKSB7IHJldHVybiB9XG5cbiAgcGFyZW50LnJlbW92ZUNoaWxkKGtleSk7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGUgKHRhcmdldE1vZHVsZSwgbmV3TW9kdWxlKSB7XG4gIC8vIHVwZGF0ZSB0YXJnZXQgbW9kdWxlXG4gIHRhcmdldE1vZHVsZS51cGRhdGUobmV3TW9kdWxlKTtcblxuICAvLyB1cGRhdGUgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgICBpZiAoIXRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gYWRkIGEgbmV3IG1vZHVsZSAnXCIgKyBrZXkgKyBcIicgb24gaG90IHJlbG9hZGluZywgXCIgK1xuICAgICAgICAgICdtYW51YWwgcmVsb2FkIGlzIG5lZWRlZCdcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUodGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSksIG5ld01vZHVsZS5tb2R1bGVzW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgVnVlOyAvLyBiaW5kIG9uIGluc3RhbGxcblxudmFyIFN0b3JlID0gZnVuY3Rpb24gU3RvcmUgKG9wdGlvbnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGFzc2VydChWdWUsIFwibXVzdCBjYWxsIFZ1ZS51c2UoVnVleCkgYmVmb3JlIGNyZWF0aW5nIGEgc3RvcmUgaW5zdGFuY2UuXCIpO1xuICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG5cbiAgdmFyIHN0YXRlID0gb3B0aW9ucy5zdGF0ZTsgaWYgKCBzdGF0ZSA9PT0gdm9pZCAwICkgc3RhdGUgPSB7fTtcbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcblxuICAvLyBzdG9yZSBpbnRlcm5hbCBzdGF0ZVxuICB0aGlzLl9jb21taXR0aW5nID0gZmFsc2U7XG4gIHRoaXMuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX21vZHVsZXMgPSBuZXcgTW9kdWxlQ29sbGVjdGlvbihvcHRpb25zKTtcbiAgdGhpcy5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX3dhdGNoZXJWTSA9IG5ldyBWdWUoKTtcblxuICAvLyBiaW5kIGNvbW1pdCBhbmQgZGlzcGF0Y2ggdG8gc2VsZlxuICB2YXIgc3RvcmUgPSB0aGlzO1xuICB2YXIgcmVmID0gdGhpcztcbiAgdmFyIGRpc3BhdGNoID0gcmVmLmRpc3BhdGNoO1xuICB2YXIgY29tbWl0ID0gcmVmLmNvbW1pdDtcbiAgdGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uIGJvdW5kRGlzcGF0Y2ggKHR5cGUsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2guY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZClcbiAgfTtcbiAgdGhpcy5jb21taXQgPSBmdW5jdGlvbiBib3VuZENvbW1pdCAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBjb21taXQuY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZCwgb3B0aW9ucylcbiAgfTtcblxuICAvLyBzdHJpY3QgbW9kZVxuICB0aGlzLnN0cmljdCA9IHN0cmljdDtcblxuICAvLyBpbml0IHJvb3QgbW9kdWxlLlxuICAvLyB0aGlzIGFsc28gcmVjdXJzaXZlbHkgcmVnaXN0ZXJzIGFsbCBzdWItbW9kdWxlc1xuICAvLyBhbmQgY29sbGVjdHMgYWxsIG1vZHVsZSBnZXR0ZXJzIGluc2lkZSB0aGlzLl93cmFwcGVkR2V0dGVyc1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHN0YXRlLCBbXSwgdGhpcy5fbW9kdWxlcy5yb290KTtcblxuICAvLyBpbml0aWFsaXplIHRoZSBzdG9yZSB2bSwgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIHRoZSByZWFjdGl2aXR5XG4gIC8vIChhbHNvIHJlZ2lzdGVycyBfd3JhcHBlZEdldHRlcnMgYXMgY29tcHV0ZWQgcHJvcGVydGllcylcbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHN0YXRlKTtcblxuICAvLyBhcHBseSBwbHVnaW5zXG4gIHBsdWdpbnMuY29uY2F0KGRldnRvb2xQbHVnaW4pLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKHRoaXMkMSk7IH0pO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc3RhdGU6IHt9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl92bS5fZGF0YS4kJHN0YXRlXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgYXNzZXJ0KGZhbHNlLCBcIlVzZSBzdG9yZS5yZXBsYWNlU3RhdGUoKSB0byBleHBsaWNpdCByZXBsYWNlIHN0b3JlIHN0YXRlLlwiKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiBjb21taXQgKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgY29tbWl0XG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gIHZhciBtdXRhdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgIHJldHVyblxuICB9XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIGVudHJ5LmZvckVhY2goZnVuY3Rpb24gY29tbWl0SXRlcmF0b3IgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIocGF5bG9hZCk7XG4gICAgfSk7XG4gIH0pO1xuICB0aGlzLl9zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1YihtdXRhdGlvbiwgdGhpcyQxLnN0YXRlKTsgfSk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlt2dWV4XSBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUgKyBcIi4gU2lsZW50IG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBcIiArXG4gICAgICAnVXNlIHRoZSBmaWx0ZXIgZnVuY3Rpb25hbGl0eSBpbiB0aGUgdnVlLWRldnRvb2xzJ1xuICAgICk7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoIChfdHlwZSwgX3BheWxvYWQpIHtcbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGRpc3BhdGNoXG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgcGF5bG9hZCA9IHJlZi5wYXlsb2FkO1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuX2FjdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChmbikge1xuICB2YXIgc3VicyA9IHRoaXMuX3N1YnNjcmliZXJzO1xuICBpZiAoc3Vicy5pbmRleE9mKGZuKSA8IDApIHtcbiAgICBzdWJzLnB1c2goZm4pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBzdWJzLmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gd2F0Y2ggKGdldHRlciwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBhc3NlcnQodHlwZW9mIGdldHRlciA9PT0gJ2Z1bmN0aW9uJywgXCJzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgYSBmdW5jdGlvbi5cIik7XG4gIHJldHVybiB0aGlzLl93YXRjaGVyVk0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHRlcih0aGlzJDEuc3RhdGUsIHRoaXMkMS5nZXR0ZXJzKTsgfSwgY2IsIG9wdGlvbnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlIChzdGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS5fdm0uX2RhdGEuJCRzdGF0ZSA9IHN0YXRlO1xuICB9KTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlIChwYXRoLCByYXdNb2R1bGUpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCkpO1xuICAvLyByZXNldCBzdG9yZSB0byB1cGRhdGUgZ2V0dGVycy4uLlxuICByZXNldFN0b3JlVk0odGhpcywgdGhpcy5zdGF0ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUudW5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJNb2R1bGUgKHBhdGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gIHRoaXMuX21vZHVsZXMudW5yZWdpc3RlcihwYXRoKTtcbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUodGhpcyQxLnN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgVnVlLmRlbGV0ZShwYXJlbnRTdGF0ZSwgcGF0aFtwYXRoLmxlbmd0aCAtIDFdKTtcbiAgfSk7XG4gIHJlc2V0U3RvcmUodGhpcyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuaG90VXBkYXRlID0gZnVuY3Rpb24gaG90VXBkYXRlIChuZXdPcHRpb25zKSB7XG4gIHRoaXMuX21vZHVsZXMudXBkYXRlKG5ld09wdGlvbnMpO1xuICByZXNldFN0b3JlKHRoaXMsIHRydWUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLl93aXRoQ29tbWl0ID0gZnVuY3Rpb24gX3dpdGhDb21taXQgKGZuKSB7XG4gIHZhciBjb21taXR0aW5nID0gdGhpcy5fY29tbWl0dGluZztcbiAgdGhpcy5fY29tbWl0dGluZyA9IHRydWU7XG4gIGZuKCk7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBjb21taXR0aW5nO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFN0b3JlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbmZ1bmN0aW9uIHJlc2V0U3RvcmUgKHN0b3JlLCBob3QpIHtcbiAgc3RvcmUuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX3dyYXBwZWRHZXR0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgc3RhdGUgPSBzdG9yZS5zdGF0ZTtcbiAgLy8gaW5pdCBhbGwgbW9kdWxlc1xuICBpbnN0YWxsTW9kdWxlKHN0b3JlLCBzdGF0ZSwgW10sIHN0b3JlLl9tb2R1bGVzLnJvb3QsIHRydWUpO1xuICAvLyByZXNldCB2bVxuICByZXNldFN0b3JlVk0oc3RvcmUsIHN0YXRlLCBob3QpO1xufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlVk0gKHN0b3JlLCBzdGF0ZSwgaG90KSB7XG4gIHZhciBvbGRWbSA9IHN0b3JlLl92bTtcblxuICAvLyBiaW5kIHN0b3JlIHB1YmxpYyBnZXR0ZXJzXG4gIHN0b3JlLmdldHRlcnMgPSB7fTtcbiAgdmFyIHdyYXBwZWRHZXR0ZXJzID0gc3RvcmUuX3dyYXBwZWRHZXR0ZXJzO1xuICB2YXIgY29tcHV0ZWQgPSB7fTtcbiAgZm9yRWFjaFZhbHVlKHdyYXBwZWRHZXR0ZXJzLCBmdW5jdGlvbiAoZm4sIGtleSkge1xuICAgIC8vIHVzZSBjb21wdXRlZCB0byBsZXZlcmFnZSBpdHMgbGF6eS1jYWNoaW5nIG1lY2hhbmlzbVxuICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmbihzdG9yZSk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0b3JlLmdldHRlcnMsIGtleSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5fdm1ba2V5XTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUgLy8gZm9yIGxvY2FsIGdldHRlcnNcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gIC8vIHN1cHByZXNzIHdhcm5pbmdzIGp1c3QgaW4gY2FzZSB0aGUgdXNlciBoYXMgYWRkZWRcbiAgLy8gc29tZSBmdW5reSBnbG9iYWwgbWl4aW5zXG4gIHZhciBzaWxlbnQgPSBWdWUuY29uZmlnLnNpbGVudDtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xuICBzdG9yZS5fdm0gPSBuZXcgVnVlKHtcbiAgICBkYXRhOiB7XG4gICAgICAkJHN0YXRlOiBzdGF0ZVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkXG4gIH0pO1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHNpbGVudDtcblxuICAvLyBlbmFibGUgc3RyaWN0IG1vZGUgZm9yIG5ldyB2bVxuICBpZiAoc3RvcmUuc3RyaWN0KSB7XG4gICAgZW5hYmxlU3RyaWN0TW9kZShzdG9yZSk7XG4gIH1cblxuICBpZiAob2xkVm0pIHtcbiAgICBpZiAoaG90KSB7XG4gICAgICAvLyBkaXNwYXRjaCBjaGFuZ2VzIGluIGFsbCBzdWJzY3JpYmVkIHdhdGNoZXJzXG4gICAgICAvLyB0byBmb3JjZSBnZXR0ZXIgcmUtZXZhbHVhdGlvbiBmb3IgaG90IHJlbG9hZGluZy5cbiAgICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2xkVm0uX2RhdGEuJCRzdGF0ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9sZFZtLiRkZXN0cm95KCk7IH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNb2R1bGUgKHN0b3JlLCByb290U3RhdGUsIHBhdGgsIG1vZHVsZSwgaG90KSB7XG4gIHZhciBpc1Jvb3QgPSAhcGF0aC5sZW5ndGg7XG4gIHZhciBuYW1lc3BhY2UgPSBzdG9yZS5fbW9kdWxlcy5nZXROYW1lc3BhY2UocGF0aCk7XG5cbiAgLy8gcmVnaXN0ZXIgaW4gbmFtZXNwYWNlIG1hcFxuICBpZiAobW9kdWxlLm5hbWVzcGFjZWQpIHtcbiAgICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdID0gbW9kdWxlO1xuICB9XG5cbiAgLy8gc2V0IHN0YXRlXG4gIGlmICghaXNSb290ICYmICFob3QpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZShyb290U3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICB2YXIgbW9kdWxlTmFtZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICBWdWUuc2V0KHBhcmVudFN0YXRlLCBtb2R1bGVOYW1lLCBtb2R1bGUuc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGxvY2FsID0gbW9kdWxlLmNvbnRleHQgPSBtYWtlTG9jYWxDb250ZXh0KHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpO1xuXG4gIG1vZHVsZS5mb3JFYWNoTXV0YXRpb24oZnVuY3Rpb24gKG11dGF0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIG11dGF0aW9uLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQWN0aW9uKGZ1bmN0aW9uIChhY3Rpb24sIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3RlckFjdGlvbihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIGFjdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEdldHRlcihmdW5jdGlvbiAoZ2V0dGVyLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJHZXR0ZXIoc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBnZXR0ZXIsIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGtleSkge1xuICAgIGluc3RhbGxNb2R1bGUoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aC5jb25jYXQoa2V5KSwgY2hpbGQsIGhvdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIG1ha2UgbG9jYWxpemVkIGRpc3BhdGNoLCBjb21taXQsIGdldHRlcnMgYW5kIHN0YXRlXG4gKiBpZiB0aGVyZSBpcyBubyBuYW1lc3BhY2UsIGp1c3QgdXNlIHJvb3Qgb25lc1xuICovXG5mdW5jdGlvbiBtYWtlTG9jYWxDb250ZXh0IChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKSB7XG4gIHZhciBub05hbWVzcGFjZSA9IG5hbWVzcGFjZSA9PT0gJyc7XG5cbiAgdmFyIGxvY2FsID0ge1xuICAgIGRpc3BhdGNoOiBub05hbWVzcGFjZSA/IHN0b3JlLmRpc3BhdGNoIDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmICghc3RvcmUuX2FjdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIGFjdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2godHlwZSwgcGF5bG9hZClcbiAgICB9LFxuXG4gICAgY29tbWl0OiBub05hbWVzcGFjZSA/IHN0b3JlLmNvbW1pdCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoIXN0b3JlLl9tdXRhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIG11dGF0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmNvbW1pdCh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0dGVycyBhbmQgc3RhdGUgb2JqZWN0IG11c3QgYmUgZ290dGVuIGxhemlseVxuICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBjaGFuZ2VkIGJ5IHZtIHVwZGF0ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsb2NhbCwge1xuICAgIGdldHRlcnM6IHtcbiAgICAgIGdldDogbm9OYW1lc3BhY2VcbiAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbmFtZXNwYWNlKTsgfVxuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TmVzdGVkU3RhdGUoc3RvcmUuc3RhdGUsIHBhdGgpOyB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbG9jYWxcbn1cblxuZnVuY3Rpb24gbWFrZUxvY2FsR2V0dGVycyAoc3RvcmUsIG5hbWVzcGFjZSkge1xuICB2YXIgZ2V0dGVyc1Byb3h5ID0ge307XG5cbiAgdmFyIHNwbGl0UG9zID0gbmFtZXNwYWNlLmxlbmd0aDtcbiAgT2JqZWN0LmtleXMoc3RvcmUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIHNraXAgaWYgdGhlIHRhcmdldCBnZXR0ZXIgaXMgbm90IG1hdGNoIHRoaXMgbmFtZXNwYWNlXG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgc3BsaXRQb3MpICE9PSBuYW1lc3BhY2UpIHsgcmV0dXJuIH1cblxuICAgIC8vIGV4dHJhY3QgbG9jYWwgZ2V0dGVyIHR5cGVcbiAgICB2YXIgbG9jYWxUeXBlID0gdHlwZS5zbGljZShzcGxpdFBvcyk7XG5cbiAgICAvLyBBZGQgYSBwb3J0IHRvIHRoZSBnZXR0ZXJzIHByb3h5LlxuICAgIC8vIERlZmluZSBhcyBnZXR0ZXIgcHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV2YWx1YXRlIHRoZSBnZXR0ZXJzIGluIHRoaXMgdGltZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0dGVyc1Byb3h5LCBsb2NhbFR5cGUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyc1t0eXBlXTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGdldHRlcnNQcm94eVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX211dGF0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX211dGF0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkTXV0YXRpb25IYW5kbGVyIChwYXlsb2FkKSB7XG4gICAgaGFuZGxlcihsb2NhbC5zdGF0ZSwgcGF5bG9hZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9hY3Rpb25zW3R5cGVdIHx8IChzdG9yZS5fYWN0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkQWN0aW9uSGFuZGxlciAocGF5bG9hZCwgY2IpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlcih7XG4gICAgICBkaXNwYXRjaDogbG9jYWwuZGlzcGF0Y2gsXG4gICAgICBjb21taXQ6IGxvY2FsLmNvbW1pdCxcbiAgICAgIGdldHRlcnM6IGxvY2FsLmdldHRlcnMsXG4gICAgICBzdGF0ZTogbG9jYWwuc3RhdGUsXG4gICAgICByb290R2V0dGVyczogc3RvcmUuZ2V0dGVycyxcbiAgICAgIHJvb3RTdGF0ZTogc3RvcmUuc3RhdGVcbiAgICB9LCBwYXlsb2FkLCBjYik7XG4gICAgaWYgKCFpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzID0gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgfVxuICAgIGlmIChzdG9yZS5fZGV2dG9vbEhvb2spIHtcbiAgICAgIHJldHVybiByZXMuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzdG9yZS5fZGV2dG9vbEhvb2suZW1pdCgndnVleDplcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR2V0dGVyIChzdG9yZSwgdHlwZSwgcmF3R2V0dGVyLCBsb2NhbCkge1xuICBpZiAoc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gZHVwbGljYXRlIGdldHRlciBrZXk6IFwiICsgdHlwZSkpO1xuICAgIHJldHVyblxuICB9XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSA9IGZ1bmN0aW9uIHdyYXBwZWRHZXR0ZXIgKHN0b3JlKSB7XG4gICAgcmV0dXJuIHJhd0dldHRlcihcbiAgICAgIGxvY2FsLnN0YXRlLCAvLyBsb2NhbCBzdGF0ZVxuICAgICAgbG9jYWwuZ2V0dGVycywgLy8gbG9jYWwgZ2V0dGVyc1xuICAgICAgc3RvcmUuc3RhdGUsIC8vIHJvb3Qgc3RhdGVcbiAgICAgIHN0b3JlLmdldHRlcnMgLy8gcm9vdCBnZXR0ZXJzXG4gICAgKVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmFibGVTdHJpY3RNb2RlIChzdG9yZSkge1xuICBzdG9yZS5fdm0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEuJCRzdGF0ZSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgYXNzZXJ0KHN0b3JlLl9jb21taXR0aW5nLCBcIkRvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLlwiKTtcbiAgfSwgeyBkZWVwOiB0cnVlLCBzeW5jOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROZXN0ZWRTdGF0ZSAoc3RhdGUsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoXG4gICAgPyBwYXRoLnJlZHVjZShmdW5jdGlvbiAoc3RhdGUsIGtleSkgeyByZXR1cm4gc3RhdGVba2V5XTsgfSwgc3RhdGUpXG4gICAgOiBzdGF0ZVxufVxuXG5mdW5jdGlvbiB1bmlmeU9iamVjdFN0eWxlICh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gIGlmIChpc09iamVjdCh0eXBlKSAmJiB0eXBlLnR5cGUpIHtcbiAgICBvcHRpb25zID0gcGF5bG9hZDtcbiAgICBwYXlsb2FkID0gdHlwZTtcbiAgICB0eXBlID0gdHlwZS50eXBlO1xuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgKFwiRXhwZWN0cyBzdHJpbmcgYXMgdGhlIHR5cGUsIGJ1dCBmb3VuZCBcIiArICh0eXBlb2YgdHlwZSkgKyBcIi5cIikpO1xuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQsIG9wdGlvbnM6IG9wdGlvbnMgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsIChfVnVlKSB7XG4gIGlmIChWdWUpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ1t2dWV4XSBhbHJlYWR5IGluc3RhbGxlZC4gVnVlLnVzZShWdWV4KSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBWdWUgPSBfVnVlO1xuICBhcHBseU1peGluKFZ1ZSk7XG59XG5cbi8vIGF1dG8gaW5zdGFsbCBpbiBkaXN0IG1vZGVcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gIGluc3RhbGwod2luZG93LlZ1ZSk7XG59XG5cbnZhciBtYXBTdGF0ZSA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBzdGF0ZXMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoc3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkU3RhdGUgKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGU7XG4gICAgICB2YXIgZ2V0dGVycyA9IHRoaXMuJHN0b3JlLmdldHRlcnM7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcFN0YXRlJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IG1vZHVsZS5jb250ZXh0LnN0YXRlO1xuICAgICAgICBnZXR0ZXJzID0gbW9kdWxlLmNvbnRleHQuZ2V0dGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmNhbGwodGhpcywgc3RhdGUsIGdldHRlcnMpXG4gICAgICAgIDogc3RhdGVbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwTXV0YXRpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIG11dGF0aW9ucykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChtdXRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkTXV0YXRpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwTXV0YXRpb25zJywgbmFtZXNwYWNlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5jb21taXQuYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBtYXBHZXR0ZXJzID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGdldHRlcnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICB2YWwgPSBuYW1lc3BhY2UgKyB2YWw7XG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRHZXR0ZXIgKCkge1xuICAgICAgaWYgKG5hbWVzcGFjZSAmJiAhZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBHZXR0ZXJzJywgbmFtZXNwYWNlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghKHZhbCBpbiB0aGlzLiRzdG9yZS5nZXR0ZXJzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGdldHRlcjogXCIgKyB2YWwpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1t2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBtYXBBY3Rpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGFjdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICB2YWwgPSBuYW1lc3BhY2UgKyB2YWw7XG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRBY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwQWN0aW9ucycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZGlzcGF0Y2guYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1hcCAobWFwKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1hcClcbiAgICA/IG1hcC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDoga2V5IH0pOyB9KVxuICAgIDogT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDogbWFwW2tleV0gfSk7IH0pXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWVzcGFjZSAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1hcCkge1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgbWFwID0gbmFtZXNwYWNlO1xuICAgICAgbmFtZXNwYWNlID0gJyc7XG4gICAgfSBlbHNlIGlmIChuYW1lc3BhY2UuY2hhckF0KG5hbWVzcGFjZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICBuYW1lc3BhY2UgKz0gJy8nO1xuICAgIH1cbiAgICByZXR1cm4gZm4obmFtZXNwYWNlLCBtYXApXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlQnlOYW1lc3BhY2UgKHN0b3JlLCBoZWxwZXIsIG5hbWVzcGFjZSkge1xuICB2YXIgbW9kdWxlID0gc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXTtcbiAgaWYgKCFtb2R1bGUpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBtb2R1bGUgbmFtZXNwYWNlIG5vdCBmb3VuZCBpbiBcIiArIGhlbHBlciArIFwiKCk6IFwiICsgbmFtZXNwYWNlKSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZVxufVxuXG52YXIgaW5kZXhfZXNtID0ge1xuICBTdG9yZTogU3RvcmUsXG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICcyLjMuMCcsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMsXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMsXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnNcbn07XG5cbmV4cG9ydCB7IFN0b3JlLCBtYXBTdGF0ZSwgbWFwTXV0YXRpb25zLCBtYXBHZXR0ZXJzLCBtYXBBY3Rpb25zIH07ZXhwb3J0IGRlZmF1bHQgaW5kZXhfZXNtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWV4L2Rpc3QvdnVleC5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")}]);